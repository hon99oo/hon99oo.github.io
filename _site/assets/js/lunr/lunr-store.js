var store = [{
        "title": "블로그를 다시 시작해 보자",
        "excerpt":"4학년 1학기 졸업작품을 3월부터 6월까지 열심히 달렸다. 졸업작품을 끝마치고 나니 현업의 욕심이 생겨 열심히 인턴 지원을 진행하였다. 그렇게 자소서를 쓰고 대학생활을 하며 잰힝했던 포트폴리오를 정리하고 7월 11일에 ‘스페이스워크’라는 회사에 인턴 포지션으로 입사하게 되었다. 인턴 포지션에 입사한 이후로 코딩에 대한 열정이 팍 식은거 같다. 회사일은 내가 졸업작품을 했을 때 처럼 큰 열정을 쏟아 붓지 못한 채 시키는 일만 하는 수동적 인간이 되었다. 그렇게 거의 5개월을 따로 공부도 하지 않고 열정이 없는 채로 살아왔던 것 같다. 당장 내 앞에 펼쳐져 있는 숙제들도 해결하지 않고 뒤로 미뤄두고 기상 - 회사 일 쪼금 - 게임 - 취침의 쳇바퀴의 반복적 인생을 살아왔다.   인턴 포지션 종료일은 1월 11일이다. 이후 나는 졸업요건을 하나 충족하지 않아 초과학기를 해야하며 다음 취업을 준비해야 한다. 인턴 포지션 종료까지는 약 2개월 정도 남았다. 지금은 욕심이지만, 인턴 종료 이후 곧바로 다른 회사의 인턴 포지션으로 들어가거나 현재 있는 회사에 잔류 하는 것이 목표이다. 현재 다니고 있는 회사에서 열심히 하지 못했던 이유는 나에게 목표의식이 조금 사라졌다는 변명을 들 수 있을 것 같다. 다시금 목표가 생긴 현재 이를 정확히 인지하고 행동으로 실천할 때가 온 것 같다.   인턴 생활을 하기 전까지는 모두 뇌피셜로 코딩을 해오고 공부를 해왔다. 그 때는 BE와 FE의 차이점도 몰랐고 DE가 요즘 핫하다는 이야기만 듣고 무슨 일을 하는지도 모른채로 DE포지션으로 인턴을 지원했었다. 하지만, 현업 생활을 약 4개월정도 하고 난 뒤 내 주변에 현업 생활을 하고 있는 지인들의 이야기가 궁금해졌고 많은 사람들의 이야기를 듣고 싶어 일명 DevTalk을 요청하였다. 그리고 이제는 정확하지는 않지만, 개발자라는 직군이 어떻게 돌아가는지 그리고 내가 어떤 일을 할 수 있고 어떤 일을 하고 싶은지 조금은 알 수 있게 되었다.   우선 나의 문제점을 발견했다. 간단하고 명확하게 말하자면, 나는 현재 ‘코싸개’이다. 생각하지 않고 주어진 문제를 해결하기 위해 수단과 방법을 가리지 않고 그저 코드만을 작성했던 굉장히 질 나쁜 개발자였던 것이다. 생각해보면 내가 이 프로그래밍에 관해 진지하게 공부했던 적이 없다. 학문을 가르치는 대학에서 소프트웨어학과를 진학하고 전공 과목은 집중하지 않고 프로젝트를 어떻게든 이쁘게 만들기 위해서 프로젝트를 위한 공부만 했던 것 같다. 현재 사용하고 있는 기술들은 모두 근본이 되는 알고리즘과 컴퓨터구조론에서부터 비롯된 기술임을 몰랐던 것이다. 나에게 가장 부족한 점은 ‘근본 지식’을 모르는 것이다. 많이 늦었다고 말할 수 있지만, 오늘부터 ‘근본 지식’에 관련하여 몇가지를 체계적으로 공부할 생각이다.   첫번째, 알고리즘이다. 알고리즘을 제대로 배워본 적이 없다. 사실 우리학교의 전공 필수 과목이지만, 너무 어렵고 공부하기도 싫어서 대충 했던 기억이 있다. 그리고 모르는 지식이 있으면 그 때 그 때 구글링으로 일시적으로 지식의 빈자리를 매꿀 뿐이었다. 근본이 되는 알고리즘 서적으로 공부할 계획이다. 두번째, 컴퓨터구조론이다. 컴퓨터구조론 또한 우리학교의 전공 필수 과목이지만, 족보를 바탕으로 공부해서 학점은 좋게 받았지만 남아있는 지식은 없다. 알고리즘과 컴퓨터구조론을 우선 공부하여 인턴 포지션 종료 전 까지 어느정도의 지식을 확보하고 싶은 계획이다.   이후 나는 BE나 DE 직군으로 나아갈 예정이다. 현재 내가 사용하는 주 언어는 python이지만, java에도 관심이 조금씩 가고 있다. 알고리즘과 컴퓨터구조론 공부를 마치고 나면 DE의 근본책과 BE의 근본책 두가지를 구매해서 공부할 예정이다. 이 열정이 언제 식을지 모르겠지만, 현재 내 발등에는 불이 그것도 존나게 뜨거운 불이 떨어졌다.   화이팅이다 홍구야  ","categories": ["Doodle"],
        "tags": ["Doodle"],
        "url": "/doodle/doodle_01/",
        "teaser": null
      },{
        "title": "2022년 초보 개발자의 취업 계획",
        "excerpt":"   곧 2022년이다. 2021년 한해를 마무리해보자.     2021년 : 마무리   3月-6月 졸업작품    7月-12月 인턴생활    졸업작품 하얗게 불태우고 바로 인턴 생활을 했다. 현업이 되게 궁금했는데 이 부분에 대해서는 굉장히 많은 도움이 된 것 같다. 그리고 Data Engineering 직무도 굉장히 관심 있었는데 직접 경험할 수 있어서 좋았다. 나는 조금 더 다양한 경험을 하고 싶어서  Back End 직무를 공략할 생각이다. 언어는 아무래도 java가 강력하다고 생각해서 java 공부를 시작할 것 같다.    2022년 : 11월 전까지 아래 서류들을 준비해보자      졸업요건 맞추기    토익 또는 오픽    정보처리기사    CS    Algorithm    Java 스킬    ~2022년 포트폴리오 정리    코딩 캠프(네이버부캠,우테코 등등…) 준비      Java Backend Roadmap   ","categories": ["Doodle"],
        "tags": ["Doodle"],
        "url": "/doodle/doodle_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Google's Neural Machine Translation System : Bridging the Gap between Human and Machine Translation 논문 리뷰",
        "excerpt":"Introduction     Neural Machine Translation            End-to-End 학습 접근 방식의 자동 번역       기존 구문 기반 번역의 약점을 극복           Neural Machine Translation 단점            데이터 양과 매개변수가 많아 훈련과 추론 속도가 느림       Rare Word 처리의 문제점       가끔씩 모든 단어에 대해 번역하지 못함           Google’s Neural Machine Translation            LSTM으로 이루어져 있는 8개의 ENCODER와 8개의 DECODER       병렬 처리 개선을 위해 DECODER의 최하층과 ENCODER의 최상층을 ATTENTION으로 연결       번역속도를 높이기 위해 low-precision arithmetic, Rare Word 처리를 위해 WordPiece 사용            Model Architecture       Model Parallelism            모델 병렬화와 데이터 병렬화 모두 사용함       Downpour SGD를 사용하여 데이터 병렬화                    여러개의 모델로 나누어, 여러개의 머신에서 동시에 학습함, 각각 학습된 gradient를 평균내어 모델에 적용           실험에서는 10개의 머신에서 128개의 문장을 Mini-batch로 사용                       모델 병렬화                    머신당 8개의 GPU 사용 ( 각 층 마다 서로 다른 GPU에 할당 )           i번째 레이어의 작업이 종료전에 i+1번째 작업 진행 가능                            Segmentation Approches     Wordpiece Model            띄어쓰기는 _, 단어는 내부단어 통계에 기반하여 띄어쓰기로 분리       띄어쓰기를 _로 치환한 이유는 차후에 문장 복원을 위해       실험에서는 wordpiece를 8K~32K에서 좋은 결과 얻음       wordpiece로도 얻을 수 없었던 rare word는 copy model을 사용                 Mixed Word/Character Model            OOV 처리를 로 하지 않고 문자 단위로 나누어 처리함       시작 문자 , 중간 문자 , 끝 문자        전체 작업 과정에서 유지한 채로 학습한 후 태그를 삭제함             Training Criteria     Maximum-liklihood 학습 방식은 로그 확률 값을 최대화하는 목적 함수 ( BLUE 평가 지표와 부합되지 않음 )        Reward개념의 목적함수 사용        r은 문장 단위 점수 ( 출력 문서와 실제 문서의 차이 계산 )   GLEU 점수 지표 사용 ( 출력 문장과 정답 문장을 1~4 토큰으로 만든 뒤 recall과 precision을 구한 뒤 더 작은 값을 GLEU로 정함 )   ML방식과 RL 방식 혼합하여 사용 이 때, a는 0.017        Quantizable Model And Quantized Inference     NMT은 연산량이 많아 Inference 시간이 오래 걸리는 것이 큰 단점   해결하기 위하여 Quantized inference 수행!        Decoder     Beam Search를 사용하여 점수 함수를 최대화 하는 시퀀스 Y를 찾음   Length normalization            길이가 더 긴 문장의 확률이 떨어지기 때문에 이를 보정하기 위하여 사용       하이퍼 파라미터 a 사용 ( 실험에서는 0.6 ~ 0.7 사용 )           Coverage Panelty            source word xi로 부터 attention weight의 합을 구함       로그를 취했기 때문에 attention weight이 편중되지 않은 source word의 값이 매우 작음 음수를 가지게 됨       실험에서는 a는 0.6 b는 0.2 사용                Experiments And Results     Data set            WMT En -&gt; Fr 36M       WMT En -&gt; De 5M           Evaluation Metrics            BLUE       implicit human evaluation ( BLUE는 번역 점수 잘 못메김 )           Training Procederue            TensorFlow 사용하여 구현       12개의 머신으로 병렬화       [-0.04, 0.04] 사이로 매개변수를 균일하게 초기화       Adam Optimizer와 SGD 혼합하여 사용 ( 첫 60k는 Adam으로 그 후로는 SGD 사용)           Learning Rate는 0.5 ( 1.2M 이후부터 200k 단위마다 반씩 줄여가며 학습 )          Conclusion     Wordpiece 모델은 번역 품질과 inference 속도를 효과적으로 높힘   모델과 데이터의 병렬화는 sequence-to-sequence NMT 모델을 일주일 안으로 효율적으로 훈련시킬 수 있음   Model quantization은 inference 속도를 가속화할 수 있어 대형 모델에 사용하기 용이함   Length-normalization, coverage penalty 등과 같은 추가 세부 사항이 NMT 시스템을 잘 작동시키게 도와줌  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_01/",
        "teaser": null
      },{
        "title": "Docker는 대충 이런 느낌인가?",
        "excerpt":"Docker   내가 느낀 전체적인 도커의 메커니즘 : 어떠어떠한 것을 빌드해서 이미지를 만들고  -&gt; 이미지를 도커로 띄운 뒤 -&gt; 이미지를 받아서 로컬에서 개발작업을 진행   !!많은 시행착오를 거쳐 도커의 메커니즘에 대해 이해가 조금 되었다.     Dockerfile을 만든다.   해당 디렉토리 위치에서 docker build를 한다.   docker build을 하면 이미지가 생성된다.   이미지가 생성됐으면, 해당 이미지로 docker run을 한다.   docker run을 하면 컨테이너가 만들어지고 해당 이미지를 컨테이너 안으로 넣는다?띄운다?   그럼 환경셋팅이 된다…?   틀린 부분도 있겠지만 아주 조오금 조오오오오금 메커니즘이 이해가 됐다.   앗 참고로 음… 저런 run이니 이미지 파일들이니 어떤 컨테이너가 실행중인지를 GUI로 확인할 수 있는 프로그램이 Docker Desktop 같다 ㅎㅎ..   추가적으로 환경세팅을 완료한 것 같다. 음… 위의 6번까지 진행한 후에          컨테이너를 만들면 어떠한 가상환경이 만들어지는 것 같다.            그럼 그 컨테이너에가 파이썬 환경으로 이루어져있고 추가로 다양한 패키지들이 들어있다.            그럼 그 환경을 내가 사용하고 있는 Pycharm과 연동을 하는 거다.       어떻게 하냐면 파이참 프로젝트의 인터프리터를 해당 컨테이너에 있는 파이썬path로 설정해주는거다. *https://i-am-eden.tistory.com/13        그리고 코딩하면 된다 ㅎㅎ ***            도커엔진 - 도커를 실행하면 Dockered라는 데몬 프로그램이 서버로 실행.   **여기서 잠깐! 데몬 프로그램이 뭘까?   https://blogger.pe.kr/770  (포그라운드, 백그라운드, 데몬 프로세스)    https://haruhiism.tistory.com/9            도커실행 : 도커 이미지를 받아서 컨테이너로 실행   ** -it 라는 명령어는 -i와 -t 옵션이 합쳐진 옵션, -i는 호스트와 컨테이너 상호 입출력을 맞추고, -t는 TTY를 활성화해서 컨테이너에 터미널로 입력이 가능하게 한다.   ** TTY가 뭐지?!   https://cosmosproject2015.tistory.com/143 (TTY, PTS, PTY)            도커 volume : 데이터를 컨테이너에 저장하지 않고 호스트에 저장하는 방식   https://www.daleseo.com/docker-volumes-bind-mounts/       도커빌드 : Dockerfile로 사용자 정의 이미지를 만듬   *공부하기 : 도커 아키텍쳐, 컨테이너-OS 간의 통신 구조   ** Docker의 개념 및 핵심 설명 :  https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90    Docker 예제 실습중 갱장히 이상한 오류가 발생했다.   failed to solve with frontend dockerfile.v0: failed to read dockerfile: open /var/lib/docker/tmp/buildkit-mount174403522/Dockerfile: no such file or directory   구글링을 계속 해봤지만 dockerfile -&gt; Dockerfile 로 이름을 바꾸라는 답변밖에 없었다.   하지만, 오류가 고쳐지지 않았고 터미널을 Open한 디렉토리 경로를 상위 폴더 위치로 open을 해서 났던 오류였다 ㅎㅎ  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/docker_01/",
        "teaser": null
      },{
        "title": "TDD와 each map",
        "excerpt":"TDD   TDD(Test Driven Development)란 본격적인 개발에 들어가기 전에 테스트 계획 및 코드를 작성하는 것을 의미한다. 테스트가 개발을 이끌어 나가는 것이다. 예를들어, 개발 중 에러가 발생했을 때 소규모 개발에서는 큰 문제가 되지는 않지만, 대규모의 개발 상황에서는 수 많은 모듈과 함수간 종속성들이 굉장히 많은 시간을 괴롭히게 된다. 이러한 문제점을 해결하기 위해서 테스트 주도 개발이 등장했다.   나는 pytest를 사용할 것이다. https://binux.tistory.com/47   일단, monkeypatch.setattr 살펴보자.  이것은 어떤것을 하냐면, mocking이다. Mocking은 실제 값이 아닌 가짜 값을 만들어내는 것이다.   음 예를들면 Upload 클래스가 있다.   Class Upload    |_ Def Extract   |_ Def Transform   |_ Def Load   이렇게 되어있을 때 나는 Transform 부분만 테스트하고 싶다. 하지만 함수의 종속성으로 인하여 Transform에서 사용되는 data는 Extract로 부터 참조되며 Extract에서 추출되는 data는  특정 라이브러리의 기능을 참조한다. 나는 Transform 부분만 테스트하고 싶지만 이런 경우에 Extract부터 특정 라이브러리으 기능까지 테스트해야되는 상황에 처한 것이다. 이런 경우에 이제 Mocking이라는 기술을 쓴다. pytest에서도 제공하는 function이 있지만, 단순한 예를 하나 들자면 정답과 인풋값을 csv파일이나 등등으로 미리 만들어서 로컬에서 참조하도록 코드를 작성하면 된다.   하지만 이때, 테스트 코드에서 원코드를 실행할 때 원코드의 Extract가 실행 되기 때문에 monkeypatch.setattr 같은 기능으로 해당 function을 사용하지 않고 넘겨주는 기능을 넣어줘야한다.    each map  each map을 알아야한다.  음 지금 내가 하는 것은 DB -&gt; transform -&gt; DB 적재이다. transform에서 전처리 및 parsing을 해주는데, transform에서 이뤄지는 작업은 모든 Dataframe이 메모리 상으로 올라가게 된다. 작은 task면 문제없이 실행 되겠지만, 큰 규모의 task는 메모리를 많이 차지하게 되어 에러가 날 수 있다. 이럴 때 사용 하는 것이 each map이다. each map은 dataframe에서 row 별로 메모리 상으로 올린다. 이후 해당 row에서 특정 처리를 진행 후에 buffer로 옮긴 뒤 DB로 적재를 한다. 이 때 조심해야 하는 부분은 seperate다. row에서 컬럼으로 구분하는 seperate값을 잘 이용해야지 에러가 나지 않을 것이다.    즉! pytest 부분을 더 공부하고 적절한 testset을 생각해보고, testcode를 작성해보자!  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행",
        "excerpt":"CS:APP  Computer Systems A Programmer’s Perspective, CSAPP로도 잘 알려져있는 컴퓨터 구조론의 바이블이다. 이 책을 통해서 컴퓨터구조론을 다시 공부해볼 생각이다. 군대 전역 직후 2학년 2학기로 복학해서 컴퓨터 구조론 전공 수업을 들었지만 학점을 위한 공부만 해서 남아있는게 없는 것 같다. 인턴 생활을 하면서 다양한 부분에서 어려움을 겪었는데 기초를 몰라서 헤메고 있다는 느낌을 굉장히 많이 받았다.   첫 페이지를 읽었을 때 이 책으로 정하길 정말 잘했다는 생각이 들었다. 전공 수업때 사용했던 컴퓨터구조론 책은 제작자의 관점에서 기술 되었다는 느낌을 강하게 받았었다. 하지만, CSAPP는 프로그래머의 관점에서 기술하였고, 컴퓨터구조론의 시스템들을 어떻게 사용해서 좋은 프로그램을 개발할 수 있는지를 배울 수 있다고 한다.  인턴 생활을 하면서 실제 현업을 겪고 느꼇던 강한 의문들을 해결할 수 있을 것 같은 느낌이다.   책의 목차는 정보의 표현과 처리로 시작하여 프로그램의 기계어 표현, 프로세서 구조, 프로그램 성능 최적화, 메모리 계층구조, 링커, 예외적인 제어흐름, 가상메모리, 시스템 수준 입출력, 네트워크 프로그래밍, 동시성 프로그래밍  순서로 이어져 있다. 많은 사람들은 6장 메모리 계층구조, 7장 링커의 전까지 읽어도 좋다고 하지만, 가능하다면 12장 동시성 프로그래밍까지 읽어볼 생각이다.   Chapter 01. 컴퓨터 시스템으로의 여행     시스템 구현방식은 변하지만 근본적인 개념들은 변하지 않는다.   프로그래머들로 하여금 컴포넌트들이 어떻게 동작하고 프로그램 성능과 정확성에 어떤 영향을 주는지 알 수 있다.   1.1 정보는 비트와 컨텍스트로 이루어진다.     텍스트 문자 -&gt; 아스키(ASCII) 표준 사용하여 표현 -&gt; 각 문자를 바이트 길이의 정수 값으로 표현 -&gt; 연속된 바이트 파일 저장   1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.     hello.c 실행 -&gt; 저급 기계어 인스트럭션들로 번역 -&gt; (실행가능 목적 프로그램)으로 합쳐져 바이너리 디스크 파일로 저장  -&gt; 컴파일러 드라이브는 유닉스 시스템에서 소스파일에서 오브젝트 파일로 변경 -&gt; 4개의 단계를 거쳐서 실행            4개의 단계:                    전처리기           컴파일러           어셈블러           링커                           1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.     프로그램 성능 최적화하기            eg1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?       eg2) while 루프는 for 루프보다 더 효율적일까?       eg3) 포인터 참조가 배열 인덱스보다 더 효율적인가?           링크 에러 이해하기            eg1) 정적변수와 전역변수의 차이는 무엇인가?       eg2) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?           보안 약점 피하기            eg1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?           1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.     인스트럭션이란 : 컴퓨터에게 일을 시키는 단위(기계어)       시스템의 하드웨어 조직            버스 : 시스템 내를 관통하는 전기적 배선군       입출력 장치 : 시스템과 외부세계외의 연결 담당       메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치       프로세서 : 인스트럭션들을 해독(실행)하는 엔진                    인스트럭션의 요청에 의해 CPU(프로세서)가 실행하는 단순한 작업의 예                            적재(load), 저장(store), 작업(operate), 점프(jump)                                                        프로그램의 실행              1.5 캐시가 중요하다.     hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다.   프로그램이 로딩될 때 이들은 메인 메모리로 복사된다.   이 작업이 시간이 너무 오래 걸려서 “단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하는” 캐시 메모리가 설계 되었다.   캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성을 활용하였다.   1.6 저장장치들은 계층구조를 이룬다.          모든 컴퓨터 시스템의 저장장치즈들은 메모리 계층구조로 구성되어 있다.              1.7 운영체제는 하드웨어를 관리한다.     운영체제는 두 가지 주요 목적을 가지고 있다.            제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해       응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해           위 두가지 목표를 위해 근본적인 추상화를 통해 달성하고 있다.   추상화 결과            프로세스 : 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과       가상 메모리 : 메인 메모리와 디스크 입출력 장치의 추상화       파일 : 입출력장치의 추상화           1.8 시스템은 네트워크를 사용하여 다른 시스템과 통신한다.     네트워크는 또 다른 입력장치로 볼 수 있다.   시스템이 메인 메모리로부터 네트워크 어댑터로 일련의 바이트를 복사할 때, 데이터는 로컬디스크 드라이브 대신에 네트워크를 통해서 다른 컴퓨터로 이동된다.   1.9 중요한 주제들     Amdahl의 법칙            우리가 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 구 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계된다.           동시성과 병렬성            동시성 : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념       병렬성 : 동시성을 사용해서 시스템을 보다 더 빠르게 동작하도록 하는 것       쓰레드 수준 동시성                    쓰레드를 이용하면 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수 있음                       인스트럭션 수준 병렬성                    프로세서들은 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있음                           컴퓨터 시스템에서 추상화의 중요성            추상화의 사용은 전산학에서 가장 중요한 개념!           1.10 요약     컴퓨터 내의 정보는 비트들의 그룹으로 표시   컴파일러와 링커에 의해 바이너리 실행파일들로 번역   프로세서는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석   컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간에 데이터를 복사하고 쓰는 데 사용   위와 같은 이유로 시스템의 저장장치들은 계층구조 형성   운영체제 커널은 응용프로그램과 하드웨어 사이에서 중간자 역할 수행   네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법 제공   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.   비트 패턴            이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.       표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.           인코딩            비부호형 : 전통적인 이진수 표시 사용       부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법       부동소수점 : 2진수 버전의 소수 표시방법           이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.        2.1 정보의 저장     기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급   메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음   모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름   2.1.1 16진수 표시     1바이트는 8비트로 이루어짐        이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&gt; 16진수 사용              16진수 &lt;-&gt; 10진수 &lt;-&gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음            2.1.2 데이터의 크기     모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨            w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐       프로그램은 최대 2^w 바이트에 접근 가능                최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임              2.1.3 주소지정과 바이트 순서     여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정            객체의 주소가 무엇이 되어야 하는지       메모리에 바이트들을 어떻게 정렬해야 하는지           비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.            가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]       가장 덜 중요한 바이트 : [x7, x6, . . . , x0]           바이트 저장 방법            리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는       빅 엔디안 : 가장 중요한 바이트가 먼저 오는       대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작           바이트 순서가 이슈가 되는 경우            이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때                    리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜                       정수 데이터를 나타내는 바이트들을 살펴볼 때       프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때           2.1.4 스트링의 표시      그냥 ASCII를 사용한다는 내용,,,    2.1.5 코드의 표현          인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름                   컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것       2.1.6 부울 Boolean 대수     NOT : ~   AND : &amp;   OR : |        EXCLUSIVE-OR : ^              2.1.7 C에서의 비트수준 연산          C에서는 비트들 간의 부울 연산을 지원                   비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.             마스크: 비트 연산에 사용되는 데이터            2.1.9 C에서의 쉬프트 연산     비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공   x « k            x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.           x » k            좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.       논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움       산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움           부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용        2.2 정수의 표시          컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것              2.2.1 정수형 데이터 타입     서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.   64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위            음수의 범위가 양의 범위보다 1 더 넓은 것에 주목                  2.2.2 비부호형의 인코딩     음수 값을 포함하지 않음        B2U는 Binary 에서 Unsigned의 줄임말               2.2.3 2의 보수 two’s complement 인코딩     음수 값을 포함        B2T는 Binary 에서 Two’s complement의 줄임말                  모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며,  부호형 수에 대해서 특정 표시를 가정해서도 안된다.    2.2.4 비부호형과 부호형 간의 변환     C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.   2의 보수에서 비부호형으로의 변환            TMin ≤ x ≤ TMax를 만족하는 x에 대해  x가 0보다 크거나 같으면 x x가 0보다 작으면 x+2^w                  이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.            비부호형에서 2의 보수로의 변환            0 ≤ u ≤ UMax를 만족하는 u에 대해 u가 TMax보다 작거나 같으면 u u가 TMax보다 크면 u-2^w                  이유는 T2U의 이유와 동일하다.  이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)            2.2.5 C에서 부호형과 비부호형의 비교     C에서는 부호형과 비부호형 산술연산을 지원한다.            C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.            2.2.6 수의 비트 표시를 확장하기     비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.            영의 확장 zero extension 이라고 알려짐           2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.            부호 확장 sign extension 이라고 알려짐                  2.2.7 숫자의 절삭     진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.       비트의 개수를 줄이는 경우이다.            eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.           비부호형 수의 절삭            x’ = x mod 2^k 이다.                    삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.           자리값들은 모듈(mod) 계산으로 모두 0이 된다.                           2의 보수 숫자의 절삭            x’ = U2T(x mod 2^k) 이다.                    가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.                           2.2.8 Signed와 Unsigned에 관한 조언     부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.   비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.      2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다. 위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수                2.3 정수의 산술연산     두 개의 양수를 더해서 음수가 나오는 경우, x&lt;y와 x-y&lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,            그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.               2.3.1 비부호형 덧셈  x,y, 0≤x, y≤e^w가 있다고 하자, 두 합의 계산 범위는 0≤x+y≤2^(w+1)-2를 갖는다. 이 합의 크기를 표현 하기 위해서는 w+1개의 비트가 필요하게 된다.     “워드 크기 증가”는 산술연산의 결과를 완벽하게 표시하려면 필요한 워드 크기를 제한할 수 없다는 것을 의미한다.   프로그래밍 언어들은 고정길이 산술연산을 지원하며 따라서 “덧셈”과 “곱셈”같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.        x,y에 대해 x+y 정수합을 w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타낸다.                   정상적인 경우에는 x+y값을 유지하지만, 오버플로우의 경우에는 2^w만큼 줄어드는 효과를 낸다.                 산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때 이 연산은 “오버플로우한다”고 한다.         2.3.2 2의 보수의 덧셈  2의 보수 덧셈의 결과값이 너무 크거나(양수) 또는 너무 작아서(음수) 표시할 수 없을 때 우리는 어떻게 해야 할지 결정해야 한다.          x+y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산이다.                    2의 보수의 합이 2^(w-1)을 넘어간다면 양수 오버플로우가 생기고, -2^(w-1) 미만으로 내려간다면 음수 오버플로우가 생겨 각각에 2^w을 더해주거나 빼준다.         2.3.3 2의 보수에서의 비트반전 Negation          비부호형 비트반전                   2의보수 비트반전                   2.3.4 비부호형 곱셈     비부호형 곱셉은 2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것으로 정의된다.        비부호형 수를 w비트로 절삭하는 것은 해당 값을 2^w로 나눈 나머지를 계싼하는 것과 같다.                  2.3.5 2의 보수 곱셈          2^w로 나눈 나머지를 취하고 비부호형에서 2의 보수형태로 변환하는 것과 같다.                  2.3.6 상수를 사용한 곱셈     정수 곱셉은 매우 느리다. 컴파일러에서 수행되는 중요한 최적화는 상수를 곱하게 되는 경우들을 쉬프트와 덧셈의 조합으로 대체한다.   2의 제곱을 곱하는 경우            k≥0인 모든 k에 대해 x2^k의 w+k 비트수준 표현은 우측에 k개의 0을 추가한 것이다.       eg) 11은 w=4인 경우 [1011]이다. 이것을 왼쪽으로 k=2 쉬프트 하면 [101100]이 되며 이것은 11*4=44를 인코딩한 것이다.           2의 제곱을 곱하면 비부형이건 2의 보수 산술연산이건 오버플로우가 발생할 수 있다.            eg) 위의 예제를 예로 들자면, [101100]을 4비트로 절삭하면 1100을 얻는다.              정수 곱셈이 쉬프트와 덧셈을 사용하는 것보다 훨씬 비용이 많이 드는 연산이기 때문에 C 컴파일러들은 정수가 상수와 곱해지는 경우에 이들을 쉬프트, 덧셈, 뺄셈 등의 조합을 사용해서 제거하려고 노력한다.        2.3.7 2의 제곱으로 나눗셈하기     정수 나눗셈은 정수 곱셉보다 훨씬 느리다. 2의 제곱으로 나누는 것은 오른쪽 쉬프트를 사용한다.   비부호형은 논리 쉬프트, 2의 보수는 산술 쉬프트를 사용한다.   2의 보수 음수에서는 보정값을 더해서 결과값을 0 방향으로 근사하도록 한다.       2.3.8 정수 산술연산에 대한 마지막 고찰  컴퓨터에서 실행되는 “정수” 산술연산은 실제로는 modular 산술연산의 형태로 수행된다. 숫자를 표현하기 위해 유한한 길이의 워드를 사용하기 때문에 가능한 값의 범위가 제한되며 연산의 결과가 오버플로우될 수 있다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_03/",
        "teaser": null
      },{
        "title": "[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성",
        "excerpt":"IntelliJ  학교에서는 java를 배울 때 이클립스(Eclipse)를 사용했다. 하지만 python을 주로 다루면서 파이참(Pycharm)에 익숙해졌다.  java 공부를 하면서 좀 더 친숙한 JetBrains 회사의 개발도구를 사용하려고 한다. 정보를 조금 찾아보니 IntelliJ가 현재 내가 사용하고 있는 환경인 Mac Os에서 이클립스보다 오류가 덜 발생한다고 한다. 통합 개발 환경도 제공한다고 하니 이보다 더 좋을 수가 없다!    해당 포스트는 Mac Os 환경에서 진행되었다.   1. IntelliJ 설치  우선 IntelliJ Mac Os 버전을 설치하려면  IntelliJ 설치 링크 에 접속한다.  각자 Mac 환경에 맞는 파일을 다운로드한다.          java 학습을 위해선 Community Edition으로도 충분하다고 한다. 하지만 본인이 학생 신분이라면 학생 라이센스를 이용한 Ultimate 버전을 추천한다.          아래와 같은 창이 뜨면 설치 성공!      2. Java Project 만들기  위의 창에서 Create New Project를 누르면 아래와 같은 창이 열린다.   왼쪽의 리스트에서는 Java 선택, 오른쪽 리스트에서는 아무것도 선택하지 않고, 오른쪽 아래의 “Next” 버튼을 누른다.          Java 프로젝트를 생성할 때 샘플코드를 생성할지 여부.   본인이 직접 생성할 것이기 때문에 아무것도 선택하지 않고 “Next” 버튼을 누른다.          프로젝트 이름을 정하고 “Next” 버튼을 누른다.      3. Hello World 출력하기  프로젝트 생성이 완료되면, main 메소드가 있는 새로운 Java 클래스를 생성하기 위해 src 폴더를 우클릭한다.  New &gt; Java Class 를 선택한다.          새로 생성할 Java Class 이름을 설정하고 Enter를 친다.          Hello World 출력 코드를 작성한다.  상단의 망치 버튼을 클릭하여 빌드하거나 “control + option + R”키를 눌러 빌드한다.          혹은 out &gt; production &gt; “project_name” &gt; “Class_name” 우클릭 후 Run을 선택해도 된다.          이제 IntelliJ와 함께 Java 공부를 시작해보자,,,!  ","categories": ["IntelliJ"],
        "tags": ["Java","IntelliJ"],
        "url": "/intellij/java_01/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산",
        "excerpt":"Part1 자바 시작하기  Java     객체지향언어   C,C++ 문법을 기본으로 개발            C언어에 객체지향 특성 확장           플랫폼에 독립적임            JVM으로 인해서 어떤 플랫폼에서도 실행 가능함           Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌   JDK : Java Development Kit        JAVA 개발순서     코드 작성   코드 컴파일   컴파일한 소스를 JVM을 이용하여 실행        주석문     // : 행단위 주석   /* */ : 블럭단위 주석   /** ..*.. */ : 문서화 주석       Part2 변수와 계산   변수  변수 값(Data)을 저장할 수 있는 메모리 공간     java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨   java 식별자 명명 규칙            첫 번째 글자는 문자 이거나 $,_ 이어야 함       $,_ 이외의 특수문자는 사용 불가능       키워드는 식별자로 사용할 수 없음           java 변수 명명 관례            첫 번째 문자가 소문자인 명사로 정함       여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)       _를 쓰지 않음               상수  상수란 수식에서 변하지 않는 값을 의미     상수의 선언            final 상수타입 상수명;                    eg) final int J;                           상수 명명 관례            대문자로만 구성된 명사로 정함       여러 단어로 구성된 이릠의 경우 단어 사이에 _을 써서 구분함           상수를 사용해야 하는 경우            값이 변하면 위험한 경우에 상수 사용       값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용               기본형 타입  기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.     논리형            boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음           문자형            char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능           정수형            int 4byte, long 8byte           실수형            float 4byte, double 9byte           리터럴            CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어       리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함           사용 방법            long : 값을 적을 때 뒤에 l이나 L 적어야함       float : 값을 적을 때 뒤에 f나 F를 적어야함               기본형 타입변환     묵시적 형변환            크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌           명시적 형변환            크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함       eg) long x = 20; int y = (int) x;               연산자 우선순위     최우선연산자 ( ., [], () )   단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&gt;부호&gt;증감)            단, 후위연산자(a++)은 우선순위가 낮음       eg) a=5, x = a++ - 5 라면 x는 0, a는6           산술연산자 ( *,/,%,+,-,shift) &lt; 시프트연산자 ( »,«,»&gt; ) &gt;   비교연산자 ( &gt;,&lt;,&gt;=,&lt;=,==,!= )   비트연산자 ( &amp;,|,,~ )   논리연산자 (&amp;&amp; , || , !)   삼항연산자 (조건식) ? :   대입연산자 =,*=,/=,%=,+=,-=  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_02/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 제어문",
        "excerpt":"Part3 제어문   if 조건문  조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.     if 문   if - else 문   if - else if - else 문       논리 연산자  논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.                                     OR :                                       AND : &amp;&amp;   NOT : !   EXCLUSIVE-Or : ^       삼항 연산자     조건식 ? 피연산자1 : 피연산자2            조건식의 결과가 true 라면 결과는 피연산자1       조건식의 결과가 false 라면 결과는 피연산자2               switch문  switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.   switch(변수){         case 값1 :              실행문;              break;         case 값2 :              실행문;              break;           default;         }     break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.   JDK7 이후에는 문자열 타입의 변수도 가능함      당연한걸 수도 있지만, case 에 조건문을 달면 오류가 난다 하하,,,        while문  조건문의 실행 결과가 true일 동안 반복해서 실행한다.   while(조건문){         실행문;      }      do while문  while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.      do{         실행문;     }while(조건문);     실행문을 한번은 실행하고 싶을 경우에 사용됨       for 반복문  for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨       for(초기화식; 조건식; 증감식){         실행문;         실행문;     }  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 배열",
        "excerpt":"Part4 배열   배열 만들기  배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다.   int[] array1 = new int[4]; int[] array2 = new int[]{1,2,3,4}; int[] array3 = {1,2,3,4};      배열 사용하기     배열에 접근할 때에는 인덱스를 통해서 접근한다.   배열의 길이를 알아내는 방법 : array.length        2차원 배열  2차원 배열이란 배열의 배열이다.   int[][] array4 = new int[3][4];  int[][] array5 = new int[3][]; //위와 같이 선언하면 array5는 3개짜리 배열을 참조한다. 3개짜리 배열은 아직 참조하는 배열이 없다는 것을 의미. array5[0] = new int[1]; //정수를 하나 담을 수 있는 배열을 생성해서 array5 의 0 번째 인덱스가 참조한다.   array5[1] = new int[2]; //정수를 두개 담을 수 있는 배열을 생성해서 array5 의 1 번째 인덱스가 참조한다.   array5[2] = new int[3]; //정수를 세개 담을 수 있는 배열을 생성해서 array5 의 2 번째 인덱스가 참조한다.       for each  for문 안에 (value:array), array의 값 하나씩 value로 매칭된다.     python for in 이랑 똑같은거 같아서 너무 반갑다!    int[] iarr = {10,20,30,40,50};  for(int value:iarr){     System.out.println(value); } ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_04/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수           2.3 정수의 산술연산            비부호형 및 2의보수의 덧셈,뺄셈,곱셉,나눗셈                2.4 부동소수점     부동소수점 표현은 V = x*2^y 형태의 소수를 인코딩한다.   거의 모든 컴퓨터가 IEEE 부동소수점이라고 알려지게 된 방식을 지원한다.        2.4.1 비율이진수(Fractional Binary Numbers)     부동소수점에 대해서 이해하기 위한 첫 단계는 비율 이진수에 대해 생각해보는 것이다.            숫자들의 자리값은 십진 소수점 부호(‘.’)에 상대적으로 정의된다.                  위와 같은 방식으로 binary 표기법으로 생각해보자.            부호 ‘.’는 이진 소수점이 되고, 좌측의 브트들은 비음수의 2의 제곱을 자리값으로 가지며, 우측은 2의 음의 제곱을 자리값으로 갖는다.       이진 소수점을 한 자리 우측으로 이동하면 2로 곱한 효과, 좌측으로 이동하면 2로 나눈 효과를 가진다.                  이진수 표기는 x*2^y로 나타낼 수 있는 수만 표시할 수 있다.   이진 표시를 길게 늘려서 정확도를 높이도록 근사해야 한다.        2.4.2 IEEE 부동소수점 표시     IEEE 부동소수점 표준은 수를 V = (-1)^sM2^E 형태로 나타낸다            s는 음수와 양수를 결정한다.       유효숫자 M은 비율 이진수다.       지수 E는 2의 제곱으로 자리값을 제공한다.           부동소수점 수의 비트 표시는 이 값들을 인코딩하기 위해 세 개의 필드로 나누어진다.            한 개의 부호 비트 s는 부호 s를 직접 인코딩한다.       k비트 지수 필드 exp = ek-1…e1e0는 지수 E를 인코딩한다.       n비트 비율 필드 frac = fn-1 … f1f0는 유효숫자 M을 인코딩한다.                 Case 1: 정규화 값 Normalized Values            가장 일반적인 경우       exp의 비트 패턴이 모두 0은 아니며, 모두 1이 아니어야 한다.       E = e - Bias (Bias = 2^(k-1) - 1)       비율 필드 frac은 비율 값 f       유효 숫자 M = 1 + f 로 정의           Case 2: 비정규화 값 Denormalized Values            지수 필드가 모두 0일 때 나타낸 수는 비정규화 형태를 갖는다.       E = 1 - Bias       M = f = 0       비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타냄                    이들은 점증적 언더플로우라고 알려진 특성을 제공 (가능한 숫자 값들이 0.0 근처에서 같은 간격을 갖는다는 의미)                           Case 3: 특수 값 Special Values            지수 필드가 모두 1인 경우                    비율 필드가 모두 0이면, 결과값은 무한대를 나타냄           비율 필드가 0이 아니면 NaN(not a numbuer)                                   2.4.3 숫자 예제      2.4.4 근사법 Rounding     부동소수점 산술연산은 표시방법이 제한된 범위와 정밀도를 갖기 때문에 실제 연산의 근사값을 사용할 수밖에 없다.   “가장 유사한” 값 x를 체계적으로 계산하는 방법을 근사rounding 연산이다.   네가지 근사 모드를 정의함            짝수근사법(round-to-even): 가장 가까운 값, 중간에 위치할 경우 짝수를 향해 근사함       영방향근사 모드(round toward-zero): 양수 값을 아래쪽으로, 음수를 위쪽으로 근사함       하향근사 모드(round-down): 양수와 음수를 모두 아래쪽으로 근사함       상향근사 모드(round-up): 양수와 음수를 모두 위쪽으로 근사함                2.4.5 부동소수점 연산     부동소수점 값 x,y를 실수로 보고, 일부 연산이 실수들에 대해 정의된다면 Round(x,y)가 되는데, 이것은 실수 연산의 정확한 결과 값을 근사한 것이다.   부동소수점 덧셈에서 결합법칙이 성립하지 않는 것은 그룹의 특징 중에서 빠진 가장 중요한 부분이다.   교환법칙은 성립하지만, 결합벅칙은 성립 되지 않는다.        C에서 부동소수점     C는 짝수 근사모드를 사용한다.   int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.   int나 float에서 double로, 정확한 수치 값은 보존될 수 있다.   double에서 float로 범위가 더 작아지기 때문에 값이 오버플로우하여 무한대가 될 수 있따.   float나 double에서 int로, 값은 0 방향으로 근사된다        2.5 요약     정보를 비트로 인코딩하며, 이들은 일반적으로 연속된 바이트들로 구성된다.   대부분의 머신들은 정수를 인코딩하기 위해 2의 보수를 사용하고 부동소수점을 인코딩하기 위해 IEEE 표준 754를 사용한다.   부호형 및 비부호형 정수를 캐스팅할 때 비트 패턴을 유지하려고 하는데, T2U, U2T 함수들에 의해 나타난다.   제한된 길이는 숫자들이 나타낼 수 있는 범위를 넘어설 때 오버플로우를 발생시킨다.   비부호형과 2의 보수 산술연산은 결합법칙, 교환법칙, 분배법칙 등의 정수 산술연산의 많은 특성을 만족한다.   결합법칙, 교환법칙, 분배법칙 특성을 쉬프트와 2의 제곱의 곱셈 간 관계와 함께 사용된다.   부동소수점 산술연산은 매우 조심스럽게 사용해야한다.            제한된 범위와 정밀도를 갖기 때문이며, 결합법칙 같은 일반적인 수학 법칙을 따르지 않기 때문이다.                   부동소수점을 마지막으로 Chapter2 정보의 표현과 처리를 마무리하였다. 데이터 엔지니어링 인턴 포지션에서 ETL 작업을 하며 소수점 데이터에 접근 했을 때  R코드와 Python의 소수 처리 방식이 달라서 해당 오류를 잡는데 많은 시간이 걸린 경험이 있었다. 그 때 당시에는 대충 방식이 다르구나~ 로 끝났지만, 이번 챕터를 공부하게 되면서 아 부동소수점의 표현 방식 때문에(책은 C를 기준으로 하고 있지만,,,) 그런 오류가 잡혔던 거구나 하고 시야가 조금 더 넓어진 것 같다.  2.2절의 캐스팅과 2.4절의 부동소수점을 공부하면서 꽤 많은 애를 먹었지만, 앞으로 코딩을 하면서 캐스팅이나 소수점을 다룰 때 더 주의 깊게 다룰 수 있을 것 같다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_04/",
        "teaser": null
      },{
        "title": "[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰",
        "excerpt":"Introduction     Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나   Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델   NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음            Machine Translation, Abstract Text Summarization           자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨   Encoder-Attention-Decoder       Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형   Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조       Related Works       Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train   GPT는 Language Modeling을 위해 Decoder를 Pre-train   이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음       MASS:Masked Sequence to Sequence Pre-training       새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자   Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking   마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴   Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공   Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선   Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨        K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터   하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능   BERT Masked LM            K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐           GPT Standard LM            하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨       Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐                m - Input sequence의 전체길이   u - Maskinge된 Fragment의 시작점   v - Masking된 Fragment의 끝점   X^u - u부터 v까지의 fragment   X^\\u:v - u부터 v까지 Making된 Input Sequence       Experiments     Model Configuration            1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer           Datasets            2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M       MASS의 효과 검증을 위한 low-resource language Romanian           Pre-training Details            Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험               Experiment:Unsupervised Machine Translation       Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행   Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델   MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록        Experiment:Low-resource Translation       Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역   Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트   MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가   데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남        Experiment:Abstractive Summarization       Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교   MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가        Experiment:Conversational Response Generation       Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교   MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌        The probability formulation       (a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL   하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과   실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨            문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공           K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증       Couclusion     MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록   Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정   또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%       Related Works     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.       Model     ELMO            ELMO word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM          Task-specific ELMo Embedding         Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.                  Evaluation         6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.        Analysis        기존에 top layer output만 사용 한 것 대비 성능 향상을 검증했다.   대부분의 경우 Regularization parameter λ 가 작을수록 성능이 더 좋아지는 경향이 있다.          일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.          GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.          biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다.          ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.       Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속되 바이트인 기계어 코드를 실행한다.   컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 기계어 코드를 생성한다.   어셈블러 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는 저급 인스트럭션들을 명시해야 한다.   기계어 코드를 배우면 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내제된 비효율성을 분석할 수 있다.   이 장은 X86-64에 기초하고 있다.        3.1 역사적 관점     x86이라고 통칭하는 인텔 프로세서 제품군은 오랜 기간 진화를 통한 개발을 해왔다.            대충 엄청 많은 프로세서들이 나열 되는데, 팬티엄4E(2004, 125M 트랜지스터) 하이퍼쓰레딩 기법의 추가와 AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T가 추가된 해당 모델을 x86-64라고 부른다고 한다.                 3.2 프로그램의 인코딩     C 언어에서 gcc 명령은 소스 코드(test.c)를 실행 코드로 변환하기 위해 일련의 프로그램들을 호출한다.            C 전처리가 #include로 명시된 파일을 코드에 삽입해 주고 #define으로 선언된 매크로를 확장해준다.       컴파일러는 소스파일의 어셈블러 버전(test.s)를 생성한다.       어셈블러는 어셈블리 코드를 바이너리 목적코드인(test.o)로 변환한다.                    목적코드는 기계어 코드의 한 유형이다. - 모든 인스트럭션과 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았다.                       마지막으로 링커가 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.           커맨드 라인 옵션으로 -0g를 주면 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적호 수준을 적용한다.            높은 수준의 최적화를 적용하면 만들어진 코드가 너무 많이 변경되어 본래의 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.                3.2.1 기계수준 코드     컴퓨터 시스템은 보다 간단한 추상화 모델을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.            기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조 즉 “ISA”에 의해 정의된다.                    프로세서의 상태, 인스트럭션의 형식, 프로세서 상태에 대한 각 인스트럭션들의 영향들을 정의한다.                       기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.           컴파일러는 추상화된 실행모델로 표현된 프로그램을 프로세서가 실행하는 매우 기초적인 인스트럭션들로 변환하는 대부분의 일을 수행한다.        3.2.2 코드 예제       기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현에 주목할 필요가 있다.            x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.       인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을 기계어 인스트럭션으로 유일하게 디코딩할 수 있도록 설계한다.       역어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다.                3.3 데이터의 형식     인텔 프로세서들이 근본적으로 16비트 구조를 사용하다가 추후에 32비트로 확장했기 때문에 인텔은 “워드”라는 단어를 16비트 데이터 타입을 말할 때 사용한다.           3.4 정보 접근하기     x86-64 주처리장치 CPU는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.            이들 레지스터는 정수 데이터와 포인터를 저장하는데 사용한다.                   3.4.1 오퍼랜드 식별자 specifier     대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다.   오퍼랜드는 연산을 수행할 소스 값과 그 결과를 저장할 목적지의 위치를 명시한다.   소스 값은 상수로 주어지거나 레지스터나 메모리로부터 읽을 수 있다. 결과 값은 레지스터나 메모리에 저장된다.   세가지 타입으로 나뉘어짐            immediate로, 상수값을 말한다.       register는 레지스터의 내용을 나타내며       Memory, 메모리 참조로 유효주소라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.                   3.4.2 데이터 이동 인스트럭션     가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 복사하는 명령어다.            MOV 클래스 : 소스 위치에서 데이터를 목적지 위치로 어떤 변환도 하지 않고 복사한다.           소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다.   목적 오퍼랜드는 레지스터 또는 메모리 주소의 위치를 지정한다.   x86-64는 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다.              3.4.3 코드 예제           C언어에서 “포인터”라고 부르는 것이 어셈블리어에서는 단순히 주소를 나타낸다.     포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 과정으로 이루어진다.     지역변수들은 메모리에 저장되기보다는 종종 레지스터에 저장된다.           3.4.4 스택 데이터의 저장과 추출 push,pop     push와 pop은 프로그램 스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다.   스택은 프로시저 호출을 처리하는 데 중요한 역할을 한다.   프로그램 스택은 메모리의 특정 영역에 위치한다.   스택의 탑top 원소가 모든 스택 원소 중에서 가장 낮은 주소를 갖는 형태다.   스택은 pop이 되어도 stack의 top을 표현하는 주소가 올라간거지 값은 여전히 pop이 된 위치에 남아있다.   스택이 프로그램 코드와 다른 형태의 프로그램 데이터와 동일한 메모리에 저장되기 때문에 프로그램들은 표준 메모리 주소지정 방법을 사용해서 스택 내 임의의 위치에 접근할 수 있다.      ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_05/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.5 산술연산과 논리연산       위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.   인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.            addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.           연산들은 네 개의 그룹으로 나누어진다.            유효주소 적재, 단항unary, 이항binary, 쉬프트                    이항 연산은 두 개의 오퍼랜드를 가진다.           단항 연산은 한 개의 오퍼랜드를 가진다.                           3.5.1 유효주소 적재 Load Effective Address     유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.   메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.   가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.   이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.   또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다            ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.           목적 오퍼랜드는 반드시 레지스터만 올 수 있다.   3.5.2 단항 및 이항 연산     단항 연산            하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.       오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.       ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자           이항 연산            첫 번째 오퍼랜드는 상수나 레지스터, 메모리 위치가 올 수 있고 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.       C에서 x -= y와 유사하다.       두 개의 오퍼랜드가 모두 메모리 위치가 될 수 없다.       두 번째 오퍼랜드가 메모리 위치일 때 프로세서가 메모리에서 값을 읽고, 연산을 하고, 그 결과를 다시 메모리에 써야 한다는 점에 유의해야 한다.           3.5.3 쉬프트 연산     쉬프트하는 크기를 먼저 주고, 쉬프트할 값을 두 번째로 준다.   산술과 논리형 우측 쉬프트가 모두 가능하다.   쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 명시할 수 있다.   좌측 쉬프트 인스트럭션에는 두 가지 이름이 있다.            SAR: 산술 쉬프트, 부호비트를 복사해서 채운다       SHR: 논리 쉬프트, 0으로 채운다           쉬프트 연산의 목적 오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.   3.5.4 토의     인스트럭션들은 비부호형과 2의 보수 산술연산에 사용될 수 있다.   오직 우측 쉬프트만이 부호형과 비부호형 데이터를 구분하는 인스트럭션을 요구한다.   이것이 부호형 정수 산술연산을 구현하는 방식으로 2의 보수 산술연산을 선호하는 주요 특징이다.   3.5.5 특수 산술연산       두 개의 64비트 부호형 또는 비부호형 정수들 간의 곱셈 결과값을 표시하기 위해 128비트를 필요로한다.   x86064 인스트럭션 집합은 128비트 숫자와 관련된 연산에 대해서는 제한적인 지원을 제공한다.            워드(2바이트), 더블워드(4바이트), 쿼드워드(8바이트), 인텔은 16바이트 워드를 옥트워드oct word라고 명명한다.           IMUL 인스트럭션 클래스의 멤버인 형태            이 형식은 두 개의 64비트 오퍼랜드로부터 64비트 곱을 생성하는 “2 오퍼랜드” 곱셈 인스트럭션을 제공한다.           추가적으로 x86-64는 두 개의 다른 “단일 오퍼랜드” 곱셈 인스트럭션을 제공하며 64비트 값의 완전한 128비트 곱을 계산한다.            하나는 비부호형(mulq), 다른 하나는 2의 보수(imulq) 곱셈이다.       이들 모두 한 개의 인자는 레지스터 %rax에 보관해야 하고 다른 하나는 인스트럭션 소스 오퍼랜드로 주어진다.       곱은 레지스터 %rdx(상위 64비트)와  %rax(하위 64비트)에 저장된다.           곱을 저장하기 위해서는 아래의 그림처럼 두 개의 movq 인스트럭션이 필요하다.        단일 오퍼랜드 곱셈 인스트럭션과 비슷한 단일 오퍼랜드 나눈셈 인스트럭션으로 제공된다.   나눗셈 인스트럭션 idviq은 피제수dividened를 128비트로 레지스터 %rdx(상위 64비트)와 %rax(하위 64비트)에 저장한다.   제수divisor는 인스트럭션의 오퍼랜드로 주어진다.   인스트럭션은 몫은 레지스터 %rax에, 나머지는 레지스터 %rdx에 저장한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_06/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰",
        "excerpt":"Introduction     Multi-Task Learning(MTL)은 새로운 Task를 학습하는 데 도움이 되도록 이전 작업에서 학습된 지식을 적용하는 인간 학습 활동에서 영감을 받음   Deep neural networks(DNN)를 이용한 representation learning에 MTL을 적용하는 것에 대한 관심이 높아지고 있음            DNN을 이용한 representation learning은 많은 양의 데이터를 요구함, MTL은 많은 task에서의 supervised labeled data를 제공함       MTL은 특정 Task에 Overfitting 되지 않도록 Regularization 효과를 줌           MTL과 대조적으로, Language Model은 대용량의 unsupervised dataset을 활용하여 모델을 학습함            ELMo, GPT, BERT           MT-DNN은 Language Model Pre-Training을 활용한 BERT에 Multi-task learning을 적용하여 성능을 개선한 모델      Tasks     GLUE의 9개 task를 MTL에 활용   Single Sentence Classification            하나의 문장이 주어졌을 때 문장의 Class를 분류하는 Task       CoLA : 문장이 문법적으로 맞는지 분류 (True/False)       SST-2 : 영화 Review 문장의 감정 분류 (Poistive/Negative)           Text Similarity            문장 쌍이 주어졌을 때, 점수를 예측하는 Regression Task       STB-B : 문장 간의 의미적 유사도를 점수로 예측           Pairwise Text Classification            문장 쌍이 주어졌을 때, 문장의 관계를 분류하는 Task       RTE, MNLI : 문장 간의 의미적 관계를 3가지로 분류 (Entailment, Contradiction, Neutral) – QQP, MRPC : 문장 간 의미가 같음 여부를 분류 (True/False) – Relevance Ranking – QNLI : 질문과 해당 지문 중 한 문장이 쌍으로 주어졌을 때 해당 지문 문장에 질문의 답이 있는지 여부를 분류 (True/False) – MT-DNN에서는 이를 Rank 방식으로 바꾸어 모든 지문 문장에 정답이 있을 가능성을 Scoring 하여 가장 Score가 높은 지문 문장을 True로 분류하는 방식으로 Task 수행              Model Architecture         Lexicon Encoder            Token Embedding                    맨 앞에 [CLS] 토큰을 추가. 추후 Output에서 Classification 등을 위해 사용됨           만약 문장쌍이 들어온다면 각 문장은 Wordpiece로 Toenization 되며 [SEP] Token이 두 문장 사이의 구분자로 사용됨                       Sentence Embedding - 1번째 혹은 2번째 문장임을 표현하는 Vector       Positional Embedding - 각 Token의 위치 정보를 표현하는 Vector                 Transformer Encoder            Lexicon Encoder로 부터 각 Token의 Input Vector를 입력으로 받아 Ouput Vector 추출       BERT 모델과 달리 task별로 fine-tunning하지 않고 MTL로 fine-tunning 함                 Single-Sentence Classification Ouput            [CLS] Token과 Task Specific Parameter의 곱에 Softmax를 취하여 Ouput 추출                  Text Similarity Ouput            [CLS] Token을 활용하여 Task Specific Parameter와 곱한 후 sigmoid function을 사용하여 Score를 예측                  Pairwise Text Classification Ouput            BERT와 다르게 Stochastic Answer Network(SAN)를 이용함                    NLI의 기존 SOTA 모듈, 주어진 문장들에 대한 Multi-step Reasoning을 모델링하는 구조 (한번에 classification 결과를 예측하지 않고 여러번의 예측을 통한 Reasoning으로 결과를 예측)           SAN은 GRU모듈에 주어진 문장쌍의 representation을 Input 및 hidden state로 넣는 과정을 k번 반복함으로써 정제된 representation을 얻고 이를 이용하여 최종 예측                                 각 step을 진행할때마다 linear classifier를 거쳐 각 클래스에 대한 확률 분포 계산         모든 K-step output을 평균하여 클래스에 대한 최종 확률 분포를 계산, averaging 연산 전에 stochastic prediction droput을 적용         Relevance Ranking Ouput            Question과 문장 Pair Input으로 넣어 생성한 [CLS] Token에 Sigmoid를 취하여 문장 별로 점수를 Scoring하고 가장 높은 점수 만 Question에 해당하는 정답이 있다고 예측하는 방식              Training Procedure      Experiments     Datasets            GLUE 벤치마크는 QA, Sentiment Analysis, Text Similarity, Textual Entailment를 포함한 NLU task       SNLI 데이터셋은 570K개의 문장 쌍       SciTail은 Science Question Answering 데이터셋에서 파생된 Textual Entailment 데이터셋임                    주어진 전제가 주어진 가설을 수반하는지 여부를 평가                                  Implementation details            Optimizer : Adamax       learning rate : 5e-5       Batch Size : 32       Maximum number of epoch : 5       Fine-tuning layer dropout : task마다 다르게 설정(MNLI:0.3, CoLA:0.05, Else:0.1)       Tokenizer : WordPiece           Experiments - GLUE Results         MT-DNN이 BERT보다 전체 성능이 약 1.8% 향상됨   각각의 Task 결과가 대부분 SOTA임        Dataset이 적은 Task(MRPC, RTE)의 경우 비교적 높은 성능 향상이 있음              Specific layer로 SAN 사용, pairwise ranking을 한 효과를 보여주는 실험   BERT vs ST-DNN            ST-DNN은 BERT처럼 single-task로 fine-tunning함       MNLI, QQP, MRPC, QNLI에서 BERT보다 성능이 좋음           ST-DNN vs MT-DNN            데이터가 적은 실험에서 더 큰 성능향상이 있음           Experiments - Domain Adaptation Results         SNLI와 SciTail에 MT-DNN을 적용한 실험   MT-DNN은 데이터를 0.1%만 써도 성능이 잘나옴   MT-DNN이 BERT보다 데이터가 적을 때, 압도적인 성능을 보여줌   Conclusion      Multi-task learning model과 pre-training을 결합한 MT-DNN 모델 제안   MT-DNN은 SNLI, SchiTail 및 GLUE에서 10가 NLU task에 높은 성능 향상 결과를 얻음   MT-DNN은 Domain Adaption 실험에서도 탁월한 일반화 기능을 보여줌   MT-DNN 개선을 위해 MTL에서의 모델 구조 공유에 더 깊은 이해, fine-tuning과 pre-training을 위한 더 효과적인 훈련 방법을 더 연구해야함  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 클래스와 객체",
        "excerpt":"Part5 클래스와 객체   클래스 선언     클래스            자바는 객체를 만들기 위해 반드 클래스를 먼저 만들어야 한다. 클래스는 객체를 만들기 위한 일종의 틀이다.                    붕어빵이 객체라면, 붕어빵 틀은 클래스           자동차 클래스 생성           컴파일하여 디스크에 Car라는 클래스를 생성한다.           자동차 클래스가 생성되었다고 해서 자동차가 만들어 진것은 아니다.                                   public class Car{         }        Car객체 생성하기 (자동차 만들기)            new 연산자는 new 연산자 뒤에 나오는 생성자를 이용하여 메모리에 객체를 만들라는 명령.       메모리에 만들어진 객체를 인스턴스(instance)라고도 한다.       이렇게 만들어진 객체를  참조하는 변수가 c1, c2 이다.       아래의 코드가 실행되면 Car라는 객체가 2개가 만들어지고 각각의 객체를 참조하는 c1과 c2변수가 선언된다.                   public class CarExam{              public static void main(String args[]){                 Car c1 = new Car();                 Car c2 = new Car();             }          }  참조타입  참조형 타입은 기본형 타입을 제외한 모든 타입입니다. 앞서 배웠던, 배열도 참조형이고, 클래스도 모두 참조 타입이다.     기본형 타입: boolean, char, byte, short, int, long, float, double   참조형 타입: 기본형 타입을 제외한 모든 타입   참조형 변수            Stirng str = new String(“Hello);                    str 변수 앞에 기본형 타입이 아닌 String 클래스가 적혀있다.           이퀄(=) 뒤에는 new 다음에 생성자라는 것이 있다.           new 라는 키워드는 객체를 메모리에 올려준다. 이렇게 메모리에 올라간 객체를 인스턴스라고 말한다.                       메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 레퍼런스 하는 변수가 str 이다. 레퍼런스 한다라는 것은 변수가 인스턴스를 가지고 있는게 아니라 말 그대로 가리킨다는 의미이다.       str이라는 변수에는 메모리의 위치 값이 저장되는 것이다. 메모리의 위치값이 저장된다고 하더라도,  어떤 메모리에 저장되는지 그 정보를 알 수 있는 방법은 없다. 그렇기 때문에 str변수는 String 인스턴스를 참조한다라고만 알면 된다.           String 클래스  문자열을 표현하는 자바에서 가장 많이 사용하는 클래스    자바 인스턴스 생성 방법     new 연산자를 이용하지 않고 인스턴스를 만드는 경우            “hello”라는 문자열이 메모리 중에서 상수가 저장되는 영역에 저장된다. 상수는 변하지 않는 값을 의미.       String str2 = “hello”; 이 문장이 실행될 때에 hello 라는 문자열 상수는 이미 만들어져 있으므로 str1이 참조하는 인스턴스를 str2도 참조한다.               String str1 = \"hello\";     String str2 = \"hello\";      new 연산자를 이용해서 인스턴스를 만드는 경우            new연산자를 이용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어진다.       String str4 = new String(“hello”); 이 문장이 실행될때도 새롭게 만들게 되므로, str3 과 str4는 서로 다른 인스턴스를 참조한다.       변수끼리 == 로 비교하면 서로 같은 것을 참조하는지 비교한다.       String은 다른 클래스와 다르게 new를 사용하지 않고 사용할 수 있다. 메모리를 아끼려면 String은 new를 사용하지 않고 사용하는 것이 좋다.       String은 불변 클래스이다. 불변이란 String이 인스턴스가 될때 가지고 있던 값을 나중에 수정할 수 없다.       String은 문자열과 관련된 다양한 메소드를 가지고 있다. 메소드를 호출한다 하더라도 String은 내부의 값이 변하지 않는다.       String이 가지고 있는 메소드중 String을 반환하는 메소드는 모두 새로운 String을 생성해서 반환한다.               String str3 = new String(\"hello\");     String str4 = new String(\"hello\");  필드(filed) 선언  자동차는 자동차 이름, 자동차 번호를 가지고 있고, 자동차는 달리고 멈추는 기능이 있따. 여기에서 가지고 있는 것을 속성이라고 한다. 자바에서는 이러한 속성을 필드(Field)라는 용어로 사용한다.     이름과 번호를 필드로 가지고 있는 Car 클래스 선언       public class Car{         String name;             int number;     }     Car 클래스를 인스턴스화 하기       Car c1 = new Car();     Car c2 = new Car();     //Car라는 인스턴스가 메모리에 2개 만들어 진다. 객체별로 name과 number라는 속성을 가진다.     속성 이용하기            참조 변수 다음에 나오는 점(dot)은 참조변수가 참조하는 객체가 가지고 있는 것을 사용할 때 사용               //c1.name은  c1이 참조하는 객체의 name 을 의미.      c1.name = \"소방차\";  //c1이 참조하는 객체의 name을 소방차로 설정      c1.number = 1234;   // c1.number = 1234란 c1이 참조하는 객체의 number를 1234 로 설정       c2.name = \"구급차\"  //c2가 가리키는 객체의name을 구급차로 설정     c2.number = 1004;  //c2가 가리키는 객체의 number를 1004로 설정       System.out.println(c1.name);  //콘솔에 c1이 참조하는 객체의 name 을 출력합니다.      System.out.println(c1.number); //콘솔에 c1이 참조하는 객체의 number 를 출력합니다.       String name = c2.name;   //c2가 참조하는 객체의 name 을 String 타입 변수 name 도 참조하게 합니다.  메소드란?     필드가 물체의 상태라면, 물체의 행동에 해당하는게 메소드다. car에 이름과 번호가 있기도 하지만, car는 앞으로 전진할 수도 있고 후진하는 행동도 할 수 있다.            메소드는 입력값이 있고, 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념이다.       이때 입력값을 매개변수라고 하고, 결과값을 리턴값이라고 한다.                    인자(Argument)는 어떤 함수를 호출시에 전달되는 값을 의미한다.           매개 변수(Parameter)는 그 전달된 인자를 받아들이는 변수를 의미한다.                       메소드란 클래스가 가지고 있는 기능이다. 클래스 안에 선언된다.           메소드(Method) 선언     매개변수도 없고 리턴하는 것도 없는 형태의 메소드            리턴하는 것이 없을 경우 void라고 작성합니다.               public class MyClass{         public void method1(){             System.out.println(\"method1이 실행됩니다.\");         }     }          정수를 받아들인 후, 리턴하지 않는 메소드            받아 들이는 값은 어떤 타입이라도 상관없다.       받아 들이는 값의 수는 여러개 일 수 있다. 여러개일 경우 콤마(,)로 구분한다.               public class MyClass{                public void method2(int x, int y){             System.out.println(x + \" 를 이용하는 method2입니다.\");         }        }          정수를 받아들인 후, 정수를 반환하는 메소드       public int method3(int y){         System.out.println(y + \" 를 이용하는 method5입니다.\");         return 5;     }       String 클래스의 메소드     문자열 길이 구하기            str.length()는 str이 참조하는 문자열의 길이를 구해서 int 타입으로 리턴해주는 메소드이다.           문자열 붙이기(concat)            str.concat(“world”) 메소드는 str이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world를 붙여서 String 타입으로 리턴하는 메소드다.       String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.           문자열 자르기(subString)            str.subString(1,3)은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.       str.subString(2)는 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.           변수의 scope와 static  변수의 scope: 프로그램상에서 사용되는 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의스코프라고 한다.     변수가 선언된 블럭이 그 변수의 사용범위이다.            클래스의 속성으로 선언된 변수 globalScope의 사용 범위는 클래스 전체이다.       매개변수로 선언된 int value는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭 내이다.       메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭 내이다.               public class ValableScopeExam{          int globalScope = 10;   // 인스턴스 변수           public void scopeTest(int value){                int localScope = 10;             System.out.println(globalScope);             System.out.println(localScpe);             System.out.println(value);         }     }          main메소드에서 사용하기            같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.       main은 static한 메소드이다. static한 메소드에서는 static 하지 않은 필드를 사용 할 수 없다.               public class VariableScopeExam {         int globalScope = 10;           public void scopeTest(int value){             int localScope = 20;                         System.out.println(globalScope);             System.out.println(localScope);             System.out.println(value);         }            public static void main(String[] args) {             System.out.println(globalScope);  //오류             System.out.println(localScope);   //오류             System.out.println(value);        //오류           }        }          static            같은 클래스 내에 있음에도 해당 변수들을 사용할 수 없다.       main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메소드를 static 한 메소드라고 한다.       static한 필드(필드 앞에 static 키워드를 붙임)나, static한 메소드는 Class가 인스턴스화 되지 않아도 사용할 수 있다.               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }          static한 변수는 공유된다.            static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.       globalScope같은 변수(필드)는 인스턴스가 생성될 때 생성되기 때문에 인스턴스 변수라고 한다.       staticVal같은 static한 필드를 클래스 변수라고 한다.       클래스 변수는 레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는 것이 더 바람직하다.                    VariableScopeExam.staticVal                               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }       열거형(enum)     자바는 열거타입을 이용하여 변수를 선언할 때 변수타입으로 사용할 수 있다.            열거형은 JDK5에서 추가되었다.       JDK5 이전에는 상수를 열거형 대신 사용                    상수를 이요한는 방법                               public class EnumExam {         public static final String MALE = \"MALE\";         public static final String FEMALE = \"FEMALE\";          public static void main(String[] args) {             String gender1;              gender1 = EnumExam.MALE;             gender1 = EnumExam.FEMALE;                           }     }          상수를 사용했을 때의 문제점            String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에   gender1 = “소년”; 이렇게 수행 되어도 전혀 문제가 되지 않는다.       실행할 때 원했던 값인 MALE,FEMALE이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.           해결 방법            이런 문제를 발생시키지 않게 하기 위해 열거형을 사용한다.       열거형 정의 및 사용 방법               // 정의 방법     enum Gender{         MALE, FEMALE;     }            // 사용 방법     Gender gender2;      gender2 = Gender.MALE;     gender2 = Gender.FEMALE;      //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.            enum에 대해서 좀 더 궁금하다면!! enum의 뿌리   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part6 클래스 다듬기 ",
        "excerpt":"Part6 클래스 다듬기   생성자  모든 클래스는 인스턴스화 될 때 생성자를 사용한다.      생성자의 특징            생성자는 리턴타입이 없다.       생성자를 프로그래머가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어진다.       매개변수가 없는 생성자를 기본생성자라고 한다.       생성자를 하나라도 프로그래머가 만들었따면 기본생성자는 자동으로 만들어지지 않는다.           생성자의 역할            생성자가 하는 일은 객체가 될 때 필드를 초기화 하는 역할을 수행한다.       자동차가 객체가 될 때 반드시 이름을 가지도록 하려면, Car 클래스를 다음과 같이 만들어야 한다.               public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }            // 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법     public class CarExam2{         public static void main(String args[]){                  Car c1 = new Car(\"소방차\");             Car c2 = new Car(\"구급차\");             //Car c3 = new Car(); // 컴파일 오류가 발생합니다.                  System.out.println(c1.name);                  System.out.println(c2.name);         }     }     // Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.       this  this는 현재 객체, 자기 자신을 나타낸다.      this의 사용       public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }                 Car 클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽게 알 수 없다.       n 으로 쓰기 보다는 name 으로 사용하는 것이 좋다.               public Car(String name){         name = name;     }                 “name=name”이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 “name=name”이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.       즉, 필드는 바뀌지 않는다. 이런 경우 필드라는 것을 컴파일러와 JVM에게 알려주기 위해서 this 키워드를 사용해야 한다.               public Car(String name){         this.name = name;     }                 앞의 this.name은 필드 name을 말하고 =(이퀄) 뒤의 name은 매개변수를 의미한다.       즉 매개변수의 값을 필드에 대입하라는 의미가 된다.           클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.   메소드 오버로딩     매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게하는 기술   메소드 오버로딩            이름은 같지만 매개변수가 다른 메소드       메소드 오버로딩은 매개변수 부분이 달라야 한다.       매개변수의 타입과 개수가 동일한 메소드를 또 정의 할 수는 없다.           오버로딩된 메소드 이용하기            메소드의 인자에 어떤 값이 쓰이냐에 따라서 각기 다른 메소드가 호출된다.               public MethodOverloadExam{         public static void main(String args[]){             MyClass2 m = new MyClass2();             System.out.println(m.plus(5,10));             System.out.println(m.plus(5,10,15));             System.out.println(m.plus(\"hello\" + \" world\"));         }     }  생성자 오버로딩과 this     생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.            생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.       매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.               public class Car{         String name;         int number;          public Car(){          }          public Car(String name){             this.name = name;         }          public Car(String name, int number){             this.name = name;             this.number = number;         }     }     오버로딩된 생성자 이용하기   public class CarExam4{     public static void main(String args[]){         Car c1 = new Car();         Car c2 = new Car(\"소방차\");         Car c3 = new Car(\"구급차\", 1234);     } }     자기 생성자 호출하는 this()            기본생성자를 호출하였을 때 name을 “이름없음”, 숫자를 0으로 초기화 하기               public Car(){         this.name = \"이름없음\";         this.number = 0;     }       -     - 위처럼 작성했을 경우 코드의 중복이 일어난다.     - 자신이 가지고 있는 다른 생성자를 이용할 수 있다.       public Car(){         this(\"이름없음\", 0);     }       패키지  패키지(package)란 서로 관련이 있는 클래스 또는 인터페이스들을 묶어 놓은 묶음이다. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록 하고, 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 관리를 편하게 해준다.     패키지 정의방법            package이름은 보통 도메인 이름을 거꾸로 적은 후, 그 뒤에 프로젝트 이름을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.       package이름은 폴더명 점 폴더명 점 폴더명 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.       도메인 이름이 8cruz.com 이고 프로젝트 이름이 javastudy 라면 com.eightcruz.javastudy.Hello 로 패키지를 지정 할 수 있다.                    도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.           도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.                           패키지에 생성된 클래스 사용하기            java.lang 패키지를 제외하고는 다른 패키지에 있는 클래스를 사용하려면 import라는 구문을 적어줘야 한다.                    import com.eightcruz.javastudy.Hello;           import com.eightcruz.javastudy.*;                            해당 패키지에 있는 모든 클래스를 사용한다는 의미                                                   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_06/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 상속",
        "excerpt":"Part7 상속   상속     상속이란? 부모가 가진것을 자식에게 물려주는 것을 의미한다.            노트북은 컴퓨터의 한 종류다.       침대는 가구의 한 종류다. 혹은 침대는 가구다.       소방차는 자동차다.           이렇게 말할 수 있는 관계를 is a 관계 혹은 kind of 관계라고 한다.      Car를 상속받은 Bus를 class로 표현하는 방법            자바는 클래스 이름 뒤에 extends 키워드를 적고 부모 클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.       상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있께 된다.               public class Car{      }      public class Bus extends Car{      }     부모 클래스와 자식 클래스의 메소드            자식 클래스는 부모 클래스에 선언된 메소드를 사용할 수 있다.       자식 클래스는 부모가 가지고 있는 메소드 외에 추가로 메소드를 선언할 수 있다.                    이것을 확장하였다고 표현한다.                           접근제한자  접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.      접근 제한자의 종류            public                    어떤 클래스든 접근할 수 있다는 것을 의미                       protected                    자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속받은 자식 클래스에서는 접근할 수 있다는 것을 의미                       private                    자기 자신만 접근할 수 있다는 것을 의미                       접근제한자를 적지 않으면 default 접근 지정자                    자기자신과 같은 패키지에서만 접근할 수 있다는 것을 의미(상속X)                       public &gt; protectd &gt; default &gt; private           추상클래스  추상 클래스란 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하는데 새, 포유류 같은 것은 구체적이지 않다.     추상 클래스 정의하기            추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.       추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.                    추상 메소드란, 내용이 없는 메소드이다. 즉 구현이 되지 않은 메소드이다.           추상 메소드는 리턴 타입 앞에 abstract라는 키워드를 붙여야 한다.                       추상 클래스는 인스턴스를 생성할 수 없다.               public abstract class Bird{         public abstract void sing();          public void fly(){             System.out.println(\"날다.\");         }     }     추상 클래스를 상속받는 클래스 생성하기            추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 반드시 구현해야 한다.       추상 클래스를 상속받고, 추상 클래스가 갖고 있는 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다.           super와 부모생성자     class가 인스턴스화 될 때 생성자가 실행되면서 객체의 초기화를 한다. 그 때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.            new 연산자로 자식 객체를 생성하면, 자식객체가 메모리에 올라갈 때 부모인 객체도 함께 메모리에 올라간다.       생성자는 객체를 초기화 하는 일을한다.       생성자가 호출될 때 자동으로 부모의 생성자가 호출되면서 부모객체를 초기화 하게된다.           super            자신을 가리키는 키워드가 this 라면, 부모를 가리키는 키워드는 super       super()는 부모의 생성자를 의미한다.       부모의 생성자를 임의로 호출하지 않으면, 부모 class의 기본 생성자가 자동으로 호출된다.           부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법            클래스는 기본 생성자가 없는 경우도 존재한다.               public Bus(){         super(\"소방차\"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.         System.out.println(\"Bus의 기본생성자입니다.\");     }  super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용한다.   오버라이딩  오버라이딩이란 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것이다. 즉 오버라이딩이란 메소드를 재정의 하는 것이다.     메소드 오버라이딩            메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출된다.       오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.                    super 키워드를 이용하면, 부모의 메소드를 호출 할 수 있다.                               //run 메소드를 가지고 있는  Car클래스      public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      //Car 를 상속받는 Bus 클래스      public class Bus extends Car{      }          //오버라이딩     public class Bus extends Car{         public void run(){             System.out.println(\"Bus의 run메소드\");         }     }        //super 키워드     public class Bus extends Car{         public void run(){             **super.run();**  // 부모의  run()메소드를 호출              System.out.println(\"Bus의 run메소드\");         }     }     오버라이딩 vs 오버로딩  오버로딩(Overloading) : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술  오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용    클래스 형변환  부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.     형변환       public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      public class Bus extends Car{         public void ppangppang(){             System.out.println(\"빵빵.\");         }        }  상속 관계란 is a 관계다. “Bus는 Car다.”라는 관계가 성립된다.      부모타입으로 자식객체를 참조할 수 있다.            부모타입으로 자식객체를 참조하게 되면 부모가 있는 메소드만 사용할 수 있다.               public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             car.ppangppang(); // 컴파일 오류 발생         }     }     ppangppang()메소드를 호출하고 싶다면 Bus 타입의 참조변수로 참조 해야한다.       public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             //car.ppangppang(); // 컴파일 오류 발생              Bus bus = (Bus)car;  //부모타입을 자식타입으로 형변환              bus.run();             bus.ppangppang();         }     }     객체들 끼리도 형변환이 가능하다. 단 상속관계에 있었을 때만 가능하다.   부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환이 일어난다.   부모타입의 객체를 자식타입으로 참조하게 할 때는 명시적으로 형변환 해주어야 한다. 단, 이렇게 형변활 할때에는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능하다.      과연 이 형변환을 왜 언제 사용할까! 라는 의문을 가졌다면,,,, 이런 상황들을 생각해보자  첫번째, VIP 회원을 VVIP 회원으로 등급을 올려줄 때  두번째, 모험가 직업을 가진 플레이어가 전사 직업을 가지게 되었을 때…  보통 다형성을 활용하려고 사용한다고 한다… 코드 한줄만 바꿔도 돌아갈수 있도록…?   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.6 제어문)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.6 제어문     일부 구문인 반복문, 스위치문들은 데이터에 적용된 시험결과에 따라 일련의 연산이 실행되는 조건부 실행이 요구된다.   기계어 코드에서는 조건부 동작을 구현하기 위해 두 개의 기본적인 낮은 수준의 방법을 제공한다.            데이터 값들을 시험해서 이 시험 결과에 따라 데이터흐름이나 제어흐름을 변경한다.           기계어 인스트럭션들의 실행 순서는 점프jump 인스트럭션으로 변경할 수 있다.   점프 인스트럭션은 때에 따라서는 어떤 시험의 결과에 따라 프로그램의 다른 일부분으로 제어를 넘겨준다.   3.6.1 조건 코드     정수 레지스터들과 함께 CPU는 가장 최근 산술 또는 논리연산의 특성을 설명하는 단일 비트 조건 코드로 구성된 레지스터들을 운영한다.   이 레지스터들은 조건부 분기를 수행하기 위해서 시험될 수 있다.            CF: 캐리 플래그Carry flag. 가장 중요한 비트로부터 받아 올림이 발생한 것을 표시. 비부호형 연산에서 오버플로우를 검출할 때 사용       ZF: 영 플래그Zero flag. 연산의 결과가 0인 것을 표시       SF: 부호 플래그Sign flag. 연산이 음수를 생성한 것을 표시       OF: 오버플로우 플래그Overflow flag. 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시           leaq 인스트럭션은 주소계산에 사용하기 위한 것이므로 조건 코드를 변경하지 않는다.           반면에, 위의 그림에 나열된 모든 인스트럭션들은 조건 코드 값을 변경한다.            XOR 같은 논리연산에서는 캐리와 오버플로우 플래그가 0으로 세팅된다.       쉬프트 연산에서는 캐리 플래그가 쉬프트되어 없어지는 마지막 비트로 설정되며, 오버플로우 플래그는 0으로 세팅된다.           위의 그림의 인스트럭션들에 의해 조건 코드 값이 변경될 뿐만 아니라, 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 두 개의 인스트럭션 클래스가 있다.(아래의 그림 참조)    CMP 인스트럭션들은 만일 두 오퍼랜드가 같으면 영 플래그르 1로 설정한다. 다른 플래그들은 두 오퍼랜드의 순서관계를 결정하는 데 사용될 수 있다.   TEST 인스트럭션은 목적지 오퍼랜드를 변경하지 않으면서 조건 코드를 설정하는 점만 제외하고는 AND 인스트럭션과 같은 방식으로 동작한다.   3.6.2 조건 코드 사용하기     조건 코드를 이용하는 보편적인 세 가지 방법이 있다.            조건 코드의 조합에 따라 0 또는 1을 한 개의 바이트에 기록       조건에 따라 프로그램의 다른 부분으로 이동하는 방법       조건에 따라 데이터를 전송하는 방법              SET 인스트럭션         첫 번째 경우의 인스트럭션의 클래스를 SET 인스트럭션이라고 부른다.   이 인스트럭션들은 접미어를 이용해서 오퍼랜드의 크기를 나타내는 것이 아니라, 조건 코드의 어떤 조합을 사용할 것인지를 나타낸다.            ex) setl, setb -&gt; long word와 byte를 의미하지 않고 less와 below를 의미한다.           SET 인스트럭션은 목적지로 하위 단일 바이트 레지스터 가운데 한 개나 단일 바이트 메모리 주소를 사용하며, 이 바이트를 0이나 1로 기록한다.            32비트나 64비트 결과를 만드려면, 다른 상위 비트들을 0으로 만들어줘야 한다.           a&lt;b를 계산하는 전형적인 인스트럭션은 아래의 그림과 같이 작성된다.    3.6.3 점프jump 인스트럭션     일반적인 실행의 경우, 인스트럭션들은 나열된 순서에 따라 순차적으로 실행된다.   점프 인스트럭션은 프로그램이 완전히 새로운 위치로 실행을 전환하도록 한다.   점프의 목적지는 일반적으로 어셈블리 코드에서는 레이블label로 표시한다.        인스트럭션 jmp .L1은 프로그램이 movq 인스트럭션을 건너뛰는 대신에 popq로 실행을 다시 시작하게 한다.   어셈블러는 모든 레이블이 붙은 인스트럭션들의 주소를 결정하고, 점프 인스트럭션의 일부분인 “점프 목적지jump target”을 인코딩한다.        위 그림은 여러 가지 점프 인스트럭션을 보여준다.   jmp 인스트럭션은 무조건적으로 점프한다.            점프 목적지가 인스트럭션의 일부로 인코딩 되는 경우에는 직접 점프       점프 대상을 레지스터나 메모리 위치로부터 읽어들여야 하는 경우에는 간접 점프           3.6.4 점프 인스트럭션 인코딩     점프 인스트럭션의 대상이 어떻게 인코딩 되는지 이해하는 것은 7장의 링커를 공부할 때 중요한 역할을 하게 된다.   어셈블리 코드에서, 점프 목적지는 심벌 레이블을 사용해서 작성한다.   점프를 인코딩하는 가장 일반적인 방법은 PC 상대적PC relative 방법이다.            대상 인스트럭션과 점프 인스트럭션 바로 다음에 오는 인스트럭션 주소와의 차이를 인코딩한다.                첫 번째 점프 인스트럭션의 목적지가 0x03으로 인코딩, 다음 인스트럭션의 주소인 0x05에 더하면 점프 목적지 주쇤 0x8을 얻을 수 있다.   PC-상대 주소지정을 수행할 때 프로그램 카운터의 값은 점프 인스트럭션 자신의 주소가 아니라, 점프 다음에 나오는 인스트럭션의 주소가 된다.   PC-상대 방식으로 점프 목적지를 인코딩하면, 인스트럭션들이 간결하게 인코딩(2바이트만 필요)될 수 있고, 목적코드는 수정 없이 메모리 상의 다른 위치로 이동될 수 있다.   3.6.5 조건부 분기를 조건제어로 구현하기     C에서 조건부 수식과 문장을 기계어 코드로 번역하는 가장 일반적인 방법은 조건부 및 무조건 점프를 함께 사용하는 것이다.   어셈블리 코드에서의 무조건 점프와 유사한 C의 goto문을 사용한다.            어셈블리 코드의 제어흐름을 설명하는 C 프로그램을 구성하는 방법으로 사용됨                     위의 그림은 조건문의 컴파일이다.            if-else             컴파일러는 else-문과 then-문에 대해 별도의 코드 블록을 생성한다.       정확한 블록이 실행되도록 조건부와 무조건 분기를 삽입한다.             3.6.6 조건부 이동으로 조건부 분기 구현하기     조건부 동작을 구현하는 전형적인 방법은 조건이 만족되면 프로그램의 한 가지 실행경로를 따르고, 아닌 경우에는 다른 경로를 따라가도록 하는 제어의 조건부 전환을 통해 이루어진다.            이 방법은 간단하고 일반적이지만 최신 프로세서들에서는 매우 비효율적일 수 있다.           또 다른 전략은 데이터의 조건부 전송을 이용하는 것이다.            이 방법은 조건부 동작의 산출물 모두를 계싼하고 조건에 따라 하나만 선택하는 방식이다.       최신 프로세서의 성능특성과 잘 일치하는 간단한 조건부 이동move 인스트럭션으로 구현될 수 있다.                C버전을 공부하면, 이것이 y-x와 x-y 모두를 계산해서 rval, eval로 명명한다는 것을 알 수 있다.            x가 y보다 크거나 같은지 테스트하고, 만일 그렇다면, eval을 Rval로 명명한다는 것을 알 수 있다.           조건부 제어 이동 기반 코드보다 조건부 데이터 이동 코드가 성능이 우수한 이유를 이해하기 위해서는 최신 프로세서들이 어떻게 동작하는지 이해해야 한다.            프로세서들은 각 인스트럭션을 일련의 단계로 처리하며, 이 단계들은 각각 요구된 동작의 작은 부분만을 실행하는 파이프라인을 통해 높은 성능을 얻는다.       이를 위해서는 파이프라인을 실행할 인스트럭션들로 미리 채우기 위해 실행할 인스트럭션들의 순서를 훨씬 일찍 결정할 수 있어야 한다.       결과적으로 분기의 예측오류 손실이 함수의 성능을 결정한다.                    위의 그림은 x86-64로 가능한 조건부 이동 move 인스트럭션을 보여준다.   이들 인스트럭션은 두 개의 오퍼랜드를 갖는다.            소스 레지스터 또는 메모리 위치 S, 그리고 목적지 레지스터 R.           인스트럭션들의 결과는 조건 코드 값에 따라 달라진다.   소스 값은 메모리나 소스 레지스터로부터 읽히지만, 목적지에는 명시된 조건이 만족될 때만 복사된다.      이 이후로 조건부 분기의 “분기의 예측 오류”에 관한 내용이 나온다.   조건부 이동은 조건부 점프와는 달리 결과를 예측하지 않고서도 해당 인스트럭션을 실행할 수 있다.  조건부 이동을 사용한다고 해서 언제나 코드 효율성을 개선할 수 있는 것은 아니다.  컴파일러는 낭비되는 계산량과 분기 예측오류에 의한 잠재적 성능 손실 사이의 상대적 성능을 고려해야 한다.   등의 내용이 담겨져 있는데 이해하기 조금 힘들다….   3.6.6은 뒷부분을 좀 더 읽고 다시 읽으러 돌아오자!!!!!!!    조건부 분기에 따른 실제 어셈블리 코드     조건부 분기를 구하는 방법은 3.6.2에서 세가지 방법이 있다고 했으며, 3.6.5절과 3.6.6절에 조건제어와 조건부이동 두가지로 더욱 자세한 설명으로 풀어냈다. 두 가지의 방법은 예제코드를 활용하여 설명해줬는데 다음의 예제코드와 같다. (C 언어로 작성 되어있다.)    long absdiff(long x, long y){   long result;   if(x&lt;y) result = y - x;   else reuslt = x - y;   return result; }     이 코드를 가지고 if문의 여러가지 어셈블리어로 표현할 수 있다고 표현하는데, 나는 같은 코드인데 기계는 어떻게 알고 다른 어셈블리어들을 생성해내는지가 너무 긍금했다.  다시말해 기계는 언제 조건부 이동을 하여 컴파일을하고, 언제 조건제어를 하여 컴파일을 하는지 너무 궁금했다!!!  궁금증을 참지 못하고 윈도우 환경에서 gcc 컴파일을 진행하였다.          tdm-gcc를 설치했다.     터미널에 gcc -v 명령어를 입력하면 설치 완료를 확인할 수 있다.     위 예제의 코드를 txt 파일로 작성했다.(파일 이름은 p1으로 하였다.)     gcc -S p1.c 명령어를 입력하면 어셈블리 코드를 생성할 수 있다.     gcc -S -Og p1.c 명령어를 입력하면 컴파일 최적화를 진행한다.     -Og, -O1, -O2 …으로 설정하면 단계별로 최적화를 적용한다.        다음의 그림은 default, -Og, -O1, -O2 의 결과다.  가독성을 위해서 main문과 디렉티브문은 삭제하였다.(*디렉티브: 어셈블러와 링커에 지시하기 위한 문장)       //최적화 없음 absdiff:    pushq   %rbp    .seh_pushreg   %rbp    movq   %rsp, %rbp    .seh_setframe   %rbp, 0    subq   $16, %rsp    .seh_stackalloc   16    .seh_endprologue    movl   %ecx, 16(%rbp)    movl   %edx, 24(%rbp)    movl   16(%rbp), %eax    cmpl   24(%rbp), %eax    jge   .L2    movl   24(%rbp), %eax    subl   16(%rbp), %eax    movl   %eax, -4(%rbp)    jmp   .L3 .L2:    movl   16(%rbp), %eax    subl   24(%rbp), %eax    movl   %eax, -4(%rbp) .L3:    movl   -4(%rbp), %eax    addq   $16, %rsp    popq   %rbp    ret  //Og로 최적화함 absdiff:    cmpl   %edx, %ecx    jge   .L2    movl   %edx, %eax    subl   %ecx, %eax .L1:    ret .L2:    movl   %ecx, %eax    subl   %edx, %eax    jmp   .L1   //O1으로 최적화함 absdiff:    movl   %edx, %r8d    subl   %ecx, %r8d    movl   %ecx, %eax    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret   //O2으로 최적화함 absdiff:    movl   %edx, %r8d    movl   %ecx, %eax    subl   %ecx, %r8d    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret     Og가 본문의 조건제어, O1이 조건이동에서 설명한 어셈블리어로 표현되어있다.  유레카를 발견한 것처럼…. 너무 속이 시원했다….  컴파일 명령어에서 최적화의 수준에 따라 어셈블리어 인코딩이 달라진다는 것을 직접 확인할 수 있었다.    3.6.7 반복문     C에서는 여러가지 반복문 구문을 제공한다.            do-while, while, for       기계어에는 반복문에 대응되는 인스트럭션이 없다.       그렇기 때문에 조건부 테스트와 점프를 함께 사용해서 반복문의 효과를 구현한다.                 do-while            body-statement를 반복적으로 실행하고, test-expr를 계산하여 조건에 따라 반복 수행을 계속한다.       body-statement가 적어도 한 번은 실행되는 점이 특이사항이다.               do         body-statement         while (test-expr);        while            while문은 test-expr를 먼저 계산해서, body-statement를 실행하기 전에 종료될 수 있다.       do-while 루프에서 우리가 본 것과 루프 구조가 동일하고, 초기 테스트의 구현방법에서만 다르다.               while (test-expr)         body-statement                     while문은 두가지 번역 방법이 있다.                    중간으로-점프jump-to-middle            조건부 do 번역 사용guarded-do                            for       while (test-expr)         body-statement           init-expr;     while (test-expr){         body-statement         update-expr;     }                 두 반복문이 동일한 동작을 한다.       먼저 초기화 수식인 init-expr를 계산한다.       테스트 조건인 test-expr를 계산하는 곳에서 루프에 들어가며       테스트가 실패하면 루프를 빠져나오고, 반복문 body-statement를 실행한다.       마지막으로 update-expr를 계산한다.       for 루프에 대해 생성된 어셈블리 코드는 최적화 수준에 따라 while 루프의 번역 전략중 하나를 따른다.           3.6.8 Switch문     Switch문은 정수 인덱스 값에 따라 다중분기 기능을 제공한다.   C 코드를 읽기 쉽게 해줄 뿐만 아니라 점프 테이블이라는 자료구조를 사용해서 효율적인 구현을 간응하게 한다.   switch문을 실행하는 데 걸리는 시간이 case의 수에 관계없다는 점이 장점이다.   switch문을 실행하는 데 있어서 핵심 단계는 점프 테이블을 통해서 코드의 위치로 접근하는 것이다.      ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.7 프로시져)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.7 프로시저      프로시저 호출은 소프트웨어에서의 주요 추상화다.   이들은 지정된 인자들과 리턴 값으로 특정 기능을 구현하는 코드를 감싸주는 방법을 제공한다.   프로그램의 여러 지점으로부터 호출될 수 있게 된다. 프로그램 상태에 무슨 효과를 갖는지에 대한 명쾌하고 간결한 인터페이스 정의를 제공한다.   프로시저는 서로 다른 프로그래밍 언어에서 여러가지 다른 모습으로 사용된다.            함수, 메소드, 서브루틴, 핸들러등       이 모두는 일반적인 특징들을 공유한다.           프로시저에 대한 기계어수준 지원을 제공할 떄 처리되어야 하는 여러가지 많은 특성들이 존재한다.   프로시저P가 프로시저Q를 호출하고, 다시 리턴할 경우            제어권 전달: PC는 Q에 대한 코드의 시작주소로 설정되고, 리턴할 때 P에서 Q를 호출하는 인스트럭션 다음의 인스트럭션으로 설정       데이터 전달: P는 하나 이상의 매개변수를 Q에 제공할 수 있어야 하며, Q는 다시 P로 하나의 값을 리턴할 수 있어야 한다.       메모리 할당과 반납: Q는 시작할 때 지역변수들을 위한 공간을 할당, 리턴할 때 이 저장소를 반납할 수 있다.           X86-64에서의 프로시저 구현은 레지스터와 프로그램 메모리 같은 머신의 자원들을 사용하는 방법에 관한 특수 인스트럭션들과 일련의 관습들과 연관되어있다.   프로시저가 요구하는 메커니즘만을 최소한으로 구현하는 최소주의자 전략으로 볼 수 있는 방식들을 따른다.   3.7.1 런타임 스택      프로시저 호출 동작방식의 주요 특징은 스택 자료구조가 제공하는 후입선출 메모리 관리 방식을 활용할 수 있다는 점이다.   프로시저 P가 프로시져 Q를 호출하는 에를 들 때            Q가 실행되고 있는 동안 P까지의 연속된 호출 중의 프로시저 P는 일시적으로 정지되는 것을 볼 수 있다.       Q가 실행되는 동안에는 자신의 지역변수를 위한 새로운 저장공간을 할당할 수 있는 능력이나 다른 프로시저로의 호출을 설정하는 능력만을 필요로 한다.       Q가 리턴할 때는 자신이 할당받은 로컬 저장장소는 반납될 수 있다.       따라서 프로그램은 스택을 사용해서 프로시저들이 요구하는 저장장소를 관리할 수 있으며, 스택과 프로그램 레지스터들은 제어와 데이터를 전송하기 위해, 그리고 메모리를 할당하기 위해 필요한 정보를 제공한다.           x86-64의 스택은 작은 주소 방향으로 성장하며, 스택 포인터 %rsp는 스택의 최상위 원소를 가리킨다.   데이터는 pushq와 popq 인스트럭션을 이용해서 스택에 저장되고 읽어올 수 있다.          아래 그림은 일반적인 스택 프레임 구조. 스택을 프로시저의 인자를 전달하고, 리턴 정보를 저장하며, 레지스터를 저장하고, 지역 저장공간의 목적으로 사용한다. 필요하지 않은 경우 일부분은 생략될 수 있다.             프로시저가 레지스터들에 저장할 수 있는 개수 이상의 저장공간을 필요로 할 때는 공간을 스택에 할당한다.            이 영역을 이 프로시저의 스택 프레임이라고 부른다.           현재 실행 중인 프로시저에 대한 프레임은 항상 스택의 맨 위에 위치한다.   대부분의 프로시저의 스택 프레임들은 프로시저가 시작될 때 할당되는 고정 크기를 갖는다.   시간과 공간 효율성을 위해 x86-64 프로시저는 요청받은 스택 프레임의 부분만을 할당한다.      스택 프레임에 대해서 조금 더 조사할 필요가 있으며, 공간 효율성에 대해서도 조사해보자.    3.7.2 제어의 이동      제어를 함수 P에서 함수 Q로 전달하는 것은 단순히 프로그램 카운터를 Q를 위한 코드의 시작주소로 설정하는 것과 관련된다.   나중에 Q가 리턴해야할 때가 오면 프로세서는 P의 실행을 다시 시작해야하는 코드 위치의 일부 기록을 갖고 있어야한다            인스트럭션 call Q로 프로시저 Q를 호출해서 기록된다.       주소 A를 스택에 푸시하고 PC를 Q의 시작으로 설정한다.       푸시된 주소 A는 리턴주소라고 불리며, call인스트럭션 바로 다음 인스트럭션의 주소로 계산된다.       ret는 주소 A를 스택에서 pop해오고 PC를 A로 세팅한다.        call 인스트럭션은 호출된 프로시저가 싲가하는 인스트럭션의 주소를 목적지로 갖는다.                  아래의 그림은 call과 ret 기능의 에제다. call 인스트럭션은 함수의 시작 부분으로 제어를 이동하는 반면, ret 인스트럭션은 call 다음에 오는 인스터럭션으로 제어를 되돌린다.           아래의 그림은 프로시저 콜과 리턴에 연관된 프로그램의 상세한 실행이다.           리턴 주소를 스택에 푸시하는 간단한 방법을 사용해서 함수가 나중에 프로그램이ㅡ 적절한 위치로 리턴이 가능하게 된다는 것을 알 수 있다.   스택이 제공하는 후입, 선출 메모리 관리 방식과 편리하게 일치한다.   3.7.3 데이터 전송      호출될 때, 그리고 프로시저가 다시 리턴하게 될 때 프로시저로 제어를 전달하는 것 뿐만 아니라, 프로시저 콜은 데이터를 인자로 전달하는 것과 관련되어 있으며, 프로시저에서 리턴하는 것도 어떤 값을 리턴하는 것과 관련되어 있을 수 있따.   대부분의 이들 프로시저로, 프로시저로부터의 데이터 전달은 레지스터를 통해서 일어난다.   x86-64에서는 최대 여섯 개의 정수형(즉, 정수와 포인터) 인자가 레지스터로 전달될 수 있다.   함수가 여섯 개 이상의 정수형 인자를 가질 때, 다른 인자들은 스택으로 전달된다.            인자 1~6은 적절한 레지스터들에 복사하고, 인자 7에서 n까지는 인자 7을 스택 탑에 넣는 방법으로 저장한다.                 3.7.4 스택에서의 지역저장공간      지역 데이터가 메모리에 저장되어야 하는 경우가 있다.            지역 데이터 모두를 저장하기에는 레지스터의 수가 부족하다.       지역변수에 연산자 ‘&amp;’가 사용되었으며, 이 변수의 주소를 생성할 수 있어야 한다.       배열 또는 구조체여서 이들이 배열이나 구조체 참조로 접근되어야 한다.       위 세가지의 경우에 “Local variables”로 명명된 스택 프레임의 일부분이 생겨난다           3.7.5 레지스터를 이용하는 지역저장소      프로그램 레지스터들은 모든 프로시저들이 공유하는 단일 자원의 역할을 한다.   피호출자는 호출자가 나중에 사용할 계획인 일부 레지스터 값은 덮어쓰지 않는다.   레지스터 %rbx, %rbp, %r12-%r15는 피호출자-저장 레지스터로 구분한다.   리턴하기 전에 스택에서 이전 값을 팝해오는 방식으로 레지스터를 보존한다.   레지스터 값들을 푸시하는 것은 “Saved registers”로 이름 붙인 스택 프레임의 일부분을 생성하는 효과를 갖는다.    3.7.6 재귀 프로시저     레지스터와 스택을 사용하는 것에 대해 설명한 관습으로 프로시저들이 이들을 재귀적으로 호출하는 것을 설명할 수 있다.   각 프로시저 콜은 스택상에 자신만의 사적인 공간을 가지며, 따라서 다수의 별도의 호출들의 지역변수들은 서로 간섭하지 않는다.   스택 운영방식은 프로시저가 호출될 때 지역저장소를 할당하고, 리턴하기 전에 이것을 반환하는 적절한 정책을 자연스럽게 제공한다.   스택 기법을 사용해서 함수의 각 호출 시에 상태정보를 위한 자신만의 개별적 저장곤간을 제공한다.   필요한 경우에는 지역변수를 위한 저장공간도 제공할 수 있다.   스택의 할당과 반환 동작은 자연스럽게 함수의 호출-리턴 순서와 일치한다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_08/",
        "teaser": null
      },{
        "title": "[GitBlog] GitBlog 글 포스팅 후 커밋은 했지만, github.io에 적용이 안될 때",
        "excerpt":"사건의 개요    지금은 새벽 한시… csapp 공부가 조금 밀려서 공부를 하던 중에…   3.7절 프로시져에 대한 포스팅을 하려고 미리 csapp 포스트 탭을 만들고 커밋을 해두었다..  하지만, 아무리 새로고침을 해도 새로 포스팅한 글이 github.io에 업데이트가 안된다..    삽질    처음 깃블로그를 만들 때도 github.io에 업데이트가 되지 않는 끔찍함을 겪어서  몇번이고 레포를 새로 만들었던 끔찍한 기억이 떠올랐다.   지금까지 열심히 블로그에 글을 포스팅 했는데 이 글들을 다 날리는건가…?  무슨 캐시 충돌…? 뭐 서버 오류…? 어디선가 꼬였나…?  등등의 오만가지 생각이 들면서 지금까지 포스팅한 글을 지켜야겠다는 생각에 하던 공부를 올스탑했다..    새로운 레포도 파보고,, 글을 하나씩도 올려보고,, config파일을 수정도 해보고,, 캐시도 삭제해보고,,  커밋도 돌려보고,,, 별에 별짓을 다해보았다,,,l   사건 해결    한가지의 특징을 알게 되었다.   포스팅 날짜가 오늘 1월 31일로 되어있는 글만 업데이트가 되지 않는 것이었다.  오늘은 1월 31일 오전 1시였다.  드디어 알게되었다….  현재 날짜는 1월 31일이지만, 아직 새벽이기 때문에? (git 서버 시간의 기준이 다른 나라인가…?)   1월 31일로 작성된 글은 아직 github.io에 업데이트 되지 않는 것이구나!   결론  깃블로그를 처음 만들 때 글이 업데이트 되지 않는 오류 때문에 굉장히 힘들었었다.  하지만, 해당 오류는 서버와의 시간과 포스팅 시간이 맞지 않기 때문이었다!   다음부터 시간이 애매(새벽)하면 어제 날짜로 포스팅 하자!  이제부터 맘편히 깃블로그 포스팅을 하자!!!!      시간 날린게 너무 아깝다ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ  다시는 이런 바보같은 짓은 하지 말자…!   ","categories": ["Doodle"],
        "tags": ["Doodle","GitBlog"],
        "url": "/doodle/doodle_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 인터페이스와 다른 형식의 클래스",
        "excerpt":"Part8 인터페이스와 다른 형식의 클래스   인터페이스 만들기  인터페이스: 서로 관계까 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템     인터페이스 정의하는 방법            추상 메소드와 상수를 정의 할 수 있다.               public interface TV{         public int MAX_VOLUME = 100;         public int MIN_VOLUME = 0;          public void turnOn();         public void turnOff();         public void changeVolume(int volume);         public void changeChannel(int channel);     }     인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.       public static final int MAX_VOLUME = 100;     public static final int MIN_VOLUME = 0;     인터페이스에서 정의된 메소드는 모두 추상 메소드이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.       public abstract void on();     public abstract void off();     public abstract void volume(int value);     public abstract void channel(int number);  인터페이스 사용하기     인터페이스 사용하는 방법            인터페이스는 사용할 때 해당 인터페이스를 구현하는 클래스에서 implements 키워드를 이용한다.               public class LedTV implements TV{         public void on(){             System.out.println(\"켜다\");         }         public void off(){             System.out.println(\"끄다\");            }         public void volume(int value){             System.out.println(value + \"로 볼륨조정하다.\");           }         public void channel(int number){             System.out.println(number + \"로 채널조정하다.\");                  }     }     인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.(추상클래스는 인스턴스를 만들 수 없음)       public class LedTVExam{         public static void main(String args[]){             TV tv = new LedTV();             tv.on();             tv.volume(50);             tv.channel(6);             tv.off();         }     }     참조변수의 타입으로 인터페이스를 사용할 수 있다. 이 경우 인터페이스가 가지고 있는 메소드만 사용할 수 있다.   만약 TV인터페이스를 구현하는 LcdTV를 만들었따면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것이다. 동일한 인터페이스를 구현 한다는 것은 클래스 사용법이 같다는 것을 의미한다.   클래스는 이러한 인터페이스를 여러개 구현할 수 있다.   인터페이스의 default method  JAVA 8이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.      default 메소드     인터페이스가 default키워드로 선언되면 메소드가 구현될 수 있다. 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.             return i + j;         }     }      //Calculator인터페이스를 구현한 MyCalculator클래스     public class MyCalculator implements Calculator {          @Override         public int plus(int i, int j) {             return i + j;         }          @Override         public int multiple(int i, int j) {             return i * j;         }     }      public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);         }     }     인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.      static 메소드     인터페이스에 static 메소드를 선언함으로써, 인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){             return i + j;         }         public static int exec2(int i, int j){   //static 메소드              return i * j;         }     }      //인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.        public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);              int value2 = Calculator.exec2(5, 10);  //static메소드 호출              System.out.println(value2);         }     }  내부클래스  내부 클래스란 클래스 안에 선언된 클래스    어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.     첫번째는 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언되는 경우. 보통 중첩클래스 혹은 인스턴스 클래스라고 한다.            내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 InnerExam1의 객체를 만든 후에 InnerExam1.Cal cal -= t.new Cal();과 같은 방법으로 Cal 객체를 생성한 후 사용한다.               public class InnerExam1{         class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam1 t = new InnerExam1();             InnerExam1.Cal cal = t.new Cal();             cal.plus();             System.out.println(cal.value);          }     }     두번째는 내부 클래스가 static으로 정의된 경우, 정적 중첩 클래스 또는 static 클래스라고 한다.            필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 InnerExam2 객체를 생성할 필요없이 new InnerExam2.Cal()로 객체를 생성할 수 있다.               public class InnerExam2{         static class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam2.Cal cal = new InnerExam2.Cal();             cal.plus();             System.out.println(cal.value);          }     }     세번째로는 메소드 안에 클래스를 선언한 경우, 지역 중첩 클래스 또는 지역 클래스라고 한다.            메소드 안에서 해당 클래스를 이용할 수 있다.               public class InnerExam3{         public void exec(){             class Cal{                 int value = 0;                 public void plus(){                     value++;                 }             }             Cal cal = new Cal();             cal.plus();             System.out.println(cal.value);         }                public static void main(String args[]){             InnerExam3 t = new InnerExam3();             t.exec();         }     }     네번째로는 익명클래스가 있다.            아래의 절로 이동하여 설명하겠다!           익명클래스  익명 중첩 클래스는 익명 클래스라고 보통 말하며, 내부 클래스이기도 하다.       //추상클래스 Action      public abstract class Action{         public abstract void exec();     }      //추상클래스 Action을 상속받은 클래스 MyAction     public class MyAction extends Action{         public void exec(){             System.out.println(\"exec\");         }     }      //MyAction을 사용하는 클래스 ActionExam      public class ActionExam{         public static void main(String args[]){             Action action = new MyAction();             action.exec();         }     }      //MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.     public class ActionExam{         public static void main(String args[]){             Action action = new Action(){                 public void exec(){                     System.out.println(\"exec\");                 }             };             action.exec();         }     }     생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻한다.   괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다. 이렇게 생성된 이름 없는 객체를 action이라는 참조변수가 참조하도록 하고, exec() 메소드를 호출한다.   익명클래스를 만드는 이유는 Action을 상속받는 클래스를 만들 필요가 없을 경우이다.   Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우이다.   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_08/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part9 예외처리",
        "excerpt":"Part9 예외처리   Exception  프로그램 실행중 예기치 못한 사건을 예외라고 한다. 예외 상황을 미리 예측하고 처리할 수 있는데, 이렇게 하는 것을 예외 처리라고 한다.       public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 5;             int k = i / j;             System.out.println(k);             System.out.println(main 종료!!);         }     }     위 코드에서 j를 0으로 바꾸면 Exception 발생            j를 0으로 바꾸면 Arithmetic Exception이 발생하면서 프로그램이 종료된다.       Java는 정수를 정수로 나눌 때 0으로 나누면 오류가 발생한다.           예외 처리            프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.           예외 처리하는 문법            오류가 발생할 예상 부분을 try라는 블록으로 감싼 후, 발생할 오류와 관련된 Exception을 catch라는 블록에서 처리한다.       오류가 발생했든 안했든 무조건 실행되는 finally라는 블록을 가질 수 있다.       finally 블록은 생략가능하다.               public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = i / j;                 System.out.println(k);             }catch(ArithmeticException e){                 System.out.println(\"0으로 나눌 수 없습니다. : \" + e.toString());             }finally {                 System.out.println(\"오류가 발생하든 안하든 무조건 실행되는 블록입니다.\");             }         }     }     실행결과            0으로 나눌 수 없습니다. :java.lang.ArithmeticException:/by zero  오류가 발생하든 안하든 무조건 실행되는 블록입니다.           Exception 처리하지 않았을 때는 프로그램이 강제 종료되었는데 catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행되는 것을 알 수 있다.   try 블록에서 여러종류의 Exception이 발생한다면 catch라는 블록을 여러개 둘 수 있다.   Exception 클래스들은 모두 Exception 클래스를 상속받으므로, 예외 클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 하나의 catch 블록에서 모든 오류를 처리 할 수 있다.   Throws  throws는 예외가 발생했을 때 예외를 호출한 쪽에서 처리하도록 던져준다.       public class ExceptionExam2 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j){             int k = i / j;             return k;         }     }  정수를 매개변수로 2개를 받아들인 후 나눗셈을 한 후 그 결과를 반환하는 divide 메소드  main 메소드에서는 divide 메소드를 호출   다음과 같이 divide 메소드를 수정       public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }     }  메소드 선언 뒤에 throws ArithmeticException이 적혀있는 것을 알 수 있다. 이렇게 적어놓으면 divide 메소드는 ArithmeticException이 발생하니 divide 메소드를 호출하는 쪽에서 오류를 처리하라는 뜻이다.       package javaStudy;     public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             } catch(ArithmeticException e){                 System.out.println(\"0으로 나눌수 없습니다.\");             }          }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }      }  Exception 발생시키기  강제로 오류를 발생시키는 throw   throw는 오류를 떠넘기는 trhows와 보통 같이 사용된다.       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j){             int k = i / j;             return k;         }        }     divide 메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.      위의 코드를 에러가 발생하지 않게 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);               }          public static int divide(int i, int j){             if(j == 0){                 System.out.println(\"2번째 매개변수는 0이면 안됩니다.\");                 return 0;             }             int k = i / j;             return k;         }     }     j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴   이렇게 할 경우 main 메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.   0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할 수도 있다.      에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     j가 0일 경우에 new연산자를 통하여 IllegalArgumentException 객체가 만들어 진다.   new 앞에 throw는 해당 라인에서 Exception이 발생한다는 의미이다.   즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌 수 없습니다. 라는 오류가 발생한 것이다.   Exception 클래스 이름을 보면 argument가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.      divide 메소드를 호출한 쪽에서의 오류 처리       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             }catch(IllegalArgumentException e){                 System.out.println(\"0으로 나누면 안됩니다.\");             }                    }          public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     divide 메소드 뒤에 throws IllegalArgumentException은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미한다.   사용자 정의 Exception     Exception 클래스를 상속 받아 정의한 checked Exception            반드시 오류를 처리 해야만 하는 Exception       예외 처리하지 않으면 컴파일 오류를 발생 시킨다.           RuntimeException 클래스를 상속 받아 정의한 unChecked Exception            예외 처리하지 않아도 컴파일 시에는 오류를 발생시키지 않는다.              RuntimeException을 상속받은 BizException 객체       public class BizException extends RuntimeException {         public BizException(String msg){             super(msg);         }                public BizException(Exception ex){             super(ex);         }     }     BizSerice 클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.       public class BizService {         public void bizMethod(int i)throws BizException{             System.out.println(\"비지니스 로직이 시작합니다.\");             if(i &lt; 0){                 throw new BizException(\"매개변수 i는 0이상이어야 합니다.\");             }             System.out.println(\"비지니스 로직이 종료됩니다.\");         }     }     앞에서 만든 BizService를 이용하는 BizExam 클래스     매개변수 값을 -1을 넘길 때는 Exception이 발생하기 때문에 try catch 블록으로 처리한다.       public class BizExam {           public static void main(String[] args) {             BizService biz = new BizService();             biz.bizMethod(5);             try{                 biz.bizMethod(-3);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }      프로그래머스 자바 입문을 마무리하며  강의 자체는 굉장히 깔끔했다. 개념 설명 이후 실습을 진행하고, 해당 개념에 대한 의문점도 강의에서는 미리 지적하여 설명해준다. 입문 강의를 들으니 대학 2학년 때 들었던 java 강의가 생각났다. 그 때 이정도 수준의 이해도를 얻었다면 어땠을까… 라는 생각이 스쳐 지나갔다. 이제 입문 강의를 들은 것 뿐이지만, java의 j정도 알게 되었다. 인터페이스나 내부클래스 같은 개념은 실제로 사용해봐야지 더 확실하게 개념이 와닿을 것 같다.   강의를 모두 수강하고도 개념이 조금 헷갈리는 것들을 적어두고 한번 더 복습을 해야할 것 같다.     인스턴스를 만들 때 Parents c = new Child(); &lt;- Parents와 Child가 정확히 어떤 역할을 하는지   인터페이스와 추상클래스의 차이점   내부 클래스들 각각의 쓰임   사용자 정의 Exception   java의 얕은 복사와 깊은 복사   super()   클래스 형변환     해당 강의와 강의 노트는 프로그래머스 자바 입문에서 언제든지 다시 들을 수 있다!  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_09/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 Object 클래스, Part2 java.lang 패키지",
        "excerpt":"Part1 Object 클래스   Object와 오버라이딩     Object 클래스는 모든 클래스의 최상위 클래스   아무것도 상속받지 않으면 자동으로 Object를 상속   Object가 가지고 있는 메소드는 모든 클래스에서 다 사용할 수 있다는 것을 의미   대표적인 예            equals : 객체가 가진 값을 비교할 때 사용       toString : 객체가 가진 값을 문자열로 반환       hashCode : 객체의 해시코드 값 반환           Part2 java.lang 패키지   java.lang 패키지/오토박싱  자바는 기본적으로 다양한 패키지를 지원 그중에서 가장 중요한 패키지     java.lang 패키지의 클래스는 import를 하지 않고도 사용할 수 있다.   java.lang 패키지에는 기본형 타입을 객체로 변환시킬 때 사용하는 Wrapper 클래스가 있다.            Boolean, Byte, Short, Integer, Long, Double 클래스           모든 클래스의 최상위 클래스인 Object도 java.lang 패키지   문자열과 관련된 String StringBuffer, StringBuilder도 모두 java.lang 패키지   화면에 값을 출력할 때 사용했던 System 클래스도 java.lang 패키지   수학과 관련된 Math 클래스도 java.lang 패키지   Thread와 관련된 중요 클래스들이 java.lang 패키지   이외에도 다양한 클래스와 인터페이스가 java.lang 패키지에 속해 있다.   public class WrapperExam {     public static void main(String[] args) {         int i = 5;          Integer i2 = new Integer(5);         Integer i3 = 5;     //오토박싱         int i4 = i2.intValue();         int i5 = i2;       //오토언박싱     } }     오토박싱(Auto Boxing)            Integer i3 = 5; 숫자 5는 원래 기본형이지만 자동으로 Integer 형태로 변환된다.           오토 언박싱(Auto Unboxing)            int i5 = i2; Integer 객체타입의 값을 기본형 int로 자동으로 변환되어 값을 할당한다.           오토박싱, 오토 언박싱은 JAVA 5부터 지원한다. 이 때 내부적으로 Wrapper 클래스들이 사용된다.   스트링버퍼  아무 값도 가지고 있지 않은 StringBuffer 객체를 생성   StringBuffer sb = new StringBuffer(); // 해당 스트링 버퍼에 \"hello\", 공백, \"world\"를 차례대로 추가  sb.append(\"hello\"); sb.append(\" \"); sb.append(\"world\"); // StringBuffer에 추가된 값을 toString()메소드를 이용하여 반환  String str = sb.toString();     출력결과 : hello world   StringBuffer가 가지고 있는 메소드들은 대부분 자기 자신, this를 반환   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     자기 자신의 메소드를 호출하여 자기 자신의 값을 바꿔나가는 것을 메소드체이닝 이라고 한다.   StringBuffer 클래스는 메소드 체인 방식으로 사용할 수 있도록 만들어져 있다.   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     앞에서 5줄로 작성했던 코드를 위와 같이 한 줄로 수정할 수 있다.   StringBuffer는 append 메소드 외에도 길이를 구하거나, 자르거나 등의 다양한 메소드들을 가지고 있다.   스트링 클래스의 문제점  String 클래스는 문자열을 다룰 때 사용하는 클래스   String 클래스는 불변클래스이다.   String str1 = \"hello world\"; String str2 = str1.substring(5); System.out.println(str1); System.out.println(str2);     실행결과            hello world  world           기존의 str1은 전혀 변화 없다.   substring 메소드는 5번째부터 문자열을 잘라서 새로운 문자열을 반환하는 메소드   str1 자체는 전혀 변화가 없다.   String 클래스를 사용할 때 가장 문제가 발생하는 경우는 다음과 같은 코드를 사용할 때이다.   String str3 = str1 + str2; System.out.println(str3);     실행결과            hello world world           문자열과 문자열을 더하게 되면 내부적으로는 다음과 같은 코드가 실행   String str4 = new StringBuffer().append(str1).append(str2).toString(); System.out.println(str4);     java 에서는 new 연산자가 많을 수록 성능이 저하된다. 위와 같은 str3 = str1 + str2; 코드를 반복문에서 사용하게 된다면, new 연산자가 내부에서 계속해서 생성되고 성능이 저하될 수 있다.    Math  Math클래스는 이름 그대로 수학계산을 위한 클래스   코싸인, 싸인, 탄젠트, 절대값, 랜덤값등을 구할 수 있는 클래스     Math 클래스는 생성자가 private으로 되어 있기 때문에 new 연산자를 이용하여 객체를 생성할 수 없다.   객체를 생성할 수는 없지만 모든 메소드와 속성이 static으로 정의되어 있기 때문에 객체를 생성하지 않고도 사용할 수 있다.   public class MathExam {     public static void main(String[] args) {         int value1 = Math.max(5, 20);         int value2 = Math.min(5, -5);         int value3 = Math.abs(-10);         double value4 = Math.random();         double value5 = Math.sqrt(25);       } }  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_10/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 java.util 패키지",
        "excerpt":"Part3 java.util 패키지   java.util 패키지  java.util 패키지는 유용한 클래스들을 많이 가지고 있는 패키지     날짜와 관련된 클래스인 Date, Calendar 클래스   자료구조와 관련된 컬렉션 프레임워크와 관련된 인터페이스와 클래스   deprecated란 더이상 지원하지 않으니 사용하지 않는 것이 좋다란 의미   Date 클래스는 지역화를 지원하지 않는다. 지역화란 국가별로 현재 날짜와 시간은 다룰 수 있는데, 그 부분을 지원하지 못한다.            이런 문제를 해결하기 위하여 나온 클래스가 Calendar 클래스. Calendar 클래스는 자바 1.1에 등장           지역화와 관련된 클래스들은 Locale로 시작되는 일므을 가진 클래스다.   List, Set, Collection, Map은 자료구조 즉 컬렉션 프레임워크와 관련된 인터페이스   컬렉션 프레임워크  java.util 패키지에는 자료를 다룰 수 있는 자료구조 클래스가 다수 존재한다. 자료구조 클래스들을 컬렉션 프레임워크라고 한다.     자료구조란 자료를 저장할 수 있는 구조   책을 보관하기 위해 책장을 이용하는 것 처럼 다양한 자료들을 다양한 방식으로 관리하기 위한 방법이 필요한데, 이러한 방법을 제공하는 것을 자료구조, 컬렉션 프레임워크이다.   컬렉션 프레임워크에서 가장 기본이 되는 interface는 Collection 인터페이스            Collection 인터페이스는 여기에 자료가 있다라는 것을 표현       중복도 허용하고, 자료가 저장된 순서도 기억하지 못하는 것이 Collection 인터페이스       Collection이 가지고 있는 대표적인 메소드는 add(), size(), iterator() 메소드       Collection은 저장된 순서를 기억하지 못하기 때문에, 하나씩 하나씩 꺼낼 수 있는 Iterator라는 인터페이스를 반환한다.                    Iterator는 꺼낼것이 있는지 없는지 살펴보는 hasNext() 메소드와 하나씩 자료를 꺼낼때 사용하는 next() 메소드를 가지고 있다.                           Set 자료구조는 중복을 허용하지 않는 자료구조를 표현하는 인터페이스            Collection 인터페이스를 상속받는다.       Set 인터페이스가 가지고 있는 add 메소드는 같은 자료가 있으면 false, 없으면 true를 반환하는 add 메소드를 가지고 있다.           List 자료구조는 중복은 허용하면서 순서를 기억하는 자료구조를 표현            Set 인터페이스와 마찬가지로 Collection 인터페이스를 상속받고 있다.       List는 순서를 기억하고 있기 때문에 n번째의 자료를 꺼낼 수 있는 get(int) 메소드를 가지고 있다.           Map 자료구조는 Key와 Value를 가지는 자료구조이다.            저장할 때 put() 메소드를 이용하여 key와 value를 함께 저장한다.       원하는 값을 꺼낼 때는 key를 매개변수로 받아들이는 get() 메소드를 이용하여 값을 꺼낸다.       Map에 저장되어 있는 모든 Key들은 중복된 값을 가지면 안된다.       Key의 이런 특징 때문에 Map은 자신이 가지고 있는 모든 Key들에 대한 정보를 읽어들일 수 있는 Set을 반환하는 KeySet() 메소드를 가지고 있다.           Generic  Box 클래스   public class Box {     private Object obj;     public void setObj(Object obj){     this.obj = obj;     }      public Object getObj(){     return obj;     } }  BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box box = new Box();         box.setObj(new Object());         Object obj = box.getObj();          box.setObj(\"hello\");         String str = (String)box.getObj();         System.out.println(str);          box.setObj(1);         int value = (int)box.getObj();         System.out.println(value);     } }     Box는 매개변수 Object를 하나 받아들이고, Object를 반환한다.   Object를 받아들일 수 있다는 것은 Object의 후손이라면 무엇이든 받아들일 수 있다는 것이다.   하지만 반환을 할 경우에는 반환 값에 맞는 형변환을 해주어야한다.            이 귀찮음(?)을 해결하기 위하여 Java5에 Generic이라는 문법이 사용됨           Generic을 이용하여 Box 클래스 수정   public class Box&lt;E&gt; {     private E obj;     public void setObj(E obj){         this.obj = obj;     }      public E getObj(){         return obj;     } }     클래스 이름 뒤에 가 제네릭을 적용한 것이다. Box는 가상의 클래스 E를 사용한다는 의미   Object를 받아들이고, 리턴하던 부분이 E로 변경. E는 실제로 존재하는 클래스는 아니다.   Generic을 이용하여 수정한 Box를 이용하는 BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box&lt;Object&gt; box = new Box&lt;&gt;();         box.setObj(new Object());         Object obj = box.getObj();          Box&lt;String&gt; box2 = new Box&lt;&gt;();         box2.setObj(\"hello\");         String str = box2.getObj();         System.out.println(str);          Box&lt;Integer&gt; box3 = new Box&lt;&gt;();         box3.setObj(1);         int value = (int)box3.getObj();         System.out.println(value);     } }     참조타입에 &lt;Object&gt;, &lt;String&gt;, &lt;Integer&gt;가 있는 것을 볼 수 있다.   첫번째는 Object를 사용하는 Box를 인스턴스로 만들겠다는 의미   두번째는 String을 사용하는 Box 인스턴스를 만들겠다는 의미   세번째는 Integer를 사용하는 Box 인스턴스를 만든다는 의미      Generic을 사용함으로써 선언할 때는 가상의 타입으로 선언하고, 사용시에는 구체적인 타입을 설정함으로써 다양한 타입의 클래스를 이용하는 클래스를 만들 수 있다. Generic을 사용하는 대표적인 클래스는 컬렉션 프레임워크와 관련된 클래스다.    Set  set은 중복이 없고, 순서도 없는 자료구조. HashSet과 TreeSet이 있다.   import java.util.HashSet; import java.util.Iterator; import java.util.Set;  public class SetExam {     public static void main(String[] args) {         Set&lt;String&gt; set1 = new HashSet&lt;&gt;();          boolean flag1 = set1.add(\"kim\");         boolean flag2 = set1.add(\"lee\");         boolean flag3 = set1.add(\"kim\");          System.out.println(set1.size());   //저장된 크기를 출력합니다. 3개를 저장하였지만, 이미 같은 값이 있었기 때문에 2개가 출력         System.out.println(flag1);  //true         System.out.println(flag2);  //true         System.out.println(flag3);  //false          Iterator&lt;String&gt; iter = set1.iterator();          while (iter.hasNext()) {   // 꺼낼 것이 있다면 true 리턴.                       String str = iter.next(); // next()메소드는 하나를 꺼낸다. 하나를 꺼내면 자동으로 다음것을 참조한다.             System.out.println(str);         }     } }  List  list는 데이터의 중복이 있을 수 있고, 순서도 있다.   import java.util.ArrayList; import java.util.List;  public class ListExam {      public static void main(String[] args) {         List&lt;String&gt; list = new ArrayList&lt;&gt;();          // list에 3개의 문자열을 저장합니다.         list.add(\"kim\");         list.add(\"lee\");         list.add(\"kim\");          System.out.println(list.size()); //list에 저장된 자료의 수를 출력 (중복을 허용하므로 3 출력)          for(int i = 0; i &lt; list.size(); i++){             String str = list.get(i);             System.out.println(str);         }     }    }  Map  Map은 key와 value를 쌍으로 저장하는 자료구조. 키는 중복될 수 없고, 값은 중복될 수 있다.   import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;    public class MapExam {       public static void main(String[] args) {         // Key, Value가 모두 String 타입인 HashMap인스턴스를 만듭니다.         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();          // key와 value값을 put으로 저장합니다.         map.put(\"001\", \"kim\");         map.put(\"002\", \"lee\");         map.put(\"003\", \"choi\");         // 같은 key가 2개 있을 수 없습니다. 첫번째로 저장했던 001, kim은 001, kang으로 바뀐다.         map.put(\"001\", \"kang\");          // map에 저장된 자료의 수를 추력합니다. 3이 출력됩니다.         System.out.println(map.size());          // 키가 001, 002, 003인 값을 꺼내 출력합니다.         System.out.println(map.get(\"001\"));         System.out.println(map.get(\"002\"));         System.out.println(map.get(\"003\"));          // map에 저장된 모든 key들을 Set자료구조로 꺼냅니다.         Set&lt;String&gt; keys = map.keySet();         // Set자료구조에 있는 모든 key를 꺼내기 위하여 Iterator를 구합니다.         Iterator&lt;String&gt; iter = keys.iterator();         while (iter.hasNext()) {             // key를 꺼냅니다.             String key = iter.next();             // key에 해당하는 value를 꺼냅니다.             String value = map.get(key);             // key와 value를 출력합니다.             System.out.println(key + \" : \" + value);         }     } } ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.8 배열의 할당과 접근)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.8 배열의 할당과 접근   C에서 배열은 스칼라 데이터를 보다 큰 자료형으로 연계시키는 수단이다.   3.8.1 기본 원리      자료형 T와 정수형 상수 N에 대해서 다음과 같은 선언에 대해 생각해보자.            T A[N];            시작하는 위치를 Xa로 표시하자. 이 선언은 두가지 효과를 갖는다.            이것은 L*N 바이트의 연속적인 공간을 메모리에 할당하며, 여기서 L(바이트 단위)은 자료형 T의 크기를 나타낸다.       새로운 식별자 a를 통해서 배열이 시작하는 위치의 포인터로 사용한다.           배열의 각 원소는 0에서 N-1 사이의 정수형 인덱스를 사용해서 접근할 수 있다.   배열의 원소 i는 주소 Xa +L*i에 저장된다.   3.8.2 포인터 연산      C는 포인터 간에 연산을 허용하며, 계산된 값은 포인터가 참조하게 되는 자료형의 크기에 따라 그 값이 확대된다.   어떤 객체를 나타내는 식 Expr에 대해 &amp;Expr는 그 객체의 주소를 주는 포인터이다.   주소를 나타내는 식 A Expr에 대해 *A Expr는 그 주소에 위치한 값을 준다.   3.8.3 다중 배열      배열 할당과 참조에 관한 일반적인 원칙들은 심지어 배열의 배열을 생성할 때도 적용된다.   배열의 원소들은 메모리에 “행 우선row major” 순서로 저장된다.    3.8.4 고정크기의 배열      C 컴파일러는 고정크기의 다차원 배열을 위한 코드에 대해 다양한 최적화를 수행할 수 있다.   아래의 그림은 고정길이 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.    3.8.5 가변크기의배열      가변크기 배열을 원하는 프로그래머는 배열들을 위한 저장공간을 mallock이나 calloc 같은 함수를 사용해서 할당해야한다.   아래의 그림은 가변크기 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.       다중배열의 원소들을 접근할 때 발생하는 패턴을 인식할 수 있다는 것을 살펴보았다.  곱셈을 회피하는 코드를 생성할 수 있다.  이런 최적화들은 프로그램 성능을 상당히 개선하게 된다   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_09/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 K번째수 Java 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 첫 문제였다. 배열 생성도 어색하고 디버깅 하는 것도 너무 어려웠다. 몇가지 문법은 구글링을 해가면서 풀었다. 나는 지금까지 python으로만 알고리즘 문제를 해결했었다. python과 java는 너무나도 다르다… 우선 변수들간의 전송과 출력 모두 python과 달랐다. 여튼 java는 거의 모든 기능을 모듈을 import하여 사용한다는 것이다. 예를들어 Arrays 모듈을 import하여 배열을 한번에 출력하고, ArrayList를 import하여 연결리스트를 만든다.       2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.   commands에 포함된 1차원 배열에서 index 0,1에 위치한 value로 Arrays.copyOfRange(arr,startIndex,endIndex)를 사용하여 array를 slicing 한다.            ex) arr = {10,20,30,40,50} Arrays.copyOfRange(arr, 2, 4) -&gt; returns {20,30,40}           Arrays.sort()를 사용하여 slicing된 배열을 정렬한다.   정렬된 배열에서 commands index 2에 위치한 value에 해당하는 위치를 answer arrayList에 add한다.   return answer   코드       import java.util.ArrayList;     import java.util.Arrays;          public class Main {         public static void main(String[] args){             int[] array = {1,5,2,6,3,7,4};             int[][] commands =  {{2,5,3},{4,4,1},{1,7,3}};                  int[] answer = solution(array,commands);             System.out.println(Arrays.toString(answer));         }              public static int[] solution(int[] array, int[][] commands){             ArrayList&lt;Integer&gt; arrList = new ArrayList&lt;&gt;();                  for(int i=0; i&lt;commands.length; i++){                 int[] k = Arrays.copyOfRange(array,commands[i][0]-1,commands[i][1]);                 Arrays.sort(k);                 arrList.add(k[commands[i][2]-1]);             }                  int size = arrList.size();             int[] answer = new int[size];                  for(int i=0; i&lt;size; i++){                 answer[i] = arrList.get(i);             }                  return answer;         }     } ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_01/",
        "teaser": null
      },{
        "title": "[키보드/해피해킹] 해피해킹 하이브리드 type-s 리뷰",
        "excerpt":"이게뭐지?!      이건 바로 “해피해킹”이 들어있는 택배다. 무려 일본에서 2주일을 기다려서 받게 된 기다리고 기다리던 나의 첫 내돈내산 키보드이다.(매직키보드는 제외하도록 하겠다.. 왜냐면 매직키보드는… 애플… 이니깐… 꼭 사야하는… 물건중 하나…) 사실 나는 키보드에 그렇게 관심이 있던 사람은 아니였지만 동기들이 자꾸 꼬셨다. 그 중 가장 강렬했던 말은 “민석이형도 몇년동안 계속 키보드 바꾸다가 리얼포스로 정착했는데 너가 해피해킹 사면 한번에 다 뛰어넘고 대장급 되는거다” 이 말에 혹해 그날 저녁먹고  집에 오자마자 바로 “해피해킹 하이브리드 type-s”를 일본에서 직구하였다. 배송 기간 동안 설 연휴가 끼는 바람에 주문을 하고 약 2주뒤에 도착한 것 같다. 그 후로 동기들 집가서 여러 키보드도 타건해보면서 생전 관심도 없던 키보드를 사랑하게 돼버렸다..(사실 아직 뭐가 다른지 크게는 잘 모르겠따…)   택배박스를 열어보자..   회사 퇴근시간에 배송 완료 됐다는 카톡을 받자마자 칼퇴하고 집으로 곧장 달려갔다. 나의 해피해킹을 언능 영접하고 싶어서 호다닥 박스를 열었다.      완충제가 아주 가득 차있어서 일본에서부터 서울까지 다친데 하나 없이 아주 잘 도착한 것 같다 ㅎㅎ 완충제까지도 이쁘다.         완충제를 걷어내면 해피해킹 본체와 같이 주문한 정품 루프가 보인다. 정품 루프가 6만원인건 안비밀이다;;(그냥 아크릴일뿐인데 6만원이나 받아간다 ㅋ…)         이렇게 상자 안에 있는 물건을 다 꺼내면 해피해킹 본체, 전용 루프, 전용 키캡이 들어있다. 모두 다 옵션이고 키캡은 너무 이뻐서 살 수 밖에 없게 만들어놨다.      대망의 해피해킹 하이브리드 type-s   먼저 해피해킹 본체를 살펴보겠다.      “영롱 그 자체” 정말 영롱 그 자체다… 너무 이쁘다… 저 모던하지만 클래식한 디자인.. 투박하지만 미세하게 느껴지는 유려한 곡선.. 이 둘이 함꼐 탱고를 추는듯한 화려함… 가히 키보드의 왕이라 칭하기에 한점 부끄러움 없는 자태를 뽐내고 있다…         키보드를 꺼내고 나면 사용 설명서와 키보드에 들어갈 AA건전지 두개가 함께 들어있다. 건전지가 없을 줄 알고 집오는 길에 편의점에 들려서 AA건전지를 샀는데 여분용으로 남겨놔야할 것 같다. 무려 40만원이 넘는 키보드인데 왜 이런 구식용 건전지를 사용하는지 의문이었는데  구글링을 몇번 하고나니 납득이 되었다. 내장 배터리는 수명이 있기 때문에 키보드를 오래 쓰기에는 이런 건전지를 사용하는 것이 더 좋다고 한다.         다시 비닐을 벗긴 해피해킹을 보자. 글이 길어지면 진심은 흐려지는 법이라고 하였다. 후훗..      전용루프와 전용키캡      전용루프와 전용키캡은 이렇게 생겼다. 참.. 이쁘다.. 돈값 한다..!!         ㅎㅎ 키캡까지 장착해보았다. 키캡은 무각과 일반 두개가 있다. 정말 이쁘죠? ㅎㅎ         루프도 덮어보았다!       간단 후기   간단 후기를 남겨 보겠다. 우선 나는 키보드는 매직키보드, 맥북키보드 그리고 게이밍용 청축키보드만 사용해본 키린이라는걸 인지해줬으면 좋겠다,,,!   해피해킹 하이브리드 type-s 는 토프레 무접점 키보드라고 한다. 소음은 확실히 적다. 그리고 굉장히 부드럽다. 하지만, 키압이 생각보다 있어 그렇게 가볍지만은 않다. 그리고 해피해킹은 방향키가 없어 커맨드로 사용해야하고, 컨트롤 키도 캡스락에 있어 맥북 한영키와 굉장히 헷갈린다. 백스페이스도 기존 키보드보다 한단계 아래에 위치해 있다. 이러한 부분들이 아직은 익숙하지 않아서 버벅거리는데, 확실히 익숙해진다면 손의 움직임이 기존 키보드보다 적어서 효율적일 것 같다. 키보드를 좀 더 사용해보고 과연 배송비 10만원, 전용루프와 전용키캡 7만원, 본체 35만원 값어치를 하는지 깊은 후기를 남겨보겠다.   ","categories": ["Doodle"],
        "tags": ["키보드","해피해킹"],
        "url": "/doodle/doodle_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 날짜와 시간",
        "excerpt":"Part4 날짜와 시간   Date  날짜와 시간을 구하기 위한 클래스 Date 클래스     Date 클래스는 JDK 1.0때 만들어졌고, Calendar 클래스는 JDK1.1에 만들어졌따.   Date는 지역화에 대한 부분이 고려되지 않았다.            지역화란, 지역에 따라서 시간, 통화(원, 달러, 엔 등) 언어등에 고려하는 프로그래밍을 지역화에 맞춘 프로그래밍이라고 한다.           Date 클래스를 보면 대부분의 생성자와 메소드가  Deprecated 되어 있다.            Deprecated된 것은 앞으로 지원을 안하거나 문제가 있을 수 있으니 사용하지 말란 뜻이다.           기본 생성자를 이용한 Date 클래스 생성            기본 생성자로 Date인스턴스를 만들게 되면 현재 시간과 날짜 정보를 Date인스턴스가 가지게 된다                 Date date = new Date();     toString() 메소드를 이용하여 현재 시간을 문자열로 구한다.            출력 결과 : Wed Jan 06 18:36:56 KST2016                 System.out.println(date.toString());     java.util.SimpleDateFormat 클래스를 이용해서 원하는 형태로 출력하는 방법            yyyy는 년, MM은 월, dd는 일을 표현       hh는 시간, mm은 분, ss는 초를 표현하며 a는 오전/오후를 표현한다.       zzz는 TimeZone을 나타낸다. 한국의 겨우 한국ㅁ표준시 KST가 TimeZone에 해당하는 값이다.               SimpleDateFormat ft = new SimpleDateFormat (\"yyyy.MM.dd 'at' hh:mm:ss a zzz\");     System.out.println(ft.format(date));     현재 시간을 Long값으로 구하는 방법       System.out.println(date.getTime());     // System이 가지고 있는 currentTimeMillis()메소드를 이용해도 됩니다.     long today = System.currentTimeMillis();     System.out.println(today);  Calendar  Date의 단점을 해결하고 등장한 것이 Calendar 클래스     Calendar 클래스 생성 방법            Calendar 클래스는 추상클래스이다.       Calendar 클래스에 대한 인스턴스를 생성하려면 Calendar가 가지고 있는 클래스 메소드 getInstance()를 사용해야 한다.       getInstance() 메소드를 호출하면 내부적으로 java.util.GregorianCalendar 인스턴스를 만들어서 리턴한다.       GregorianCalendar는 Calendar의 자식 클래스다.                 Calendar cal = Calendar.getInstance();     Calendar 클래스를 이용해서 현재 날짜와 시간에 대한 정보를 알아내는 방법            Calendar는 현재 날짜와 시간에 대한 정보를 가진다.       Calendar가 가지고 있는 get메소드에 Calendar의 상수를 어떤 것을 넣어주느냐에 따라서 다른 값이 나온다.                 int yyyy = cal.get(Calendar.YEAR);       int month = cal.get(Calendar.MONTH) + 1; // 월은 0부터 시작       int date - cal.get(Calendar.DATE);       int hour = cal.get(Calendar.HOUR_OF_DAY);       int minuate = cal.get(Calendar.MINUTE);     Calendar 클래스를 이용해서 원하는 날짜나 시간에 대한 정보 얻어오는 방법            Calendar가 가지고 있는 add 메소드를 이용하면 쉽게 다음 날짜나 이전 날짜를 구할 수 있다.       현재 캘린더에 시간을 5시간 더하는 방법.                 cal.add(Calendar.HOUR,5);  java.time 패키지  Java에서 제공하는 ㅇate, Time API는 부족한 기능 지원을 포함한 여러가지 문제점을 가지고 있었다. JDK 코어에서 이런 문제점들을 해결하고 더 좋고 직관적인 API들을 제공하기 위해 새롭게 재 디자인한 date, Time API를 Java SE 8 부터 제공한다.     새로운 API의 핵심 클래스는 오브젝트를 생성하기 위해 다양한 factory 메서드를 사용   오브젝트 자기 자신의 특정 요소를 가지고 오브젝트를 생성할 경우 of 메서드를 호출하면 되고, 다른 타입으로 변경할 경우에는 from 메서드를 호출하면 된다.   LocalDateTime 클래스를 이용해서 현재 시간 time 객체 만드는 방법            now는 현재 시간을 구한다.                 LocalDateTime timePoint = LocalDateTime.now();  // 현재의 날짜와 시간     원하는 시간으로 time 객체 생성하는 방법       // 2012년 12월 12일의 시간에 대한 정보를 가지는 LocalDate객체를 만드는 방법       LocalDate ld1 = LocalDate.of(2012, Month.DECEMBER, 12); // 2012-12-12 from values          // 17시 18분에 대한 LocalTime객체를 구한다.     LocalTime lt1 = LocalTime.of(17, 18); // 17:18 (17시 18분)the train I took home today      // 10시 15분 30초라는 문자열에 대한 LocalTime객체를 구한다.     LocalTime lt2 = LocalTime.parse(\"10:15:30\"); // From a String     현재와 날짜와 시간정보를 getter 메소드를 이용하여 구하는 방법       LocalDate theDate = timePoint.toLocalDate();     Month month = timePoint.getMonth();     int day = timePoint.getDayOfMonth();     int hour = timePoint.getHour();     int minute = timePoint.getMinute();     int second = timePoint.getSecond();     // 달을 숫자로 출력한다 1월도 1부터 시작하는 것을 알 수 있습니다.      System.out.println(month.getValue() + \"/\" + day + \"  \" + hour + \":\" + minute + \":\" + second);  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_12/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 IO, Part6 어노테이션",
        "excerpt":"Part5 IO   자바IO  입출력을 위한 인터페이스와 클래스들     자바 IO는 크게 byte단위 입출력과 문자 단위 이출력 클래스로 나뉜다.            byte단위 입출력클래스는 모두 InputStream과 OutputStream이라는 추상클래스를 상속받아 만들어진다.       문자(char)단위 입출력클래스는 모두 Reader와 Writer라는 추상클래스를 상속받아 만들어진다.           4가지 추상클래스(InputStream, OutputStreamReader,Reader,Writer)를 받아들이는 생성자가 있다면, 다양한 입출력방법을 제공하는 클래스다.   4가지 클래스를 받아들이는 생성자가 없다면, 어디로부터 입력받을 것인지, 어디에 쓸것인지를 나타내는 클래스다.   파일로부터 입력받고 쓰기 위한 클래스 : FileInputStream, FileOutputStream, FileReader, FileWriter   배열로부터 입력받고 쓰기 위한 클래스 : ByteArrayInputStream, ByteArrayOutputStream, CharReader, CharWriter            해당 클래스들은 어디로부터, 어디에라는 대상을 지정할 수 있는 IO클래스다. 이런 클래스를 장식대상 클래스라고 한다.           DataInputStream, DataOutputStream같은 클래스를 보면 다양한 데이터 형을 입력받고 출력한다.   PrintWriter는 다양하게 한줄 입력받는 readLine() 메소드를 가진다.   BufferedReader는 한줄 입력받는 readLine() 메소드를 가진다.            이런 클래스들은 다양한 방식으로 입력하고, 출력하는 기능을 제공한다. 이런 클래스를 장식하는 클래스라고 한다.                    데코레이터 패턴(Decorator Pattern) : 하나의 클래스를 장식 하는 것처럼 생성자에서 감싸서 새로운 기능을 계쏙 추가 할 수 있도록 클래스를 만드는 방식    Byte 단위 입출력  Byte 단위 입출력 클래스는 클래스의 이름이 InputStream 이나 OutputStream으로 끝난다.     파일로부터 1byte씩 읽어들여 파일에 1byte씩 저장하는 프로그램을 작성            파일로부터 읽어오기 위한 객체 - FileInputStream       파일에 쓸 수 있게 해주는 객체 - FileOutputStream           read() 메소드            byte를 리턴한다면 끝을 나타내는 값을 표현할 수가 없기때문에, byte가 아닌 int를 리턴한다.       음수의 경우 맨 좌측 비트가 1이 된다. 읽어들일 것이 있다면 항상 양수를 리턴한다고 볼 수 있다.           FileInputStream과 FileOutputStream을 이용하여, 1바이트씩 읽어들여 1바이트씩 저장            read()메소드가 리턴하는 타입은 정수인데, 정수 4바이트중 마지막 바이트에 읽어들인 1바이트를 저장한다.       read()메소드는 더이상 읽어들일 것이 없을 때 -1을 리턴한다.               public class ByteIOExam1 {         public static void main(String[] args){                  FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readData = -1;                  while((readData = fis.read())!= -1){                     fos.write(readData);                 }                        } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         }     }  Byte 단위 입출력 심화  Byte단위 입출력 클래스는 클래스의 이름이 InputStream이나 OutputStream으로 끝난다.      파일로부터 512byte씩 읽어들여 파일에 512byte씩 저장하는 프로그램을 작성            byte[] buffer = new byte[512];       512byte만큼 읽어 들이기 위해 byte배열을 사용               public class ByteIOExam1 {         public static void main(String[] args){                  //메소드가 시작된 시간을 구하기 위함             long startTime = System.currentTimeMillis();                     FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readCount = -1;                  byte[] buffer = new byte[512];                 while((readCount = fis.read(buffer))!= -1){                     fos.write(buffer,0,readCount);                 }             } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         //메소드가 끝났을때 시간을 구하기 위함.          long endTime = System.currentTimeMillis();         //메소드를 수행하는데 걸린 시간을 구할 수 있음.          System.out.println(endTime-startTime);          }     }  다양한 타입의 출력     try-with-resources 블럭 선언            java io 객체는 인스턴스를 만들고, 모두 사용하면 close()메소드를 호출해야 한다.       close() 메소드를 사용자가 호출하지 않더라도, Exxception이 발생하지 않았다면 자동으로 close()가 되게 할 수 있는 방법                   try(                 //io객체 선언         ){                 //io객체 사용         }catch(Exception ex){             ex.printStackTrace();         }     다양한 타입으로 저장할 수 있는 DataOutputStream            writeInt() - 정수값으로 저장       writeBoolean() - boolean값으로 저장       writeDouble() - double값으로 저장               import java.io.DataOutputStream;     import java.io.FileOutputStream;         public class ByteExam3 {             public static void main(String[] args) {             try(                     DataOutputStream out = new DataOutputStream(new FileOutputStream(\"data.txt\"));             ){                 out.writeInt(100);                 out.writeBoolean(true);                 out.writeDouble(50.5);             }catch (Exception e) {                 e.printStackTrace();             }         }        }  다양한 타입의 입력     data.dat로부터 값을 읽어들여 화면에 출력하는 클래스   다양한 타입의 데이터를 읽어낼 수 있는 DataInputStream            readInt() - 정수를 읽어들이는 메소드       readBoolean() - boolean 값을 읽어들이는 메소드       readDouble() - double 값을 읽어들이는 메소드               import java.io.DataInputStream;     import java.io.FileInputStream;      public class ByteIOExam4 {          public static void main(String[] args) {             try(                     DataInputStream out = new DataInputStream(new FileInputStream(\"data.dat\"));             ){                 int i = out.readInt();                           boolean b = out.readBoolean();                           double d = out.readDouble();                  System.out.println(i);                 System.out.println(b);                 System.out.println(d);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }     파일에 저장된 순서대로 읽어 들여야한다.    Char 단위 입출력(Console)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     char 단위 입출력 클래스를 이용해서 키보드로부터 한줄 입력 받아서 콘솔에 출력            System.in - 키보드를 의미(InputStream)       BufferedReader - 한줄씩 입력 받기위한 클래스       BufferedReader 클래스의 생성자는 InputStream을 입력받는 생성자가 없다.       System.in은 InputStream 타입이므로 BufferedReader의 생성자에 바로 들어갈 수 없으므로 InputStreamReader 클래스를 이용해야함               import java.io.BufferedReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.InputStreamReader;     import java.io.PrintWriter;      public class CharIOExam01 {         public static void main(String[] args) {             BufferedReader br = new BufferedReader(new InputStreamReader(System.in));             //키보드로 입력받은 문자열을 저장하기 위해 line변수를 선언                            String line = null;                  try {                 line = br.readLine()             } catch (IOException e) {                 e.printStackTrace();             }             //콘솔에 출력              System.out.println(line);         }     }  Char 단위 입출력(File)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     파일에서 한 줄씩 입력 받아서 파일에 출력            파일에서 읽기 위해서 FileReader 클래스 이용       한 줄 읽어 들이기 위해서 BufferedReader 클래스 이용                    BufferedReader 클래스가 가지고 있는 readLine() 메소드가 한줄씩 읽게 해준다.           readLine() 메소드는 읽ㅇ낼 때 더 이상 읽어 들일 내용이 없ㅇ르 때 mnull을 리턴한다.                       파일에 쓰게하기 위해서 FileWriter 클래스 이용       편리하게 출력하기 위해 PrintWritier 클래스 이용               import java.io.BufferedReader;     import java.io.FileReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.PrintWriter;      public class CharIOExam02 {         public static void main(String[] args) {             BufferedReader br = null;              PrintWriter pw = null;             try{                         br = new BufferedReader(new FileReader(\"src/javaIO/exam/CharIOExam02.java\"));                 pw = new PrintWriter(new FileWriter(\"test.txt\"));                 String line = null;                 while((line = br.readLine())!= null){                     pw.println(line);                 }             }catch(Exception e){                 e.printStackTrace();             }finally {                 pw.close();                 try {                     br.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }     }  Part6 어노테이션   어노테이션  어노테이션은 Java5에 추가된 기능     어노테이션은 클래스나 메소드 위에 붙는다. @(at)기호로 이름이 시작한다.   어노테이션을 클래스나 메타코드에 붙인 후, 클래스가 컴파일되거나 실행될 때 어노테이션의 유무나 어노테이션에 설정된 값을 통하여 클래스가 좀 더 다르게 실행되게 할 수 있다. 이런 이유로 어노테이션을 일정의 설정파일처럼 설명하는 경우도 있다.   어노테이션은 자바가 기본으로 제공해주는 것도 있고, 사용자가 직접 만들 수도 있다.            사용자가 직접 작성하는 어노테이션을 Custom 어노테이션이라고 한다.           커스텀 어노테이션을 이용하는 방법            어노테이션을 정의한다.       어노테이션을 클래스에서 사용한다. (타겟에 적용)       어노테이션을 이용하여 실행           패키지 익스플로러에서 [new - Annotation]을 이용하여 Count100이라는 어노테이션 생성            Count100어노테이션을 JVM 실행시에 감지할 수 있도록 하려면 @Retention(RetentionPolicy.RUNTIME)를 붙여줘야 한다.               import java.lang.annotation.Retention;     import java.lang.annotation.RetentionPolicy;      @Retention(RetentionPolicy.RUNTIME)     public @interface Count100 {      }     “hello”를 출력하는 hello() 메소드를 가지는 MyHello라는 클래스를 작성            hello 메소드 위에 @Count100어노테이션을 붙힌다               public class MyHello {         @Count100         public void hello(){             System.out.println(\"hello\");         }     }     MyHello 클래스를 이용하는 MyHelloExam클래스를 작성            MyHello의 hello 메소드가 @Count100어노테이션이 설정되어 있을 경우, hello()메소드를 100번 호출하도록 한다.               import java.lang.reflect.Method;      public class MyHelloExam {         public static void main(String[] args) {             MyHello hello = new MyHello();              try{                 Method method = hello.getClass().getDeclaredMethod(\"hello\");             if(method.isAnnotationPresent(Count100.class)){                     for(int i = 0; i &lt; 100; i++){                         hello.hello();                     }                 }else{                     hello.hello();                 }             }catch(Exception ex){                 ex.printStackTrace();             }                }     }  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_13/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.9 이기종 자료구조 ~ 3.10 기계수준 프로그램에서 제어와 데이터의 결합)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.9 이기종 자료구조      C는 서로 다른 유형의 객체를 연결해서 자료형을 만드는 두 가지 방법을 제공한다.            struct 키워드를 사용해서 선언하는 구조체                    다수의 객체를 하나의 단위로 연결한다.                       union으로 선언하는 공용체                    하나의 객체를 여러 개의 다른 자료형으로 참조될 수 있도록 한다.                           3.9.1 구조체      서로 다른 유형의 객체들을 하나의 객체로 묶어주는 자료형을 생성한다.   구조체의 구현은 구조체의 모든 컴포넌트들이 메모리의 연속된 영역에 저장된다.   구조체의 포인터가 첫 번째 바이트의 주소라는 점에서 배열과 유사하다.      3.9.2 공용체      C언어의 자료형 체제를 회피해서 하나의 객체가 다수의 자료형에 따라 참조될 수 있도록 해준다.   공용체를 선언하는 문법은 구조체와 동일하나 그 의미는 매우 다르다.            다른 필드들이 메모리의 다른 블록을 참조하는 것이 아니라 동일한 블록을 참조한다.           3.9.3 데이터의 정렬      많은 컴퓨터 시스템들은 기본 자료형들에 대해 사용 가능한 주소를 제한하고 있어서 어떤 객체의 주소는 어떤 값 K의 배수가 되도록 요구한다.   이러한 정렬제한은 프로세서와 메모리 시스템 간의 인터페이스를 구성하는 하드웨어의 설계를 단순화한다.   이들의 정렬 규칙은 모든 K의 원시 객체들은 K의 배수를 주소로 가져야 한다는 원칙에 기초한다.   정렬은 자료형 내의 모든 객체들이 각각의 정렬 제한사항을 만족하는 방법으로 조직되고 할당되도록 강요된다.   아래의 그림처럼 컴파일러는 c와 j 사이에 3바이트 공간을 삽입한다.            추가로, 컴파일러는 구조체의 마지막에 0을 채워서 구조체 배열에서 각 원소가 각각의 정렬 요건을 만족하도록 해준다.   3.10 기계수준 프로그램에서 제어와 데이터의 결합      데이터와 자료가 상호작용 하는 방식을 살펴본다.   C 프로그래밍 언어에서 가장 심오한 개념인 포인터를 자세히 살펴본다.   기계수준 프로그램의 상세한 동작을 심벌 디버거인 GDB를 사용해서 검토한다.   실제 시스템에서 중요한 보안취약성인 버퍼 오브펄로우를 어떻게 이해할 수 있는지 살펴본다.   함수가 요구하는 스택 저장공간의 양이 실행때마다 달라지는 경우를 기계수준 프로그램이 어떻게 구현하는지 살펴본다.   3.10.1 포인터 이해하기      다른 자료구조 내 원소들에 대한 참조를 생성하는 통일된 방법으로서의 역할을 수행한다.   포인터의 일부 주요 원리            포인터는 연관된 자료형을 갖는다.       모든 포인터는 특정 값을 가진다.       포인터는 &amp;연산자를 사용해서 만든다.       ㅍ포인터는 *연산자를 사용해서 역참조한다.       배열과 포인터는 밀접한 관련이 있다. 배열의 이름은 마치 포인터 변수처럼 참조될 수 있다.       한 종류의 포인터에서 다른 종류로의 자료형 변환은 그 종류만 바뀔 뿐 값은 변화가 없다.       포인터는 함수를 가리킬 수도 있. 이것은 프로그램의 다른 부분에서 호출할 수 있는 코드에 대한 참조를 저장하거나 넘겨줄 수 있는 강력한 기능을 제공한다.           3.10.2 실제 적용하기: GDB 디버거 사용하기      GNU 디버거인 GDB는 기계어 프로그램의 런타임 평가 및 분석에 유용한 기능을 제공한다.            GNU는 운영체제의 하나이자 컴퓨터 소프트웨어의 모음집이다.            GDB를 사용하면, 프로그램의 실행을 정교하게 제어하면서 실행되는 프로그램을 관찰하여 프로그램의 동작을 분석할 수 있다.   일반적인 방법은 브레이크포인트를 프로그램에서 관심이 있는 부분 근처에 설정하는 것이다.   프로그램 실행중에 브레이크포인트를 만나게 되면, 프로그램은 실행을 중단하고, 제어를 사용자에게 넘긴다.   3.10.3 범위를 벗어난 메모리 참조와 버퍼 오버플로우      C에서는 배열참조 시 범위를 체크하지 않으며, 지역변수들이 스택에 보존용 레지스터들과 리턴 주소 같은 상태정보와 함께 스택에 저장된다는 것을 배웠다.   에를들어 배열에 문자열이 저장될 때 stack top인 return address 범위까지 저장이 되면 심각한 오류를 발생시킨다.             버퍼 오버플로우의 보다 치명적인 사용은 일반적으로 프로그램이 하지 않을 기능들을 실행하도록 하는 것이다.   일반적으로 탐색코드exploit code 라고 하는 실행코드를 바이트 인코딩한 탐색코드를 가리키는 포인터 리턴 주소를 덮어쓰는 약간의 추가적인 바이트들을 포함하는 스트링을 입력한다. ret 인스트럭션을 실행하면 탐색코드로 점프하게된다.            인터넷 상의 많은 컴퓨터에 접속을 획득한 FINGER 데몬인 fingerd로의 버퍼 오버플로우 공격이 있다.           3.10.4 버퍼 오버플로우 공격 대응 기법      이들 공격이 실행되기 어렵게 하는 방법과 침입자가 버퍼 오버플로우 공격을 통해서 시스템의 제어권을 획득할 수 있는 방법을 제한하는 방법을 구현하였다.      스택 랜덤화            공격자는 탐색코드를 시스템에 삽입하기 위해서 공격 스트링 내에 코드뿐만 아니라 코드로의 포인터까지 집어넣어야한다. 이 포인터를 만들기 위해서는 스트링이 위치하게 될 스택의 주소를 알아야 한다. 역사적으로 프로그램의 스택 주소는 쉽게 에측할 수 있었다.              스택 랜덤화의 아이디어는 스택의 위치를 프로그램의 매 실행마다 다르게 해주는 것이다.   ASLR을 사용하면 프로그램 코드, 라이브러리 코드, 스택, 전역변수, 힙 데이터를 포함하는 여러 프로그램의 부분들이 프로그램이 매번 실행할 때마다 메모리의 다른 지역에 로딩된다.   하지만, 이런 방법은 공격자가 반복적으로 주소를 바꿔가며 무지막지한 공격을 하면 랜덤화를 극복할 수 있다.      스택 손상 검출            두번째 방법은 스택이 손상되는 것을 감지하는 것이다.       아래의 그림은 스택 보호기가 작동될 때 해당 함수의 스택 구성이다. 특별 “canary” 값이 배열 buf와 저장된 상태 값 사이에 위치한다. 코드는 스택 상태가 손상되었는지 여부를 결정하기 위해 canary 값을 체크한다.                 실행코드 영역 제한하기            마지막 방법은 공격자가 실행코드를 시스템에 추가할 가능성을 제거하는 것이다.       어느 메모리 영역이 실행코드를 저장할지를 제한하는 거시앋. 다른 부분들은 읽기와 쓰기만 허용하도록 제한할 수 있다.           3.10.5 가변크기 스택 프레임 지원하기      공통적으로 할당되어야 하는 스택 프레임의 크기를 컴파일러가 미리 결정할 수 있다는 특징이 있었다. 하지만 일부 함수들은 가변적인 지역저장공간 크기를 필요로 한다.     ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_10/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 완주하지 못한 선수 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 해시 완주하지 못한 선수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 두번째 문제이다. 처음 풀어본 문제보다는 자바 문법이 조금 익숙했다. 하지만, 해시를 어떻게 선언하는지 조차 모르고 있어서, 이 부분은 구글링을 하며 풀었다. 이번 문제를 통해서 자바의 해쉬맵을 사용할 수 있게 되었다. 해쉬맵의 여러가지 method들을 숙지하고 있으면 코테에 많은 도움이 될 것 같다.       참가자들이 저장되어 있는 String 배열을 HashMap에 옮겨 담는다.   이 때 참가자들의 이름은 Key값으로 Value는 참가자들의 중복의 유무를 포함하기 위해 default 값을 0으로, 중복된 참가자가 있으면 value를 1씩 증가시킨다.   완주한 참가자들의 이름을 containsKey를 사용하여 해당 Key값의 Value를 1씩 감소시킨다.   해쉬맵의 모든 키를 순회하면서 value값이 0보다 큰 값을 찾는다.   해당 키값을 answer에 저장한다.   return answer   코드       import java.util.*;          public class Main {         public static void main(String[] args){             String[] participant = {\"mislav\", \"stanko\", \"mislav\", \"ana\"};             String[] completion = {\"stanko\", \"ana\", \"mislav\"};                  String answer = solution(participant, completion);             System.out.println(answer);         }              public static String solution(String[] participant, String[] completion){             //정답 문자열 변수 선언             String answer = \"\";             //해쉬맵(딕셔너리) 변수 선언 -&gt; participant 키값으로 넣고 value 값에 Integer 선언해서 completion이랑 비교할거임             Map&lt;String, Integer&gt;ht = new HashMap&lt;String,Integer&gt;();             //해쉬맵에 participant를 키값으로 밸류는 default로 0씩, 키값 중복되면 1씩 추가             for(int i=0; i&lt;participant.length; i++){                 if(ht.containsKey(participant[i])){                     ht.put(participant[i],ht.get(participant[i])+1);                 }                 else{                     ht.put(participant[i],1);                 }             }             //completion을 키값으로 찾아서 밸류값 1씩 감소             for(int i=0; i&lt;completion.length; i++){                 if(ht.containsKey(completion[i])){                     ht.put(completion[i],ht.get(completion[i])-1);                 }             }             //해쉬맵 모든 키를 순회하면서 0보다 큰거 answer에 저장             for(String key:ht.keySet()) {                 if(ht.get(key)&gt;0){                     answer=key;                 }             }                  return answer;         }     }  ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_02/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 모의고사 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동   문제풀이     완전 탐색 문제다. 완전 탐색은 “컴퓨터의 빠른 계산을 이용하여 가능한 모든 경우의 수를 구하는 알고리즘”이다.  문제를 어떻게 해결할지 방향을 잡고 최대한 빠른 로직으로 코드를 구현하는 것이 관건으로 보인다.       사용자들의 정답 패턴을 각각의 배열에 저장한다.   사용자들이 정답을 맞추는 개수를 저장하는 배열을 선언한다. (0으로 초기화한다.)   사용자들의 정답 패턴의 length를 answers와의 나머지를 구하여 패턴을 일치시킨다.   사용자들의 정답의 개수를 저장하고, 해당 배열의 max값을 찾는다.   max값과 일치하는 사용자들의 정답 개수를 갖는 index를 answer 배열에 저장한다.   return answer      BadSolution을 보면 Solution보다 더 많은 조건문이 존재하는 것을 알 수 있다. 이렇듯, 완전 탐색 문제에서는 로직을 최대한 간결하게 작성하는 것이 중요하다.    코드         import java.util.*;              public class Main {       public static void main(String[] args){       int[] answers = {1,2,3,4,5};                      int[] answer = solution(answers);               System.out.println(Arrays.toString(answer));           }           public static int[] solution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};                      int[] answerList = {0,0,0};                      for(int i=0; i&lt;answers.length; i++){                   if(user1[i%user1.length]==answers[i]){                       answerList[0]++;                   }                   if(user2[i%user2.length]==answers[i]){                       answerList[1]++;                   }                   if(user3[i%user3.length]==answers[i]){                       answerList[2]++;                   }               }               int max=answerList[0];               for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]&gt;max) {                       max = answerList[i];                   }               }                      ArrayList&lt;Integer&gt; arrList = new ArrayList();                      for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]==max){                       arrList.add(i);                   }               }                      int size = arrList.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = arrList.get(i)+1;               }               return answer;           }                  public static int[] BadSolution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};               int j1=0,j2=0,j3=0;               int[] user_answer ={0,0,0};               List&lt;Integer&gt; answer_list = new ArrayList&lt;Integer&gt;();               for(int i=0; i&lt;answers.length; i++){                   if(j1&gt;=user1.length){                       j1=0;                   }                   if(answers[i] == user1[i]){                       user_answer[0]++;                   }                   j1++;                   if(j2&gt;=user2.length){                       j2=0;                   }                   if(answers[i] == user2[i]){                       user_answer[1]++;                   }                   j2++;                   if(j3&gt;=user3.length){                       j3=0;                   }                   if(answers[i] == user3[i]){                       user_answer[2]++;                   }                   j3++;               }               int max=user_answer[0];               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]&gt;max){                       max = user_answer[i];                   }               }               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]==max){                       answer_list.add(i);                   }               }                      int size = answer_list.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = answer_list.get(i)+1;               }               return answer;           }       }  ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 쓰레드",
        "excerpt":"Part7 쓰레드   쓰레드란   동시에 여러가지 작업을 동시에 수행할 수 있게 하는것     동시에 여러가지 작업을 수행할 수 있다.   프로세스란 현재 실행되고 있는 프로그램을 말한다.   자바 프로그램은 JVM에 위해 실행된다. 이 JVM도 프로그램중에 하나이다.   운영체제 입장으로 보면 자바도 하나의 프로세스로 실행 하는 것이다.   워드프로세서가 하나의 프로세스라면, 하나의 프로세스 안에서도 여러개의 흐름이 동작할 수 있다. 이것은 Thread라고 말한다.   쓰레드 만들기   자바에서 Thread를 만드는 방법은 크게 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.     Thread를 상속 받아서 쓰레드를 생성하는 방법            java.lang.Thread 클래스를 상속받는다. 그리고 Thread가 가지고 있는 run() 메소드를 오버라이딩한다.       10번 반복하면서 str를 찍는다.               public class MyThread1 extends Thread {         String str;         public MyThread1(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     //컴퓨터가 너무 빠르기 때문에 수행결과를 잘 확인 할 수 없어서 Thread.sleep() 메서드를 이용해서 조금씩                      //쉬었다가 출력할 수 있게한다.                      Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Thread 클래스를 상속받은 MyThread1을 사용하는 클래스            Thread를 상속 받았으므로 MyThread1은 Thread 이다.       쓰레드를 생성하고, Thread 클래스가 가지고 있는 start() 메소드를 호출 한다.               public class ThreadExam1 {         public static void main(String[] args) {             // MyThread인스턴스를 2개 만듭니다.              MyThread1 t1 = new MyThread1(\"*\");             MyThread1 t2 = new MyThread1(\"-\");              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }     Runnable 인터페이스를 구현해서 쓰레드를 만드는 방법            Runnable 인터페이스가 가지고 있는 run() 메소드를 구현한다.               public class MyThread2 implements Runnable {         String str;         public MyThread2(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Runnable 인터페이스를 구현한 MyYhread2 사용하는 방법            MyThread2는 Thread를 상속받지 않았기 때문에 Thread가 아니다.       Thread를 생성하고, 해당 생성자에 MyThread2를 넣어서 Thread를 생성한다.       Thread 클래스가 가진  start() 메소드를 호출한다.               public class ThreadExam2 {           public static void main(String[] args) {             MyThread2 r1 = new MyThread2(\"*\");             MyThread2 r2 = new MyThread2(\"-\");              Thread t1 = new Thread(r1);             Thread t2 = new Thread(r2);              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }  쓰레드와 공유객체   하나의 객체를 여러개의 Thread가 사용한다는 것을 의미   MusicBox 라는 클래스가 있다고 가정한다. 해당 클래스는 3개의 메소드를 가지고 있다. 각각의 메소드는 1초 이하의 시간동안 10번 반복하면서,  어떤 음악을 출력한다. 이러한 MusicBox를 사용하는 MusicPlayer를 3명 만들어 보겠다.   MusicPlayer 3명은 하나의 MusicBox를 사용할 것이다. 이 때 어떤 일이 발생하는지 살펴보겠다.      공유객체 MusicBox       public class MusicBox {          //신나는 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicA(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"신나는 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicA          //슬픈 음악!!!이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicB(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"슬픈 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicB         //카페 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicC(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"카페 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicC       }     MusicBox를 가지는 Thread 객체 MusicPlayer       public class MusicPlayer extends Thread{         int type;         MusicBox musicBox;           // 생성자로 부터 musicBox와 정수를 하나 받아들여서 필드를 초기화         public MusicPlayer(int type, MusicBox musicBox){             this.type = type;             this.musicBox = musicBox;         }                // type이 무엇이냐에 따라서 musicBox가 가지고 있는 메소드가 다르게 호출         public void run(){             switch(type){                 case 1 : musicBox.playMusicA(); break;                 case 2 : musicBox.playMusicB(); break;                 case 3 : musicBox.playMusicC(); break;             }         }            }     MusicBox와 MusicPlayer를 이용하는 MusicBoxExam1 클래스       public class MusicBoxExam1 {          public static void main(String[] args) {             // MusicBox 인스턴스             MusicBox box = new MusicBox();              MusicPlayer kim = new MusicPlayer(1, box);             MusicPlayer lee = new MusicPlayer(2, box);             MusicPlayer kang = new MusicPlayer(3, box);              // MusicPlayer쓰레드를 실행합니다.              kim.start();             lee.start();             kang.start();                    }        }  동기화 메소드와 동기화 블록      고유객체가 가진 메소드를 동시에 호출 되지 않돚록 하는 방법            메소드 앞에 synchronized 를 붙힌다.       여러개의 Thread 들이 공유객체의 메소드를 사용할 때 메소드에 synchronized가 붙어 있을 경우 먼저 호출한 메소드가 객체의 사용권(Monitoring Lock)을 얻는다.               public synchronized void playMusicA(){         for(int i = 0; i &lt; 10; i ++){             System.out.println(\"신나는 음악!!!\");             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicA     메소드 앞에 synchronized 를 붙혀서 실행해 보면, 메소드 하나가 모두 실행된 후에 다음 메소드가 실행된다.   해당 모니터링 락은 메소드 실행이 종료되거나, wait() 와 같은 메소드를 만나기 전까지 유지된다.   다른 쓰레드들은 모니터링 락을 놓을 때 까지 대기한다.   synchronized를 붙히지 않은 메소드는 다른 쓰레드들이 synchronized메소드를실행하면서 모니터링 락을 획득했다 하더라도, 그것과 상관없이 실행된다.   synchronized를 메소드에 붙혀서 사용 할 경우, 메소드의 코드가 길어지면, 마지막에 대기하는 쓰레드가 너무 오래 ㅣㄱ다리는 것을 막기 위해서 메소드에 synchronized를 붙이지 않고, 문제가 있을 것 같은 부분만 synchronized 블록을 사용한다.       public void playMusicB(){         for(int i = 0; i &lt; 10; i ++){             synchronized(this){                 System.out.println(\"슬픈 음악!!!\");             }             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicB  쓰레드와 상태제어   쓰레드가 3개가 있다면 JVM은 시간을 잘게 쪼갠 후에 한번은 쓰레드1을, 한번은 쓰레드 2를, 한번은 쓰레드3을 실행한다. 이것을 빠르게 일어나다 보니 쓰레드가 모두 동작하는 것처럼 보이는 것이다.      쓰레드는 실행가능상태인 Runnable과 실행상태인 Running상태로 나뉜다.   실행되는 쓰레드 안에서 Thread.sleep() 이나 Object가 가지고 있는 wait() 메소드가 호출이 되면 쓰레드는 블록상태가 된다.   Thread.sleep() 은 특정시간이 지나면 자신 스스로 블록상태에서 빠져나와 Runnable 이나 Running상태가 된다.   Object가 가지고 있는 wait() 메소드는 다른 쓰레드가 notify()나 notifyAll() 메소드를 호출하기 전에는 블록상태에서 해체되지 않는다.   wait()메소드는 호출이 되면 모니터링 락을 놓게 된다. 그래서 대기중인 다른 메소드가 실행한다.   쓰레드의 run메소드가 종료되면, 쓰레드는 종료된다. 즉 Dead상태가 된다.   Thread의 yeild메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 된다.   Thread가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료될 때까지 대기하게 된다.   쓰레드와 상태제어 (join)   join() 메소드는 쓰레드가 멈출 때까지 기다리게 한다.      일단 0.5초씩 쉬면서 숫자를 출력하는 MyThread5를 작성해 보겠다.       public class MyThread5 extends Thread{         public void run(){             for(int i = 0; i &lt; 5; i++){                 System.out.println(\"MyThread5 : \"+ i);                 try {                     Thread.sleep(500);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }         } // run     }     해당 쓰레드를 실행하고, 해당 쓰레드가 종료될 때 까지 기다린 후, 내용을 출력하는 joinExam 클래스       public class JoinExam {          public static void main(String[] args) {             MyThread5 thread = new MyThread5();             // Thread 시작              thread.start();              System.out.println(\"Thread가 종료될때까지 기다립니다.\");             try {                 // 해당 쓰레드가 멈출때까지 멈춤                 thread.join();             } catch (InterruptedException e) {                 e.printStackTrace();             }             System.out.println(\"Thread가 종료되었습니다.\");          }        }     실행 결과           Thread가 종료될때까지 기다립니다.         MyThread5 : 0         MyThread5 : 1         MyThread5 : 2         MyThread5 : 3         MyThread5 : 4         Thread가 종료되었습니다.  쓰레드와 상태제어 (wait, notify)   wait과 notify는 동기화된 블록 안에서 사용해야 한다. wait를 만나게 되면 해당 쓰레드는 해당 객체의 모니터링 락에 대한 권한을 가지고 있다면 모니터링 락의 권한을 놓고 대기한다.      Thread를 상속받는 ThreadB 클래스 작성       public class ThreadB extends Thread{        // 해당 쓰레드가 실행되면 자기 자신의 모니터링 락을 획득        // 5번 반복하면서 0.5초씩 쉬면서 total에 값을 누적        // 그후에 notify()메소드를 호출하여 wiat하고 있는 쓰레드를 깨움          int total;         @Override         public void run(){             synchronized(this){                 for(int i=0; i&lt;5 ; i++){                     System.out.println(i + \"를 더합니다.\");                     total += i;                     try {                         Thread.sleep(500);                     } catch (InterruptedException e) {                         e.printStackTrace();                     }                 }                 notify();             }         }     }     이번에는 ThreadB 를 사용하며 wait 하는 클래스 작성       public class ThreadA {         public static void main(String[] args){             // 앞에서 만든 쓰레드 B를 만든 후 start              // 해당 쓰레드가 실행되면, 해당 쓰레드는 run메소드 안에서 자신의 모니터링 락을 획득             ThreadB b = new ThreadB();             b.start();              // b에 대하여 동기화 블럭을 설정             // 만약 main쓰레드가 아래의 블록을 위의 Thread보다 먼저 실행되었다면 wait를 하게 되면서 모니터링 락을 놓고 대기                    synchronized(b){                 try{                     // b.wait()메소드를 호출.                     // 메인쓰레드는 정지                     // ThreadB가 5번 값을 더한 후 notify를 호출하게 되면 wait에서 깨어남                     System.out.println(\"b가 완료될때까지 기다립니다.\");                     b.wait();                 }catch(InterruptedException e){                     e.printStackTrace();                 }                  //깨어난 후 결과를 출력                 System.out.println(\"Total is: \" + b.total);             }         }     }     실행 결과           b가 완료될때까지 기다립니다.         0를 더합니다.         1를 더합니다.         2를 더합니다.         3를 더합니다.         4를 더합니다.         Total is: 10  데몬 쓰레드   데몬(Daemon)이란 보통 리눅스와 같은 유닉스계열의 운영체제에서 백그라운드로 동작하는 프로그램을 말한다.     데몬쓰레드를 만뜨는 방법은 쓰레드에 데몬 설정을 하면 된다.            이런 쓰레드는 자바프로그램을 만들 때 백그라운드에서 특별한 작업을 처리하게 하는 용도로 만든다.           데몬쓰레드는 일반 쓰레드(main 등)가 모두 종료되면 강저젝으로 종료되는 특징을 가지고 있다.       // Runnable을 구현하는 DaemonThread클래스를 작성     public class DaemonThread implements Runnable {          // 무한루프안에서 0.5초씩 쉬면서 데몬쓰레드가 실행중입니다를 출력하도록 run()메소드를 작성         @Override         public void run() {             while (true) {                 System.out.println(\"데몬 쓰레드가 실행중입니다.\");                  try {                     Thread.sleep(500);                  } catch (InterruptedException e) {                     e.printStackTrace();                     break; //Exception발생시 while 문 빠찌도록                  }             }         }          public static void main(String[] args) {             // Runnable을 구현하는 DaemonThread를 실행하기 위하여 Thread 생성             Thread th = new Thread(new DaemonThread());             // 데몬쓰레드로 설정             th.setDaemon(true);             // 쓰레드를 실행             th.start();              // 메인 쓰레드가 1초뒤에 종료되도록 설정.              // 데몬쓰레드는 다른 쓰레드가 모두 종료되면 자동종료.             try {                 Thread.sleep(1000);             } catch (InterruptedException e) {                 e.printStackTrace();             }                System.out.println(\"메인 쓰레드가 종료됩니다. \");             }        } ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_14/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 람다",
        "excerpt":"Part8 람다   람다식   람다식은 다른말로 익명 메소드라고도 한다.      인터페이스 중에서 메소드를 하나만 가지고 있는 인터페이스르함수형 인터페이스라고 한다.            쓰레드를 만들 때 사용하는 Runnable 인터페이스의 경우 run() 메소드를 하나만 가지고 있다.           Runnable을 이용하여 쓰레드를 만드는 방법       public class LambdaExam1 {          public static void main(String[] args) {             new Thread(new Runnable(){public void run(){                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }}).start();         }        }     쓰레드가 실행되면 쓰레드 생성자 안에 넣은 run()메소드가 실행된다.   자바는 메소드만 배개변수로 전달할 방법이 없다. 인스턴스만 전달할 수 있다.   그렇기 때문에 run()메소드를 가지고 있는 Runnable 객체를 만들어서 전달한다.   메소드만 전달할 수 있다면, 좀 더 편리하게 프로그래밍할 수 있을텐데, 자바는 메소드만 전달할 수 있는 방법은 없었기 때문에 매번 객체를 생성해서 매개변수로 전달해야 했다. 이러한 부분을 해결한 것이 람다 표현식이다.      람다식을 이용해서 수정한 코드       public class LambdaExam1 {           public static void main(String[] args) {             new Thread(()-&gt;{                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }).start();         }        }     ()-&gt;{……} 부분이 람다식, 다른말로 익명 메소드   JVM은 Thread생성자를 보고 ()-&gt;{} 이 무엇인지 대상을 추론한다.   Thread 생성자 api를 보면 Runnable 인터페이스를 받아들이는 것을 알 수 있다.   JVM은 Thread 생성자가 Runnable 인터페이스를 구현한 것이 와야 하는 것을 알게 되고 람다식을 Runnable을 구현하는 객체로 자동으로 만들어서 매개변수로 넣어준다.        프로그래머스 자바 중급을 마무리하며  자바 초급 강의보다는 조금 덜 직관적으로 와닿은 강의였다. 자바 중급 강의에서 배우는 다양한 패키지와 IO 그리고 쓰레드와 람다를 정확히 어느 경우에 사용 하는지 모호하기 때문인 것 같다. 이러한 부분들은 향후 java 언어를 자주 사용하게 됨으로써 해당 기능들을 사용하게 되었을 때 더 직관적으로 이해할 수 있을 것 같다. 해당 기능들을 사용할 때 이해가 되지 않는다면, 이번에 포스팅한 프로그래머스 자바 중급 강의를 사용하면 좋을 것 같다.     해당 강의와 강의 노트는 프로그래머스 자바 중급에서 언제든지 다시 들을 수 있다!  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_15/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.11 부동소수점 코드 ~ 3.12 요약)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.11 부동소수점 코드   3.12 요약   3.11 부동소수점 코드      프로세서의 부동소수점 아키텍처는 부동소수점 데이터로 연산하는 방법이 기계에 매피되는 방법에 영향을 주는 다음과 같은 여러 가지 개념들로 구성된다.            부동소수점 값들이 저장되고 접근되는 방법                    이것은 대개 레지스터들의 일부 형태로 이뤄진다.                       부동소수점 데이터로 연산하는 인스트럭션       함수들의 인자와 리턴 값으로 부동소수점 값들을 전달하기 위해 이용되는 관례들       함수를 호출하는 동안에 레지스터들을 보존하는 관례들           x86-64 부동소수점 아키텍처를 이해하기 위해선 간략한 역사적 고찰을 해보는 것이 유용하다.            1997년에 펜티엄/MMX를 발표한 이래, 인텔과 AMD는 그래픽과 영상처리를 지원하기 위해 일련의 미디어 인스트럭션 세대들을 포함해왔다.       이들에 대한 확장현태가 진행되었고 MMX로부터 SSE, AVX로 개선되어갔다.       AVX 부동소수점 아키텍처는 %ymm0-%ymm15로 이름 붙인 16개의 YMM 레지스터들에 저장된다.       스칼라 데이터로 연산할 때, 이 레지스터들은 부동소수점 데이터만을 보관하며, 하위 32비트(float), 64비트(double)만이 사용된다.              3.11.1 부동소수점 이동 및 변환 연산      XMM 레지스터에서 다른 레지스터로 이동하는 것뿐만 아니라 메모리와 XMM 레지스터들 간의 부동소수점 데이터를 이동하는 인스트럭션들을 보여준다.   메모리를 참조하는 인스트럭션들은 스칼라 인스트럭션들이다.            이것은 이들이 묶인 데이터 값들이 아닌 개별 값들에 대해 연산한다는 것을 의미한다.           GCC는 데이터를 메모리에서 XMM 레지스터로,또는 XMM 레지스터에서 메모리로 이동하기 위해서만 스칼라 이동연산을 이용한다.        두 개의 XMM 레지스터들 간의 데이터 이동을 위해서는 한 개의 XMM 레지스터의 내용 전체를 다른 레지스터로 복사하기 위해 두 개의 인스트럭션 중 하나를 이용한다.       아래의 그림은 부동소수점 이동 명령. 이 연산들은 레지스터들 간, 레지스터와 메모리 간에 값을 이동한다.         아래의 그림은 두 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 부동소수점 데이터를 정수로 변환한다.         아래의 그림은 세 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 첫번째 소스의 자료형으로부터 목적지의 자료형으로 변환한다. 두번째 소스 값은 결과의 하위 바이트에는 영향을 주지 않는다.      3.11.2 프로시저에서 부동소수점 코드      XMM 레지스터들이 함수로 부동소수점 인자를 전송하고 부동소수점 값들을 리턴할 때 사용된다.            최대 여덟 개의 부동소수점 인자들이 %xmm0-%xmm7 XMM 레지스터들로 전달될 수 있다.       한개의 부동소수점 값을 리턴하는 함수는 레지스터 %xmm0를 이용한다.       모든 XMM 레지스터들은 호출자 저장방식이다.           어떤 함수가 포인터, 정수, 부동소수점 인자들의 조합을 가지고 있을 때, 포인터와 정수들은 범용 레지스터로 전달되지만, 부동소수점 값들은 XMM 레지스터들로 전달된다.      3.11.3 부동소수점 산술연산      스칼라 부동소수점 산술연산. 이 인스트럭션들은 한 개 또는 두 개의 소스 오퍼랜드와 하나의 목적지 오퍼랜드를 갖는다.   첫번빼 소스 오퍼랜드 S1은 XMM 레지스터나 메모리 위치일 수 있다.   두번째 소스 오퍼랜드와 목적지 오퍼랜드는 XMM 레지스터만 가능하다.      3.11.4 부동소수점 상수의 정의 및 이용      AVX 부동소수점 연산은 즉시값immediate value을 오퍼랜드로 가질 수 없다.   그 대신, 컴파일러는 상수 값들을 위해 저장공간을 할당하고 초기화해야 한다.        그리고 나서 코드는 메모리에서 값들을 읽어들인다.       아래의 그림을 보면 값 1.8을 .LC2로 명명된 메모리 위치에서 읽어들이고, 32.0을 메모리 위치 .LC3에서 읽어들이는 것을 알 수 있다.      3.11.5 부동소수점 코드에서 비트연산 사용하기      아래의 그림은 통합데이터에 대한 비트 연산이다. 이 인스트럭션들은 XMM 레지스터에 들어 있는 128비트들에 대한 부울연산을 수행한다.      3.11.6 부동소수점 비교 연산      AVX2는 부동소수점 값들을 비교하기 위해 두 개의 인스트럭션을 제공한다.         부동소수점 비교 인스트럭션은 세 개의 조건코드를 설정한다: zero 영 플래그 ZF, 캐리 플래그 CF, 패리티 플래그 PF            패리티 플래그는 가장 최근 산술 또는 논리연산이 최소중요바이트를 짝수 패리티를 갖는 값을 생성했을 때 설정된다.                    패리티 플래그 무슨소린지 하나도 모르겠다… 이건 좀더 조사해보자!                            3.11.7 부동소수점 코드에 대한 관찰      AVX2로 부동소수점 데이터에 대해 연산하기 위해 생성된 머신코드의 일반적인 스타일이 정수데이터에 연산하는 경우에 대해 살펴본 것과 유사하다는 것을 알았다.   이 둘은 모두 값을 보관하고 연산하기 위해 레지스터들을 사용하며, 이들은 이 레지스터를 사용해서 함수의 인자를 전달한다.   3.12 요약     이 장에서는 기계어 수준 프로그래밍의 시각을 얻기 위해 C언어에서 제공하는 추상화 계층 아래를 살펴보았다.        컴파일러가 기계어 수준 프로그램의 어셈블리 코드 표현을 생성하게 해서 프로세서, 자료형, 인스트럭션 집합과 함께 컴파일러와 컴파일러의 최적화 능력에 대한 통찰을 얻을 수 있었다.       기계어 수준 프로그램들과 이들의 어셈블리 코드 표시는 C 프로그램들과는 여러모로 다른다.   서로 다른 자료형들 사이에 차이는 거의 없다.   프로그램은 인스트럭션들의 연속으로 표시되고, 각각은 한 개의 연산을 수행한다.   컴파일러는 여러 가지 자료구조를 생성하고 처리하기 위해서, 조건문, 루프, 프로시저 같은 제어문을 구현하기 위해서 다수의 인스트럭션들을 사용해야 한다.        C에서 경계 값을 체크하지 않기 때문에 많은 프로그램들이 버퍼 오버플로우의 위험에 놓인다는 것을 알게 되었다.       자바는 ‘자바 바이트 코드’라고 알려진 특별한 이진 표현이다.      Chapter3 또한 부동소수점을 마지막으로 마무리 하였다. 기계어 표현인 어셈블리어에 대한 내용이 한가득 있었던 챕터였다. 간단한 이동과 연산부터 배열, 조건문, 프로시저, 부동소수점 까지의 기계어 인스트럭션들을 살펴보았고, 이러한 인스트럭션을 통해서 컴퓨터는 연산 명령을 받게 된다. 이해하기 어려운 기계어는 실제로 C언어를 기계어 단계에서 디버깅 하면서 이해를 도왔다. &lt;- 이부분이 이해가 직관적으로 되어서 참 좋았다. Chapter2~3은 Chapter4의 빌드업이라고도 한다. 확실히 이해하고 Chapter 4로 넘어가자!   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.1 Y86-64 인스트럭션 집합 구조)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조      3장까지는 컴퓨터 시스템을 기계어 프로그램의 수준까지만 내려가서 살펴보았다.   프로세서가 일련의 명령어들을 샐힝하고, 각 명령으들은 두 개의 수를 더한다든지의 기본적인 기능을 수행하는 것을 알게 되었다.   한 개의 인스트럭션은 연속된 바이트들로 이진수의 형태로 인코딩된다.   인스트럭션들은 특정 프로세서에 의해 지원되며, 바이트수준의 인코딩을 인스트럭션 집합 구조instruction set architecture(ISA)라고 한다.   ISA는 어떤 인스트럭션들이 허용되고, 어떻게 그들이 인코딩되었는지 알고 있는 컴파일러 작성자와 이들 인스트럭션을 실행해야 하는 머신을 만들어야 하는 프로세서 설계자들에게 개념적 추상화 계층을 제공하고 있다.      4장에서는 프로세서 하드웨어의 설계를 간단히 살펴본다.   하드웨어 시스템이 어떻게 특정 ISA의 인스트럭션들을 실행할 수 있는지를 학습한다.   이러한 관점은 어떻게 컴퓨터들이 동작하는지와 컴퓨터 제작자들이 직면하고 있는 기술적인 도전들을 더 잘 이해할 수 있게 해준다.   왜 프로세서 설계를 공부해야 하는 것인가?            지적으로 흥미롭고 중요하기 때문이다.       프로세서의 동작방법을 이해하면 전체 컴퓨터 시스템의 동작 방법을 이해하는 데 도움을 준다.       비록 적은 수의 사람들만이 프로세서를 설꼐하지만 많은 사람들이 프로세서를 포함하는 하드웨어 시스템을 설계한다.              4장에서는 인스트럭션 집합을 정의한다 : “Y86-64” 인스트럭션 집합   x86-64에 비해서 적은 자료형, 인스트럭션, 주소지정 모드를 갖는다.   디지털 하드웨어 설계에 관한 약간의 배경지식을 제공한다.            기초 설계 블록과 이들이 어떻게 서로 연결되고 동작하는지 설명한다.       불 대수와 비트수준 연산에 관한 논의에 기초한다.       간단한 언어인 HCL : 하드웨어 시스템의 제어 부분을 설명하는 데 사용된다.           순차 설계를 기초로 해서 파이프라인형pipelined 프로세서를 만드는 일련의 변환을 적용한다.            각 인스트럭션의 실행단계를 5단계로 나누어서 각각 별도의 부분 또는 하드웨어 단계에서 처리되도록 한다.           4.1 Y86-64 인스트럭션 집합  인스트럭션 집합을 설계하기 위해서는 여러 가지 상태요소들, 인스트럭션 집합과 이들의 인코딩, 프로그래밍 관습들, 예외적 사건들의 처리 등에 대한 정의를 해야 한다.   4.1.1 프로그래머-가시성 상태programmer-visible state     Y86-64의 각 인스트럭션은 프로세서 상태의 일부를 읽거나 변경할 수 있다.            이것을 프로그래머-가시성상태programmer-visible state라고 한다.           프로세서를 구현할 때는 기계수준 프로그램이 프로그래머 가시 상태에 접근하는 것을 확실히 할 수만 있다면 이 상태를 ISA가 의미하는 방식대로 정확히 표시하거나 구성할 필요가 없다는 것을 알게 될 것이다.        아래의 그림은 Y86-64 프로그래머-가시성 상태이다. 프로그램 레지스터, 조건코드, 프로그램 카운터(PC), 메모리를 접근하고 수정할 수 있다. 상태코드는 이 프로그램이 정상적으로 실행되고 있는지, 어떤 특수한 사건이 발생했는지를 나타낸다.                     레지스터 %rsp는 push, pop, call, return 인스트럭션을 사용할 때 스택 포인터로 이용된다.       메모리는 개념적으로 커다란 바이트의 배열이다.                    Y86-64 프로그램들은 가상주소를 사용해서 메모리 위치를 참조한다.           운영체제와 하드웨어가 함께 이 가상주소를 실제주소, 즉 물리 주소로 번역한다.                       프로그램 상태의 마지막 부분은 상태코드 Stat이다.                    프로그램 실행의 전체적인 상태를 나타낸다.                           4.1.2 Y86-64 인스트럭션      아래의 그림은 Y86-64 인스트럭션 집합이다.            인스트럭션 인코딩은 1에서 10바이트가 쇼요된다.       한개의 인스트럭션은 1바이트의 인스트럭션 식별자와 1바이트 레지스터 식별자, 8바이트 상수 워드로 구성될 수 있다.       필드 fn은 특정 연수 연산(OPq), 데이터 이동 조건(cmovXX), 분기조건(jxx)을 나타낸다.       모든 숫자 값은 16진수로 나타낸다.                         movq 인스트럭션은 네 개의 인스트럭션으로 나누어진다.                    irmovq, rrmovq, mrmovq, rmmovq           소스와 목적지를 명시적으로 나타낸다.           소스는 상수 immediatde(i), 레지스터(r), 메모리(m) 중의 하나가 될 수 있다.                       OPq로 나타낸 것처럼 네 개의 정수 연산이 있다.                    addq, subq, andq, xorq           이 인스트럭션 집합은 ZF, SF, OF(zero, sign, overflow) 조건코드를 결정한다.                       일곱개의 jump 인스트럭션이 있다.                    jmp, jle, jl, je, jne, jge, jg                       여섯 개의 move 인스트럭션이 있다.                    cmovle, cmovl, cmove, cmovne, cmovge, cmovg           목적지 레지스터는 조건코드가 요구된 조건을 만족할 때에만 갱신된다.                       call 인스트럭션은 리턴주솔들 스택에 넣고 목적지 주소로 이동한다.       ret 인스트럭션은 call에서 리턴해준다.       pushq와 popq 인스트럭션은 push와 pop을 구현한다.       halt 인스트럭션은 인스트럭션의 실행을 정지시킨다.           4.1.3 인스트럭션 인코딩          아래의 그림은 인스트럭션들의 바이트 수준 인코딩을 보여준다.                     각 인스트럭션은 인스트럭션의 타입을 의미하는 첫 번째 바이트를 사용한다.                아래의 그림은 인스트럭션들에 대한 특정 인코딩을 보여준다.                     rrmovq가 조건부 이동과 동일한 인스트럭션 코드를 갖는 점에 유의하라.                    jmp 인스트럭션이 무조건적 점프인 것과 마찬가지로 이것은 “무조건적 move”로 생각 할 수 있다.                                아래의 그림은 Y86-64 프로그램 레지스터 식별자이다.                     15개의 프로그램 레지스터들은 0에서 0xE 사이의 식별자를 갖는다.       프로그램 레지스터들은 CPU 내의 레지스터 파일에 저장된다.       레지스터 파일은 레지스터 ID가 주소로 이용되는 작은 크기의 RAM이다.       식별자 0xF는 레지스터에 접근하지 말아야 한다는 것을 나타낼 필요가 있을 때, 인스트럭션 인코딩에서, 우리의 하드웨어 설계 내에서 이용된다.       일부 인스트럭션들은 1바이트 길이를 사용하지만, 오퍼랜드를 필요로 하는 경우에는 좀 더 긴 인코딩을 사용한다.       하나 또는 두 개의 레지스터를 명시하기 위해 추가적인 레지스터 식별자 바이트를 사용할 수 있다.       어떤 인스트럭션들은 추가로 8바이트 상수 워드를 필요로 한다.                    이 워드는 irmovq의 즉시 데이터가 될 수 있다.           rmmovq와 mrmovq 주소 지시자를 위한 변위값으로 그리고 분기와 call 명령의 목적지로 사용될 수 있다.                           모든 인스트럭션 집합에 있어서 한 가지 중요한 특성은 바이트 인코딩이 유일한 해석을 가져야 한다는 것이다.   모든 인스트럭션이 첫 번째 바이트에 코드와 기능의 유일한 조합을 갖기 때문이며, 바이트만 주어지면 추가적인 바이트들의 의미와 길이를 결정할 수 있다.   4.1.4 Y86-64 예외상황     프로그래머가 볼 수 있는 상태는 현재 실행하고 있는 프로그램의 전체적인 상태를 나타내는 Stat 상태코드를 포함한다.        아래의 그림은 Y86-64 상태코드이다.. 우리의 설계에서 프로세서는 AOK 이외의 모든 코드에서 정지한다.                     코드1, AOK라고 이름 붙인 이 프로그램이 정상적으로 실행되고 있음을 나타낸다.       코드2, HLT 인스트럭션을 실행한 것을 나타낸다.       코드3, ADR 인스트럭션을 선입하거나 데이터를 읽거나 쓰는 경우에 잘못된 메모리주소 읽어오거나 쓰려고 한 것을 나타낸다.       코드4, 잘못된 인스트럭션 코드를 만났다는 것을 의미한다.           4.1.5 Y86-64 프로그램          아래의 그림은 Y86-64 어셈블리 코드로 작성한 에제 프로그램이다. Sum함수는 4개의 원소를 갖는 배열의 합을 계산하기 이해 호출된다.                     이 프로그램은 데이터와 인스트럭션 모두를 가지고 있다.       지시자들은 코드나 데이터를 어느 위치에 저장하고 이것을 어떻게 정렬할지를 나타낸다.       스택 위치, 데이터 초기화, 프로그램 초기화, 프로그램 종료 같은 이슈들을 보여주고 있다.       ”.”로 시작하는 단어들은 어셈블러 지시자directive들로 어셈블러가 만드는 코드의 주소를 조정하고 일부 데이터 워드를 추가하도록 어셈블러에게 지시한다.                아래의 그림은 위의 그림을 YAS라고 하는 어셈블러를 사용해서 어셈블한 결과를 보여준다. == 어셈블러, 목적코드                     목적코드는 인스트럭션이나 데이터를 포함하는 어셈블리 파일의 각 줄에서 주소를 가지며, 다음에 1에서 10바이트의 값들이 따라온다.          ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_12/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.2 논리 설계와 하드웨어 제어 언어 HCL)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.2 논리 설계와 하드웨어 제어 언어 HCL      하드웨어를 설계할 때 전자회로를 사용해서 비트들의 함수를 계산하고 여러 가지 메모리 원소들에 비트들을 저장한다.   디지털 시스템을 만들기 위해서는 다음과 같은 세 개의 주요 컴포넌트가 있어야 한다.            비트연산을 위한 조합회로 combinational logic       비트를 저장하는 메모리 소자       메모리 소자의 갱신을 조절하는 클럭 신호           4.2.1 논리 게이트     논리 게이트는 디지털 회로에서 기초 연산 소자들이다.   아래의 그림은 AND, OR, NOT 논리 게이트의 유형이다. 각 게이트는 입력들의 불 함수 같은 출력을 만든다.      4.2.2 조합회로와 HCL 불 수식      여러 가지 논리 게이트를 모아서 네트워크를 만들면 조합회로라고 알려진 계산 블록을 만들 수 있다.   어떻게 네트워크가 구성되는지와 관련해서 몇가지 제한이 있다.            모든 논리 게이트 입력은 정확히 다음 중의 하나에 연결되어야 한다.                    시스템 입력중의 하나(주요입력이라고 알려진)           일부 메모리 소자의 출력 연결           일부 논리게이트의 출력                       두 개 이상의 논리 게이트의 출력은 서로 연결될 수 없다.       네트워크에는 순환회로가 없어야 한다.           아래의 그림은 비트 동일성을 시험하기 위한 조합회로이다. 출력은 입력이 모두 0이거나 1이면 1이된다.         아래의 그림은 멀티플렉서multiplexor로 알려진 간단하지만 유용한 조합회로의 에를 보여준다.            멀티플렉서는 제어 입력 신호 값에 따라 여러 데이터 신호 중에서 한 값을 선택한다.       제어신호 s가 1이면 출력은 a가 되고, s가 0이면 입력 b가 출력이된다.                 HCL 수식들은 조합논리회로와 C에서의 논리 수식 간에 분명한 연관관계를 보여준다.            이들은 모두 입력에 대한 함수를 계산하기 위해 불 연산을 사용한다. 계산을 표현하는 이들 간의 차이를 살펴보는 것은 의미가 있다.                    조합회로가 일련의 논리 게이트로 이루어지기 때문에 출력들이 입력 변화에 연속적으로 반응하는 특성을 갖는다.                            반대로 C 수식은 프로그램 실행 중에 이 식을 마난야 계산이 이루어진다.                                   C에서 논리 수식을 0을 거짓으로, 다른 값들을 참으로 해석한다.                            반대로 논리 게이트는 비트 값 0과 1에 대해서만 연산을 한다.                                                   4.2.3 워드수준 조합회로와 HCL 정수 수식     논리 게이트들의 커다란 네트워크를 연결해서 보다 복잡한 함수를 계산하는 조합회로를 구성할 수 있다.   데이터 워드를 가지고 동작하는 회로를 설계 하게 된다.   HCL에서 워드 크기를 명시하지 않고 모든 워드수준 신호를 int로 선언한다.            이것은 단순성을 위한 것이다.           아래의 그림은 워드수준 동일성 시험 회로다.         아래의 그림은 워드수준 멀티플렉서 회로다.         멀티플렉서 함수는 HCL의 case 수식을 사용해서 기술된다.            case 수식은 다음과 같은 일반 형태를 갖는다.       이 수식은 여러 개의 case를 가지고 있으며, 각 case i는 언제 이 case가 선택되어야 하는지를 나타내는 불 수식 selecti와 결과 값을 나타내는 정수수식 expri로 구성된다.               [         select1 : expr1;         select2 : expr2;           .           .           .         selectk : exprk;     ]     아래의 그림은 4입력 멀티플렉서이다. 제어신호 s1과 s2의 여러가지 조합에 의해 어떤 데이터 입력이 출력에 전송될지가 결정된다.            그 아래의 수식은 그림에 해당하는 수식이다.                  ex = [         !s1 &amp;&amp; !s0  : A; #00         !s1         : B; #01         !s0         : C; #10         1           : D; #11     ]     조합논리회로는 워드수준 데이터에 대해 여러 가지 많은 연산을 수행하도록 설계될 수 있다.   아래의 그림은 산술/논리 유닛 ALU이다. 함수 입력의 설정에 따라 이 회로는 4개의 서로 다른 산술 및 논리연산을 실행하게 된다.            제어 값들이 이 인스트럭션들을 위한 함수코드와 일치한다.              4.2.4 집합의 원소 관계     집합의 원소 여부를 시험하는 일반적인 형태는 다음과 같다.            iexpr in {iexprq, iexpr2, … , iexprk}           4.2.5 메모리와 클럭     조합회로들은 근본적으로 정보를 저장하지 않는다.   이들은 단순히 입력 신호들에 반응하여 그 입력을 갖는 함수와 동일한 출력을 만들어 낸다.   순차회로, 즉 상태를 가지며 이 상태에 대해 계산을 하는 회로를 만들기 위해서는 비트로 표시된 정보를 저장하는 장치를 이용해야한다.   저장장치들은 로딩되는 때를 결정하는 주기적 신호인 한 개의 클럭에 의해 새 값들이 모두 제어된다.            클럭을 사용하는 레지스터들 : 워드나 개별 비트를 저장한다.       랜덤 액세스 메모리 : 워드를 읽거나 쓰기 위해 주소를 사용해서 여러 워드를 저장한다.                    ex) 가상메모리 시스템, 레지스트 파일                           “레지스터”라는 단어는 하드웨어와 기계어 프로그램에서 사용할 때 다르다.            하드웨어에서 레지스터는 입력과 출력 전선들로 회로의 나머지 부분과 직접 연결된다.       기계어 수준 프로그래밍에서 레지스터는 주소가 레지스터의 ID인 CPU 내의 주소지정이 가능한 워드들의 작은 집합을 나타낸다.                아래의 그림은 레지스터 연산이다. 레지스터 출력은 클럭 신호가 상승할 때까지 현재 레지스터 상태를 유지한다. 클럭이 상승할 때, 레지스터의 입력 값들이 새로운 레지스터의 상태로 저장된다.                     하드웨어 레지스터의 보다 상세한 모습이다.       레지스터는 어떤 고정된 상태(x로 나타냄)로 남는데, 자신의 현재 상태와 동일한 출력을 낸다.       클럭이 올라가면 입력 신호들이 다음 상태(y)로 레지스터에 로딩되고, 이것이 다음 상승 클럭 에지edge까지 새로운 레지스터의 출력이된다.       레지스터들이 회로의 여러 부분에서 조합논리 간에 장벽으로의 역할을 수행한다는 것이다.                아래의 그림은 전형적인 레지스터 파일을 보여준다.                     다중포트 랜덤 액세스 메모리는 여러 번의 읽기와 쓰기 연산이 동시에 일어날 수 있도록 해준다.       레지스터 파일에서 이 회로는 두 프로그램 레지스터의 값을 읽을 수 있고 세 번째 레지스터의 상태를 갱신 할 수 있다.       두 개의 읽기 포트는 주소 입력 srcA, srcB와 데이터 출력 valA, valB를 갖는다.       쓰기 포트는 주소 입력 dstW, 데이터 입력 valW를 갖는다.       레지스터 파일은 조합회로는 아닌데, 이는 레지스터 파일이 내부 저장장치를 가지고 있기 때문이다.       데이터는 주소를 입력으로 가지며, 데이터를 출력으로 갖는 조합논리 블록인 것처럼 데이터가 레지스터 파일로부터 읽을 수 있다.       srcA, srcB가 어떤 레지스터 ID로 설정되었을 때, 해당 프로그램에 저장된 값은 valA, valB에 나타난다.       레지스터 파일에 워드를 쓰는 작업은 클럭이 있는 레지스터에 값을 로딩하는 것과 비슷하게 클럭 신호에 의해 제어된다.                아래의 그림은 프로세서는 다음과 같이 도식적으로 나타낸 것처럼 프로그램 데이터를 저장하기 위해 랜덤 액세스 메모리를 갖는다.                     한 개의 주소 입력, 쓰기를 위한 데이터 입력, 읽기를 위한 데이터 출력을 갖는다.       레지스터 파일처럼 우리의 메모리에서의 읽기 작업은 조합회로와 유사한 방식으로 동작한다.          ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_13/",
        "teaser": null
      },{
        "title": "[Python/Pandas] Python Pandas Cheat Sheet을 한번 만들어 보겠습니다.",
        "excerpt":"Cheat Sheet! 왜 필요할까?   Data Engineering 인턴을 경험하면서 나는 ETL 작성을 주업무로 맡게 되었다. R 코드로 작성된 레거시 파일을 Python 코드로 마이그레이션 하는 업무인데, 가끔씩 data 요청사항이 있으면 직접 로직을 구현하는 경우도 있었다. 보통 data 가공을 DataFrame으로 만들어 Pandas 문법을 사용하는데, 자주 사용했던 문법도 기억이 안나서 구글링으로 시간을 낭비했던 경험이 꽤 있다. 그래서! “구글링의 속도를 높여줄 혹은 구글링이 필요 없을 정도의 Cheat Sheet을 만들어두면 굉장히 편할 것 같다!” 라고 생각한다. 약 8개월간의 인턴생활중 자주 사용했던 Pandas 문법을 정리해보겠다.   우선 Pandas 문법을 크게 세가지로 분류하겠다.     Input/output            pandas의 input output 관련 문법       ex) read_csv,to_json…           General functions            DataFrame 자체를 가공하는 문법..?       ex) pd.merge(), pd.concat()…           DataFrame            DataFrame 이 갖고있는 메소드..?       ex) DataFrame.astype, DataFrame.pop…           Input/output      read_csv   to_csv   General functinons   DataFrame 합치기 관련           pandas.merge             n개의 dataframe을 merge 또는 join                pandas.concat             n개의 dataframe을 단순히 합침           DataFrame 중복제거 관련           pandas.unique             중복된 값을 제거           DataFrame Nan값 관련           pandas.isna             Nan인 값 True                pandas.notna             Nan이 아닌 값 True              isnull, notnull 도 있음   DataFrame   DataFrame Info 관련           pandas.DataFrame.dtypes             column들의 type 출력                pandas.DataFrame.shape             df의 column과 row수 출력                pandas.DataFrame.head             df의 상위 n개의 정보 출력           DataFrame value 관련           pandas.DataFrame.values             df의 value들을 출력       ex) df[“A”].values.to_list() -&gt; A컬럼의 value들을 list로 변경함                pandas.DataFrame.value_counts             df의 value 수 출력                pandas.DataFrame.sort_values             df의 값을 df의 X column value 기준으로 정렬           DataFrame index 관련           pandas.DataFrame.reset_index             df의 index를 reset                pandas.DataFrame.set_index             df의 X column으로 index 설정           DataFrame column 관련           pandas.DataFrame.rename             column 명을 변경                pandas.DataFrame.astype             column의 type 변경           DataFrame 조건 추출 관련           pandas.DataFrame.where             특정 조건을 만족하지 않은 값, False인 값을 특정 값으로 변경                pandas.DataFrame.mask             특정 조건을 만족하는 값, True인 값을 특정 값으로 변경                pandas.DataFrame.equals             DataFrame과 DataFrame을 비교하여 True of False 추출           DataFrame Nan 관련           pandas.DataFrame.dropna             Nan값 drop           DataFrame 중복제거 관련           pandas.DataFrame.drop_duplicates             중복된 값 drop           DataFrame groupby 관련           pandas.DataFrame.groupby             특정 컬럼으로 groupby 후 min(),max() 등의 함수 적용하여 새로운 DataFrame 생성                pandas.DataFrame.agg             특정 컬럼으로 groupby 후 커스텀 함수 적용하여 새로운 DataFrame 생성                groupby에는 추가 메소드가 존재함!   DataFrame 특정 함수 적용 관련           pandas.DataFrame.apply             axis 기준으로 row 또는 column의 value들이 인자 값으로 넘어가는데, 해당 인자 값을 커스텀 함수로 변경 후 return 가능.           DataFrame col &lt;-&gt; row 변형 관련           pandas.DataFrame.stack            pandas.DataFrame.T       ETC…           DataFrame의 간단한 조건 추출             A라는 Data Frame이 있다고 가정해보자       A[A[“pnu”]==”123”] -&gt; pnu가 123인 값들로 새로운 df를 생성한다.                DataFrame과 Series의 차이             Series는 contains나 .str을 적용할 수 없다.       DataFrame은 df.str.contains(“x”) 사용 가능하지만, Series는 pd.Series([1,2]) in [1] 로 사용해야한다.                DataFrame.str             python string 관련 메소드를 df에 적용하고 싶을 때 사용, df에 적용하면 vector값으로 계산이 가능하다.           사용하기 어려운 문법  사용하기 어려운 문법은, 다음에 더 자세히 정리해서 포스팅하겠다. 우선 갑자기 어떤 문법을 사용해야하는데 생각이 안난다! 싶으면 해당 문법이 어떤 카테고리인지 생각해보고 Cheat Sheet에 와서 ctrl+F를 해보자! Cheat Sheet에 각각의 문법에 해시태그를 추가해서 키워드로 검색이 가능해서 구글링의 편의성을 늘려보자!   pandas doumentation API reference &lt;- 여기에 다~~ 있다!   이제부터 공식문서를 보는 힘을 기르자! 아자아자 화이팅!  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.1 작업을 단계로 구성하기      인스트럭션을 처리하는 데는 다수의 연산이 관련되어 있다.   이들은 특정한 단계들Stages로 구성해서 비록 인스트럭션들의 동작은 다를지라도 모든 인스트럭션들이 일정한 순서를 따르도록 한다.   각 단계에서의 세부 처리내용은 실행하는 인스트럭션에 따라 달라진다.            선입 fetch                    프로그램 카운터 PC를 메모리주소로 사용해서 메모리로부터 인스트럭션 바이트들을 읽어들인다.           icode(인스트럭션 코드)와 ifun(instruction function)을 추출한다.           한 개의 레지스터 지시자 바이트를 선입해서 한 개 또는 두 개의 레지스터 오퍼랜드 지시자 rA와 rB를 얻어내는 경우도 있다. 또한 8바이트 상수 워드 valC를 선입할 수도 있다.           이것은 지금 실행 중인 인스트럭션의 순차적인 다음 인시트럭션의 주소가 되는 valP를 계산한다.                       해독 decode                    레지스터 파일에서 최대 두 개의 오퍼랜드를 읽어서 valA, valB를 얻어온다.           일부 인스트럭션에 대해서는 레지스터 %rsp를 읽어온다.                       실행 excution                    산술/논리 연산 유닛(ALU)이 인스트럭션이 지시하는 연산을 수행하거나(ifun 값에 따라), 메모리 참조 시 유효주소를 계산하거나, 스택 포인터 값을 변경한다. 이 결과를 valE라고 부른다.           조건 코드들은 이 경우에 설정될 수 있다. 조건부 이동 인스트럭션에 대해서 조건코드와 분기 조건(ifun에서 주어진)을 평가하고 조건이 참이 되는 경우에만 목적지 레지스터를 갱신한다. 점프 인스트럭션도 마찬가지이다.                       메모리                    데이터를 메모리에 쓰거나 메모리에서 데이터를 읽어올 수 있다. 이 값을 valM이라고 한다.                       재기록 write back                    두 결과를 레지스터 파일에 기록한다.                       PC 갱신                    PC는 다음 인스트럭션의 주소로 설정된다.                           프로세서는 위의 사항들을 무한히 반복하면서 이 단계들을 실행한다.   한 개의 인스트럭션을 실행하는 데는 놀라운 양의 작업을 요구한다.            각 인스트럭션에 대해 기술한 연산을 싫애해야하고       주소를 계산하고       스택 포인터를 갱신하고       다음 인스트럭션을 결정해야 한다.           Y86-64 인스트럭션 처리과정        위의 그림은 Y86-64 인스트럭션 예제이다. 해당 코드를 사용해서 여러가지 Y86-64 인스트럭션들의 처리과정을 그림으로 나타낸다.           OPq 인스트럭션 타입(정수와 논리연산), rrmovq(레지스터-레지스터 이동), irmovq(상수-레지스터 이동)에 대해 요구되는 작업을 보여준다.   선입 단계에서 상수 워드는 필요하지 않기 때문에 valP는 PC+2로 계산된다.   해석 단계에서 두 개의 오퍼랜드를 읽어들인다.   실행단계에서 함수 지시자 ifun과 함께 ALU에 제공된다.   valE는 인스트럭션 결과가 된다.   rrmovq인스트럭션을 실행하면 산술연산과 매우 비슷하게 진행한다.   irmovq의 경우에도 첫 번째 ALU 입력 대신에 상수 값 valC를 사용한다는 점을 제외하고는 유사한 처리가 발생한다.            프로그램 카운터를 10 증가시켜야 하는데, 그 이유는 irmovq가 긴 인스트럭션 형식을 가지기 때문이다.                   메모리 쓰기와 읽기 인스트럭션인 rmmovq와 mrmovq를 위해 필요한 처리작업을 보여준다.   valC를 valB에 더하기 위해 ALU를 사용해서 메모리 연산을 위한 유효주소를 만들어 낸다.           pushq와 popq 인스트럭션을 처리하기 위해 요구되는 단계들을 보여준다.   메모리에 접근 하면서 동시에 스택 포인터를 변경한다.   pushq 인스트럭션은 해석단계에서 %rsp를 두 번째 레지스터 오퍼랜드의 식별자로 사용해서 스택 포인터를 valB로 만든다.           세 개의 제어 전환 인스트럭션에서의 처리과정을 나타낸다: jump, call, ret   정수연산에서처럼 분기를 할지 말지 결정할 때에만 이들이 다르기 때문에 모든 점프를 통합된 방법으로 처리할 수 있다.   점프 인스트럭션은 선입에서 해독까지는 레지스터 명시자를 필요로 하지 않는다.   실행단계에서 조건코드와 점프 조건을 체크해서 분기를 할지 말지 결정하고, 1비트 신호 Cnd를 만든다.   PC갱신단계 동안에 이 플래그를 시험하고, 만일 플래그가 1이면 PC를 valC(점프 목적지)로 설정하고, 만일 0이면 valP(다음 인스트럭션의 주소)로 설정한다.   인스트럭션 call과 ret은 프로그램 카운터 값을 push, pop한다는점 외에는 pushq, popq와 약간의 유사성을 갖는다.   call할 때는 call 인스트럭션의 다음 인스트럭션의 주소인 valP를 push한다.   PC 갱신 단계 동안에 PC를 call 목적지인 valC로 설정한다.   ret 인스트럭션에서 스택에서 pop한 값인 valM을 PC 갱신 단계에서 PC에 저장한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_14/",
        "teaser": null
      },{
        "title": "[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리",
        "excerpt":"Data Development      Crawler   ETL   Docker   k8s   airflow      Data Platform     Data Orchestration   Data Storage            Data Lake       Data Warehouse           Data Catalog   Data Monitoring            Data Validation       Data Notification              Data Governance         하둡 스파크 카프카 스칼라…? 알아야할게 산더미군..!!!  ","categories": ["DataEngineering"],
        "tags": ["DataEngineering"],
        "url": "/dataengineering/de_01/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%   Related Work     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.   Model     ELMo            ELMo word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM            Task-specific ELMo Embedding            Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.              Evaluation        6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.   Analysis        일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.           GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.           biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다           ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.   Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_05/",
        "teaser": null
      },{
        "title": "[NLP/CS224n]CS224n Lecture 17: Multitask Learning",
        "excerpt":"   lecture 5, 7, 13 ,17 을 리뷰 했는데,,, 17강 밖에 안남아있다…T.T    The Limits of Single-task Learning     Great performance improvements in recent years given            dataset       task       model       metric           Models typically start from ranbdom or are only partly pre-trained   Pre-training and sharing knowledge is great!     Computer Vision            ImageNet + CNN이 큰 성공을 거두었음       Classification task가 과거에 큰 장벽이었음       이 문제가 해결되고 많은 문제들을 푸는 것이 가능해짐           Natural Language Processing            Word2Vec, Glove       최근 CoVe, ELMo, BERT 성공을 거두기 시작함           Why has weight&amp;model sharing not happened as much in NLP?     NLP는 많은 종류의 추론이 요구됨            logical, linguistic, emotional, visual           Short and long term memory가 요구됨   NLP는 중간 단계 또는 분리된 Task로 많이 나누어져 있음   하나의 Unsupervised Task가 전체 문제를 해결할 수 없음   언어는 현실적으로 분명한 Supervision이 필요함   Why a unified multi-task model for NLP     Multi-task learning은 General NLP system이 넘어야할 장벽임   하나의 통합된 모델은 지식을 어떻게 전달할지 결정 가능            Domain adaptation, weight sharing, transfer and zero shot learning           하나의 통합된 Multi-task 모델은            새로운 task가 주어졌을 때 쉽게 적응할 수 있음       실제 production을 위해 deploy하는 것이 매우 간단해짐       더 많은 사람들이 새로운 task를 해결할 수 있도록 도와줌       잠재적으로 Continual learning으로 나아갈 수 있음       모든 프로젝트를 계속 다시 시작하게 된다면 자연 언어의 복잡성을 점점 더 많이 포함하는 하나의 모델에 도달하지 못함           인공지능이 대화를 가능하게 하는 task를 진행할 때 사람의 언어처럼 순차적으로 처리하는 것 만큼 비효율적인 것은 없음. 컴퓨터가 인간의 언어를 supervision하지 않다면 훨씬 더많은 언어로 의사소통 가능.   How to express many NLP tasks in the same framework?     Sequence tagging            Named Entity Recognition, aspect specific sentiment           Text classification            Dialogue state tracking, sentiment classification           Seq2seq            Machine Translation, Summarization, Question Answering           Three equivalent Supertasks of NLP     Language Modeling            다음 단어를 예측하는 것은 질문의 일종이다.           Question Answering            말 그대로 Question &amp; Answering 이다.           Dialogue System            질문 답변, 답변에 대한 답변 형태이다.              The Natural Language Decathlon(decaNLP)     The Natural Language Decathlon : Multitask Learning as Question Answering            10개의 NLP Task를 하나의 Question Answering모델 학습만으로 풀 수 있도록 디자인       이를 위해 모든 데이터 셋에 대하여 question, context, answer 형태로 전처리              Multitask Question Answering Network(MQAN)            Fixed Glove+Character n-gram embeddings -&gt; Linear -&gt; Shared BiLSTM with skip connection   Attention summations from one sequence to the other and back again with skip connections   Separate BiLSTMs to reduce dimensionality, two transformer layers, another BiLSTM   Auto-regressive decoder :            Fixed GloVe, character n-gram embeddings       Two transformer layers       LSTM Layers (attend last 3 layers of encoder)                             Training Strategies: Fully Joint        Curriculum learning : 모델 학습시 전체 데이터를 한번에 학습시키지 않고 쉬운것-&gt;어려운 것 순서로 학습함   Batch를 Sampling할 때, Fixed order로 계속 Round Robin하여 수집함   많은 양이 돌아 Converge되는 Task들은 잘 동작하지 않음   Training Strategies: Anti-Curriculum Pre-training         Training Strategies: CoVe      What’s next for NLP?     ","categories": ["NLP"],
        "tags": ["cs224n","nlp"],
        "url": "/nlp/NLP_06/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.2 SEQ 하드웨어 구조     인스트럭션을 구현하는 데 필요한 계산들은 여섯 개의 순차적인 기본 단계로 구성될 수 있다.            선입       해독       실행       메모리       재기록       PC 갱신           SEQ에서는 하드웨어 유닛에 처리되는 모든 일들은 하나의 클럭 사이클 내에서 일어난다.             위 그림은 순차적인 구현인 SEQ의 추상적인 모습이다.            인스트럭션을 실행하는 동안 처리된 정보는 그림의 좌측 하단 구석에 있는 PC를 사용해서 인스트럭션 선입으로 시작해서 시계방향을 따라 진행한다.           하드웨어 유닛들은 여러가지 처리 단계들과 연계되어있다.            선입                    프로그램 카운터 레지스터를 주소로 사용해서 인스트럭션 메모리는 인스트럭션의 바이트들을 읽어들인다.           PC 가산기는 valP, 증가된 프로그램 카운터를 계산한다.                       해독                    레지스터 파일은 두 개의 읽기 포트 A,B를 가지고 있다.           이를 통해서 레지스터 값 valA, valB를 동시에 읽어들일 수 있다.                       실행                    인스트럭션의 종류에 따라 여러 가지 목적을 위해 산술/유닛 유닛(ALU)을 사용한다.           조건코드 레지스터(CC)는 세 개의 조건코드 비트를 저장한다. 목적지 레지스터를 갱신할지 여부를 결정하는 조건코드와 이동 조건에 의해 계산된다.                       메모리                    메모리 인스트럭션을 실행할 때 메모리 워드를 읽거나 쓴다.           인스트럭션과 데이터 메모리는 같은 메모리 위치에 접근하지만, 목적은 서로 다르다.                       재기록                    레지스터 파일은 두 개의 쓰기 포트를 가지고 있다.           E 포트는 ALU가 계산한 값을 기록하기 위해 사용된다.           M 포트는 데이터 메모리에서 읽어온 값을 기록할 때 사용한다.                       PC 갱신                    프로그램 카운터의 새로운 값은 다음 인스트럭션의 주소 valP, call이나 점프 인스트럭션에 의해 지정된 목적지 주소, 또는 메모리에서 읽어온 리턴주소 valM 중에서 선택된다.                                위 그림은 SEQ, 순차적 구현의 하드웨어 구조이다.           위 표는 순차적 구현에서 여러가지 계산 단계 식별 표이다.            두번째 열은 SEQ의 단계에서 계산되는 값 또는 수행되는 연산을 나타낸다.           4.3.3 SEQ 타이밍      SEQ는 조합논리회로와 두 가지 형태의 메모리 장치로 이루어진다.            레지스터(프로그램 카운터와 조건코드 레지스터)       랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)           조합논리회로는 순차처리나 제어를 필요로 하지 않는다.            입력이 바뀔 때마다 논리 게이트의 네트워크를 통해 값들이 전파된다.           랜덤 액세스 메모리를 읽는 것은 출력 워드가 주소 입력에 따라 생성되는 방식으로 조합논리회로와 매우 유사하게 동작한다.   순차실행을 위해 명시적인 제어를 필요로 하는 네 개의 하드웨어 유닛            프로그램 카운터, 조건코드 레지스터, 데이터 메모리, 레지스터 파일       이들은 새로운 값을 레지스터에 로딩하는 것과 값들을 랜덤 액세스 메모리에 기록하는 작업을 만드는 한 개의 클럭 신호를 통해서 제어된다.       프로그램 카운터 : 매 클럭 사이클마다 새로운 인스트럭션 주소를 적재한다.       조건코드 레지스터 : 정수연산 인스트럭션이 실행될 때에만 값이 적재된다.       데이터 메모리 : rmmovq, pushq, call 인스트럭션이 실행될 때에만 값이 기록된다.       레지스터 파일 : 두 개의 쓰기 포트를 통해서 두 개의 프로그램 레지스터가 매 사이클마다 갱신될 수 있다.           위와 같이 레지스터들과 메모리에 클럭을 공급하는 것은 프로세서에서 여러 동작들을 순서대로 제어하기 위해 필요한 모든 거싱다.   프로세서는 인스트럭션의 처리를 완료하기 위해 어떤 인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 절대 없다.           위 그림은 SEQ의 두 실행 사이클 추적이다.            각 사이클은 이전 인스트럭션에 의해 설정된 상태 원소들(프로그램 카운터, 조건코드 레지스터, 레지스터 파일, 데이터 메모리)을 가지고 시작된다.       신호들은 이 상태 원소들을 위한 새로운 값을 만들면서 조합회로를 지나면서 전파된다.       이 값들은 다음 사이클을 시작하기 위해 상태 원소들에 적재된다.           상태 원소들의 갱신을 제어하기 위해서 조합회로를 통한 값들의 전파와 함께 클럭을 사용하면 SEQ에서 각 인스트럭션을 위해 수행한 계산들을 충분히 제어할 수 있다.   클럭이 low에서 high로 전환이 이루어지는 매 시점마다 프로세서는 새 인스트럭션의 실행을 시작한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_15/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.4 SEQ 단계의 구현      SEQ를 구현하는 데 필요한 제어로직 블록을 위한 HCL작성방법을 설명한다.   여러가지 인스트럭션 코드, 함수코드, 레지스트 이름, ALU 연산, 상태코드 등을 위한 상수 값뿐만 아니라 여러가지 하드웨어 신호의 이름이 포함된다.             위의 표는 HCL 문장에 사용된 상수 값들이다.   선입 단계        선입 단계는 인스트럭션 메모리 하드웨어 유닛을 포함한다.   유닛은 PC를 첫 바이트(0번 바이트)의 주소로 사용해서 메모리로부터 한 번에 10바이트를 읽어들인다.   이 바이트는 인스트럭션 바이트로 해석되고, 두 개의 4비트 값으로 나누어진다.(“Split”이라고 표시된 유닛에 의해 icode와 ifun으로 나뉜다.)   icode 값에 따라 세 개의 1비트 신호를 계산할 수 있다.            instr_valid: 이 신호는 부정 인스트럭션을 검출하기 위해 사용된다.       need_regids: 레지스터 지정 바이트를 포함하는가       need_valC: 상수 워드를 포함하는가           instr_valid, imem_error 신호(인스트럭션 주소가 범위를 벗어날 때 만들어지는)는 메모리 단계에서 상태코드를 만들기 위해 사용된다.   need_regids를 위한 HCL 표현은 icode 값이 레지스터 지정자 바이트를 갖는 인스트럭션인지를 결정한다.     bool need_regids =           icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,                      IIRMOVQ, IRMMOVQ, IMRMOVQ };     인스트럭션 메모리에서 읽은 나머지 바이트는 레지스터 지정자와 상수 워드들이다.            Align 이라고 이름 붙인 하드웨어 유닛이 레지스터 필드들과 상수 워드에 대해 처리작업을 수행한다.       계산된 need_regids가 1이면, 레지스터 지정자 rA와 rB로 나누어진다.       상수 워드 valC도 만든다.           PC 증가 하드웨어 유닛은 현재의 PC 값, need_regids, need_ValC에 따라 valP를 만든다. (p+1+r+8i)   해동과 재기록 단계        SEQ에서 해독과 재기록 단계 모두를 구현하는 로직의 상세한 모습을 보여준다.            해동과 재기록 단계 모두 레지스터 파일에 접근하기 때문이다.           레지스터 파일은 네 개의 포트를 가지고 있다.            두 개의 동시 읽기(포트 A와 B), 두 개의 동시 쓰기(포트 E와 M)           각 포트는 한 개의 주소 연결과 데이터 연결을 모두 갖는다.            주소 연결은 레지스터 ID, 데이터 연결은 레지스터 파일의 출력 워드 이거나 입력워드로 사용           두 개의 읽기 포트는 주소 입력 srcA와 srcB를 가진다.   두 개의 쓰기 포트는 dstE와 dstM을 주소 입력으로 갖느다.   네 개의 블록은 인스트럭션 코드 icode, 레지스터 지정자 rA, rB, 실행 단계에서 계산된 조건신호 Cnd에 기초하여 네 개의 레지스터 ID를 만들어 낸다.   레지스터 ID dstE는 쓰기 포트 E를 위한 목적지 레지스터를 나타내며 계싼된 valE가 저장된다.   실행 단계       실행 단계는 산술/논리 유닛(ALU)을 포함한다.   이 유닛은 ADD, SUBTRACT, AND, EXCLUSIVE-OR를 입력 aluA, aluB에 alufun 신호의 설정에 따라 실행한다.   ALU가 대부분의 경우에 덧셈기로 사용된다.            OPq 인스트럭션에 대해서는 인스트럭션의 ifun 필드에 인코딩된 연산을 사용해야 한다.           실행 단계는 조건코드 레지스터를 포함한다.            조건코드 레지스터가 갱신되어야 할지 여부는 제어하는 set_cc 신호를 생성한다.           “cond”로 명명된 하드웨어 유닛은 조건부 분기나 데이터 이동이 일어나야 할지를 결정하기 위한 조건코드들과 함수코드의 조합을 사용한다.   메모리 단계       메모리 단계는 프로그램 데이터를 읽거나 쓰는 일을 수행한다.   두 개의 제어 블록이 메모리주소와 메모리 입력 데이터(쓰기 연산을 위한)를 위한 값을 만들어낸다.   메모리 단계에서 마지막 기능은 icode, imem_error, 선입 단계에서 만들어진 instr_valid, 데이터 메모리에서 만든 dmem_error 신호에 따라 인스트럭션 실행에서 결정되는 상태코드 Stat을 계산하는 것이다.   PC 갱신 단계       SEQ의 최종 단계는 새로운 프로그램 카운터 값을 생성하는 것이다.   새로운 PC 값은 인스트럭션 타입과 분기를 택할지 여부에 따라 valC, valM, valP가 될 수 있다.   SEQ 현황 조사     여러 인스트럭션을 통일된 흐름으로 실행하기 위해 필요한 단계를 구성하면서 프로세서 전체를 적은 수의 여러 하드웨어 유닛들과 계산을 순서화하기 위한 한 개이의 클럭으로 구현할 수 있다.   SEQ에서 유일한 문제는 매우 느리다.            그 이유는 각 유닛들이 전체 클럭 사이클의 일부 동안만 사용되기 때문이다.       그렇기 때문에 파이프라인을 사용해서 보다 좋은 성능을 얻을 수 있다.              프로세서의 구조를 자세히 살펴보았는데, 굉장히 이해하기 어려운 부분이 많았다. 이번 챕터는 자주 보고 다른 자료도 더 찾아봐야겠다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_16/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.4 파이프라이닝의 일반 원리     파이프라인 시스템의 일반적인 특징과 원리들을 생각해보자.            파이프라인 시스템에서 수행해야 할 일은 여러 개의 일련의 단계뜰로 나누어진다.       식당의 예를들면, 샐러드를 먼저 제공하고, 메인 음식, 디저트 그리고 음료의 순으로 제공하는 것과 비슷하다.       컨베이어 벨트와 비슷하게 여러 고객이 동시에 시스템을 진행하도록 한다.       비록 어떤 사람은 일부 음식만을 원할지라도 모든 단계를 통과해 간다.           파이프라이닝의 주요 특징            시스템 처리량(단위시간당 처리하는 고객의 수)을 증가시킨다.       지연시간(고객을 지원하는 데 걸리는 시간)을 증가시킨다.           4.4.1 계산용 파이프라인     위의 식당의 예를 계산용 파이프라인으로 초점을 옮기면            “고객들”은 인스트럭션       단계들은 인스트럭션 실행의 일부분을 수행한다.                   위의 그림은 간단한 비파이프라인 하드웨어 시스템의 예이다.            계산을 수행하는 일부 로직으로 이루어진다.       계산 결과를 저장하는 레지스터가 따라온다.       클럭 신호는 규칙적인 시간간격으로 레지스터에 로딩되는 것을 제어한다.           이 예제에서는 조합로직은 300ps를 필요로하고 레지스터 로딩은 20ps를 필요로 한다.            이 시스템에서 처리량은 1/320 * 1,000 = 3.12       이 시스템에서 지연시간은 320ps                   위 그림은 3단계 파이프라인 계산 하드웨어이다.            시스템에서 수행하는 계산을 세 단계 A,B,C로 나눌 수 있다고 가정한다.       파이프라인 레지스터들을 단계 사이에 배치해서 각 인스트럭션이 3단계로 시스템을 통해 이동한다.       시작부토 종료할 때까지 세 개의 클럭 사이클이 소요된다.           이 예제에서는 클럭을 매 100+20=120ps이고 한 개의 인스트럭션을 처리하는 데 3클럭 사이클이 필요하다.            이 시스템에서 처리량은 1/120 * 1,000 = 8.33       이 시스템에서 지연시간은 360ps           비파이프라인 보다 처리량은 빠르지만 지연시간이 증가한 이유는 추가된 파이프라인 레지스터에 의한 오버헤드 때문이다.   4.4.2 파이프라인 연산의 상세한 고찰     파이프라인 단계들 간에 인스트럭션의 이동은 위의 파이프라인 다이어그램에 나타낸 것과 같이 클럭 신호에 의해 제어된다.           위 그림은 한 사이클 동안의 파이프라인 동작이다.            신호들은 파이프라인 레지스터 입력들로 전달되지만, 클럭이 상승할 때까지 레지스터의 상태는 바뀌지 않는다.       클럭을 늦추는 것이 파이프라인의 동작을 변화시키지 않는다는 것을 알 수 있다.           4.4.3 파이프라이닝의 한계     파이프라인의 효과를 축소시키는 여러 요소들이 종종 발생한다.   비균일 분리 Nonuniform Partitioning       위의 그림은 계산을 이전처럼 세 단계로 나눈 시스템이지만 각 단계에서 발생하는 지연시간은 50에서 150 ps까지 변화한다.   우리가 구동할 수 있는 클럭의 속도는 가장 늦은 단계의 시간지연 값에 의해 결정된다.   실제 시스템 설계에서는 타이밍을 최적화하는 것이 중요하다.   줄어드는 깊은 파이프라이닝의 효과       위의 그림은 계산을 여섯 단계로 나누었고, 각각은 50ps를 소모한다.   이 시스템의 클럭 주기는 50+20=70ps, 처리량은 14.29, 지연시간은 480이다.   각 계산 블록에서 소요되는 시간을 2분의 1로 줄였지만 파이프라인 레지스터를 통과하는 시간지연으로 인해 처리량은 두 배를 얻지 못했다.   이 지연시간은 파이프라인의 처리량에 있어서 제한요소가 된다.   최신 프로세서들은 프로세서의 클럭속도를 최대로 올리기 위해 매우 깊은(15단계 이상) 파이프라인을 사용한다.   4.4.4 피드백을 갖는 파이프라인 시스템     기계어 프로그램을 실행하는 시스템에서는 연속적인 인스트럭션들 간에는 잠재적인 의존성이 있다.        예를들어 위의 코드 배열은 각각의 연속되는 인스트럭션들 간에 원으로 표시한 레지스터 이름에 데이터 의존성이 존재한다.           위의 그림은 피드백을 갖는 시스템에 파이프라인을 추가할 때의 위험을 보여준다.            피드백이 있는 파이프라인을 사용하지 않는 시스템(a)에서 파이프라인 시스템(c)으로 전환하기 위해서 두 파이프라인 다이어그램에서 보는 바와 같이 계산적인 동작을 변경한다(b와d)           ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_17/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.4 파이프라이닝의 일반 원리   4.5 파이프라인형 Y86-64의 구현   4.5 파이프라인형 Y86-64의 구현     순차적 프로세서 SEQ를 약간 변형해서 PC의 계산을 선입 단계로 이동하는 것으로 프로세서를 변경한다.   이후 파이프라인 레지스터들을 단계별로 추가한다.      결국은 이 파이프라인형 Y86-64 “PIPE”를 만들기 위해 2장부터 4장까지 달려온 것이다.  우선 컴퓨터가 해석할 수 있는 정수와 부동소수점 표현과 기본 산술에 대해서 2장에서 배웠고,  3장에서는 프로그래머가 작성한 코드를 컴퓨터가가 해석할 수 있는 기계어로 변경하는 것을 배웠고,  4장 초반에서는 해당 기계어를 컴퓨터가 해석할 수 있도록 인스트럭션 집합으로 변경하는 것을 배웠고,  4장 후반 SEQ 구현에서는 해당 인스트럭션을 컴퓨터가 어떻게 해석하는지를 배웠고,  4장 후반 파이프라인 구현에서는 인스트럭션을 해석하는데에 있어 속도를 증가시키기 위해서 SEQ에 파이프라인을 구축하고, 파이프라인 구축할 때의 예외처리를 다룬 뒤 프로세서를 완성시킨다.    4.5.1 SEQ+: 계산 단계들을 재배치하기     PC 갱신 단계가 클럭 사이클의 마지막이 아니라 맨 처음에 오도록 한다.            파이프라인 단계에서의 순차적인 동작을 더 잘 수행할 수 있다.       수정된 설계를 “SEQ+”라고 부른다.                   위의 그림은 PC 계산 타이밍의 변경이다.            SEQ+에서 인스트럭션 실행의 첫 단계로 현재 상태에 대한 프로그램 카운터 값을 계산한다.           4.5.2 파이프라인 레지스터의 삽입     SEQ+의 단계들간에 파이프라인 레지스터들을 삽입하였으며 신호들을 재배치해서 PIPE- 프로세서를 만들었다.   파이프라인 레지스터들은 다음과 같이 명명하였다            F : 프로그램 카운터의 예측 값을 저장한다.       D : 선입과 해동 단계 사이에 위치한다. 해독 단계가 처리하기 위해서 가장 최근에 선입한 인스트럭션에 관한 정보를 저장한다.       E : 해독과 실행 단계 사이에 위치한다. 실행 단계가 처리하기 위해서 레지스터 파일로부터 읽어들인 값과 가장 최근에 해독한 인스트럭션에 관한 정보를 저장한다.       M : 실행과 메모리 단계 사이에 위치한다. 메모리 단계가 처리하기 위한 가장 최근에 실행 인스트럭션 결과와 조건부에 관한 정보를 저장한다.       W : 레지스터 파일에 기록을 위한 결과, 리턴주소, PC 선택 로직을 저장한다.                   위의 그림은 SEQ+ 하드웨어 구조           위의 그림은 PIPE- 의 하드웨어 구조, 초기 파이프라인 구현           위의 그림은 코드 배열이 어떻게 5단계 파이프라인을 통해 흘러가는지를 보여준다.   4.5.3 신호의 재배치와 재명명     SEQ에서는 한 번에 한 개의 인스트럭션만을 처리했지만, 파이프라인 설계에서는 인스트럭션에 연계된 여러 버전의 값이 존재한다.   PIPE-의 상세 설계에서 네 개의 서로 다른 인스트럭션을 위한 상태코드를 저장하는 “Stat”이 있다.   파이프라인 레지스터의 이름은 대문자를 사용한다. D_stat, E_stat, M_stat, W_stat   계산된 일부 신호의 이름은 소문자를 사용한다 f_stat, m_stat   전체 프로세서의 실제 상태 Stat이 파이프라인 레지스터 W에 기록된 상태값에 따라 재기록 단계에서 계산된다.   일반적인 원칙으로 특정 인스트럭션에 관한 모든 정보를 한 개의 파이프라인 단계 내에 유지하는 것을 원한다.   4.5.4 다음 PC 값의 추정     파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이며, 새 인스트럭션이 실행 단계로 진행해서 궁극적으로는 완료되는 것을 의미한다.   리턴이나 조건부 점프 인스트럭션은 선입 단계에 계산된 정보를 사용해서 다음 인스트럭션의 주소를 결정할 수 없다.   따라서 매 클럭 사이클마다 하나의 새 인스트럭션을 실행하려는 우리의 목표를 달성하기 위해서 대부분의 경우에 PC의 새로운 값을 예측해야 한다.            이부분이 처음에 조금 이해가 안됐지만, 파이프라인 해저드를 공부하고 이해가 됐다. 해저드를 통해 이러한 분기예측을 제어한다.            분기의 방향을 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술을 분기예측branch prediction 이라고 한다.   4.5.5 파이프라인 해저드     피드백이 있는 시스템에 파이프라인을 도입하면 연속되는 인스트럭션들 간에 의존성이 존재할 때 문제가 발생할 수 있다.   의존성은 두 가지 형태를 띈다.            데이터 의존성: 한개의 인스트럭션이 계산한 결과가 다음에 오는 인스트럭션을 위한 데이터로 사용되는 경우       제어 의존성: jump, call, ret와 같이 한 개의 인스트럭션이 다음에 따라오는 인스트럭션의 위치를 결정하는 경우           의존성들이 파이프라인으로 인해 잘못된 계산을 야기할 가능서이 있을 때 해저드라고 부른다.   해저드 또한 데이터 해저드, 제어 해저드로 구분할 수 있다.       특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러X)     특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러O)     스톨을 사용한 데이터 해저드의 회피             해저드를 회피하는 매우 일반적인 기술은 프로세서가 하나 또는 여러 인스트럭션을 해저드 조건이 사라질 때까지 파이프라인 내에 유지하는 스톨과 관련된다.   해독 단계에서 인스트럭션을 소스 오퍼랜드를 생성하는 인스트럭션들이 재기록 단계를 통과할 때까지 스톨시키는 방법으로 데이터 해저드를 회피할 수 있다.   스톨링은 한 그룹의 인스트럭션들을 이들의 단계에 붙잡아두지만, 다른 인스트럭션들은 파이프라인을 계속 흘러가도록 한다.   인스트럭션을 해독단계에 붙잡아 놓을 때마다 실행 단계에 버블을 삽입하는 방식으로 처리한다.   버블은 동적으로 생성된 nop 인스트럭션과 비슷하다.   포워딩Forwarding을 이용한 데이터 해저드의 회피             재기록 단계에서 이들 소스 레지스터 중의 하나에 대기하고 있는 쓰기 작업이 존재할 수 있다.   쓰기 작업이 완료될 때까지 스톨하기보다는 소스 오퍼랜드로 파이프라인 레지스터 E에 기록될 값을 단순히 전달할 수 있다.   데이터 포워딩은 메모리 단계에서 대기하고 있는 레지스터 쓰기 작업이 있을 때에도 사용될 수 있다.   위 그림은 해독 단계 로직이 레지스터 파일에서 온 값을 사용할지, 포워딩된 값을 사용할지 여부를 어떻게 결정할 수 있는지 보여준다.            레지스터 파일에 재기록되는 모든 값과 관련된 것은 목적지 레지스터 ID이다.       이 로직은 이 ID들을 소스 레지스터 ID인 srcA, srcB와 비교해서 포워딩을 위한 경우를 검출할 수 있다.           다섯개의 포워딩 소스가 해독 단계에 “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.   로드/사용 데이터 해저드          메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 데이터 해저드는 순수하게 포워딩만 가지고는 처리할 수 없다.   해당 경우는 스톨링과 포워딩을 함께 사용해서 로드/사용 데이터 해저드를 회피할 수 있다.   로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것을 로드 인터록load interlock이라고 부른다.   포워딩과 결합된 로드 인터록은 가능한 모든 형태의 데이터 해저드를 충분히 처리할 수 있다.   제어 해저드의 회피     제어 해저드는 프로세서가 선입 단계에서 현재 인스트럭션에 기초하여 다음 인스트럭션의 주소를 안정적으로 결정할 수 없을 때 발생한다.   제어 해저드는 ret와 점프 인스트럭션에 대해서만 발생할 수 있다.          위의 그림은 ret 인스트럭션 처리과정이다.            파이프라인은 ret가 해독, 실행, 메모리 단계를 통과하며 세개의 버블을 삽입하는 동안 스톨해야한다.       PC 선택 로직은 ret가 재기록 단계에 도착하면(사이클 7) 인스트럭션 선입 주소로 리턴주소를 선택하게 된다.                  위의 그림은 잘못 예측한 분기 인스트럭션의 처리이다.            파이프라인은 분기를 할 것이라고 예측하고, 따라서 점프 목적지에서 인스트럭션 선입을 시작한다.       점프 인스트럭션이 실행 단계를 통해 흘러갈 때 두 인스트럭션은 사이클 4에서 예측오류가 검출되기 전에 선입된다.       사이클 5에서 파이프라인은 해독과 실행단계에 버블을 삽입해서 두 목적지 인스트럭션을 취소하고, 점프 다음에 오는 인스트럭션을 선입한다.                 간단히 두 개의 잘못 선입한 인스트럭션을 취소할 수 있다.            인스트럭션 스쿼싱squashing이라고 불린다.           programmers-visible state에는 아무런 영향을 주지 않지만 단점은 두 클럭 사이클 만큼의 인스트럭션 처리 능력이 낭비된다는 점이다.   스톨링과 파이프라인에 버블을 삽입하는 기술들은 특수한 상황이 발생할 때 파이프라인의 흐름을 동적으로 조절한다.   4.5.6 예외처리     프로세서의 다양한 동작은 예외적인 제어흐름을 발생시키며, 이 경우 정상적인 프로그램 실행의 연결은 끊어진다.   예외들은 프로그램 실행에 의해 내부적으로 발생하거나 외부 신호에 의해 외부적으로 생성될 수 있다.   세 가지 서로 다른 내부 생성 예외            halt 인스트럭션에 의한 예외       인스트럭션과 함수코드의 잘못된 조합을 갖는 인스트럭션       인스트럭션 선입 또는 데이터 읽기나 쓰기를 위해 유효하지 않은 주소에 접근하려 하는 경우           프로세서가 예외를 만나면 정지하고 적절한 생태코드를 설정한다.   프로세서는 운영체제의 일부인 예외핸들러라는 프로시저를 계속 호출한다.   파이프라인과 예외처리     파이프라인을 사용한 시스템에서 예외처리는 여러 가지 미묘한 부분들이 관계되어 있다.      예외상황이 다수의 인스트럭션들에 의해 동시에 발생할 수 있다.            기본 규칙은 파이프라인에서 가장 멀리 있는 인스트럭션이 유발한 예외상황에 우선순위를 둔다.           어떤 인스트럭션이 선입되고, 실행을 시작해서 예외를 발생시키고, 나중에 잘못 예측한 분기명령으로 인해 취소할 때 발생한다.            파이프라인 제어로직은 인스트럭션을 취소한다.           파이프라인 프로세서가 서로 다른 단계에서 시스템 상태의 서로 다른 부분을 갱신하기 때문에 발생한다.         파이프라인 제어로직은 메모리나 재기록 단계의 인스트럭션이 예외를 발생시켰을 때 데이터 메모리나 조건코드 레지스터를 갱신하는 것을 김지한다.   파이프라인의 하나 이상의 단계에서 예외가 발생할 때 정보는 단순히 파이프라인 레지스터의 상태 필드에 저장된다.   4.5.7 PIPE 단계의 구현     파이프라인 레지스터, 재구성 가능한 로직 블록, 추가적인 파이프라인 제어로직을 추가하고, 이전의 순차적 설계 같은 하드웨어 유닛들을 사용한다.   PC 선택과 선입 단계        프로그램 카운터의 현재 값을 선택해야하며, 다음 PC 값을 예측해야 한다.   메모리에서 인스트럭션을 읽고 여러 가지 인스트럭션 필드들을 추출하기 위한 하드웨어 유닛들은 SEQ를 위해 고려한 것과 동일하다.   하나의 사이클 시간의 범위 내에 프로세서는 다음 인스트럭션의 주소를 예측만 할 수 있다.   해독 및 재기록 단계       valP와 레지스터 포트 A로부터 읽은 값을 동시에 요구하는 인스트럭션은 없으며 따라서 이들은 다음 단계를 위한 신호 valA를 구성하기 위해 통합할 수 있따.            “Sel+FwdA” 블록이 해당 일을 수행하고 valA를 위한 포워딩 로직을 구현한다.       “FwdB” 블록은 소스 오퍼랜드 valB를 위한 포워딩 로직을 구현한다.           레지스터 쓰기 위치는 해독 단계보다는 재기록 단계에서 가져온 dstE와 dstM으로 나타낸다.            해독 단계가 현재 재기록 단계에 있는 인스트럭션의 결과를 기록하고 있기 때문이다.                    위 HCL 코드에서 다섯 개의 포워딩 소스에 주어진 우선순위는 매우 종요하다.   우선순위는 HCL코드에서 다섯 개의 목적지 레지스터 ID가 시험되는 순서에 의해 결정된다.   실행 단계       PIPE 실행 단계 로직이다. 이 부분의 설계는 SEQ의 로직과 매우 유사하다.   메모리 단계       PIPE 메모리 단계 로직이다.            파이프라인 레지스터 M, W의 많은 신호들이 앞 단계들로 전달되어 재기록한 결과, 인스트럭션 주소, 포워드된 값들을 제공한다.           4.5.8 파이프라인 제어로직     데이터 포워딩과 분기예측과 같이 다른 방법들로는 처리할 수 없는 다음과 같은 네 개의 제어 경우를 처리해야 한다.            로드/사용 해저드 : 메모리에서 값을 읽은 인스트럭션과 이 값을 사용하는 인스트럭션 사이에 한 사이클 동안 스톨해야한다.       잘못 예측한 분기 : 예측으로 인해 잘못 선입된 인스트럭션들은 취소되어야 하며, 선입 단계는 점프 인스트럭션 다음의 인스트럭션에서 시작해야한다.       예외 : 어떤 인스트럭션이 예외를 발생시키면 programmer-visible state가 갱신되는 것을 막아야 한다.           특수한 제어 상황들의 바람직한 처리       위의 그림은 ret 인스트럭션의 상세한 처리과정이다.            선입 단계는 ret 인스트럭션 다음의 rrmovq 인스트럭션을 반복적으로 선입하지만, 파이프라인 제어회로는 rrmovq 인스트럭션이 진행하는 것을 허용하는 대신에 해독 단계에 한 개의 버블을 삽입한다.                  위의 그림은 유효하지 않은 메모리 참조 예외의 처리이다.            사이클 6에서 pushq 인스트럭션으로 인한 유효하지 않은 메모리 차몾는 조건코드 갱신을 금지시킨다.       파이프라인은 메모리 단계에 버블을 삽입하기 시작하고 재기록 단계에 있는 예외 인스트럭션을 스톨시킨다.           특수 제어 조건의 감지     ret 인스트럭션이 파이프라인을 통과해 갈 때 검출하려면 해독, 실행, 메모리 단계에 있는 인스트럭션들의 인스트럭션 코드를 단순히 체크하면 된다.   로드/사용 해저드를 검출하려면 실행 단계에 있는 인스트럭션의 종류(mrmovq, popq)를 체크해야 하고, 해독 단계에 있는 인스트럭션의 소스 레지스터들과 목적지 레지스터들을 비교해야 한다.   파이프라인 제어로직은 인스트럭션이 해독 단계에 있는 동안 잘못 예측한 분기를 검출해야 한다.   파이프라인 제어 과정        위의 그림은 파이프라인 레지스터 동작이다.            a. 정상 조건 시 레지스터의 상태와 출력은 클럭이 상승할 때 입력 값으로 설정된다.       b. 스톨 모드에서 동작할 때, 상태는 이전 값으로 고정된다.       c. 버블 모드에서 동작할 때 상태는 연산의 결과로 기록된다.           제어 조건들의 조합        위의 그림은 특수한 제어 조건들에 대한 파이프라인 상태이다.            표시한 두 쌍은 동시에 발생할 수 있다.           제어 로직의 구현        위의 그림은 PIPE 파이프라인 제어로직이다.            이 로직은 프로시저 리턴, 잘못 예측한 분기, 로드/사용 해저드, 프로그램 예외 같은 특수한 조건들을 처리하기 위해서 정상적인 인스트럭션 흐름이 파이프라인을 통과하는 것을 정지시킨다.           4.5.9 성능 분석     인스트럭션마다 걸리는 평균 클럭 사이클 수는 CPIcycles per instruction라는 단위로 추정값을 계산한다.            Ci 인스트르럭션, Cb 버블을 처리한다면, 프로세서는 Ci + Cb개의 클럭 사이클을 필요로한다.       CPI = 1.0 + Cb/Ci 이다.       오직 세개의 인스트럭션 타입만이 버블을 추가하기 때문에                    CPI = 1.0 lr(load penalty) + mp(mispredicted branch penalty) + rp(return penalty)                           4.5.10 남아 있는 작업     다중 사이클 인스트럭션            다중 인스트럭션을 구현하는 한 가지 간단한 방법은 실행 단계 로직의 성능을 정수와 부동 소수점 산술연산 유닛들을 포함하도록 단순히 확장하는 것이다.                    한 개의 인스트럭션이 해독 단계에 들어갈 때 특수 유닛으로 보낸다.(ex. 부동소수점 유닛)                           메모리 시스템과의 인터페이스   4.6 요약      해당 장을 통해 인스트럭션 집합 아키텍처 ISA는 프로세서의 동작과 프로세서가 어떻게 구현되는지 간에 추상화 계층을 제공한다는 것을 알 수 있었다.   ISA는 프로그램 실행을 하나의 인스트럭션이 다음 인스트럭션이 시작되기 전에 실행되어 종료되는 순차적인 프로그램 실행의 모습을 제공한다.   여러 가지 인스트럭션들이 요구하는 처리작업을 5단계로 구성하였으며, 전체 인스트럭션이 다섯 단계를 통해 들어가서 매 클럭 사이클마다 실행된다.   파이프라인은 여러 단계들이 동시에 동작하도록 하여 시스템의 처리량 성능을 개선한다.   예외를 적절히 처리하는 것은 높은 파이프라인 단계와 병렬성을 사용하는 시스템에서 보다 복잡해진다.   교훈            복잡성을 관리하는 것이 최우선순위를 갖는다.                    모든 인스트럭션 타입을 처리하기 위한 매우 간단하고 통일된 프레임워크를 만들어서 구현하였다.                       ISA를 직접 구현할 필요는 없다.                    파이프라인 설계를 사용하였고 파이프라인 해저드를 처리할 수 있었다.                       하드웨어 설계자는 꼼꼼해야 한다.              2장부터 4장이 하드웨어까지의 모든 부분들을 살펴본 것 같다. 4장은 꼭 한번 더 읽어보자.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_18/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 05 프로그램 성능 최적화하기",
        "excerpt":"Chapter 05. 프로그램 성능 최적화하기     프로그램을 작성하는 주목적은 모든 가능한 조건에서 프로그램이 정확하게 동작하도록 하는 것이다.   프로그래머는 명확하고 간결한 코드를 작성해야하고, 이해하기 쉽고, 코드를 검토할 때와 수정할 때 다른사람들도 코드를 읽고 이해할 수 있어야 한다.   효율적인 프로그램을 작성하는 방법            적절한 알고리즘과 자료구조를 선택해야한다.       컴파일러가 효과적으로 최적화해서 효율적인 실행코드로 바꿀 수 있는 소스코드를 작성해야 한다.       작업을 부분으로 나누어 멀티코어와 멀티프로세서의 조합을 갖는 컴퓨터에서 병렬로 계산한다.           프로그래머는 컴파일러를 도와서 쉽게 최적화될 수 있는 코드를 작성해야한다.            불필요한 작업 제거                    불필요한 함수호출 제거           조건 테스트 제거           메모리 참조 제거                       인스트럭션-수준 병렬성을 제공           5.1 최적화 컴파일러의 능력과 한계     컴파일러는 프로그래머의 코드를 자동으로 최적화 해준다.   하지만 특정 코드는 컴파일러가 자동으로 최적화해줄 수 없다.            두 개의 포인터가 같은 메모리 위치를 가리킬 수 있는 경우(메모리 연결memory aliasing)       함수 호출                    ex) 호출되는 횟수에 따라 프로그램의 동작이 변경 되는 경우(부가효과 side effect)                           위 항목들이 ‘최적화 장애물blocker’이 되는데, 이것은 컴파일러가 최적화된 코드를 생성하기 위한 기회를 제한한다.   5.2 프로그램 성능의 표현     CPE : 요소당 측정 사이클metric cycle      5.3 프로그램 예제     코드를 최적화하는 방법은 다음과 같은 방법들이 존재한다.            타깃 머신의 특징을 고려하지 않은 최적화 기법                    루프 비효율성 제거하기           프로시저 호출 줄이기           불필요한 메모리 참조 제거                       최신 프로세서의 인스트럭션 수준 병렬성을 고려한 최적화 기법                    루프풀기           병렬성 높이기           재결합 변환                              최신프로세서의 인스트럭션 수준 병렬성을 고려하기 위해 5.7절에서 최신프로세서에 대해서 조금 다루고 넘어간다.    5.4 루프 비효율성 제거하기     테스트 조건이 루프의 매 실행마다 평가된다.           lower1은 n^2        lower2는 n       겉보기에는 의미 없는 코드가 감춰진 잠재적 비효율성을 갖고 있다.   적은 데이터 셋으로 시험하고 분석되지만, 프로그램이 궁극적으로 배포되면, 프로시저가 백만 개 문자들의 스트리에 적용될 수 있다.            이러한 상황에 안전했던 코드조각이 주요 성능 병목이 되게된다.           경쟁력 있는 프로그래머 역할의 한 부분은 지속적으로 소개되는 그러한 잠재적 비효율성을 피하는것이다   5.5 프로시저 호출 줄이기     프로시저 호출은 오버헤드를 발생시키고 대부분의 프로그램 최적화 작업을 방해할 수 있다.   경계값을 체크하는 것은 배열의 임의로 접근하는 경우를 처리할 때에는 유용할 수 있지만, 특정 경우에는 모든 참조 시도가 유효하다.   예제에서 각 벡터의 원소를 가져오기 위해서 작성된 함수(벡터 경계값 체크 함수)를 매번 호출하는 대신 배열에 직접 접근한다.            결벽주의자들은 이렇게 변환하는 것이 프로그램 모듈성을 심각하게 훼손한다고 말할 수 있다.       실용적인 프로그래머라면 이러한 변환과정이 고성능 결과를 얻기 위해서 필요한 단계라고 주장할 것이다.           5.6 불필요한 메모리 참조의 제거           결과값을 임시로 누적한다.            누적값을 지역변수 acc에 저장하면 매 루프 반복실행마다 메모리에서 가져오고 갱신된 값을 다시 기록할 필요가 없어진다.           5.7 최신 프로세서 이해하기     코드의 성능을 더 개선하기 위해서는 프로세서의 마이크로구조, 즉 프로세서가 인스트럭션을 실행하도록 하는 하부 시스템 설계를 활용하는 최적화 기법을 고려해야한다.   실제 프로세서에서 많은 인스트럭션들이 동시에 처리된다.            이것을 인스트럭션 수준 병렬성이라고 부른다.       두 개의 서로 다른 하위 경계값lower bounds가 프로그램의 최대 성능을 결정한다.                    지연시간 경계값 : 일련의 연산들이 엄격하게 순서를 준수하여 수행되어야 할 때 발생           처리량 경계값: 프로세서의 기능 유닛들의 기본 계산 능력을 결정한다.                           5.7.1 전체적인 동작     최신 프로세서는 인스트럭션이 실행되는 순서가 기계어 수준 프로그램에서의 순서와 일치할 필요가 없다.            무순서 out-of-order라고 한다.                위의 그림은 최신 프로세서의 블록 다이어그램이다.            인스트럭션 제어 유닛(ICU)은 인스트럭션들을 메모리에서 읽고 일련의 기본연산들을 생성하는 역할을 수행한다.       그 이후 실행 유닛(EU)은 연산을 수행하여 분기가 정확히 예측되었는지 여부를 나타낸다.           최신 프로세서들은 ‘분기 예측branch prediction’이라는 기술을 사용한다.   ‘추정 실행speculative execution’이라는 기술을 사용해서 분기가 이동해야 하는 위치에 있는 인스트럭션을 선입하고 해독한다.   Fetch control 블록은 분기예측과 연동해서 어떤 인스트럭션을 선입할지를 결정한다.   추정 실행을 사용해서 연산들이 계산되지만, 확실할 때까지 최종 결과값들은 데이터 메모리나 레지스터에 저장되지 않는다.      결국 최신 프로세서들은 ‘무순서로 연산들을 병렬로 진행한다.’라고 말하는 것 같다. 하지만, 데이터 의존성이 있는 경우에는 병렬로 진행할 수 없기 때문에 지연이 발생하고, 이런 데이터 의존성은 컴파일러가 최적화를 할 수 없다.(다른 코드로 변경시 무조건적으로 무결성하다는 것을 입증할 수 없어서) 그렇기 때문에 우리는 데이터 의존성을 줄일 수 있는 코드를 작성하여 최적화를 한다.    5.7.2 함수유닛의 성능     발급시간 issue time: 두 연산 사이에 소요되는 최소 사이클 수   용량 capacity: 해당 연산을 수행할 수 있는 함수 유닛의 수   지연 latency: 실제 연산을 수행하는 데 걸린 클럭 사이클 수        위의 그림은 인텔 코어 i7의 지연시간과 발급시간 특성이다.   기계수준 코드로부터 데이터흐름 그래프로의 변환          combine4에 대한 내부 루프의 그림            인스트럭션들은 동적으로 하나 또는 두 개의 연산으로 번역된다.       각각은 다른 연산들 또는 레지스터들로부터 값들을 받고 다른 연산과 레지스터를 위한 값들을 생성한다.           루프를 구성하는 코드부분에 대해서 접근하게 되는 레지스터들을 다음의 네 종류로 구분할 수 있다.            읽기전용 Read-only : 데이터 또는 메모리 주소를 계산하기 위한 소스 값들로 사용된다.       쓰기전용 Write-only : 데이터 이동 연산의 목적지로 사용된다.       지역적 Local : 루프 내에서 사용되고 갱신되지만, 한 번의 반복 실행에서 다른 실행으로의 의존성은 없다.                    ex) cmp에 의해 갱신되며 jne 연산에 의해 사용된다.                       루프 Loop : 한 번의 반복실행에서 생성된 값은 다른 실행에서 사용되는 방식으로 소스 값들로 사용되며 루프의 목적지로도 사용된다.           루프 레지스터들 간의 연산들의 연결이 성능을 제한하는 데이터 의존성을 결정한다.        위의 그림은 combine4 연산들을 데이터 흐름 그래프로 추상화하였다.            (b)를 보면 데이터의존성을 확인할 수 있다.           5.8 루프풀기     루프 풀기는 루프의 매 반복실행마다 계산되는 원소의 수를 증가시켜 루프에서의 반복 실행 횟수를 줄이는 방법이다.   루프 풀기는 두가지 측면에서 성능을 개선할 수 있다.            루프 인덱스 계산과 조건부 분기와 같이 프로그램의 결과와는 직접적으로 관련 없는 연산들의 수를 줄인다.       전체 계산의 핵심 경로에 있는 연산의 수를 줄이기 위한 추가적인 코드변환을 할 수 있는 방법들을 적용할 수 있게 된다.           /* default */ for(i=0; i&lt;limit; i+=1){     acc = acc OP data[i] }  /* Combine 2 elements at a time (2X1 루프풀기)*/ for(i=0; i&lt;limit; i+=2){     acc = acc OP data[i] OP data[i+1] }     위 코드와 같이 반복 횟수를 줄인다.            kX1로 가능하다.           5.9 병렬성 높이기     데이터 의존성을 줄이고자 병렬성을 높이는 방법이다.   다수의 누산기 사용   /* default */ for(i=0; i&lt;limit; i+=1){     acc = acc OP data[i] }  /* Combine 2 elements at a time (2X1 루프풀기)*/ for(i=0; i&lt;limit; i+=2){     acc0 = acc0 OP data[i]      acc1 = acc1 OP data[i+1] }     위 코드와 같이 홀수와 짝수를 나누면 데이터 의존성이 사라진다.   재결합 변환   /* default */ acc = (acc OP data[i]) OP data[i+1];  /* reassociation transform (2X1a 루프풀기) */ acc = acc OP ( data[i] OP data[i+1] );  5.11 일부 제한 요인들     최적화중 프로그램의 성능을 제한하는 다른 요소들이 존재한다.   5.11.1 레지스터 넘기기     프로그램이 사용 가능한 레지스터의 수를 넘어가는 병렬성을 가지면, 메모리에 저장하게 되는 레지스터 넘기기 spilling 방법이 사용된다.            이 때 런타임 스택에 공간을 할당하기 때문에 성능이 저하된다.           5.11.2 분기예측과 예측비용     if문보다 삼항연산자가 더 빠르다.            if문은 statement, 삼항연산자는 expression이다.            5.12 메모리 성능의 이해     Load의 성능            반복실행에 대한 로드 연산은 이전 반복실행에 대한 로드 연산이 완료되었을 때까지는 시작할 수 없다.           Store의 성능            store 연산은 레지스터 값을 메모리로 기록한다.       store 연산은 데이터 의존성을 발생시키지 않는다.           load 연산만이 store 연산의 결과에 영향을 받는다.   5.13 실제상황: 성능개선 기술     프로그램 성능의 최적화하는 기본적인 전략들            상위수준 설계 : 적절한 알고리즘과 자료구조를 선택       기본 코딩원칙 : 최적화 장애물 피하기                    함수 호출 제거           계산은 루프 밖으로 이동           불필요한 메모리 참조 제거           중간 값들을 저장하는 임시 변수 사용(데이터 의존성 피하기)           최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)                       하위수준 최적화 : 하드웨어의 성능을 활용할 수 있는 코드 작성                    루프풀기           다중누산기와 재결합 기법 사용           statement보다 expression 사용하기                           마무리     2장부터 4장까지 컴퓨터가 해석할 수 있는 언어들과 해당 언어들을 컴퓨터가 어떻게 해석하는지를 공부했다. 해당 방법들을 통해서 5장에서는 프로그래머들이 어떻게 코드를 작성해야 하는지를 배웠다.  만약 컴퓨터가 코드를 해석하는 방법을 몰랐더라면, 코드 최적화 방법을 공부할 때 정확히 이해할 수 없었을 것이다. 작성한 코드에서 인스트럭션 조합과 기계어가 어떻게 동작하는지를 항상 생각하자.     추가적으로, CSAPP 포스팅 방식을 조금 변경해야할 것 같다. 4장 초반까지는 솔직히 굉장히 어려웠다. “무슨 말을 하는지 이걸 도대체 컴퓨터가 어떻게 해석한다는거지?” 라고 생각하며 의문으로 가득차 거의 모든 내용을 포스팅한 것 같다. 하지만, 4장 후반 SEQ와 파이프라이닝을 공부하고 “아! 이래서 지금까지 이런 내용들을 공부했구나!” 그리고 5장을 공부하면서 뭔가 “득도”를 하게 된 것 같다. 다양한 부분들의 이해가 빨라졌다. 앞으로 챕터를 공부하고 나의 방식으로 녹인 후 포스팅을 하는 것으로 포스팅 방향을 바꿀 것이다.     6장은 드디어 메모리 파트이다. 너무 기대된다!   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_19/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)",
        "excerpt":"Chapter 06. 메모리 계층구조     메모리 시스템은 용량, 비용, 접근시간을 갖는 저장장치들의 계층구조다.            캐시메모리는 CPU 부근에서 비교적 느린 메인메모리에 대한 준비장소       메인메모리는 크고 느린 디스크들에 대한 준비장소       디스크들은 네트워크로 연결된 다른 머신들의 준비장소           메모리의 계층별로 접근 속도가 상이하다.            레지스터가 가장 빠르고, 그 다음은 메인메모리, 그 다음은 디스크이다.           데이터를 계층의 상부에 저장시켜서 CPU가 보다 빨리 접근할 수 있도록 프로그램을 작성해야한다.            이 개념은 지역성locality라고 알려진 컴퓨터 프로그램의 근본특징에 근거를 두고 있다.           6.1 저장장치 기술   6.1.1 랜덤-접근 메모리     랜덤-접근 메모리(RAM)은 두 종류를 가진다.            정적 SRAM : 동적램 DRAM 보다 더 빠르고 훨 씬 비싸다. 캐시메모리로 사용된다.       동적 DRAM : 메인메모리와 그래픽 시스템의 프레임 버퍼로도 사용된다.           정적 SRAM     SRAM은 각 비트를 이중안정bistable 메모리 셀cell에 저장한다.   SRAM은 전원이 공급되는 한 지속성을 갖는다.   리프레시가 필요없다.   DRAM보다 트랜지스터를 더 많이 사용하여 밀도가 낮으며 비싸고 전력을 많이 사용한다.   동적 DRAM     DRAM은 각 비트를 전하로 캐패시터에 저장한다.   리프레시가 필요하다.            메모리 시스템은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식           일반 DRAM       위의 그림은 DRAM 칩의 구조이다.   DRAM 칩 내의 셀들은 d 슈퍼셀들로 나누어지며, 각각은 w DRAM 셀들로 이루어진다.   슈퍼셀 (i,j)의 내용을 읽으려면 메모리 컨트롤러는 행 주소 i를 DRAM에 보내고, 다음에 열 주소 j를 보낸다.        위의 그림은 DRAM 슈퍼셀의 내용을 읽는 과정이다.   메모리 모듈     DRAM 칩은 메인 시스템(머더보드)의 확상슬롯에 꽂을 수 있는 메모리 모듈 형태로 패키징 된다.   DRAM을 여러개 추가하여 바이트를 순서대로 저장한다.   비휘발성 메모리     DRAM과 SRAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.   비휘발성 메모리는 이들의 전원 꺼져도 정보를 유지한다.   Read-only memory : ROM 이라고 부른다.   ROM 디바이스에 저장된 프로그램들은 종종 펌웨어firmware라고 부른다.   메모리에 접근하기     데이터는 ‘버스’라고 하는 공유된 전기회로를 통해서 프로세서와 DRAM메인메모리간에 앞뒤로 교환한다.   CPU와 메모리 간의 매 전송은 버스 트랜잭션bus transaction이라고 부르는 일련의 단계들을 통해 이뤄진다.             위의 그림은 CPU와 메인메모리를 연결하는 버스 구조다.       읽기 트랜잭션(movq A,%rax)            CPU는 주소 A를 시스템 버스에 보낸다. I/O브릿지는 신호를 메모리 버스를 따라 보낸다.       메인메모리는 메모리 버스에서 주소 신호를 감지하고, 메모리 버스로부터 주소를 읽고 DRAM에서 데이터 워드를 선입, 데이터를 메모리 버스에 쓴다.       I/O 브릿지는 신호를 시스템 버스 신호로 변환해서 시스템 버스를 따라 보낸다. CPU는 시스템 버스에서 데이터를 감지하고 %rax에 복사한다.           쓰기 트랜잭션(movq %rax,A)            CPU는 주소를 시스템 버스에 보낸다. 메모리는 메모리 버스에서 주소를 읽고 데이터가 도착하기를 기다린다.       CPU는 %rax에 있는 데이터를 시스템 버스에 복사한다.       메인메모리는 데이터를 메모리 버스에서 읽고 비트들을 저장한다.           6.1.2 디스크 저장장치     디스크는 RAM 메모리의 수천 메가바이트 단위에 비해 수백에서 수천 기가비이트 단위의 엄청난 양의 데이터를 저장하는 대표적인 저장장치다.   디스크 용량            기록밀도: 1인치의 트랙에 집어넣을 수 있는 비트의 수       트랙밀도: 원판 중심에서 반지름의 1인치 길이에 넣을 수 있는 트랙의 수       면적밀도: 기록밀도와 트랙밀도의 곱           디스크의 동작            탐색시간: 섹터의 내용을 읽기위해 헤드를 타깃 섹터를 보유한 트랙 위로 위치시키는 시간       회전 지연시간: 헤드가 트랙 위에 위치하면 타깃 섹터의 첫번째 비트가 헤드 아래로 지나가는 것을 기다리는 시간.(헤드의 위치와 디스크의 회전 속도 모두 관련됨)       전송시간: 하나의 섹터를 전송하는 시간(회전속도와 트랙당 섹터 수에 관련됨)           디스크 접근하기(디스크 섹터 읽기)            CPU는 명령어, 논리블록 번호, 목적지 메모리 주소를 디스크와 관련된 메모리 매핑한 주소에 써주어서 디스크 읽기를 개시한다.       디스크 컨트롤러는 이 섹터를 읽고 메인메모리로 DMA 전송을 수행한다.       DMA 전송이 완료될 때, 디스크 컨트롤러는 CPU에 인터럽트로 알려준다.           6.2 지역성     잘 작성한 컴퓨터 프로그램은 좋은 지역성locality를 보여준다.            최근에 참조했던 데이터 아이템 근처의 데이터 아이템이나 최근에 자신을 참조했던 데이터 아이템을 참조하려는 경향이 있다.           지역성은 두가지 형태가 있다.            시간 지역성 : 한번 참조된 메모리 위치는 여러 번 참조될 가능성이 높다.       공간 지역성 : 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.           캐시 메모리 : 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장            캐시 메모리라는 작고 빠른 메모리를 도입하여 메인메모리를 빠르게 돌릴 수 있게 됐다.           6.2.1 프로그램 데이터 참조의 지역성   int i, j, sum=0; for(i=0; i&lt;M; i++){   for(j=0; j&lt;N; j++){     sum += a[i][j];   } }     위의 코드는 좋은 지역성을 갖는다.            행 우선 순서로 접근되기 때문이다.           int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];   } }     위의 코드는 나쁜 지역성을 갖는다.   int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];   } }  int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];     sum1 += b[i][j];   } }     위의 코드도 썩 좋은 지역성을 갖고 있지는 않다.            보폭이 존재하기 때문           6.2.2 지역성 요약     동일한 변수들을 반복적으로 참조하는 프로그램은 좋은 시간 지역성   Stride-k참조 패턴에서 stride가 적으면 적을수록 공간 지역성도 좋아진다.   루프는 인스트럭션 선입에 대해 좋은 시간 및 공간 지역성을 갖는다.   6.3 메모리 계층구조     아래 두가지를 보완하기 위해 ‘메모리 계층구조’라고 알려진 메모리 시스템 조직을 위한 접근 방법을 사용한다.            저장장치 기술 : 다양한 저장장치 기술들은 매우 광범위한 접근시간을 갖는다.       컴퓨터 소프트웨어 : 잘 작성한 프로그램들은 좋은 지역성을 나타내는 경향이 있다.                위의 그림은 메모리 계층구조이다.   6.3.1 메모리 계층구조에서의 캐시     캐시는 보다 크고 느린 디바이스에 저장된 데이터 객체를 위한 준비 영역으로 사용하는 작고 빠른 저장장치다.   메모리 계층구조의 중심 개념은, 레벨 k에 있는 보다 빠르고 더 작은 장치가 레벨 k+1을 위한 캐시 서비스를 제공한다는 것이다.        위의 그림은 메모리 계층구조에서 캐싱의 기본 원리이다.   캐시 적중     레벨 k+1로부터 특정 데이터 객체 d를 필요로 한다.   현재 레벨 k에 저장된 블록들 중의 하나에서 d를 찾는다.   만일 d가 레벨 k에서 우연히 캐시되어 있다.   캐시 미스     만일 d가 레벨 k에서 캐시되지 않는다면 ‘캐시 미스’가 발생한 것이다.   k+1에 있는 캐시로부터 d를 포함하는 블록을 가져온다.   만일 레벨 k 캐시가 이미 꽉 찬 상태full라면 기존 블록에 덮어쓴다.            축출 : 기존 블록을 덮어쓰는 과정       희생블록 : 축출되는 블록       교체정책 : 어떤 블록을 교체할지에 관한 결정           캐시 미스 종류     cold cache : 캐시가 비어있을 때   충돌미스conflict miss : 캐시의 배치 정책으로 인한 캐시 미스   캐시 관리     메모리 계층 구조의 핵심은 각 레벨에 있는 저장장치가 다음 낮은 레벨을 위한 캐시   레벨 L1,L2,L3의 캐시들은 캐시에 구현된 하드웨어 로직으로 전적으로 관리된다.   가상모메리를 사용하는 시스템에서 DRAM메인메모리는디스크에 저장된 데이터 블록에 대한 캐시 서비스를 제공한다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_20/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 06 메모리 계층구조(캐시)",
        "excerpt":"Chapter 06 메모리 계층구조     저장장치 기술   지역성   메모리 계층구조   캐시메모리   캐시 친화적 코드 작성하기   프로그램 성능에 대한 캐시의 영향   요약   6.4 캐시 메모리     CPU와 메인메모리 사이의 성능 격차가 커짐에 따라 L1 캐시 및 L2 캐시를 삽입하였다.   캐시는 SRAM이다.        위의 그림은 캐시 메모리를 위한 일반적인 버스 구조이다.   6.4.1 기본 캐시 메모리 구조     캐시의 구성은 순서쌍 S,E,B,m 으로 규정할 수 있다.            S : 2^s개의 캐시 집합       E : 집합에 포함되는 캐시 라인       B : 2^b 바이트의 데이터 블록       m : M = 2^m 개의 교유의 주소를 구성하는 m비트       C : 모든 블록의 크기 SEB           캐시는 요청된 워드를 간단히 주소비트만 조사해서 찾아ㅓ낼 수 있도록 구성되어있다.            해당 방식은 해시 함수를 사용하는 해시 테이블과 유사하다.                위의 그림은 캐시의 일반적인 구조이다.   6.4.2 캐시 종류     직접매핑 캐시            집합당 정확히 한개의 라인을 갖는 경우           집합결합성 캐시            집합당 k개의 라인을 갖는 경우           완전결합성 캐시            모든 캐시 라인들을 갖는 하나의 집합으로 구성된 경우           6.4.3 캐시 동작 방법     캐시의 동작 방법은 세 단계로 이루어진다.            집합 선택       라인 매칭       워드 추출                  위와 같은 방법으로 캐시가 어떤 요청이 적중인지 미스인지 결정하고, 요청한 워드를 뽑아내기 위해 작업을 수행한다.              집합 선택            s개의 집합 인덱스 비트를 w의 주소 중에서 뽑아낸다.           라인 매칭            워드 w의 사본이 집합 i에 포함된 캐시 라인에 들어 있는지 결정한다.       유효비트 valid가 1이고, 태그비트들이 일치해야한다. -&gt; 캐시 적중           워드 선택            캐시 적중이 발생하면 원하는 워드가 블록 내 어디에서 시작하는지 결정한다.                        위의 그림은 집합 선택과 라인 매칭 그리고 워드 선택이다.(직접매핑 캐시)       Thrashing : 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는 경우            해결 방법 : 예를들어 x배열, y배열에서 쓰레싱이 일어나면 x배열에 패딩을 주어 x[i]와 y[i]가 서로 다른 집합에 매핑되도록 한다.           인덱스를 중간 비트로 사용하는 이유            연속적인 메모리 블록들은 동일한 캐시 집합으로 매핑된다. -&gt; 어떠한 특정 순간에 한 개의 블록 크기의 배열 묶음만을 저장하게 되며 캐시를 비효율적으로 사용하게 된다.                     위의 그림은 중간 비트로 캐시 인덱스를 사용하는 이유다.       집합결합성 캐시에서의 동작 방법            직접매핑 캐시와 동작이 비슷하지만,       라인 매칭에서 캐시 내 태그와 주소의 태그가 일치하는 라인을 찾기위해 탐색을 한다.       캐시에서 미스 발생시 : LFU(최소 빈도 사용), LRU(최소 최근 사용) 정책 활용           완전결합성 캐시            집합결합성 캐시와 동작이 비슷하지만,       많은 수의 태그를 병렬로 검색해야 한다.           6.4.4 쓰기와 관련된 이슈     Write-through: 즉시 w의 캐시 블록 전체를 다음 하위 레벨로 써준다.            버스 트래픽을 발생시키는 단점이 있다.           Write-back : 갱신을 지연시켜 이 블록이 블록 교체 알고리즘에 의해 캐시에서 축출될 때에만 하위 레벨에 써준다.            캐시 블록이 수정되었는지 여부를 나타내는 dirty bit 을 각 라인마다 추가로 유지해야 한다.           Write-allocate : 해당 블록을 다음 하위 레벨에서 캐시로 가져오고 난 뒤에 캐시 블록을 갱신한다.   No-write-allocate : 캐시를 통과하고 워드를 직접 다음 하위 레벨에 써준다.   Write-through &amp; no-write-allocate, Write-back &amp; Write-allocate   6.4.5 실제 캐시 계층구조의 해부     i-cache : 인스트럭션만을 보관하는 캐시   d-cache : 데이터만 보관하는 캐시   6.4.6 캐시 매개변수의 성능에 대한 효과     미스 비율 Miss rate : 미스하는 메모리를 참조하는 비율   적중 비율 Hit rate : 1 - miss rate   적중 시간 Hit Time : 캐시에 있는 워드를 CPU 로 전달하는 데 걸리는 시간   미스 비용 Miss Penalty : 미스로 인해서 추가적으로 요구되는 시간   캐시 크기의 영향     큰 캐시는 적중비율을 높여주지만 더 적중시간이 길어진다.   블록 크기의 영향     적중 비율을 높여주지만 전송시간이 길어진다.   시간 지역성이 더 많은 프로그램에서 적중 비율에 타격을 줄 수 있다.   결합도의 영향     집합당 캐시 라인 수의 선택이 미치는 영향   충돌미스로 인해 쓰레싱하는 위험성을 감소시킨다   라인당 더 많은 태그비트 필요, LRU 상태비트 필요   6.5 캐시 친화적 코드 작성하기     좋은 프로그래머란 항상 캐시 친화적으로, 즉 좋은 지역성을 가지도록 프로그램을 작성해야 한다.            공통적인 경우를 빠르게 동작하게 만들어야한다.       각 내부 루프의 캐시 미스 수를 최소화 해야한다.       지역변수들에 대한 반복적인 참조는 좋다.(시간 지역성)       Stride-1 참조 패턴은 좋다.(공간 지역성)           6.6 프로그램 성능에 대한 캐시의 영향     읽기 처리량 or 읽기 대역폭 : 프로그램이 메모리 시스템에서 데이터를 읽는 비율   6.7 요약     이렇게 메모리까지 하드웨어와 프로그램 사이의 상호작용에 대해 공부했다. 메모리에 대해서 좀 더 자세히 살펴볼 필요가 있어 보인다. 대학 2학년 때 컴구 수업에서 캐시 매핑 관련 내용이 생각나는데, 이 책에는 수록되어 있지 않은 것 같다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_21/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 K번째수 (정렬)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 파이썬(Python) 풀이      풀이로 이동!   문제풀이     반복문과 slicing, sort 함수를 사용하면 간단하게 해결되는 가장 기초적인 정렬 문제이다.       2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.   1차원 배열인 command에서 0번 index와 1번 index에 해당되도록 slicing 한다.   slicing된 배열을 정렬한다.   정렬된 배열에서 index 2번에 해당되는 인자값을 answer 배열에 append 한다.   return answer   코드   def solution(array, commands):     answer = []     for command in commands:         answer.append(sorted(array[command[0]-1:command[1]])[command[2]-1])     return answer  if __name__ == \"__main__\":     array = [1, 5, 2, 6, 3, 7, 4]     commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]]     print(solution(array, commands)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_01/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 모의고사 (완전탐색)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 완전탐색 모의고사 파이썬(Python) 풀이      풀이로 이동!   문제풀이     반복문의 횟수를 줄이는 것이 핵심인 문제인 것 같다. 반복문의 횟수를 줄이기 위해 접근하는 index를 학생들의 정답 패턴의 길이로 나누는 아이디어를 채택하였다.       정답의 길이로 반복문을 돌린다.   학생 a,b,c의 정답 패턴의 길이로 현재 반복문의 index를 나누어 각 학생의 정답 패턴에 접근한다.   정답이 각각 일치하면, answer_list의 a-&gt;0, b-&gt;1, c-&gt;2 인덱스에 맞게 +1을 해준다.   answer_list를 enumerate를 사용하여 인덱스와 밸류값으로 함께 반복문을 돌린다.   answer_list의 max값을 찾아 해당 max값과 밸류값이 같은 인덱스값을 answer배열에 저장한다.   return answer   코드   def solution(answers):     answer = []     answer_list = [0,0,0]     a = [1, 2, 3, 4, 5]     b = [2, 1, 2, 3, 2, 4, 2, 5]     c = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]     for i in range(len(answers)):         if a[i%len(a)]==answers[i]:             answer_list[0]+=1         if b[i%len(b)]==answers[i]:             answer_list[1]+=1         if c[i%len(c)]==answers[i]:             answer_list[2]+=1      for i,val in enumerate(answer_list):         if val == max(answer_list):             answer.append(i+1)     return answer  if __name__ == \"__main__\":     answers = [5, 5, 4, 2, 3]     print(solution(answers)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_02/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level2 가장 큰 수 (정렬)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level2 정렬 가증 큰 수 파이썬(Python) 풀이      풀이로 이동!   문제풀이     가장 큰 수를 만드려면, 예를 들어 9와 91이 있을 때 991이 919보다 더 큰 수가 된다. 수의 가장 큰 값이 1000이기 때문에, ‘9’3, ‘91’3을 해서 비교를 하면, ‘999’ &gt; ‘919191’ 이다. 그렇기 때문에 int-&gt;str-&gt;*3을 하여 비교를 하여 정렬을 하고 해당 숫자들을 원래 숫자로 변경하여 return 해준다.       배열의 값들을 str type으로 변경해준뒤 *3을 해준다.   이후 sorted 함수를 사용하여 정렬한다.(내림차순으로 정렬하기 위해 reverse=True로 설정해준다.)   다시 배열의 값들의 길이를 1/4로 나누어 slicing해준다.   해당 배열들을 ‘‘로 join해준다.   return answer   코드   def solution(numbers):     if sum(numbers)==0:         return '0'     numbers = sorted([str(number)*3 for number in numbers],reverse=True)     answer = ''.join([numbers[i][:int(len(numbers[i])/4)] for i in range(len(numbers))])     return answer  if __name__ == \"__main__\":     numbers = [6,2,10]     print(solution(numbers)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Part 1 프로그램의 구조와 실행 리뷰",
        "excerpt":"2 정보의 표현과 처리     컴퓨터가 실제로 해석하는 비트들과 연산들이 무엇이 있는지 배운다.       컴퓨터는 두 개의 값을 갖는 신호로 정보를 처리한다.   이러한 비트를 이진수 체계를 사용해서 양수들로 인코딩하여 사용한다.            비부호형       부호형(2의 보수)       부동소수점           정보의 저장     2진수: 컴퓨터의 비트 표현   16진수: 비트 패턴을 표시하는데 사용됨(2진수와 10진수는 불편함)   비트 표시 방법(xw-1,xw-2,…,x1,x0)            리틀 엔디안: 가장 덜 중요한 바이트가 먼저 온다.(x0,x1…)       빅 엔디안: 가장 중요한 바이트가 먼저 온다.(xw-1,xw-2…)           비트 수준 연산            부울 대수: ~(not),&amp;(and),|(or),^(exclusive-or)       쉬프트                    좌측 쉬프트: « 우측에는 k개의 0 채워짐           논리 우측 쉬프트 » 좌측에는 k개의 0 채워짐           산술 우측 쉬프트 » 좌측에는 k개의 중요한 비트들이 채워짐                           정수의 표시     비부호형과 부호형(2의보수)의 표현 방법에 차이점에 포인트를 두어야 한다.       부호형(2의 보수) : 맨 앞자리의 비트가 0이면 양수, 1이면 음수로 표현한다.            ex) 1101 -&gt; 앞자리가 1이므로 -8, 앞자리를 제외한 값이 5 -&gt; -8+5=-3 이렇게 계산한다.           비부호형과 부호형 간의 변환과 확장, 절삭에서 부호형의 오버플로우가 발생한다.   정수의 계산     부호형의 덧셈, 곱셈에서 음의 오버플로우와 양의 오버플로우가 발생한다.   쉬프트를 사용해서 곱셈이 가능하다.(비용이 훨씬 적게 듬)            ex) 11(1011[2])*4 = 44(101100[2])           부동소수점     부동소수점 V = x*2^y 형태로 인코딩한다. y는 1/2, 1/4… 와 같은 값   근사법 rounding            부동소수점은 정확한 값을 얻을 수 없다. 그렇기 때문에 근사 연산을 한다.                    짝수근사법, 영방향근사, 하향근사, 상향근사 모드가 있다.                           3 프로그램의 기계수준 표현     우리가 코드를 작성하면 컴파일러는 소스파일의 어셈블러 버전을 생성한다. 어셈블러는 해당 어셈블리 코드를 바이너리 목적코드로 변환한다. 이후 목적코드를 컴퓨터가 해석한다. 이번 챕터에서는 어셈블리 코드에 대해 배운다. 이것을 배우게 되면 컴파일러의 최적화 방법을 알 수 있고 코드의 비효율성을 분석할 수 있게된다.    프로그램의 인코딩     프로그램 호출방법(c언어 기)            C 전처리가 #include와 #define을 확장해준다.       컴파일러는 소스파일의 어셈블리 코드를 생성한다.(test.c -&gt; test.s)       어셈블러는 어셈블리 코드를 바이너리 목적코드로 변환한다.(test.s -&gt; test.o)       링커가 목적코드를 라이브러리 함수와 함꼐 최종 실행 파일인 test.p를 생성한다.           ISA(Instruction Set Architecture): 인스트럭션 집합구조, 프로세서의 상태 및 인스트럭션 형식과 영향을 정의한다.   인스트럭션 특성 요약            오퍼랜드: 데이터와 목적지 위치를 명시한다.       레지스터나 메모리로부터 읽고 저장한다.       immediate(상수값), register, memory 세가지 타입이 존재한다.           인스트럭션 종류     데이터 이동: mov            두 개의 오퍼랜드 모두 메모리 위치에 올 수 없다.           스택의 저장과 추출: push, pop   산술연산: add, sub, imul, idiv, sal(left shift), inc(++1), or, and…   유효주소 적재: leaq            포인터 생성하기 위한 인스트럭션           조건코드: CF(carry flag), ZF(zero flag), SF(sign flag), OF(overflow flag)            cf: 중요한 비트로부터 받아올림이 발생한 것을 표시(오버플로우 검출)           제어문: cmp, test, set            cmp는 두 오퍼랜드가 같으면 zf를 1로 설정       test는 조건 코드만 설정       set은 비교후 조건코드를 설정해줌           점프: jmp, je, jle…   조건부 이동: cmove, cmovg…   콜 리턴: call, ret   조건부 분기(if else)     조건제어: cmp와 jump를 사용함   조건부이동: cmove등을 사용함(더 빠름)            경우를 다 계산하고 이동만함           반복문(for, while)     cmp와 jump를 사용   프로시저     call: call하게 되면 이전 주소와 함께 스택 메모리에 올라감   return: 후입선출 구조이기 때문에 스택에 있던 이전 주소가 pop되며 retrun 하게됨   데이터 전송: 인자는 레지스터로 전송되지만, 6개 이상의 인자를 가지면 초과되는 인자는 스택으로 전달된다.   지역 변수: 지역변수 또한 스택 프레임 내에서 생성된다.   레지스터: 레지스터는 프로시저 모두가 굥유함. 기존에 사용하던 레지스터를 새로 호출한 함수에서 “saved registers”라는 스택의 일부분을 할당해서 저장하고 보존한다.      데이터의 정렬     사용 가능한 주소를 k의 배수가 되도록 요구한다.      버퍼 오버플로우     스택의 saved registers와 return address 범위를 침범하면 심각한 오류를 발생시킨다.   대응 방법            스택 랜덤화: 스택의 위치를 프로그램 실행마다 다르게 해준다.       스택 손상 검출: 스택에 canary값을 추가하여 손상되는 것을 감지한다.       실행코드 영역 제한           부동소수점     정수 연산과 유사하다.   부동소수점을 위한 레지스터를 따로 사용한다.   4 프로세서 구조     하드웨어 시스템이 ISA의 인스트럭션들을 어떻게 실행할 수 있는지를 학습한다. ISA인 “Y86-64”를 직접 만들어보며 학습한다. 이후 SEQ를 기초로 파이프라인형 프로세서 PIPE를 만들어본다. 프로세서는 각 인스트럭션의 실행단계를 5단계로 나누어 처리한다.       프로그래머-가시성 상태(programmer-visible state) : 프로그램 레지스터, CC(조건코드), PC, 메모리, Stat(상태코드)를 포함한다.   인스트럭션 집합(Y86-64)        위의 그림처럼 인스트럭션이 인코딩된다.            인코딩에 1에서 10바이트가 소요된다.       OPq는 정수연산이며 ZF,SF,OF 조건코드를 결정한다.                위의 그림처럼 인스트럭션에 대한 상세한 특정 인코딩으로 변환된다.   예외상황(Y86-64)     Stat(상태코드)를 나타낸다.            AOK: 정상 실행       HLT: halt 인스트럭션 실행(정지 인스트럭션)       ADR: 잘못된 메모리 주소를 읽거나 쓸 때       INS: 잘못된 인스트럭션을 만났을 때           어셈블러를 사용해 어셈블한 결과 == 목적코드      SEQ 설계 1 (레지스터 파일)     SEQ는 sequential 프로세서를 의미한다. SEQ를 설계하기 위해서는 SEQ 내에 있는 레지스터 파일을 이해해야 한다. 레지스터 파일을 이해하기 위해서는 논리게이트와 클럭을 이해해야한다.(레지스터 파일이 논리게이트로 이루어져있다.)     논리게이트 -&gt; 조합회로 -&gt; (레지스터 연산 = 클럭) -&gt; 레지스터 파일 -&gt; SEQ -&gt; SEQ+ -&gt; PIPE       논리게이트: AND, OR, NOT등의 입력들의 불 함수 출력을 만들어낸다.            출력과 입력은 0과 1이다.           조합회로: 여러 논리 게이트를 모아 네트워크를 만들어 계산 블록을 만든다.다   클럭: 주기적 신호인 한 개의 클럭에 의해 새 값들이 제어된다.            클럭을 사용하는 레지스터: 워드나 개별 비트 저장       RAM: 주소를 사용해서 여러 워드를 저장           레지스터 연산: 클럭이 상승할 때 레지스터의 입력값이 새값을 가진다.   레지스터 파일:      SEQ 설계 2 (하드웨어 구조)             위의 그림은 SEQ 하드웨어 구조다.       작업 단계            선입 fetch: PC를 메모리주소로 사용해 인스트럭션 바이트를 읽어들인다.       해독 decode: 레지스터 파일에서 오퍼랜드를 읽어서 valA, valB를 얻는다.       실행 excution: ALU(산술/논리 연산)이 인스트럭션이 지시하는 연산을 수행하거나 유효주소 계산 및 스택 포인터 값 변경한다. 조건 코드 및 점프 인스트럭션도 갱신한다. valE       메모리 memory: 데이터를 메모리에서 쓰거나 읽어온다. valM       재기록 write back: 두 결과를 레지스터 파일에 기록한다.       PC 갱신 PC update: PC는 다음 인스트럭션의 주소로 설정된다.           SEQ 타이밍            메모리와 레지스터에 클럭을 공급하며 프로세서의 여러 동작들을 순서대로 제어한다.       인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 없다.           파이프라이닝 원리     SEQ에서는 하나의 인스트럭션을 처리하는데 3~5 클럭정도 소요된다. 하지만, 다양한 단계에서 하나의 인스트럭션이 끝날 때 까지 쉬고 있는 단계가 많다. 이를 사용하기 위해 파이프라이닝 개념을 도입하였다.       파이프라이닝 주요 특징 : 시스템 처리량, 지연시간을 증가 시킨다.            위의 그림은 비파이프라인과 파이프라인            수행 시간을 계산하면 파이프라인이 약 2.5배 빠르지만, 지연시간은 40ps정도 늘어났다.           파이프라이닝의 한계     각 단계별로 처리 시간이 다르면, 가장 늦은 단계의 시간지연 값에 의해 클럭의 속도가 결정된다.   인스트럭션들 간에 데이터 의존성이 존재하면 파이프라이닝이 제한된다.            피드백을 갖는 파이프라인 시스템이라고도 한다.           PIPE 설계     SEQ 구조에서 PC갱신 단계를 맨 처음으로 바꾼 SEQ+를 설계한 후 파이프라인을 적용하여 PIPE구조를 설계한다.         위의 그림은 PIPE-의 하드웨어 구조이다.   다음 PC값의 추정     파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이다.   목표를 달성하기 위해서 PC의 새로운 값을 예측해야 한다.            조건제어나 분기등으로 인해서           분기 방향을 추측하는 기술을 branch prediction이라고 한다.   파이프라인 해저드     피드백이 있는 시스템에 파이프라인을 도입하면 인스트럭션들 간에 의존성으로 인해 문제가 발생한다.            데이터 의존성: 현재의 계산의 결과가 다음 인스트럭션을 위한 데이터로 사용되는 경우       제어 의존성: jump, call, ret과 같은 인스트럭션을 처리할 경우           해저드: 의존성들이 파이프라인으로 인해 잘못된 계산을 하는 것   스톨을 사용한 데이터 해저드 회피     해저드 조건이 사라질 때 까지 파이프 라인 내에 유지한다.   스톨링동안 실행 단계에 버블을 삽입한다.   버블은 동적으로 생성된 nop인스트럭션과 비슷하다.   포워딩을 이용한 데이터 해저드 회피     소스 오퍼랜드로 이전에 실행된 인스트럭션 결과 값을 전달할 수 있다.   “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.   로드/사용 데이터 해저드 회피     메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 포워딩으로 처리할 수 없다.   스톨링과 포워딩을 함께 사용한다.   load interlock: 로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것   제어 해저드의 회피     ret: 스톨을 사용한다.   jump: 분기할 것을 예측한다. -&gt; 잘못 예측된 것을 확인한다. -&gt; 버블을 삽입하여 인스트럭션을 취소한다. -&gt; 점프 다음에 오는 인스트럭션을 선입한다.   instruction squashing: 잘못 선입한 인스트럭션을 취소하는 것   파이프라인 예외처리       제어로직을 사용하여 예외처리를한다.   5 프로그램 성능 최적화하기     상위 수준 설계: 적절한 알고리즘과 자료구조 선택   최적화 장애물 피하기            함수 호출제거       계산은 루프 밖으로 이동       불필요한 메모리 참조 제거       중간 값을 저장하는 임시 변수 사용(데이터 의존성 피하기)       최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)           하위수준 최적화: 병렬성 이용            루프풀기       다중누산기와 재결합 기법 사용       statement 보다 expression 사용하기           6 메모리 계층구조     랜덤-접근 메모리(RAM)            SRAM: 캐시메모리로 사용                    메모리셀에 저장한다.           지속성을 갖는다.           리프레시가 필요없다.                       DRAM: 메인메모리로 사용                    캐패시터에 저장한다.           리프레시가 필요하다.           메모리 컨트롤러는 행 주소 -&gt; 열 주소를 보낸다.                       RAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.           비휘발성 메모리            전원이 꺼져도 정보를 유지한다.       Read-only memory ROM이라고 부른다.           버스            프로세서와 메인메모리간에 데이터를 교환한다.       버스 트랜잭션이라고 부르는 일련의 단계들을 통해 이뤄진다.       읽기와 쓰기 트랜잭션이 있다.           지역성     최근에 참조했던 데이터 아이템 근처나 자신을 참조하려는 경향이 있다.   종류            시간 지역성: 한번 참조된 메모리 위치는 여러번 참조될 가능성이 높다.       공간 지역성: 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.           캐시 메모리: 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장한다.   캐시     캐시 종류            직접매핑 캐시       집합결합성 캐시       완전결합성 캐시           캐시 동작 방법            집합 선택       라인 매칭       워드 추출                    Thrashing: 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는경우                            해결법: 패딩을준다.                                   인덱스를 중간비트로 쓰는 이유: 연속적인 메모리의 동일한 캐시 집합으로의 매핑을 피하기 위해                           캐시 쓰기            Write-through: 즉시 하위 레벨로 쓴다. 버스 트래픽 일으키는 단점 있다.       Write-back: 갱신을 지연시켜 교체 알고리즘에 의해 축출될 때 쓴다. dirty bit을 라인마다 추가로 유지해야한다.       Write-allocate: 하위 레벨에서 캐시로 가져오고 난 뒤 캐시 블록을 갱신한다.       No-write-allocate: 캐시를 통과하고 직접 하위 레벨에 써준다.           Part1 프로그램의 구조와 실행 리뷰  처음 csapp 책을 읽기 시작한 날이 1월 21일이다. 총 세파트로 나뉘어져 있는데, 파트1을 1회독한 시점이 3월 29일 대략 2개월정도 걸렸다. CS부터 공부하기로 다짐했을 때 매일매일 공부하려고 노력했지만, 부트캠프 지원 이슈로 인해 대략 2-3주정도는 공부를 안한 것 같다.  또 어려운 내용이 나오기 시작하면, 예를들어 부동소수점, 프로시저, SEQ구현 등… 책을 덮게되었던 것 같다.  하루빨리 CS, OS, 네트워크, 디비 이론적인 부분들에 대해 공부를 마치고 지식적으로 성장하고 싶다. 컨디션 조절을 하되 2-3주동안 공부를 안했던 것은 반성하자.   SEQ 설계 단원을 공부하기 전까지는 공부하는 내용들이 머리속에서 잘 그려지지 않았다. 하지만 SEQ 설계를 공부하고 나니 그 이전에 공부했던 부분들에 대해 조금 더 이해가 되었고, 그 이후에 최적화 부분에서 정말 말 그대로 신이났다. CS의 매력에 흠뻑 빠지게 된 것 같다. 대학에서 컴구를 공부할 때는 이론적인 부분 또는 하드웨어적인 부분에서의 설명만 하고  추가 설명은 없었다. 그래서, 나는 이런 하드웨어와 프로그램들이 어떻게 상호작용이 되는지 이해하지 못했고 재미도 못 느꼈던 것 같다. 하지만, csapp에서는 하드웨어와 프로그램의 상호작용에 대해 설명을 하면 그 이후에 실제 c코드로 예시를 들어준다. 이러한 예시코드가 프로그래밍과 접목도 되고 이해의 수준이 상승하는 것 같다.   앞으로 남은 part2,3를 4월 중순 안으로 끝마치고 운영체제 공부를 빨리 하고 싶다. 화이팅이다! 아자아자!  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_22/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 체육복 (그리디)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 그리디 체육복 파이썬(Python) 풀이      풀이로 이동!   문제풀이     그리디 문제는 ‘현재 상황에서 지금 당장 좋은 것만 고르는 방법’을 의미한다. 알고리즘의 패턴보다는 풀이하는 사람의 아이디어가 더 중요한 알고리즘이다. 우선 체육복 문제는 인접한 index의 학생들만 여벌의 옷을 받을 수 있으므로 인접한 index에 대해서만 생각해주면 된다. 또한 도난당한 학생이 여벌의 옷을 가지고 올 수 있기 때문에 이 부분에서 예외처리를 해주어야한다.       lost와 reserve를 set형식으로 변경해준뒤 각각의 차집합을 구해준다.(도난당한 학생과 여벌옷을 가져온 학생이 중복된 경우를 제거하기 위해)   reserve를 기준으로 인접한 lost를 조회하여 존재하면 reserve에서 해당 value를 삭제해주고 count(옷을 빌린 학생 수)를 1 올려준다.   전체에서 lost에 남아있는 값들의 길이를 빼주고 count(옷을 빌린 학생 수)를 더해준다.   위에 값을 answer로 return한다.   코드       def solution(n, lost, reserve):         count = 0         lost, reserve = list(set(lost)-set(reserve)), list(set(reserve)-set(lost))         for lost_v in lost:             for reserve_v in reserve:                 if lost_v - 1 == reserve_v or reserve_v == lost_v + 1:                     reserve.remove(reserve_v)                     count += 1                     break              answer = n - len(lost) + count              return answer          if __name__ == \"__main__\":         n = 5         lost = [1,2,4]         reserve = [2,3,4,5]         print(solution(n,lost,reserve)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_04/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level2 큰 수 만들기(그리디)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level2 그리디 큰 수 만들기 파이썬(Python) 풀이      풀이로 이동!   문제풀이     총 두가지의 방법으로 문제를 풀었는데 모두 테스트케이스 10에서 시간 초과로 인해 풀지 못하였다…  그래서 정답 코드를 가지고 와서 공부를 하는 것으로 대신하겠다.  파이썬에는 스택 자료구조가 따로 없고 리스트로 스택을 흉내내서 사용할 수 있다. 정답 코드는 스택의 성질을 사용하여서 문제를 해결했다.    맞는 풀이 solution3      stack을 흉내내는 리스트(stack이라 부르겠다.)에 number의 첫번째 값을 넣어준다(push).   number의 두번째 값부터 반복문을 돈다.   while문을 도는데, 조건은 세가지다.            stack에 값이 있어야한다.       stack의 마지막 값(stack.top)이 num보다 작아야한다.       k가 0보다 커야한다.           위에 해당하지 않으면 stack에 값을 추가해준다(push).   조건이 해당하면, 반복문을 돌면서 stack.pop()과 k를 1씩 줄여준다.   반복문이 끝나고도 k가 0이 아니면 stack을 뒤에서 k만큼 slicing해준다.   '’으로 join하여 문자열로 return한다.   틀린 풀이 solution1      numbur의 i와 i+1을 비교한다.   i가 i+1보다 작으면 i를 pop해준다.   다시 첫번째 index로 돌아가 1-2번을 반복한다.   남아있는 값이 len(number)-k의 길이가 아니면, 뒤에서 k만큼 slicing 해준다.   '’으로 join하여 문자열로 return한다.   틀린 풀이 solution2      number의 i와 j를 비교한다.   i가 j보다 작으면 i의 인덱스를 새로운 배열에 저장한다.   모두 저장된 배열에 포함된 인덱스를 number에서 제거해준다.   남아있는 값이 len(number)-k의 길이가 아니면, 뒤에서 k만큼 slicing 해준다.   '’으로 join하여 문자열로 return한다.   코드       def solution1(number, k):         number = list(number)         i = 0;         while k &gt; 0:             for j in range(i,i+k+1):                 if number[i] == '9': break                 if number[i] &lt; number[j]:                     number.pop(i)                     k = k -1                     if i&gt;0:                         i = i -1                         break                     i = -1                     break             i += 1         answer = ''.join(number)         return answer          def solution2(number, k):         number = list(number)         length = len(number)-k         remove_list = []         i = 0         while k &gt; 0:             if i+1+k &gt; len(number):                 break             for j in range(i+1,i+1+k):                 if number[i] &lt; number[j]:                     remove_list.append(i)                     k -= 1                     break             i += 1         number = [number[i] for i in range(len(number)) if i not in remove_list]         number = number[:length]         answer = ''.join(number)         return answer                    def solution3(number,k):         stack = [number[0]]         for num in number[1:]:             while len(stack) &gt; 0 and stack[-1] &lt; num and k &gt; 0:                 k -= 1                 stack.pop()             stack.append(num)         if k != 0:             stack = stack[:-k]         return ''.join(stack)               if __name__ == \"__main__\":         number = '4177252841'         k = 4         print(solution3(number, k)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_05/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 모험가 길드",
        "excerpt":"이것이 코딩 테스트다 with 파이썬   그리디 모험가 길드(Python)   문제   모험가 N명에겐 공포도 X가 각각 존재한다.  공포도가 X인 모험가는 반드시 X명 이상으로 구성된 그룹에 참여하고 여행을 떠나야 한다.  여행을 떠날 수 있는 그룹 수의 최댓값을 구하라.      예시    입력 : [2,3,1,2,2]  결과 : 5   풀이     공포도가 가장 큰 모험가를 우선으로 그룹을 지정해주어야 한다. 그렇기 때문에 내림차순으로 정렬을 하고 접근한다.       array를 내림차순으로 정렬   array의 첫번째 인덱스의 값만큼 slicing해서 array에 저장, count를 1 올려줌   array가 빈 리스트가 되면 while문 탈출   return count   코드       def solution(array):         count = 0         array.sort(reverse=True)프로그래머스 파이썬 알고리즘          while array:             array = array[array[0]:]             count += 1              return count          if __name__ == \"__main__\":         array = [2,3,1,2,2]         print(solution(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_01/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 곱하기 혹은 더하기",
        "excerpt":"이것이 코딩 테스트다 with python   그리디 곱하기 혹은 더하기(Python)   문제   숫자로만 이루어진 문자열 S가 있다.  숫자 사이에 ‘x’, ‘+’ 연산자를 넣어 가장 큰 수를 만들어라.       예시   입력 : ‘02984’  결과 : 576   풀이     0과 1일 때는 +를 해주고 그렇지 않으면 x를 해주는 것이 이 문제의 포인트로 보인다.       sum 변수에 str(문자열 S)의 첫번째 인덱스의 값을 넣어준다.   str의 두번째 인덱스의 값부터 반복문을 돌린다.   sum과 ch(반복문을 도는 str의 값)이 2보다 작다면 +, 그렇지 않으면 x를 해준다.            sum도 체크 하는 이유는 sum이 0이나 1이면 +를 해줘야 하기 때문           return sum   코드       def solution(str):         sum = int(str[0])              for ch in str[1:]:             ch = int(ch)             if sum &lt; 2 or ch &lt; 2:                 sum += ch             else:                 sum *= ch              return sum               if __name__ == \"__main__\":         str = \"567\"         print(solution(str)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_02/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 문자열 뒤집기",
        "excerpt":"이것이 코딩 테스트다 with python   그리디 문자열 뒤집기(Python)   문제   0과 1로만 이루어진 문자열 S가 있다.  연속된 숫자를 잡고 뒤집을 수 있다.(0을 1로, 1로 0으로)  모두 같은 수를 만들 수 있는 뒤집기의 최소 횟수를 구하라.      예시   입력 : ‘00001110000’  결과 : 1   풀이     0과1이 인접한 부분이 몇개 있는지를 체크하면 된다. 예를들어 인접한 부분의 패턴을 ‘01’을 조사한다. 하지만, 1010 문자열을 조사하게 되면 마지막 인접한 부분을 조사하지 못해 최소 횟수가 1이 되므로 마지막 문자열에 1을 붙여주고 조사한다. 이렇게만 진행했을 경우 ‘010’을 조사하게 되면 최소 횟수가 2회가 된다. 그렇기 때문에 같은 방법으로 ‘01’과 ‘10’을 둘다 조사하여 두가지의 최소 횟수중 최소값을 구한다.       문자열 S(str)의 마지막 부분을 조사해서 0 또는 1을 붙여준다.   반복문을 돌며 ‘01’패턴과 ‘10’패턴을 조사한다 각각의 횟수를 count_0, count_1에 저장한다.   count_0과 count_1중 최소값을 return한다.   코드       def solution(str):         if str[-1] == '1':             str += '0'         else:             str += '1'         count_0 = 0         count_1 = 0              for i in range(len(str)-1):             if str[i]+str[i+1] == '01':                 count_0 += 1             if str[i]+str[i+1] == '10':                 count_1 +=1              return min(count_0,count_1)                    if __name__ == \"__main__\":         str = \"010\"         print(solution(str)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_03/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 만들 수 없는 금액",
        "excerpt":"이코테   그리디 만들 수 없는 금액(Python)   문제   N개의 동전을 갖고 있다.  N개의 동전을 이용하여 만들 수 없는 정수 금액 중 최솟값을 구하라.       예시   입력 : [3,2,1,1,9]  결과 : 8   풀이     고민을 좀 많이 했던 문제이다. 만들 수 있는 금액을 모두 구한 뒤 해당 금액에서 없는 금액중 최소값을 구하는 방식으로 접근했었다. 이렇게 문제를 풀면 n^2의 시간이 걸린다. 하지만, 해답에서는 n으로 풀고 있어 정답 코드를 배울 필요성이 있어 보인다. 정답 코드는 누적합을 사용한다.    solution1     동전이 모두 저장되어 있는 array를 정렬한다.   동전들의 모든 가능한 합이 저장될 set 타입의 변수를 선언한다. (set은 중복이 없다.)   1,1,2,3,9라면, 1, 1+1, 1+1+2, 1+1+2+3, 1+1+2+3+9 \\ 1, 1+2, 1+2+3, 1+2+3+9 \\ 2, 2+3, … 식으로  2중 포문을 돌리며 값을 저장한다.   이후 set의 max값 만큼 반복문을 돌며 만들 수 없는 최솟값을 구한다.   4번에서 구한 최소값을 return한다.   solution2     동전이 모두 저장되어 있는 array를 정렬한다.   target=1을 선언한다.(0인 동전은 없기 때문에)   array를 반복문을 돌며 동전을 하나씩 꺼낸다.   target이 동전보다 작다면 break 한다.(더이상 만들 수 없는 동전을 만났기 때문)   target이 동전보다 작지 않다면 target에 동전을 더해준다.   반복문을 빠져나오면 target을 return한다.      모든 것을 다 구해야만 가능하다고 생각해서 이중 포문을 돌았지만,  누적된 합은 다시 구해도 되지 않은 수이기 때문에 부등호를 사용하여 비교한 점이 인상 깊었다.    코드       def solution1(array):         array.sort()         money_set = set()         for i in range(len(array)):             sum = 0             for j in range(i,len(array)):                 sum += j                 money_set.add(sum)              for i in range(max(money_set)):             if i not in money_set:                 return i         return max(money_set)+1          def solution2(array):         array.sort()         target = 1         for x in array:             if target &lt; x:                 break             target += x              answer = target          if __name__ == \"__main__\":         array = [3,2,1,1,9]         print(solution2(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_04/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 볼링공 고르기",
        "excerpt":"이코테   그리디 볼링공 고르기(Python)   문제   두 사람이 서로 다른 무게의 볼링공을 고르려고 한다.  같은 무게의 공이 여러개 있다면 서로 다른 공으로 간주된다.  이 때 두 사람이 고를 수 있는 볼링공 번호의 조합의 경우의 수를 구하라.      예시   입력 : [1,3,2,3,2]  결과 : 8   풀이     정렬을 한 뒤에 자신과 다른 무게를 가지고 있는 볼링공을 차례로 비교하여 count하면 쉽게 풀 수 있는 문제다. 하지만, 나는 n^2으로 풀었고 답지는 n으로 풀었다. 남아있는 볼링공의 개수와 현재 해당하는 볼링공의 무게의 개수를 곱하면 더 빠른 시간복잡도로 문제를 해결할 수 있다. 조합을 위와 같은 방법으로 접근 할 수 있다는 것을 새롭게 배웠다.    solution1(n^2)     볼링공의 무게가 담겨져 있는 배열(array)를 정렬한다.   A 사람이 i번째 볼링 공을 골랐을 때 B가 고를 경우의 수를 이중포문을 돌려서 체크한다.(A와 무게가 다르다면 count +1을 해준다.)   이중포문을 돌릴 때 i번째 이후 공만 체크하면 되기 때문에 index와 value 두가지로 포문을 돌린다.   return count   solution2(n)     weight_list에 무게의 종류만큼 0으로 초기화한다.   볼링공의 무게가 담겨져 있는 배열을 반복문을 돌면서 볼링공의 무게에 해당하는 index에 값을 1씩 증가해준다.   볼링공의 최대 무게까지 반복문을 돈다.   현재 인덱스 무개의 볼링공의 개수를 전체 개수에서 제외해준다.   result에 현재 인덱스 무게의 볼링공 * 전체 개수를 계산하여 더해준다.   return result      조합 문제를 어떻게 접근하냐에 따라서 시간복잡도를 줄일 수 있다.  앞으로도 문제를 풀 때 최대한 시간복잡도를 생각하면서 풀 수 있도록 노력해야겠다.    코드       def solution1(array):         array.sort()         money_set = set()         for i in range(len(array)):             sum = 0             for j in range(i,len(array)):                 sum += j                 money_set.add(sum)              for i in range(max(money_set)):             if i not in money_set:                 return i         return max(money_set)+1          def solution2(array):         array.sort()         target = 1         for x in array:             if target &lt; x:                 break             target += x              answer = target          if __name__ == \"__main__\":         array = [3,2,1,1,9]         print(solution2(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_05/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 무지의 먹방 라이브(2019 카카오)",
        "excerpt":"이코테   그리디 무지의 먹방 라이브 - 2019 카카오 문제(Python)   문제   문제로 이동!   풀이     k만큼 반복문을 돌며 0을 만나면 패스하고 0이 아닌 값을 만나면 인자와 k값을 -1씩 하는 방식으로 처음 문제를 접근했다. index 접근은 array의 길이만큼 나눈 나머지로 접근함으로써 반복문 하나로 접근하였지만, 시간초과로 문제를 풀지 못하였다.     답지에서는 우선순위큐로 접근하였다. 다 먹는데 가장 적게 걸리는 음식들을 순서로 접근하였고, 이 때 하나의 음식을 다 먹는 시간이 k보다 커지면 반복문을 탈출하고 남은 값들 중에서 정답을 도출하였다.    solution2(fail)     k&gt;0 인 조건에서 while문을 돈다.   index를 1씩 증가하고 index를 array의 length로 나눈 나머지로 배열에 접근한다.   0이면 continue, 1이면 k와 인자를 -1씩 해준다.   탈출 시 index로 배열에 접근하여 해당 값이 0이 아니라면 index+1(음식은 1부터 시작)로 return 한다.   0일 경우 한바퀴를 돌면서 해당 index부터 순서로 0보다 큰 값을 찾는다.   한바퀴가 돌아도 찾아지지 않는다면 -1로 return, 찾아졌다면 해당 index로 return   solution3(solved)     array의 총합이 k보다 적으면 -1로 우선 return 하여준다.   (array의 값, array의 인덱스)로 값을 기준으로 정렬하여 우선순위큐에 넣어준다.   (현재 먹은 음식과 이전에 먹은 음식의 차이)와 (현재 배열의 길이) 를 곱하고 (이전 반복문까지 더해졌던 sum_value)와 더해서 k보다 커지면 반복문을 탈출한다.            위의 값이 k보다 크다면, 더이상 음식을 다 먹을 수 있는 경우가 아니기 때문에 반복문을 탈출하고 남은 횟수만큼 인덱스를 더해 결과를 도출한다.           반복문을 탈출했다면, 다시 인덱스 기준으로 정렬하고 결과값을 찾는다.      처음 문제를 풀었을 때 문제에서 순차적으로 접근하는 것 처럼 설명이 되어 있어 순차적으로 접근하면서 푸는 방법이 맞는 방법이라고 생각했다. 하지만, 문제에 대해 조금 더 생각했더라면, 우선순위큐를 생각할 수 있었을 것 같다. 다양한 유형을 풀어본다면, 어떤 유형으로 풀 수 있는 지에 대한 생각의 폭이 넓어질 것 같다.    새로 알게된 문법     solution1을 풀 때 리스트 컴프리헨션의 조건문에 대한 새로운 문법을 알게 되었다.       조건문이 뒤에 있을 때 : 조건문에 해당 하는 값 i만 추가   [i for i in array if i%2 == 0]     조건문이 앞에 있을 때 : if에 해당하는 값은 i, 아니면 else 뒤에 있는 값으로 추가   [i if i%2 == 0 else None for i in array]  코드       def solution(food_times, k):         length = len(food_times)         quotient = k // length         remainder = k % length         food_times = [v-quotient-1 if i&lt;remainder else v-quotient for i,v in enumerate(food_times)]         time_sum = sum([i for i in food_times if i&lt;0])         index = (remainder + time_sum) % length         if food_times[index] &lt;= 0:             for i,v in enumerate(food_times[index:]):                 if v &gt; 0:                     return i+index+1             return -1         return index               def solution2(food_times, k):         length = len(food_times)         index = -1         while k &gt; 0:             index += 1             if food_times[index % length] == 0:                 continue             else:                 food_times[index % length] -= 1                 k -= 1              index = (index + 1) % length              if food_times[index] &lt;= 0:             for i in range(length+1):                 if food_times[(index+i) % length] &gt; 0:                     return (index+i) % length + 1             return -1              return index+1               def solution3(food_times, k):         import heapq              if sum(food_times) &lt;= k:             return -1              q = []         for i in range(len(food_times)):             heapq.heappush(q, (food_times[i], i+1))              sum_value = 0         previous = 0              length = len(food_times)         while sum_value + ((q[0][0] - previous) * length) &lt;= k:             now = heapq.heappop(q)[0]             sum_value += (now - previous) * length             length -= 1             previous = now              result = sorted(q, key =lambda x: x[1])         return result[(k - sum_value) % length][1]               if __name__ == \"__main__\":         food_times = [3,1,1,1,2,4,3]         k = 12         print(solution3(food_times,k)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_06/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 완주하지 못한 선수(해시)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 해시 완주하지 못한 선수 파이썬(Python) 풀이   풀이로 이동!   문제풀이     딕셔너리에 선수의 이름을 key값으로, 중복된 선수의 이름을 체크하는 count를 value값으로 만들어준 뒤,  완주한 선수의 목록을 반복문을 돌며 count를 1씩 줄이며 마지막으로 남아있는 선수를 출력하면 된다. 파이썬에서 딕셔너리는 해시테이블이라고 볼 수 있다.    solution2(solved)     딕셔너리 변수를 하나 지정해준다.   참가자들의 반복문을 돌며 딕셔너리에 key값이 존재하지 않다면 value 0을, 존재한다면 value +1로 설정해준다.   완주자들의 반복문을 돌며 딕셔너리에서 key값을 조회하며 value를 -1씩 해준다.   반복문을 돌며 0보다 큰 값을 출력해준다.   solution3(solved)     hash값을 아주 잘 이용한 case여서 배워두면 유용하게 사용할 수 있을 것 같다.       딕셔너리 변수를 하나 지정해준다.   참가자들의 반복문을 돌며 딕셔너리 key값으로 참가자의 이름에 해당하는 hash값, value에는 참가자의 이름을 저장해준다.   추가적으로 해당 hash값을 모두 더하여 저장하는 temp 변수를 만든다.   완주자의 반복문을 돌며 완주자의 이름에 해당하는 hash값을 temp에서 계속 빼간다.   이후 temp의 남아있는 값으로 딕셔너리의 key값을 조회한다.   새로 알게된 문법     solution1은 시간초과로 문제를 해결하지 못하였는데 그 이유는 딕셔너리 컴프리헨션에서 사용한 count가 O(n) 시간을 가지고 있기 때문이다.    리스트 컴프리헨션만 존재하는 줄 알았지만, 컴프리헨션은 딕셔너리에서도 적용 가능했다.       a = {p:participant.count(p) for p in participant}  key:value 형식으로 저장한다.   코드       def solution(array, commands):         answer = []         for command in commands:             answer.append(sorted(array[command[0]-1:command[1]])[command[2]-1])         return answer          if __name__ == \"__main__\":         array = [1, 5, 2, 6, 3, 7, 4]         commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]]         print(solution(array, commands)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_06/",
        "teaser": null
      },{
        "title": "전역변수 vs 매개변수",
        "excerpt":"DFS 문제를 풀며   DFS 문제를 공부하며, 예제 코드를 봤는데, graph 변수를 전역변수로 선언하고 사용하고 있었다. 컴퓨터구조를 공부하면서, 전역변수는 메모리에 할당되고 함수의 일부 매개변수는 레지스터에 저장되어 훨씬 빠른 속도로 액세스된다고 이해했었다. 그렇다면 graph 변수를 dfs 함수의 인자로 넘겨줄 때, ‘전역변수를 사용하지 않고 매개변수로 넘겨주면 성능이 더 좋은 코드가 되지 않을까?’ 라는 궁금증에 휩싸여 풀던 문제를 내려놓고 열심히 구글링을 하기 시작하였다.   기존에 알고 있던 것  우선 두가지 생각을 했다. 첫번째, 전역변수는 메모리에 올라가기 때문에 액세스가 느리다. 두번째, 매개변수는 지역변수이지만, 재귀함수처럼 호출이 잦다면 해당 매개변수를 할당하고 해제하는 작업을 반복하면서 느려질 것이다. 첫번째 의견에 대해서는 지역변수의 액세스보다 전역변수의 액세스가 느리다는 것은 대충 ‘그렇게 들었다~’ 수준으로 알고 있었다. 두번째 의견은 컴퓨터 구조를 공부하며 어셈블리 코드에 대해서도 아주 살짝 공부를 했었는데, 함수를 호출하는 부분에서 매개변수의 할당과 해제에 대한 어셈블리 코드가 없다는 것은 알고 있었다. 그렇기 때문에 ‘함수의 호출이 잦아도 매개변수의 할당과 해제로 실행속도가 느려지거나 하진 않을 것이다.’  라는 결론을 내렸지만, 이 의견이 맞는지 조금 불안했다.   전역변수와 지역변수의 저장 위치  구글링의 결과, 전역변수와 함수로 인해서 호출된 지역변수는 모두 메모리에 위치한다. 하지만, 전역변수는 메모리에서 상대적으로 낮은 위치인 데이터 영역에 저장되고, 지역변수는 상대적으로 높은 위치인 스택 영역에 저장된다. 데이터 영역은 프로그램 끝나기 전까지 해제되지 않고, 스택 영역은 해당 함수가 리턴되면 해제된다. 또한 데이터 영역보다 스택 영역의 액세스가 빠르다.   캐시 적중  해당 데이터가 캐시 위에 올라와 있을 확률은 최근에 사용된 적이 있는 지역 변수쪽이 전역 변수쪽보다는 높다. 전역 변수는 비슷한 위치의 주소공간에 존재한다는 보장이 없다.  반대로 지역변수의 경우는 스택에 쌓이기 때문에, 모두 비슷한 위치에 존재한다. 결국 지역변수들은 한 캐시 블록 안에 올라가 있을 확률이 매우 높다.   컴파일러 최적화  C언어 기준으로, 전역 변수는 최적화에 불리하다. 전역 변수는 언제 그 값이 변경되는지 알 수 없기 때문에, 컴파일러가 최적화를 진행할 때 전역 변수를 제거하지 않는다. 즉, 컴파일러가 사용자의 의도를 모르기 때문에, 최적화를 하지 못하고 그대로 코드를 남겨둔다.   결론 : 매개변수가 전역변수보다 빠르다.  물론 모든 상황에서 매개변수로 전달하는 것이 전역변수보다 빠르지 않을 수 있다. 특정 블로그에서 실험했을 때 매개변수로 전달된 변수들을 전역변수로 변경하니 실행 시간이 2배 정도 향상되었다고 한다. 하지만, 최적화를 위해서 전역변수를 사용하는 것은 잘못된 방법이며, 더 적절한 알고리즘과 자료구조를 사용하는 것이 옳다. 물론 간단한 코드에서 전역변수로 전달을 하냐 매개변수로 전달을 하냐에 대해 아주 미미한 속도 차이 혹은 차이가 없을 수도 있겠지만, 항상 이러한 생각을 가지며 혹시 모를 병목 현상을 예방하는 것이 더 나은 프로그래머가 될 수 있는 길이라고 생각한다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "/cs/csetc_01/",
        "teaser": null
      },{
        "title": "[이코테/Python] DFS/BFS - 음료수 얼려 먹기",
        "excerpt":"이코테   DFS/BFS 음료수 얼려 먹기(Python)   문제   N x M 크기의 얼음 틀이 있다.  구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.  구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있을 경우 서로 연결되어 있는 것으로 간주한다.  이때 생성할 수 있는 총 얼음의 개수를 구하라.      예시    입력 :           [0,0,1,1,0]          [0,0,0,1,1]          [1,1,1,1,1]          [0,0,0,0,0]  결과 : 3   풀이     이 문제는 0이 연결되어 있는 부분들을 모두 찾아야된다. 그렇기 때문에 하나에서 연결된 부분의 끝까지 탐색하는 DFS(깊이우선탐색) 방법으로 접근하면 쉽게 풀 수 있다.       문제의 입력으로 주어진 그래프를 2중 반복문을 사용하여 모든 인자값을 탐색한다.   dfs 함수를 호출하여 해당 인자값으로부터 시작해서 얼음틀이 어디까지 연결되어 있는지를 체크한 후 1로 변경한뒤 전체 결과값에서 +1을 해준다.   dfs 함수는 재귀함수 형식으로 호출되며, 탐색을 시작한 값에서 상,하,좌,우 를 탐색하는 방식으로 dfs 함수를 재귀로 호출하여 체크해준다.   새로 알게된 문법     새로 알게된 ‘문법’ 까지는 아니지만, DFS/BFS를 배울 때 해당 예시로 그려진 그래프와 같은 그래프에만 적용되는 줄 알았다. 하지만 해당 문제 처럼 상하좌우를 강제적으로(ex.[x-1,y],[x,y+1]) 형식으로 조회하여 찾을 수 있다는 것을 알게 되었다. 하지만 이렇게 풀 경우 반복문을 세번이나 돌게 되면서 n^3인데 시간초과가 나지 않는 것이 조금 신기하다… 해당 부분은 조금 더 공부가 필요해보인다.    코드       def solution(graph):         result = 0         for i in range(len(graph)):             for j in range(len(graph[0])):                 # 현재 위치에서 DFS 수행                 if dfs(i, j, graph) == True:                     result += 1              print(result)               def dfs(x, y, graph):              # 주어진 범위를 벗어나는 경우에는 즉시 종료         if x &lt;= -1 or x &gt;= len(graph) or y &lt;= -1 or y &gt;= len(graph[0]):             return False              # 현재 노드를 아직 방문하지 않았다면         if graph[x][y] == 0:             graph[x][y] = 1             dfs(x-1, y, graph)             dfs(x, y-1, graph)             dfs(x+1, y, graph)             dfs(x, y+1, graph)             return True              return False               if __name__ == \"__main__\":         graph = [             [0,0,1,1,0],             [0,0,0,1,1],             [1,1,1,1,1],             [0,0,0,0,0]         ]              solution(graph) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_07/",
        "teaser": null
      },{
        "title": "[이코테/Python] DFS/BFS - 미로 탈출",
        "excerpt":"이코테   DFS/BFS 미로 탈출(Python)   문제   N x M 크기의 미로가 있다.  몬스터가 있는 곳은 0, 몬스터가 없는 곳은 1로 표시된다.  몬스터를 피해서 (0,0) 좌표에서 (N,M) 좌표까지 탈출해야한다.  이때 탈출까지의 최단 거리를 구하여라.      예시    입력 :       [1,0,1,0,1,0]      [1,0,1,1,1,1]      [1,0,1,1,1,0]      [1,0,1,0,1,0]      [1,1,1,0,1,1]  결과 : 14   풀이     이 문제는 1이 연결된 길을 찾으면 되는 문제이다. 최단 거리를 구하기 위해서 현재 위치에서 근접한 1의 위치를 찾으면 된다. 그렇기 때문에 BFS로 접근하였다. 하지만, 관건은 근접한 1의 위치를 찾고 최단거리를 계산하는 방법이다. 1을 만나게 되면, 이전 노드의 정보를 더해주는 방식으로 (1,1) 좌표에서 특정 노드까지의 최단거리를 모두 저장해주면 된다. 이후 (N,M)에 저장되어 있는 정보를 출력하면 된다.    solution1     탐색하기 위해 노드를 저장하는 deque 변수를 선언한다.            deque는 (x좌표,y좌표,해당노드까지의 최단 거리) 가 tuple 형식으로 저장된다.           deque가 비게 되면 탈출하게 되는 while문을 선언한다.   반복문을 돌며 첫번째로 deque를 pop하여 각각 x,y,v에 저장한다.   x와 y가 0보다 작거나 graph의 크기를 벗어나면 continue 해준다.   graph의 x, y좌표가 1이라면, 해당 노드에 v 값을 더해준다.   이후 deque에 해당 좌표 기준 상,하,좌,우 값을 추가하여 탐색할 수 있게 설정한다.   반복문이 끝나면 graph의 N,M 좌표에 해당하는 value를 return한다.   solution2     solution1과 로직은 같지만, solution2는 상하좌우를 배열에 저장하였고, 큐에는 x와 y좌표만 저장해두었다.    코드       from collections import deque          def solution1(graph):         queue = deque([(0,0,0)])         n = len(graph)         m = len(graph[0])              while queue:             x,y,v = queue.popleft()             if x&gt;=n or y&gt;=m or x&lt;0 or y&lt;0:                 continue             if graph[x][y] == 1:                 graph[x][y] += v                 queue.append((x+1, y, graph[x][y]))                 queue.append((x, y+1, graph[x][y]))                 queue.append((x-1, y, graph[x][y]))                 queue.append((x, y-1, graph[x][y]))              return graph[n-1][m-1]               def solution2(graph):         # 이동할 네 방향 정의(상, 하, 좌, 우)         dx = [-1, 1, 0, 0]         dy = [0, 0, -1, 1]              # graph 크기 정의         n = len(graph)         m = len(graph[0])              # BFS 소스코드 구현         def bfs(x, y):                  # 큐(Queue) 구현을 위해 deque 라이브러리 사용             queue = deque()             queue.append((x, y))                  # 큐가 빌 때까지 반복             while queue:                 x, y = queue.popleft()                 # 현재 위치에서 네 방향으로의 위치 확인                 for i in range(4):                     nx = x + dx[i]                     ny = y + dy[i]                     # 미로 찾기 공간을 벗어난 경우 무시                     if nx &lt; 0 or ny &lt; 0 or nx &gt;= n or ny &gt;= m:                         continue                     # 벽인 경우 무시                     if graph[nx][ny] == 0:                         continue                     # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록                     if graph[nx][ny] == 1:                         graph[nx][ny] = graph[x][y] + 1                         queue.append((nx, ny))                  # 가장 오른쪽 아래까지의 최단 거리 반환             return graph[n - 1][m - 1]                  return bfs(0,0)          if __name__ == \"__main__\":         graph = [             [1,0,1,0,1,0],             [1,0,1,1,1,1],             [1,0,1,1,1,0],             [1,0,1,0,1,0],             [1,1,1,0,1,1]         ]         print(solution1(graph)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_08/",
        "teaser": null
      },{
        "title": "[이코테/Python] 이진 탐색 - 부품 찾기",
        "excerpt":"이코테   이진탐색 부품 찾기(Python)   문제   전자 매장에는 부품이 N개 있다.   어느날 손님이 M개 종류의 부품을 구매하려고 한다.   이 때 매장에서 손님이 사려고 하는 부품이 있는지 yes와 no 형태로 구하라.      예시   입력 :           array = [9, 3, 7, 9, 2]           target = [5, 7, 9]   결과 : no yes yes   풀이     탐색시간을 줄이기 위해서는 array를 정렬하고 이진 탐색으로 target에 저장된 배열의 인자를 하나씩 탐색해나가면 쉽게 풀 수 있다.       array를 내림차순으로 정렬   target 배열의 인자를 하나씩 꺼내서 target으로 설정   array의 end가 start보다 크거나 같을 동안 while문 반복   이진탐색 알고리즘을 사용하여 탐색이 완료되면 Yes, 탐색이 되지 않으면 while 문 밖에서 No(No 저장 때 array[mid]가 t가 아닐 때의 조건을 걸어 둔 이유는 무차별적으로 No가 저장되는 것을 방지하기 위함)   다른 풀이     이진탐색 뿐만 아니라, count sorting, set 자료형을 사용하여 풀 수 있다. set 자료형은 {} &lt;- 로 array를 묶어 target in {} 문법을 사용하여 쉽게 풀 수 있다.    코드       def solution(array, target, start, end):         array.sort()         result = []         for t in target:             while start &lt;= end:                 mid = (start + end) // 2                 if array[mid] == t:                    result.append(\"Yes\")                    break                 elif array[mid] &gt; t:                     end = mid - 1                 else:                     start = mid + 1             if array[mid] != t:                 result.append(\"No\")             start = 0             end = len(array)-1              return result               def solution2(array, target):         def binary_search(array, target, start, end):             while start &lt;= end:                 mid = (start + end) //2                 if array[mid] == target:                     return mid                 elif array[mid] &gt; target:                     end = mid - 1                 else:                     start = mid + 1                  return None              store = []              for i in target:             result = binary_search(array, i, 0, len(array)-1)             if result != None:                 store.append(\"Yes\")             else:                 store.append(\"No\")              return store               if __name__ == \"__main__\":         array = [9, 3, 7, 9, 2]         target = [5, 7, 9]         print(solution(array, target, 0, len(array)-1)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_09/",
        "teaser": null
      },{
        "title": "[이코테/Python] 이진 탐색 - 나무 자르기",
        "excerpt":"이코테   이진탐색 나무 자르기(Python)   문제   문제로 이동!   풀이     나무를 자를 수 있는 길이는 0부터 가장 긴 나무의 길이다. 0~가장 긴 나무 길이를 이진 탐색을 하며 잘려진 나무의 합이 목표 길이보다 크다면 자른 길이를 저장한다. 최대값을 구하기 위해서 탐색이 종료될 때까지 조건에 맞는 길이를 찾아간다.       나무 길이의 최대 값을 찾는다.   start는 0, end는 나무 길이의 최대 값으로 설정한다.   중간 값을 찾고, 나무 길이 - 중간 값을 리스트 컴프리헨션으로 음수가 되는 값은 0으로 변경하여 전체 합을 구한다.   전체합과 target을 비교하여 전체합 보다 target이 작거나 같으면 결과에 중간값을 저장한다.   탐색이 끝날 때 까지 반복하며 최대 값을 구한다.   추가 설명     해당 문제는 전형적인 이진 탐색 문제이자, 파라메트릭 서치parametric search 유형의 문제라고 한다. “원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제”에 주로 사용한다. 예를 들어 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진 탐색으로 결정 문제를 해결하며 범위를 좁혀갈 수 있다.    코드            def solution(array, target):         end = max(array)         return binary_search(array, target, 0, end)               def binary_search(array, target, start, end):         result = 0         while start &lt;= end:             mid = (start + end) // 2             total = sum([0 if i-mid &lt; 0 else i-mid for i in array])             if total &lt; target:                 end = mid - 1             else:                 result = mid                 start = mid + 1              return result          if __name__ == \"__main__\":         target = 6         array = [19, 15, 10, 17]         print(solution(array, target)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_10/",
        "teaser": null
      },{
        "title": "[DataEngineering] 첫 번째 데이터엔지니어 인턴 회고",
        "excerpt":"첫 회사 생활  4학년 1학기에 졸업작품을 마치고 현업을 경험하고 싶어 인턴을 지원했다. 그 때 당시에는 아직 세세한 직무를 정하지 않아서, 평소에 관심 있던 백엔드와 데이터엔지니어 두 분야에 지원했다. 둘 중 더 좋은 조건의 인턴을 붙게 된다면 해당 직무를 경험해보자는 생각이였다. 지원은 많이 했지만, 코테 준비가 미흡해서 면접까지 간 회사는 거의 없었다. 코테를 보지 않는 회사 중 두 곳을 면접을 보게 되었는데, 첫 번째 회사의 면접 경험은 정말 최악이었다. 두 번째 회사의 면접은 정말 마음에 들었다. 내가 했던 프로젝트에 대해서 상세하게 질문이 들어왔고, 꼬리에 꼬리를 무는 질문이 많았다. 면접을 하면서도 내가 부족한 부분이 무엇인지 더 공부해야할 부분들을 알게 되는 신기한 경험을 하게 되었다. 면접을 진행하면서 모르겠다고 답변했던 것들 투성이여서 그 때 당시 내 현주소도 알게 되면서 조금 부끄러웠던 것 같다. (졸업작품을 막 끝내고 더닝크루거의 우매한 봉우리에 위치 해  있었던 것 같다…)   1주일 뒤에 합격 통지를 받았고, 데이터엔지니어 챕터의 인턴으로 합류하게 되었다. 굉장히 설레면서도 무서웠다. 할 수 있는 것은 야매로 프로젝트를 했던 경험이 전부인데,  현업에 뛰어들어 내가 1인분 역할을 할 수 있을지 정말 미지수였다. 하지만, 평소에 궁금했던, 현업에서는 코딩을 어떻게 하는지, 어떤 프로젝트들을 맡아 진행하는지,  팀원들간의 의사소통은 어떻게 하는지 등등… 을 해결할 수 있어서 신나기도 했다.   좌절의 연속  인턴 생활을 하면서 내 자신이 프로그래머로서 너무나도 부족한 사람이구나를 여러번 깨달았다.   첫번째, 업무를 진행하기 위해서 환경세팅을 하는 모든 것이 어려웠다. 나는 R로 작성되어 있는 ETL 레거시 파일들을 python 으로 migration 하는 업무를 맡았다.  Docker를 사용해서 python 개발 환경을 구축해야 했고, git-secret 등록, git-secret을 등록하기 위해서 GPG Key 생성, SSH Key 생성, AWS MFA 설정 등등… 사용 방법이 작성되어 있는 문서를 봐도 쉽게 따라할 수 없는 것들이였다.   두번째, 챕터내의 전반적인 개발 프로세스를 따라하는 것이 어려웠다. 개발자들은 소통을 위한 tool을 굉장히 많이 사용하고 있었다. Slack 부터 사용해서 Notion, Jira, Ally, Github 등등… Slack을 통한 간단한 메세지와 Notion을 통한 문서화는 어렵지 않았지만, 새로운 task를 부여 받았을 때 Jira로 관리하는 것이 뭔가 어색하기도 해서  어렵게 느껴졌다. Jira를 사용할 때 문서를 작성하는 것도 어색했던 것 같다. 그리고 이러한 소통을 하면서 사용하는 단어들(예를들어 에픽, man month, OKR 등등…) 또한 처음 들어본 단어들이 많아서 의사소통을 하면서 처음에 적응하기 쉽지 않았다.   세번째, 사내에 다양한 세미나에 참여했는데, 반 이상은 이해하지 못했다. 가장 크게 좌절했던 부분이다. 다른 팀원들은 세미나 주제에 대해서 일정 시간동안 문서를 읽고  다양한 의견들을 서로 주고 받는데, 나는 문서를 읽으면서도 이해하지 못하는 것들이 태반이였고, 당연하지만 여러 의견들도 나누지 못했다. 여기서 나는 이론적으로도 실무적으로도 너무나도 부족한 개발자라는 것을 뼈저리게 느꼈다. 예를들어 우리 DE 챕터에서는 PostgreSQL을 사용했는데, 세미나 주제가 PostgreSQL의 인덱싱 알고리즘이였다. PostgreSQL 에서 인덱싱에 사용되는 여러 알고리즘들을 소개하고, 해당 방법들이 어떤 데이터에서 유용한지에 대한 공식 도큐멘테이션을 읽고 서로 의견을 나누는 세미나다. 하지만 나는  ‘인덱싱’ 이라는 개념 조차도 정확히 알고있지 못하는 상태였다.   마지막은 코딩이다. ETL을 작성하면서 python pandas를 가장 많이 사용하였는데, 코드 리뷰를 받으면서 내가 알지 못하는 문법들이 굉장히 많았고, 프로그램의 속도에 관해서  처음으로 고민을 시작하게 됐던 것 같다. Unittest를 작성하면서도 모르는 개념들 투성이였다. R로 작성되어 있는 코드를 실행하면서 실행결과를 비교해가면서 migration 했는데, 코딩 속도도 굉장히 만족스럽지 못했고, Terminal 안에서 파일들을 열고 수정하는 부분들도 부족함을 많이 느꼈다. &lt;- 이 부분에 대해서 얘기하고 싶은 것이 하나 있는데, 같은 팀원이 했던 얘기가 굉장히 인상 깊었다. “GUI 툴로는 사용자가 원하는 만큼 접근할 수 없다. 프로그램에 컨트롤 당하면 안되고 프로그램 위에서 컨트롤 할 줄 알아야 한다.”  GUI 툴에서 지원하는 기능에 너무 기대지 않고 직접 해당 기능들을 만질 수 있어야 된다는 의미 같다.   어깨 너머로 배운 것들  좌절도 많이 했지만, 독학으로는 배우지 못했던 것들을 어깨 너머로 많이 배운 것 같다. 내가 맡았던 업무에 대한 프로세스를 간단히 얘기해보자면,  레포 세팅을 하면서 webhook과 git-secret, AWS, GPG 를 secret action에 등록해준다. Docker로 해당 task의 환경을 세팅해주고, Dockerfile을 빌드하기 전에 AWS ECR 레포와 DB 환경 변수를 추가해주고 빌드를 진행한다. ETL과 Unittest를 모두 작성하면 해당 파일에 lint를 적용해 일정 점수 이상을 받게 되면 black 과 isort로 한번 더 파일을 정리해준다. 이후에 work branch 에서 test branch로 merge하게 되면, Git Action에서 CI/CD가 자동으로 돌고 AWS ECR에 생성했둔 레포에 해당 ETL 파일의 이미지가 저장된다. 해당 이미지를 가지고 Airflow에 Dag를 작성해 배포해준다.   ETL 프로세스에 대해 전반적으로 배울 수 있었던 것 같다. 추가적으로 공부하고 싶은 부분이 있다면, ETL과 unittest 작성 부분을 제외하고 나머지 모두 다이다. 나 혼자서 CI/CD를 자동으로 구축해보고 싶고, Airflow를 구축해서 자동으로 배포도 해보고 싶다. 또한 Dockerfile을 만들어 python 개발 환경을 구축해보고 싶다.     위의 것들은 개인 프로젝트로 진행해볼 예정이다! 위의 것들을 적용시키기 위한 좋은 아이디어를 생각중이다…    또한 팀내 다양한 문서와 세미나를 통해 데이터엔지니어가 알고 있어야할 개념들을 많이 알게 되었다. 입사하기 전에는 데이터웨어하우스의 개념조차도 몰랐었던걸 비교하면  굉장히 다양한 개념(딱 개념 수준정도만…)을 알게 된 것 같다.   앞으로의 방향성  어쩌다보니 다음 목적지도 데이터엔지니어로 정하게 됐다. 인턴을 하면서 부족했던 CS 지식들은 독학으로 채워가고 있다. 어느정도 CS 공부가 마무리 되면(공부에 마무리는 없지만…) 개인 프로젝트를 진행하면서 인턴 생활을 하면서 직간접적으로 배웠던 것들을 직접 적용해볼 생각이다. 또한 데이터엔지니어 과정의 국비교육도 수강할 계획에 있다. 앞으로 신입 데이터엔지니어가 되기 위해 필요한 지식들을 하나씩 쌓아가면서 든든한 데이터엔지니어가 되어보겠다.   ","categories": ["DataEngineering"],
        "tags": ["DataEngineering"],
        "url": "/dataengineering/de_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 07 링커",
        "excerpt":"Chapter 07. 링커     링킹은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파이로 만드는 작업이다.            링킹은 컴파일 시에 수행할 수 있다.       로더에 의해 로드 타임에, 응용프로그램에 의해 실행 시에도 수행될 수 있다.           링커는 소프트웨어 개발 시에 중요한 역할: 독립적인 컴파일을 가능하게 하기 때문이다.   링커를 배우는 이유            큰 프로그램을 작성하는 데 도움이 된다.       위험한 프로그래밍 에러를 피할 수 있다.       어떻게 언어의 변수 영역 규칙이 구현되었는지 이해하는 데 도움이 된다.       다른 중요한 시스템 개념을 이해할 수 있게 된다.       공유 라이브러리에 대해 이해할 수 있다.           7.1 컴파일러 드라이버     대부분의 컴파일 시스템은 사용자를 대신해서 언어 전처리기, 컴파일러, 어셈블러, 링커를 필요에 따라 호출하는 컴파일러 드라이버를 제공한다.   컴파일 순서            C 전처리기(cpp)로 main.c -&gt; ASCII 중간 파일인 main.i로 번역       C 컴파일러(cc1)로 main.i -&gt; ASCII 어셈블리 언어 파일인 main.s로 번역       어셈블러(as)로 main.s -&gt; 재배치 가능한 바이너리 목적파일인 main.o로 번역       링커(ld)로 main.o &amp; sum.o 두개를 연결 -&gt; 실행 가능 목적파일 prog 생성       로더라고 부르는 운영체제 내의 함수를 호출 -&gt; 로더는 실행파일 prog의 코드와 데이터를 메모리로 복사하고, 제어를 프로그램의 시작 부분으로 전환한다.              7.2 정적연결     정적 링커는 재배치 가능한 목적파일들과 명령줄 인자들을 받아들여 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 생성한다.   실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행한다.            심볼 해석 symbol resolutions: 각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결하는 것이다.       재배치 Relocation: 링커는 섹션들을 각 심볼 정의와 연결시켜 재배치한다.           7.3 목적파일     세가지 목적파일이 있다.            재배치 가능 목적파일 Relocatable object file: 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함       실행 가능 목적파일 Executable object file: 메모리에 직접 복사될 수 있고 실행될 수 있음       공유 목적파일 Shared object file: 로드타임 또는 런타임 시에 동적으로 링크되고 로드될 수 있는 목적파일           컴파일러와 어셈블러는 재배치 가능 목적파일을 생성, 링커는 실행 가능한 목적파일을 생성   7.4 재배치 가능 목적파일        위의 그림은 전형적인 ELF(Executable and Linkable Format) 재배치 가능 목적파일의 포맷이다.            .text: 컴파일된 프로그램의 머신 코드       .rodata: printf 문장의 포맷 스트링       .data: 초기화된 전역변수 및 정적변수       .bss: 초기화되지 않은 또는 0으로 초기화된 전역변수 및 정적변수       .symtab: 프로그램에서 정의되고 참조되는 전역변수들과 함수에 대한 정보를 가지고 있는 심볼 테이블       .rel.text: 다른 목적 파일들과 연결할 때 링커가 수정해야하는 .text 섹션 내 위치들의 리스트       .rel.data: 전역변수들에 대한 재배치 정보       .debug: 프로그램 내에서 정의된 지역변수들과 typedef       .line: 최초 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑       .strtab: 섹션 이름들을 위한 스트링 테이블           7.5 심볼과 심볼 테이블     재배치 가능 목적 모듈 m은 m에 의해서 정의되고 참조되는 심볼들에 대한 정보를 포함하는 심볼 테이블을 가지고 있다.            m에 의해 정의되고 다른 모든 모듈들에 의해서 참조될 수 있는 전역 심볼                    전역                       m에 의해 참조되지만 다른 모듈에 의해 정의된 전역 심볼                    external                       m에 의해서 배타적으로 참조되고 정의된 지역 심볼                    static                              지역 변수는 런타임에 스택에 의해서 관리되며 링커에는 관심거리가 아니다.            .symtab 섹션의 ELF 심볼 테이블은 엔트리들의 배열을 포함하고 있다.             테이블 엔트리가 없는 의사 섹션pseudo section 이 존재한다.             ABS: 재배치해서는 안 되는 심볼       UNDEF: 정의되지 않은 심볼, 해당 모듈에서는 참조만 되고 다른 곳에서 정의된 심볼들을 위함       COMMON: 아직 할당되거나 초기화되지 않은 데이터 객체를 위함              COMMON: 초기화하지 않은 전역변수들, .bss: 초기화하지 않은 정적변수들과 0으로 초기화된 전역변수나 정적변수들    7.6 심볼 해석     링커는 자신의 입력 재배치 가능 목적파일들의 심볼 테이블로부터 정확히 한 개의 심볼 정의에 각 참조를 연결시켜서 심볼 참조를 해석한다.   컴파일러가 현재 모듈에서 정의되지 않은 심볼을 만나면, 다른 모듈에서 정의되어 있다고 가정하고 링커 심볼 테이블 엔트리를 생성하며, 링커가 이것을 처리하도록 남겨둔다.   7.6.1 링커가 중복으로 정의된 전역 심볼을 해결하는 방법     링커의 입력은 여러 개의 재배치 가능한 오브젝트 모듈들이다.            일부는 지역적이다(정의된 모듈 내에서만 볼 수 있는).       일부는 전역적이다(다른 모듈에서도 볼 수 있는).           컴파일러는 각 전역 심볼을 어셈블러로 강하게 또는 약하게 보내 심볼 테이블에 묵시적으로 인코딩하게 한다.            함수들과 초기화된 전역변수들은 강한 심볼       비초기화된 전역변수들은 약한 심볼이다.           링커는 중복된 심볼 이름을 처리하기 위해서 다음과 같은 규칙을 사용한다.            동일한 이름을 갖는 복수의 강한 심불은 허용 X       동일한 이름의 강한 심볼과 다수의 약한 심볼들이 있으면 강한 심볼 선택       동일한 이름의 여러 개의 약한 심볼이 있으면 어떤 약한 심볼을 선택해도 관계 X           7.6.2 정적 라이브러리와 링크하기     모든 컴파일 시스템은 관련된 객체 모듈들을 정적 라이브러리라고 부르는 한 개의 파일로 패키징하는 매커니즘을 제공한다.            이 라이브러리는 다음에 링커의 입력으로 제공될 수 있다.              컴파일러 개발자들이 라이브러리의 다양한 함수들을 정적 라이브러리의 혜택 없이 사용자들에게 재공하려면 컴파일러가 직접 함수의 코드를 생성하거나 한 개의 재배치 가능 목적 모듈에 저장하거나 해야한다. 하지만 이런 방법들은 상당한 복잡성을 더하거나 디스크 공간을 극도로 낭비한다. 위와 같은 접근 방법의 단점들을 해겨하기 위해 정적 라이브러리 개념이 개발되었다.         위 그림은 정적 라이브러리 연결 시 링커의 동작을 요약한 것이다.   7.6.3 링커가 참조를 해석하기 위해 정적 라이브러리를 사용하는 방법     링커는 실행파일을 구성하기 위해 합쳐질 재배치 가능 목적파일들의 집합 E, 미해석 집합 U, 이전 입력파일에서 정의된 심볼 집합 D를 유지한다.            입력파일 f에 대해서 링커는 f가 목적파일 또는 아카이브인지 결정한다.       f가 목적파일이면 f를 E에 추가하고 U와 D를 갱신한다.       f가 아카이브라면, 링커는 U 안의 미해석 심볼들을 아카이브의 멤버들에 의해 정의된 심볼들과 매칭하려고 시도한다.       심볼을 정의한다면 m은 E에 추가되고 U와 D를 갱신한다.       위 과정을 U와 D가 더 이상 바뀌지 않는 일정 지점까지 반복 실행한다.       스캔을 끝마칠 때 U가 비어있지 않다면 에러 출력, 그렇지 않다면 E에 있는 목적파일들을 합치고 재배치해서 출력 실행파일을 만든다.              위의 알고리즘은 명령줄의 라이브러리와 목적파일의 순서가 중요한 이유가 된다.    7.7 재배치     링커가 심볼 해석 단계를 완료하면, 코드 내 각 심볼 참조는 정확히 한 개의 심볼 정의에 연결된다.(입력 모듈 중 하나의 심볼 테이블 엔트리로 연결됨)   이후 재배치를 하게 된다. 재배치는 두 단계로 구성된다.            섹션과 심볼 정의를 재배치한다.       섹션 내 심볼 참조를 재배치한다.           7.7.1 재배치 엔트리     어셈블러가 목적 모듈을 생성할 때, 어셈블러는 코드와 데이터가 궁극적으로 메모리 어디에 저장될지 알지 못한다.            어셈블러가 위치를 알지 못하는 객체로의 참조를 만나면, 링커에게 이 참조를 어떻게 수정하는지 알려주는 재배치 엔트리를 생성한다.                 재배치 타입            R_X86_64_PC32: 32비트 PC-상대주소를 사용하는 참조를 재배치한다.       R_X86_64_32: 32비트 절대주소를 사용하는 참조를 재배치한다.           7.7.2 심볼 참조의 재배치        위의 그림은 링커의 재배치 알고리즘을 위한 의사코드이다.   7.8 실행 가능한 목적파일         실행 가능 목적파일의 포맷은 재배치 가능한 목적파일의 포맷과 유사하다.            .text, .rodata, .data 섹션들이 각자의 최종 런타임 메모리 주소로 재배치되었다.       _init는 프로그램의 초기화 코드에서 호출한다.       실행파일이 완전히 링크(재배치) 되었기 때문에, .rel 섹션을 필요로 하지 않는다.           ELF 실행파일들은 연속적인 메모리 세그멘트에 매핑된 연속적인 실행 가능 파일들의 덩어리로 메모리에 로드하기 쉽도록 설계되었다.            이 매핑은 프로그램 헤더 테이블에 설명되어 있다.           모든 세그먼트 s에 대해, 링커는 다음과 같이 시작주소를 선택해야 한다.            vaddr mod align = off mod align       align은 프로그램 헤더에 명시된 정렬(2^21 = 0x2000000)이다.       이러한 정렬 요구사항은 프로그램이 실행될 때 목적파일의 세그먼트들이 메모리로 효과적으로 전송될 수 있도록 하는 최적화의 결과다.                    가상메모리가 크기가 큰 연속된 2의 제곱 크기의 바이트 묶음으로 구성되어 있는 방식이기 때문이다.                           7.9 실행 가능 목적파일의 로딩     실행 가능 목적파일 prog를 실행한다.   쉘은 로더loader 라고 알려진 메모리 상주 운영체제 코드를 호출해서 prog를 실행한다.   로더는 디스크로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사한다.   해당 프로그램의 첫 번째 인스트럭션, 즉 엔트리 포인트로 점프해서 프로그램을 실행한다.        모든 실행 중인 리눅스 프로그램은 위의 그림과 유사한 런타임 메모리 이미지를 가진다.   7.10 공유 라이브러리로 동적 링크하기     정적 라이브러리들은 다른 모든 소프트웨어처럼 관리해야 하고 주기적으로 갱신해야한다.   공유 라이브러리들은 정적 라이브러리의 단점들을 극복한다.            공유 라이브러리는 런타임이나 로드타임에 임의의 메모리 주소에서 로드되고, 메모리에서 프로그램으로 연결될 수 있는 목적 모듈이다.       해당 과정을 동적 링킹이라고 한다.       리눅스 시스템에서 .so 확장자, 윈도우 시스템에서 DLL(dynamic link libraries)이라고 부른다.           공유 라이브러리들은 두 가지 다른 방법으로 “공유”된다.            어떤 주어진 파일 시스템에서, 특정 라이브러리에 대해 정확히 한 개의 .so 파일만이 존재한다.                    .so 파일 내의 코드와 데이터는 이 라이브러리를 참조하는 모든 실행 가능한 목적파일들에 의해 공유된다.                       메모리에 있는 공유 라이브러리의 .text 섹션은 서로 다른 실행중의 프로세스들에 의해 공유될 수 있다.                위의 그림은 공유 라이브러리로 동적 링크 과정을 요약한 것이다.   기본 아이디어는 링킹의 일부는 실행 가능 파일이 생성될 때 정적으로 수행하고, 프로그램이 로드될 때 링킹 작업을 동적으로 완료하는 것이다.   7.11 Applications 으로부터 공유 라이브러리를 로드하고 링크하기     응용프로그램이 돌고 있는 동안에 동적 링커에게 응용프로그램을 컴파일 시에 라이브러리와 링크할 필요 없이 임의의 공유 라이브러리를 로드하고 링크할 것을 요청할 수도 있다.   기본 아이디어는 공유 라이브러리에서 동적 콘텐츠를 생성하는 각 함수들을 패키지 하는 것이다.            서버는 동적으로 적당한 함수를 로드하고 링크한 뒤에 직접 호출한다.       함수는 서버의 주소공간에 캐시된 상태로 남으며, 후속 요청들은 간단한 함수 호출하는 비용만으로 처리될 수 있다.           7.12 위치-독립성 코드(PIC)     공유 라이브러리를 사용하는 주목적은 다수의 실행되고 있는 프로세스들이 메모리 내에서 동일한 라이브러리 코드를 공유하도록 하는 것이며, 귀중한 메모리 자원을 절약하는 것이다.            한 가지 접근 방법은 공유 라이브러리를 사전에 정해진 주소공간 블록에 할당 하는 것이다.                    단점 : 사용하지 않을 때도 할당, 메모리 블록들이 중첩되지 않도록 보장해줘야 함                           위의 문제점을 피하기 위해 공유 모듈들의 코드 일부분을 컴파일해서 링커에 의해 수정되지 않고도 이들이 메모리 어디든지 로드될 수 있도록 한다.            어떠한 재배치 작업 없이 로드될 수 있는 코드는 위치-독립성코드라고 한다.(PIC)              PIC와 GOT, PLT는 아직 이해를 하지 못해 좀 더 찾아보고 공부해야 한다.    7.13 라이브러리 삽입     컴파일 삽입   링크 삽입   런타임 삽입   7.14 요약     링킹은 컴파일 시에 정적 링커에 의해 수행될 수 있으며, 로드타임과 런타임에는 동적 링커에 의해 수행된다.   목적 파일들은 세 가지 형태로 나타난다.            재배치 가능: 정적 링커에 의해 실행 가능 목적파일로 연결       실행 가능: 메모리에 로드되고 실행       공유: 공유 라이브러리           링커의 두 가지 주요 임무            전역 심볼들이 유일한 정의에 연결되는 경우 심볼 해석       재배치 작업           로더는 실행파일의 내용을 메모리로 매핑하고 프로그램을 실행한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_23/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 08 예외적인 제어흐름",
        "excerpt":"Chapter 08. 예외적인 제어흐름     프로세서에서 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터는 연속된 값들을 가정한다.            인스트럭션 I에 대응되는 주소가 ak -&gt; ak+1 로의 전환은 제어이동이라고 부른다.       이러한 제어이동의 배열은 제어흐름 또는 프로세서의 제어흐름이라고 부른다.           프로그램의 실행과는 반드시 관련되어 있지 않은 시스템 상태의 변화에도 반응할 수 있어야 한다.            현대의 시스템들은 갑작스런 변화를 만드는 방법으로 이러한 상황에 반응한다.       일반적으로 이와 같은 급격한 변화를 예외적인 제어흐름exceptional control flow(ECF)라고 한다.           ECF의 중요성            ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.       ECF를 이해하면 어떻게 application들이 운영체제와 상호작용하는지를 이해할 수 있다.       ECF는 컴퓨터 시스템에서 동시성을 구현하는 기본 메커니즘이다.       ECF를 이해하면소프트웨어적인 예외상황이 어떻게 동작하는지 이해할 수 있다.              7장까지는 시스템에 대한 application이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다. 98장은 application이 운영체제와 어떻게 상호작용하는지 배우게 되는 측면에서 전환점이라고 볼 수 있다.       컴퓨터 수준에 존재하는 ECF의 다양한 형태            하드웨어와 운영체제의 교차점에 놓인 예외       application에게 운영체제 내부로 엔트리 포인트를 제공하는 예외인 시스템콜       application과 운영체제의 교차점에 위치한 프로세스와 시그널       비지역성 점프 - ECF의 응용수준           8.1 예외상황     예외상황은 부분적으로는 하드웨어와 운영체제에 의해서 구현된 예외적인 제어흐름의 한가지 형태다.        위의 그림은 예외상황의 기본 아이디어다.   프로세서가 이벤트(상태 변화)가 발생했다는 것을 감지하면, 예외 테이블이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 간접 프로시저 콜을 하게 된다.   예외처리 핸들러가 처리를 끝마치면, 다음 세 가지 중의 한 가지 일을 발생한다.            핸들러는 제어를 현재 인스트럭션으로 돌려준다.       핸들러는 제어를 다음 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션으로 돌려준다.       핸들러는 중단된 프로그램을 종료한다.           8.1.1 예외처리     한 시스템 내에서 가능한 예외상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다.   시스템 부팅 시, 운영체제는 예외 테이블이라고 하는 점프 테이블을 할당하고 초기화해서 엔트리 k가 예외상황 k에 대한 핸들러의 주소를 갖는다.   런타임에 프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다.   k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다.   예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작 주소는 ‘예외 테이블 베이스 레지스터’라는 특별한 CPU 레지스터에 저장되어 있다.             위의 그림은 예외테이블이다.            예외상황과 프로시저 콜의 차이점             프로시저 콜: 스택에 리턴주소 푸시, 예외상황: 현재 또는 다음 인스트럭션       핸들러가 리턴할 때 중단된 프로그램을 다시 시작하기 위해 스택 상에 추가적인 프로세서 상태를 푸시한다.       모든 아이템들은 사용자 스택 위가 아니라 커널 스택 상에 푸시된다.       예외 핸들러는 ‘커널 모드’에서 돌아간다.           8.1.2 예외의 종류     예외상황은 네 가지 종류를 구분할 수 있다.            인터럽트       트랩       오류fault       중단abort           인터럽트     프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 비동기적으로 발생한다.(특정 인스트럭션을 싫애해서 발생한 것이 아니라는 의미)   핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.      인터럽트를 제외한 나머지 예외의 종류들은 동기적으로 일어난다.    트랩과 시스템 콜     의도적인 예외상황으로, 어떤 인스트럭션을 실행한 결과로 발생한다.   트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다.   트랩의 가장 중요한 사용은 시스템콜이라고 알려진 사용자 프로그램과 커널 사이의 프로시저와 유사한 인터페이스를 제공하는 것이다.   시스템 콜은 ‘커널 모드’에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.   오류(fault는 error와 다르다.)     오류는 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생한다.   핸들러가 에러 조건을 정정한다면, 제어를 오류를 발생시킨 인스트럭션으로 돌려주어 거기서부터 재실행한다.   정정하지 못한다면, 커널 내부의 abort 루틴으로 리턴해서 프로그램을 종료한다.   중단 abort     중단 핸들러는 절대로 응용프로그램으로 제어를 리턴하지 않는다.   8.1.3 리눅스/x86-64 시스템에서의 예외상황   오류와 중단     나누기 에러: 0으로 나누려할 때   일반 보호 오류: 프로그램이 가상메모리의 정의되지 않은 영역을 참조하거나 read-only를 쓰려고 하기 때문에 발생   페이지 오류: 가상메모리 페이지 오류   머신 체크: 오류 인스트럭션을 실행하는 동안에 검출된 치명적인 하드웨 에러의 결과로 발생   시스템 콜     리눅스는 파일을 읽거나 쓸 때, 또는 새로운 프로세스를 만들 때 응용프로그램이 사용할 수 있는 수백 개의 시스템 콜을 제공한다.   x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해서 제공된다.        위의 그림은 리눅스 x86-64 시스템의 주요 시스템 콜   8.2 프로세스     예외상황은 프로세스 개념을 운영체제 커널이 제공할 수 있게 하는 기본 구성 블록이다.   프로세스의 고전적인 정의는 실행 프로그램의 인스턴스이다.   시스템 내의 각 프로그램은 어떤 프로세스의 문맥context에서 돌아간다.   사용자가 실행 목적파일의 이름을 쉘에 입력해서 프로그램을 돌릴 때마다 쉘은 새로운 프로세스를 생성하고, 실행 목적파일을 이 새로운 프로세스의 문맥에서 실행한다.   프로세스가 application에 제공하는 주요 추상화            프로세서를 혼자서 사용한다는 착각을 제공하는 독립적 논리 제어 흐름       혼자서 메모리 시스템을 가진다는 착각을 제공하는 사적 주소공간           8.2.1 논리적인 제어흐름     논리흐름            프로그램과 동적으로 런타임에 링크된 공유 객체 내의 인스트럭션들에게 일련의 프로그램 카운터 PC 값들이 대응된다는 것을 관찰할 수 있다.       이러한 PC 값들의 배열을 논리적 제어흐름 또는 논리흐름이라고 부른다.                위의 그림은 논리적 제어흐름이다.            하나의 프로세서를 사용해서 여러 프로세스들이 교대로 돌아간다.           8.2.2 동시성 흐름     논리흐름은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 갖는다.            예외 핸들러, 프로세스, 시그널 핸들러, 쓰레드, 자바 프로세스는 모두 논리흐름의 예다.           자신의 실행시간이 다른 흐름과 겹치는 논리흐름을 동시성 흐름이라고 부른다.   동시성: 공동으로 실행되는 흐름의 일반적인 현상   멀티태스킹: 프로세스가 다른 프로세스들과 교대로 실행된다는 개념   타임 슬라이스: 프로세스가 자신의 흐름 일부를 실행하는 매 시간 주기      두 개의 흐름이 서로 다른 프로세서 코어나 컴퓨터에서 동시에 돌아간다면, 이것은 병렬 흐름 이라고 한다.    8.2.3 사적 주소공간     프로세스는 각 프로그램에 자신이 시스템의 주소공간을 혼자서 사용한다는 착각을 불러일으킨다.   프로세스는 각 프로그램에 자신만의 사적 주소공간을 제공한다.            이 공간의 특정 주소에 연결된 메모리의 한 개의 바이트가 일반적으로 다른 프로세스에 의해서 읽히거나 쓰일 수 없다는 의미로 이 공간은 사적이다.                위의 그림은 프로세스 주소공간이다.   8.2.4 사용자 및 커널 모드     운영체제가 완벽한 프로세스 추상화를 제공하기 위해서 프로세서는 응용프로그램이 접근할 수 있는 주소공간 뿐만 아니라 응용프로그램이 실행할 수 있는 인스트럭션들을 제한하는 메커니즘을 제공해야한다.   커널 모드에서 돌고 있는 프로세스는 인스트럭션 집합의 어떤 인스트럭션도 실행할 수 있으며, 시스템 내의 어떤 메모리 위치도 접근할 수 있다.   예외가 발생해서 제어가 예외 핸들러로 넘어가면, 프로세서는 사용자 모드에서 커널 모드로 변경한다.            핸들러는 커널 모드에서 돌아간다.           8.2.5 문맥 전환     운영체제 커널은 문맥 전환context switch 이라고 알려진 예외적인 제어흐름의 상위수준 형태를 사용해서 멀티태스킹을 구현하고 있다.   커널은 각 프로세스마다 컨텍스트를 유지한다. 컨텍스트는 커널이 선점된 프로세스를 다시 시작하기 위해서 필요로 하는 상태다.             위의 그림은 프로세스 문맥 전환의 분석이다.       스케줄링            커널은 프로세서가 실행되는 동안의 어떤 시점에 현재 프로세스를 선점하고 이전에 선점된 프로세스를 다시 시작할 것을 결정한다       스케줄러라고 불리는 커널 내부의 코드에 의해 처리된다.       커널이 실행할 새 프로세스를 선택할 때 커널이 그 프로세스를 스케줄 했다고 말한다.           문맥 전환            커널이 실행할 새 프로세스를 스케줄한 후에 현재 프로세스를 선점하는 것을 말한다.           문맥 전환의 수행 절차            현재 프로세스의 컨텍스트를 저장한다.       이전에 선점된(일시적으로 정지된) 프로세스의 저장된 컨텍스트를 복원한다.       제어를 이 새롭게 복원된 프로세스로 전달한다.           8.3 시스템 콜의 에러 처리     Unix의 시스템 수준 함수가 에러를 만날 때 이들은 대개 -1을 리턴하고, 전역 정수 변수인 errno를 세팅해서 무엇이 잘못되었는지를 나타낸다.   8.4 프로세스의 제어     Unix는 C 프로그램으로부터 프로세스를 제어하기 위한 많은 시스템 콜을 제공한다.   8.4.1 프로세스 ID 가져오기          각각의 프로세스는 고유의 양수 프로세스 ID(PID)를 가진다.       getpid 함수는 호출하는 함수의 PID를 리턴한다.   getppid 함수는 자신의 부모의 PID를 리턴한다.   8.4.2 프로세스의 생성과 종료     프로그래머의 관점에서 프로세느는 세 가지 상태가 존재한다.            실행중 running: 프로세스는 CPU에서 실행하고 있거나 실행을 기다리고 있다. 궁극적으로 커널에 의해서 스케줄될 것이다.       정지 stopped: 프로세스의 실행은 정지한 상태이고 스케줄되지 않는다.       종료 terminated: 프로세스는 영구적으로 정지된다.           exit 함수는 종료 상태 status로 프로세스를 종료한다.   fork 함수는 부모 프로세스가 자식 프로세스를 생성한다.            한 번 호출하고 두 번 리턴한다.(한 번은 부모가, 다른 한 번은 자식이)       동시 실행한다.(부모와 자식은 동시에 돌아가는 별도의 프로세스)       중복되었지만 별도의 주소공간이다.       파일을 공유한다.(자식이 부모가 오픈한 모든 파일들을 상속받음)           8.4.3 자식 프로세스의 청소     프로세스가 어떤 이유로 종료할 때, 커널은 시스템에서 즉시 제거하지 않는다.            부모가 청소할 때까지 종료된 상태로 남아 있는다.       부모가 종료된 자식을 청소할 때 커널은 자식의 exit 상태를 부모에게 전달 후 종료된 프로세스를 없앤다. 이 때 프로세스가 사라진다.       종료되었지만 아직 청소되지 않은 프로세스를 좀비라고 한다.           waitpid 함수는 자신의 자식들이 종료되거나 정지되기를 기다린다.   wait 함수는 waitpid의 단순화된 버전이다   8.4.4 프로세스 재우기     sleep 함수는 일정 기간 동안 프로세스를 정지시킨다.   pause 함수는 호출하는 함수를 시그널이 프로세스에 의해 수신될 때까지 잠을 재운다.   8.4.5 프로그램의 로딩과 실행     execve 함수는 현재 프로그램의 컨텍스트 내에서 새로운 프로그램을 로드하고 실행한다.   8.5 시그널     리눅스 시그널이라고 알려진 상위수준의 소프트웨어 형태의 예외적 제어흐름을 배운다.            해당 시그널은 프로세스와 커널이 다른 프로세스를 중단하도록 한다.           시그널            작은 메시지 형태로, 프로세스에게 시스템 내에 어떤 종류의 이벤트가 일어났다는 것을 알려준다.                위의 그림은 리눅스 시스템에서 지원되는 30개의 서로 다른 종류의 시그널을 보여준다.   8.5.1 시그널 용어     시그널을 목적지 프로세스로 전달하는 것은 두 단계로 이루어진다:            시그널 보내기: 커널은 목적지 프로세스의 컨텍스트 내에 있는 일부 상태를 갱신해서 시그널을 목적지 프로세스로 보낸다(배달한다).       시그널 받기: 목적지 프로세스는 배달된 신호에 대해서 커널이 어떤 방식으로 반응해야 할 때 목적지 프로세스는 시그널을 받는다.ㅜ           펜딩pending 시그널: 보내졌지만 아직 받지 않은 시그널   8.5.2 시그널 보내기     Unix 시스템은 시그널을 프로세스로 보내는 여러가지 메커니즘을 제공한다.            모든 메커니즘은 프로세스 그룹 개념을 사용한다.           프로세스 그룹          모든 프로세스는 정확히 한 개의 프로세스 그룹에 속한다.       getpgrp 함수는 현재 프로세스의 프로세스 그룹 ID를 리턴한다.   setpgid 함수는 프로세스 pid의 프로세스 그룹을 pgid로 변경한다.   시그널을 /bin/kill 프로그램을 사용해서 보내기     /bin/kill -9 15213: 시그널 9번(SIGKILL)을 프로세스 15213에 보낸다.   /bin/kill -9 -15213: SIGKILL 시그널이 프로세스 그룹 15213 내의 모든 프로세스에게 보내지도록 한다. (음수 PID는 전체에게 보냄)   키보드에서 시그널 보내기     Ctrl+C를 입력하면 커널은 SIGINT 시그널을 포그라운드 프로세스 그룹에 속한 모든 프로세스에게 보낸다.   Ctrl+Z를 입력하면 마찬가지로 모든 프로세스에 SIGSTP 시그널을 보낸다.   kill 함수로 시그널 보내기     프로세스는 kill 함수를 호출해서 시그널을 다른 프로세스로 보낸다.   alarm 함수로 시그널 보내기     프로세스는 SIGALRM 시그널을 alarm 함수를 호출해서 자기 자신에게 보낼 수 있다.   8.5.3 시그널의 수신     커널이 프로세스 p를 커널 모드에서 사용자모드로 전환할 때, 커널은 프로세스 p에 대한 블록되지 않은 펜딩 시그널의 집합을 체크한다.            만일 이 집합이 비어 있다면, 커널은 제어를 p의 논리 제어흐름 내의 다음 인스트럭션으로 전달한다.       집합이 비어 있지 않다면, 커널은 집합 내 어떤 시그널 k를 선택해서 p가 시그널 k를 수신하도록 한다.           8.5.4 시그널 블록하기와 블록 해제하기     묵시적 블록 방법            기본적으로, 커널은 핸들러에 의해 처리되고 있는 유형의 모든 대기 시그널들의 처리를 막는다.           명시적 블록 방법            응용 프로그램들은 sigprocmak 함수와 이들의 도움함수를 이용해서 시그널들을 명시적으로 블록하거나 해제할 수 있다.           8.6 비지역성 점프     C는 비지역성 점프라고 부르는 사용자 수준의 예외적 제어흐름의 형태를 제공한다.            이것은 보통의 콜-리턴 순서를 통할 필요 없이 하나의 함수에서 현재 실행하고 있는 다른 함수로 제어를 이동한다.       setjmp와 longjmp 함수로 제공된다.           비지역성 점프의 중요한 응용은 심하게 중첩된 함 수콜에서, 어떤 에러 조건을 검출한 결과 즉시 리턴을 허용하는 것이다.            예를 들어, 에러 조건이 중첩된 함수 호출의 깊은 곳에서 발견되면, 콜 스택을 거꾸로 돌아가는 대신 공통의 지역적인 에러 핸들러로 직접 리턴하기 위해 사용한다.           8.7 요약     예외적 제어흐름 ECF는 컴퓨터 시스템의 모든 수준에서 일어나며, 컴퓨터 시스템에 동시성을 제공하는 기본 메커니즘이다.   운영체제 수준에서, 커널은 ECF를 사용해서 프로세스의 근본적인 개념을 제공한다.   프로세스는 응용프로그램에 두 개의 추상화를 제공한다:            각 프로그램에 자신이 프로세서를 혼자서 사용하고 있다는 착각을 느끼게 하는 논리적 제어흐름.       각 프로그램이 메인 메모리를 혼자서 사용하는 착각을 제공하는 사적 주소공간.              8.4 프로세스의 제어, 8.5.5 시그널 핸들러 작성하기 8.6 비지역성 점프 부분은 한번 더 꼭 읽어보자.    ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_24/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 09 가상메모리 (9.1물리 및 가상주소 방식 ~ 9.6주소의 번역)",
        "excerpt":"Chapter 09. 가상메모리     시스템의 프로세스들은 CPU와 메인 메모리를 다른 프로세스들과 공유한다.   메모리를 보다 효율적이고 더 적은 에러를 갖도록 관리하기 위해서 현대의 시스템은 가상메모리 virtual memory VM 이라고 알려진 메인 메모리의 추상화를 제공한다.   가상메모리는 각 프로세스에 하나의 크고 통합된, 사적 주소공간을 제공한다.   가상 메모리의 중요한 세가지 기능            메인 메모리를 디스크에 저장된 주소공간에 대한 캐시로 취급해서 메인 메모리 내 활성화 영역만 유지하고, 데이터를 디스크와 메모리 간에 필요에 따라 전송하는 방법으로 메인 메모리를 효율적을 ㅗ사용       각 프로세스에 주소공간을 제공함으로써 메모리 관리를 단순화한다.       각 프로세스의 주소공간을 다른 프로세스에 의한 손상으로부터 보호한다.              가상 메모리를 이해하면 어떻게 시스템이 일반적으로 동작하는지 더 잘 이해할 수 있으며, 가상메모리의 강력한 성능을 응용프로그램에 적용할 수 있다. 또한 가상메모리는  치명적인 에러를 발생시키는데 이를 방지할 수 있다.    9.1 물리 및 가상주소 방식     컴퓨터 시스템의 메인 메모리는 M개의 연속적인 바이트 크기 셀의 배열로 구성된다.   각 바이트는 고유의 물리 주소(PA physical address)를 가진다.        위의 그림은 물리 주소 방식이다.        위의 그림은 가상주소방식이다.            CPU는 가상주소지정으로 가상주소(VA virtual address)를 생성해서 메인 메모리에 접근하다.       가상주소를 물리 주소로 변환 하는 작업은 주소 번역이다.       CPU 칩 내에 메모리 관리 유닛(MMU)를 사용해서 가상주소로 번역한다.           9.2 주소공간     메인 메모리의 각 바이트는 가상 주소공간으로부터 선택된 가상주소를 가진다.   9.3 캐싱 도구로서의 VM     가상메모리는 디스크에 저장된 N개의 바이트 크기의 셀 배열로 구성된다.   VM system은 가상메모리를 규정된 사이즈 블록 단위로 분할하여 관리한다.            분할된 블록들은 가상페이지라고 부른다.           가상페이지의 집합은 세 개의 중첩되지 않는 부분집합으로 나누어진다.            Unallocated: VM 시스템에 의해 아직까지 할당되지 않은 페이지들       Cached: 현재 물리 메모리에 캐시되어 할당된 페이지들       Uncached: 물리 메모리에 캐시되지 않은 할당된 페이지들                위의 그림은 여덟 개의 가상페이지를 갖는 작은 가상메모리를 보여준다.   9.3.1 DRAM 캐시의 구성     DRAM 캐시의 미스 비용과 첫 번째 바이트를 접근하는 데 드는 비용은 크기 때문에 가상페이지 또한 커지고 있다.   DRAM 캐시는 완전 결합성이기 때문에 모든 가상페이지는 물리페이지에 둘 수 있다.   디스크의 큰 접근 시간 때문에 DRAM은 항상 write-through 대신에 write-back을 사용하고 있다.      완전 결합성은 하나의 집합에 모든 라인이 들어있는 캐시 구조를 말한다.    9.3.2 페이지 테이블     모든 캐시에서처럼 VM 시스템은 가상페이지가 DRAM 어딘가에 캐시되었는지 결정하기 위한 방법을 갖고 있어야 한다.   이러한 기능은 운영체제 소프트웨어와 MMU 내의 주소 번역 하드웨어와 페이지 테이블의 조합으로 제공된다.            페이지 테이블: 가상페이지를 물리페이지로 매핑하는 역할       주소 번역 하드웨어: 가상주소를 물리 주소로 변환할 때마다 페이지 테이블을 읽는다.       운영체제: 페이지 테이블의 콘텐츠 관리와 페이지들을 디스크와 DRAM 사이에서 왔다 갔다 하는 것을 관장한다.                     위의 그림은 페이지 테이블의 기분 구조를 보여준다.            DRAM 캐시가 완전 결합성이므로 물리페이지가 모든 가상페이지를 포함할 수 있다.       9.3.3 페이지 적중     PTE 내의 물리 메모리 주소를 사용해서 해당 워드의 물리 주소를 구성한다.을 관장한다.      9.3.4 페이지 오류     가상메모리 용어에서 DRAM 캐시 미스는 페이지 오류page fault라고 알려져 있다.        VP3 내의 워드에 대한 참조는 미스가 되고 페이지 오류를 발생시킨다.                 페이지 오류 핸들러는 VP4를 희생시키고 디스크로부터 VP3의 사본으로 교체한 뒤 정상적으로 읽는다.       페이지: 가상메모리 용어에서의 블록   스와핑(페이징): 디스크와 메모리 사이에 페이지를 전송하는 동작   요구 페이징 demand paging: 미스가 발생할 때, 하나의 페이지로 스와핑되어 들어오는 마지막 순간까지 기다리는 전략   9.3.5 페이지의 할당     운영체제가 가상메모리의 새로운 페이지를 할당할 때 디스크 상에 공간을 만들고 임의의 PTE를 디스크에 새롭게 만든 페이지를 가리키도록 할당한다.   9.3.6 문제해결을 위한 또 한 번의 지역성의 등장     가상메모리의 개념을 공부하면 비효율적인 것을 느낄 수 있다 하지만 실제로 가상메모리는 잘 동작하는데, 주로 지역성 문제 때문이다.   지역성의 원리는 시간상의 어느 시점에서라도 이들이 동작 집합working set 또는 거주 집합resident set이라고 알려진 보다 작은 활성화된 페이지 집합에서 동작하는  경향을 보일 것이라는 점을 약속해준다.   쓰레싱thrashing: 동작 집합 크기가 물리 메모리보다 더 크면, 페이지들이 연속적으로 스왑을 반복하게 되는 불행한 상황   9.4 메모리 관리를 위한 도구로서의 VM     다수의 가상페이지들이 동일한 공유된 물리페이지에 매핑될 수 있다.   요구 페이징과 분리된 가상 주소공간의 조합은 메모리가 시스템에서 사용되고 관리되는 방식에 중요한 영향을 미친다.   특히 VM은 링킹과정과 로딩, 코드와 데이터의 공유, application으로의 메모리 할당을 단순화 해준다.            링킹을 단순화한다: 별도의 주소공간은 각 프로세스들이 각 메모리 이미지에 대해서 코드와 데이터가 실제로 물리 메모리 내 어디에 위치하는지에 상관 없이 동일한 기본 포맷을 사용하도록 해준다. 이러한 통일성은 링커의 설계와 구현을 매우 단순화해준다.       로딩을 단순화한다: 가상메모리는 실행파일과 공유 목적파일들을 메모리에 로드하기 쉽게 해준다.       공유를 단순화한다: 운영체제는 다수의 프로세스가 서로 다른 프로세스에 들어 있는 가상페이지들을 동일한 물리페이지들로 적절하게 매핑해서 한 개의 사본을 공유하도록 할 수 있다.       메모리 할당을 단순화한다: 운영체제는 적당한 수의 연속적인 가상메모리 페이지를 할당하고 이들을 물리 메모리 내에 위치한 k개의 임의의 물리페이지로 매핑한다.           9.5 메모리 보호를 위한 도구로서의 VM     컴퓨터 시스템은 운영체제가 메모리 시스템에 접근하는 것을 제어할 수 있는 수단을 제공한다.   별도의 가상 주소공간을 제공하면 사적 메모리를 다른 프로세스로부터 분리하는 것이 쉬워진다.        위 그림에서 SUP는 커널 모드(수퍼바이저)로 돌고 있는지를 나타내는 비트다.            만약 사용자모드에서 VP2에 접근하려 한다면 CPU는 일반 보호 오류를 발생해서 SIGSEGV 시그널을 위반한 프로세스로 보내 커널 내의 예외 핸들러로 제어를 이동시킨다.       위와 같은 예외를 “세그먼트 오류segmentation fault”라고 보고한다.           9.6 주소의 번역     용어설명          VA: virtual address     PETA: page table entry address     PTE: page table entry     PA: physical address           페이지 적중이 일어났을 때            프로세서는 가상주소를 생성하고 이것을 MMU로 보낸다.       MMU는 PTE 주소를 생성하고 이것을 캐시/메인 메모리에 요청한다.       캐시/메인 메모리는 PTE를 MMU로 리턴한다.       MMU는 물리 주소를 구성하고 이것을 캐시/메인 메모리로 보낸다.       캐시/메인 메모리는 요청한 데이터 워드를 프로세서로 보낸다.                페이지 오류를 처리할 때            페이지 적중과 동일       페이지 적중과 동일       페이지 적중과 동일       PTE의 유효비트는 0이므로 MMU는 예외를 발생시키고, CPU 내의 제어를 운영체제 커널의 페이지 오류 예외 핸들러로 이동시킨다.       오류 핸들러는 물리 메모리 내의 희생자 페이지를 결정하고, 만일 이 페이지가 수정되었다면 디스크로 페이지를 이동한다.       오류 핸들러는 새 페이지를 페이지 이동해서 들여오고, 메모리 내의 PTE를 갱신하다.       오류 핸들러는 처음의 프로세스로 돌아가고 오류 인스트럭션은 재시작된다.           9.6.1 캐시와 VM의 통합     대부분의 시스템은 SRAM 캐시에 물리 주소지정을 선택한다.   물리 주소를 사용하면 다중 프로세스들이 캐시에서 블록을 갖는 것과 마찬가지로 가상페이지로부터 블록을 공유하는 것이 단순해진다.   물리 주소를 사용하는 캐시가 가상메모리와 통합될 수 있는 이유는 주소 번역이 캐시 참조 이전에 일어나기 때문이다.            TLB를 사용하면 캐시 참조 이전에 주소 번역이 일어남           9.6.2 TLB를 사용한 주소 번역 속도의 개선     주소 번역의 비용을 줄이기 위해 MMU 내에 번역 참조 버퍼translation lookaside buffer(TLB)라고 부르는 작은 캐시를 포함한다.   TLB는 작은 가상주소지정 캐시로, 각 라인은 하나의 PTE로 구성된 하나의 블록을 저장한다.        TLB 적중이 발생할 때            CPU는 가상주소를 생성한다.       MMU는 적당한 PTE를 TLB로부터 선입한다.       MMU는 적당한 PTE를 TLB로부터 선입한다.       MMU는 가상주소를 물리 주소로 번역하고, 그것을 캐시/메인 메모리로 전송한다.       캐시/메인 메모리는 요청한 데이터 워드를 CPU로 리턴한다.                      TLB 미스가 발생하면, MMU는 PTE를 L1캐시에서 선입해야한다.   9.6.3 다중 레벨 페이지 테이블     주소를 번역하기 위해서 한 개의 페이지 테이블을 사용하면 낭비가 매우 심하기 때문에 페이지 테이블의 계층구조를 사용한다.        위의 그림은 2단계 페이지 테이블 계층구조이다.   위와 같은 기법은 메모리 요구량을 두 가지 방법으로 줄여준다.            만일 1단계 PTE가 널이면, 해당 2단계 페이지 테이블이 존재할 필요가 없어진다. -&gt; 절약       1단계 테이블만이 항상 메인 메모리에 있고 2단계 페이지 테이블은 필요로 할 때마다 페이지 인 또는 아웃이 되므로 메인 메모리로의 압박을 줄일 수 있다.                위의 그림은 K단계 페이지 테이블을 사용한 주소 번역이다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_25/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 09 가상메모리 (9.8 메모리 매핑 ~ 9.12 요약)",
        "excerpt":"Chapter 09 가상메모리     물리 및 가상주소 방식   주소공간   캐싱 도구로서의 VM   메모리 관리를 위한 도구로서의 VM   메모리 보호를 위한 도구로서의 VM   주소의 번역   사례 연구: 인텔 코어 i7/리눅스 메모리 시스템   메모리 매핑   동적 메모리 할당   가비지 컬렉션   C 프로그램에서의 공통된 메모리 관련 버그   요약   9.8 메모리 매핑     매핑: 리눅스는 가상메모리 영역의 내용을 디스크의 객체에 연결해서 초기화한다.   영역들은 다음 두 종류의 객체 중의 하나로 매핑될 수 있다.            리눅스 파일 시스템 내의 일반 파일: 한 영역은 실행가능 목적파일과 같은 일반 디스크 파일의 연속적인 섹션으로 매핑될 수 있다.       무기명 파일: 한 영역은 또한 무기명 파일로 매핑될 수 있다.           가상페이지가 초기화된 후에는 커널이 관리하는 특별한 스왑 파일 사이에서 스왑 인되었다가 아웃되었다가 한다.            스왑 파일은 스왑 공간 또는 스왑 영역이라고도 한다.           9.8.1 다시 보는 공유 객체     메모리 매핑에 대한 아이디어는 만일 가상메모리 시스템이 보통의 파일 시스템과 통합될 수 있다면, 단순하고 효과적으로 프로그램과 데이터를 메모리에 로드할 수 있을 것이라는 기발한  생각에서 생겨났다.   프로세스 개념은 각 프로세스에 자신만의 가상 주소공간을 제공하며, 이것은 다른 프로세스들에 의해 잘못된 쓰기와 읽기 작업이 발생하는 것을 막아준다.   객체는 공유 가상메모리 영역으로 공유 객체 또는 사적private 개체로 매핑될 수 있따.            공유 객체에 매핑: 프로세스가 해당 영역에 쓰는 모든 내용은 자신의 공유 메모리 내로 객체를 매핑한 다른 프로세스들도 볼 수 있게 한다. 변경된 내용은 디스크 상의 원래의 객체에도 반영된다.       사적 객체에 매핑: 해당 영역에 가한 수정사항들은 다른 프로세스들은 볼 수 없다.                위의 그림은 공유 객체이다.        위의 그림은 사적 copy-on-write 객체이다.            사적 객체들은 copy-on-write라고 알려진 기법을 사용해서 가상메모리에 매핑된다.       공유된 객체에 다른 프로세스가 쓰기 작업을 하게 되면 새로운 사본을 물리페이지 내에 만들고 해 사본을 가르키게 한다.       copy-on-write는 마지막 가능한 순간까지 사적 객체 내에서 페이지를 복사하는 것을 지연시켜서 부족한 물리 메모리를 가장 효율적으로 사용한다.           9.8.2 다시 보는 fork 함수     현재 프로세스가 fork 함수를 호출하면, 커널은 새로운 프로세스를 위한 여러가지 자료 구조를 생성하고, 여기에 고유한 PID를 부여한다.   새 프로세스를 위한 가상메모리를 생성하기 위해 현재 프로세스의 mm_struct, 영역 구조체, 페이지 테이블과 동일한 사본을 만든다.   두 프로세스의 모든 페이지들을 읽기-허용으로 표시하고, 두 프로세스의 영역 구조체들을 사적 copy-on-write로 표시한다.   9.8.3 다시 보는 execve 함수     가상메모리와 메모리 매핑은 또한 프로그램을 메모리로 로딩하는 과정에서 중요한 역할을 한다.   execve 함수는 현재 프로세스 내에서 현재 프로그램을 효과적으로 교체하면서 실행 목적파일에 포함된 프로그램을 실행하고 로드한다.            기존 사용자 영역을 제거한다.       사적 영역을 매핑한다. copy-on-write형식을 사용한다.       공유 영역을 매핑한다.       프로그램 카운터를 설정한다.           9.8.4 함수를 이용한 사용자수준 메모리 매핑     리눅스 프로세스들은 함수를 이용해서 가상메모리의 새로운 영역들을 만들 수 있으며, 객체들을 이 영역으로 매핑할 수 있다.   mmap 함수: 커널에 새 가상메모리 영역을 생성해 줄 것을 요청             위의 그림은 mmap 인자의 시각적 해석            nunmap 함수: 가상메모리의 영역들을 삭제한다.       9.9 동적 메모리 할당     동적 메모리 할당기을 사용하여 추가적인 가상메모리를 런타임에 획득한다.   동적 메모리 할당기는 힙heap 이라고 하는 프로세스의 가상메모리 영역을 관리한다.            힙은 미초기화된 데이터 영역 직후에 시작해서 위쪽(높은 주소 방향)으로 커지는 무요구 메모리 영역이라고 가정한다.                     위의 그림은 힙heap 이다.            할당기는 힙을 다양한 크기의 블록들의 집합으로 관리한다.             명시적 할당기: application이 명시적으로 할당된 블록을 반환해 줄 것을 요구한다. malloc 패키지.       묵시적 할당기: 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구한다. 가비지 컬렉터garbage collector.           9.9.1 malloc과 free함수     malloc 함수: 힙으로부터 블록들을 할당받는다.   sbrk 함수: brk 포인터에 인자값(incr)을 더해서 힙을 늘리거나 줄인다.   free 함수: 할당된 힙 블록을 반환한다.        위의 그림은 malloc과 free를 사용해서 블록을 할당하고 반환시키는 모습을 보여준다.   9.9.2 왜 동적 메모리 할당인가?     프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 없는 경우들이 있기 때문이다.            예를들어 n만큼의 배열 길이를 초기화 해줘야 하는데, n은 프로그램 실행 후에 입력받는다면, 배열의 길이를 n만큼 동적 할당해줘야한다.           9.9.3 할당기 요구사항과 목표     명시적 할당기들은 다소 엄격한 제한사항 내에서 동작해야 한다.            임의의 요청 순서 처리하기: application은 각각의 가용 블록이 이전의 할당 요청에의해 현재 할당된 블록에 대응되어야 한다는 제한사항을 만족해야한다.       요청에 즉시 응답하기       힙만 사용하기: 비확장성 자료 구조들은 힙 자체에 저장되어야 한다.       블록 정렬하기(정렬 요건) : 어떤 종류의 데이터 객체라도 저장할 수 있도록 정렬해야한다.       할당된 블록을 수정하지 않기: 할당기는 가용 블록을 조작하거나 변경할 수만 있다. 할당된 블록은 수정하거나 이동하지 않는다.           할당기는 두가지 목표를 달성하기 위해 노력한다.            처리량 극대화하기       메모리 이용도를 최대화하기           9.9.4 단편화     단편화: 가용 메모리가 할당 요청을 만족시킬 수 없는 상태 일어난다.            내부 단편화: 할당된 블록이 데이터 자체보다 더 클 때 일어난다. 사용하지 않는 블록이 낭비된다.       외부 단편화: 요청을 처리할 수 있는 단일한 가용블록이 없는 경우 발생한다. (가용 가능한 블록을 모두 모으면 충분한 크기가 존재하지만 단일 블록들이 만족할 수 없어서)                외부 단편화를 위의 그림을 예로 든다면, 8워드 블록의 할당을 요청하면, 가용 블록들을 모두 모으면 가능하지만, 6워드 블록과, 2워드 블록으로 나뉘어져 있기 때문에 외부 단편화가 일어난다.   9.9.5 구현 이슈     가용 블록 구성: 어떻게 가용 블록을 지속적으로 추적하는가?   배치: 새롭게 할당된 블록을 배치하기 위한 가용 블록을 어떻게 선택하는가?   분할: 블록을 새롭게 할당 후 가용 블록의 나머지 부분들로 무엇을 할 것인가?   연결: 방금 반환된 블록으로 무엇을 할 것인가?   9.9.6 묵시적 가용 리스트(implict free list)        위의 그림은 힙 블록의 포맷이다.            한 블록은 1워드 헤더, 데이터, 추가적인 패딩으로 구성된다.       헤더: 블록 크기와 블록이 할당되었는지 가용 상태인지를 인코딩한다. 블록 크기는 정렬 기준의 배수이다.       데이터: 헤더 다음에는 malloc을 불렀을 때 요구한 데이터가 따라온다.       패딩: 패딩의 크기는 가변적이다. 패딩을 해야하는 이유는 1)외부 단편화를 극복하기 위해, 2)정렬 요구사항을 만족하기 위해                위의 그림은 묵시적 가용 리스트를 사용해서 구현한 힙이다.            8byte 더블 워드 정렬을 기준으로 구현했기 때문에 블록의 크기는 항상 8의 배수이다.           이러한 구조를 묵시적 리스트라고 부르는데, 가용 블록이 헤더 내 필드에 의해서 묵시적으로 연결되기 때문이다.   9.9.7 할당한 블록의 배치     application이 메모리 할당을 요청할 때 요청한 블록을 저장하기에 충분히 큰 가용 블록을 리스트에서 검색한다. 할당기가 검색을 수행하는 방법은 배치 정책에 의해서 결정된다.            First fit: 가용 리스트를 처음부터 검색한다.       Next fit: 이전 검색이 종료된 지점에서 검색을 시작한다.       Best fit: 모든 가용 블록을 검사하며 크기가 맞는 가장 작은 블록을 선택한다.           9.9.8 가용 블록의 분할     할당기는 가용 블록을 두 부분으로 나눈다.   예를들어 8워드 크기의 가용 블록중 2워드 크기를 할당하면 나머지 6워드 크기의 내부 단편화가 생긴다. 이를 분할해서 6워드 크기의 가용 블록을 새로 만든다.   9.9.9 추가적인 힙 메모리 획득하기     가용 블록이 부족하다면 할당기는 커널에게 sork 함수를 호출해서 추가적인 힙 메모리를 요청한다.   9.9.10 가용 블록 연결하기        위의 그림은 가용할 수 있는 블록이 16/0 으로 두개로 나뉘어져 있다. 이는 오류 단편화false fragmentation라고 한다.            이를 극복하기 위해서 16/0으로 나뉘어져 있는 가용블록을 32/0으로 연결한다.                     위의 그림처럼 연결 된다.       즉시 연결: 할당기는 블록이 반환될 때마다 인접 블록을 통합한다.   지연 연결: 일정 시간 후에 가용 블록들을 연결하기 요청이 들어오면 블록들을 통합한다.   9.9.11 경계 태그로 연결하기     현재 블록(반환하려고 하는 블록)의 헤더는 다음 블록의 헤더를 가리키고 있으며, 이것은 다음 블록이 가용한지 결정하기 위해 체크될 수 있다. 하지만 이전 블록을 체크 할 수  있는 방법은 없다. 해당 문제점을 해결하기 위해서 경계 태그 기법을 만들었다.   경계태그: 각 블록의 끝 부분에 풋터footer(경계 태그)을 추가하고 이 풋터는 이전 블록의 헤더를 복사한 것이다.   9.9.12 종합설계: 간단한 할당기의 구현     현재 실력으로 구현은 조금 힘든 것 같아서 지식을 조금 더 쌓고 꼭 구현해보도록 하겠다!    9.9.13 명시적 가용 리스트(explicit free list)     묵시적 가용 리스트는 블록 할당 시간이 전체 힙 블록의 수에 비례하기 때문에 범용 할당기에는 적합하지 않다.   명시적 가용 리스트는 가용 블록들을 일종의 명시적 자료구조로 구성하는 것이다.            가용 블록들을 연결리스트로 모두 쭈르륵 연결한거라고 생각하면 된다! 반면에 묵시적 가용 리스트는 모든 블록을 연결한다.                     위의 그림은 이중 연결 가용 리스트를 사용하는 힙 블록의 포맷이다. -가용 블록 내에 pred와 succ 포인터를 포함하는 이중 연결 리스트로 구성된다.       명시적 가용 리스트의 접근법            후입선출(LIFO): 리스트를 새롭게 반환한 블록들을 리스트의 시작 부분에 삽입해서 후입선출 순으로 유지 하는 것이다. LIFO 순서와 first fit 배치 정책을 사용하면, 할당기는 대부분의 최근에 사용된 블록들을 먼저 조사한다.       주소 순으로 정렬: 리스트를 주소 순으로 정렬해 리스트 내 각 블록의 주소가 다음 블록의 주소보다 작도록 한다. 후입선출 방식보다 좀 더 좋은 메모리 이용도를 가진다.           명시적 리스트의 단점은 가용 블록들이 header와 footer 뿐만 아니라 필요한 포인터까지 포함해야한다는 것이다. 그래서 최소 블록 크기가 커지고 내부 단편화 가능성이 증가한다.   9.9.14 분리 가용 리스트     단일 연결 가용 블록 리스트를 사용하는 할당기는 한 개의 블록을 할당하는 데 가용 블록의 수에 비례하는 시간이 필요하다.   할당 시간을 줄이기 위해 분리 저장장치segregated storage는 다수의 가용 리스트를 유지하며, 각 리스트는 거의 동일한 블록들을 저장한다.   모든 가능한 블록 크기를 크기 클래스size class라고 하는 동일 클래스의 집합들로 분리하는 것이다.   9.10 가비지 컬렉션     가비지 컬렉터garbage collector: 더 이상 프로그램에서 사용하지 않는 블록들을 자동으로 반환하는 동적 저장장치 할당기다.   가비지garbage: 사용하지 않는 블록들   가비지 컬렉션: 자동으로 힙 저장장치를 반납하는 과정      많은 가비지 컬렉션이 있지만, 우리는 논의를 가비지 컬렉션을 처음 개발한 McCarthy의 오리지널 Mark&amp;Sweep 알고리즘에 국한할 것이다.    9.10.1 가비지 컬렉터 기초        가비지 컬렉터는 위의 그림과 같이 방향성 도달 그래프로 메모리를 고려한다.            그래프의 노드들은 루트 노드들과 힙 노드들로 나눈다.       각 힙 노드는 힙 내 한 개의 할당된 블록에 대응된다.       방향성 에지egde p -&gt; q는 블록 p 내부의 위치가 블록 q 내부의 위치를 가리킨다는 것을 의미한다.       루트노드들은 가상메모리의 읽기-쓰기 데이터 영역 내 레지스터, 스택변수, 전역변수가 될 수 있따.       어떤 루트 노드에서 p로 방향성 경로가 존재한다면, p는 도달할 수 있다고 말한다.       application은 어떤 시점에서든 도달할 수 없는 노드를 다시는 사용할 수 없는 가비지에 대응시킨다.       가비지 컬렉터의 역할은 이 도달성 그래프의 표시를 관리하는 것과 도달 불가 노드들을 free시키는 것이다.           컬렉터들은 자신의 서비스를 요청에 의해서 제공하거나, application과 병렬로 별도의 쓰레드로서 실행되어 도달성 그래프를 지속적으로 갱신하고 가비지를 회수한다.   9.11 C 프로그램에서의 공통된 메모리 관련 버그     메모리 관련 버그들은 위험하다, 그 이유는 이들이 종종 시간과 공간적으로 버그의 원인으로부터 멀리 떨어진 곳에서 자신을 드러내기 때문인다.   메모리 관련 버그            잘못된 포인터 역참조       초기화되지 않은 메모리를 읽는 경우: bss 메모리 위치들은 0으로 초기화, 하지만 힙 메모리는 그렇지 않다.       스택 버퍼 오버플로우 허용하기: 배열의 범위를 벗어나면 버퍼 오버플로우를 갖는다.       Off-by-One 에러 만들기: 덮어쓰기 버그       포인터가 가리키는 객체 대신에 포인터 참조하기       존재하지 않는 변수 참조하기       가용 힙 블록 내 데이터 참조하기       메모리 누수leak 유발: 블록을 할당하고 반환을 하지 않는다.           9.12 요약     가상 메모리는 메인 메모리를 추상화한 것이다.            가상메모리를 지원하는 프로세서는 가상주소지정이라고 하는 간접화의 형태로 메인 메모리를 참조한다.       프로세서는 가상주소를 생성하고, 이것은 메인 메모리로 보내지기 전에 물리 주소로 번역된다.       페이지 테이블을 사용해서 번역한다.           가상 메모리는 세 가지 중요한 기능을 제공한다.            자동으로 최근에 사용한 디스크상의 가상 주소공간의 내용을 메모리로 캐시한다.                    페이지: 가상 메모리 캐시에서 블록                       가상메모리는 메모리 관리를 단순화해 주고, 링킹, 프로세스들 간의 데이터 공유, 프로세스를 위한 메모리 할당, 프로그램 로딩을 단순화해 준다.       가상메모리는 매 페이지 테이블 엔트리 내 보호 비트를 사용해서 메모리 보호를 단순화해 준다.           TLB를 사용해서 캐시의 동작과 통합   메모리 매핑: 가상메모리 블록을 디스크 상의 파일 묶음에 이들을 연계해서 초기화하는 과정            메모리 매핑은 데이터의 공유, 새로운 프로세스의 생성, 프로그램의 로딩을 위한 효율적인 메커니즘을 제공           메모리 할당기            힙이라고 부르는 가상의 주소공간 영역에 블록 할당       명시적 할당기: malloc (동적 메모리 할당기)       묵시적 할당기: 가비지 컬렉터 (자동으로 미사용 블록들 반환)           ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_26/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 10 시스템 수준 입출력",
        "excerpt":" ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_27/",
        "teaser": null
      },{
        "title": "[Python] `__name__` 전역 변수란 무엇인가?",
        "excerpt":"모듈  __name__ 전역 변수가 정확히 어떤 역할을 하는지 알기 위해선 python 에서의 모듈 개념에 대해서 먼저 알고 있어야 한다.   인터프리터 입력을 에디터를 사용해서 준비한 후에 그 파일을 입력으로 사용해서 실행하는 것을 스크립트를 만든다고 한다. 여러 프로그램(스크립트)에서 썼던  편리한 함수를 각 프로그램에 정의를 복사하지 않고 사용하는 것을 지원하기 위해 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 수 있는 방법을 제공한다. 그런 파일을 모듈이라고 한다. 모듈로부터 정의들이 다른 모듈이나 메인 모듈로 임포트 될 수 있다.   모듈은 파이썬 정의와 문장들을 담고 있는 파일이다. 파일의 이름은 모듈 이름에 확장자 .py를 붙인다.   __name__  모듈의 이름은 전역 변수 __name__ 으로 제공 된다. 즉 현재 py 파일의 이름을 가지고 있는 변수라는 것이다.   예를들어, fibo.py 라면 __name__ 전역 변수가 fibo라는 문자열을 가지고 있게 된다.   그렇다면 if __name__ == __main__ 은 뭘까?  위에 설명했던 것 처럼 __name__ 전역 변수가 자기 자신의 모듈 이름을 가지고 있지만, 자기 자신의 모듈 안에서 __name__를 호출하게 되면 __main__ 문자열을 갖게 된다.   예를들어, test1.py 와 test2.py 가 있을 때, test1에 test2를 import 하게 되면, test1은 __main__ 이 되고 test2는 ‘test2’가 된다.   # test1.py import test2 name = __name__ print(\"test1.py :\", name)  # test2.py name = __name__ print(\"test2.py: \", name)  ------------------------------------------ \"\"\" 출력 값 test2.py:  test2 test1.py : __main__ \"\"\"  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_02/",
        "teaser": null
      },{
        "title": "[Python] 파이썬은 call by value인가? 아니면 call by reference인가?",
        "excerpt":"call by value   call by reference   call by assignment  immutable이면 값이 변경 되지 않는다. mutable이면 값이 변경된다.   mutable, immutable     숫자형(number): immutable   문자열(string): immutable   리스트(list): mutable   튜플(tuple): immutable   딕셔너리(dictionary): mutable  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_03/",
        "teaser": null
      },{
        "title": "[백준/Python] 2891 카약과 강풍(그리디)",
        "excerpt":"BOJ   그리디 2891 카약과 강풍  문제로 이동!   문제   2890번을 보면 알겠지만, 상근이는 카약 대회를 개최했다. 그런데, 갑자기 엄청난 강풍이 경기장에 불었고, 일부 카약이 부서졌다. 경기는 5분 안에 시작해야 하는 상황이다.   다행히 일부 팀은 혹시 모를 사태에 대비해서 카약을 하나 더 경기장에 들고 왔다. 카약은 매우 무겁고 운반하기 어렵다. 따라서, 자신의 바로 다음이나 전에 경기하는 팀에게만 카약을 빌려주려고 한다. 즉, 팀 4는 여분의 카약을 3이나 5에게만 빌려줄 수 있다. 다른 팀에게서 받은 카약은 또 다른 팀에게 빌려줄 수 없다. 또, 카약을 하나 더 가져온 팀의 카약이 손상되었다면, 여분의 카약으로 경기에 출전하게되고, 이 카약은 다른 팀에게 빌려줄 수 없다.   카약이 부서진 팀과 하나 더 가져온 팀이 주어진다. 카약을 적절히 빌렸을 때 출발하지 못하는 팀의 최솟값은 몇 팀인지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 팀의 수 N, 카약이 손상된 팀의 수 S, 카약을 하나 더 가져온 팀의 수 R이 주어진다. (2 ≤ N ≤ 10, 1 ≤ S, R ≤ N)   둘째 줄에는 카약이 손상된 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.   셋째 줄에는 카약을 하나 더 가져온 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.   예제 입력  입력: [5, 2, 1] [2, 4] [3],  출력: 1  입력: [5, 2, 3] [2, 4] [1, 3, 5], 출력: 0    풀이     해당 문제는 카약이 손상된 팀과 여분의 카약을 가져온 팀의 관계를 잘 생각하면서 풀어야 한다. 여분을 가져온 팀이 손상이 되는 경우가 있는 부분을 잘 생각해야한다. 또한 여분을 나누어 줄 때 index 0 부터 차례대로 나누어줘야 모두에게 적절히 분배할 수 있다. 그렇기 때문에 여분을 가져온 팀의 정렬이 필요하다.(배열이 [5, 2, 4] 이런식으로 들어올 수 있기 때문)    solution     카약을 모두 가져왔다고 가정하고 n 길이의 배열을 1로 초기화한다.   손상된 카약을 가지고 있는 팀을 반복문을 돌면서 -1 해준다.   여분을 가져온 카약팀을 정렬해준다.   여분을 가져온 카약팀을 반복문을 돌면서 양 옆에 카약이 없는 팀을 조회하고 있다면 카약이 없는 팀의 value를 +1, 여분을 가져온 카약팀을 -1 올려준다.            여분을 가져온 카약팀은 카약이 2 이상 있는 팀이기 때문에 조건문을 x&gt;=2 로 설정한다.           코드       def solution(n_list, brk_list, add_list):         kayak = [1] * n_list[0]         for i in brk_list:             kayak[i-1] -= 1         add_list.sort()         for i in add_list:             index = i-1             kayak[index] += 1             if kayak[index] &gt;= 2 and index-1 &gt;= 0:                 if kayak[index-1] == 0:                     kayak[index] -= 1                     kayak[index-1] += 1             if kayak[index] &gt;= 2 and index+1 &lt; n_list[0]:                 if kayak[index+1] == 0:                     kayak[index] -= 1                     kayak[index+1] += 1              result = kayak.count(0)         return result               if __name__ == \"__main__\":         n_list = list(map(int, input().split()))         brk_list = list(map(int, input().split()))         add_list = list(map(int, input().split()))              print(solution(n_list, brk_list, add_list)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_01/",
        "teaser": null
      },{
        "title": "[백준/Python] 1459 걷기(그리디)",
        "excerpt":"BOJ   그리디 1459_걷기  문제로 이동!   문제   세준이는 학교에서 집으로 가려고 한다. 도시의 크기는 무한대이고, 도시의 세로 도로는 모든 정수 x좌표마다 있고, 가로 도로는 모든 정수 y좌표마다 있다. 세준이는 현재 (0, 0)에 있다. 그리고 (X, Y)에 위치한 집으로 가려고 한다. 세준이가 걸을 수 있는 방법은 두가지 인데, 하나는 도로를 따라서 가로나 세로로 한 블록 움직여서 이번 사거리에서 저 사거리로 움직이는 방법이고, 블록을 대각선으로 가로지르는 방법이 있다.   세준이가 집으로 가는데 걸리는 최소시간을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 집의 위치 X Y와 걸어서 한 블록 가는데 걸리는 시간 W와 대각선으로 한 블록을 가로지르는 시간 S가 주어진다. X와 Y는 1,000,000,000보다 작거나 같은 음이 아닌 정수이고, W와 S는 10,000보다 작거나 같은 자연수이다.   예제 입력  입력: 4 2 3 10, 출력: 18  입력: 2 0 12 10, 출력: 20  입력: 135 122 43 28, 출력: 3929    풀이     해당 문제는 다양한 조건을 나누어 해결해야하는 문제이다. W와 S의 관계를 잘 관찰한 뒤 총 세가지 조건으로 나누어 문제를 해결하였다. 첫번째 조건은 S가 W보다 작을 때, 이 때는 가로 및 세로로 가는 것보다 대각선으로 가는게 훨씬 빠르다. 하지만 이 조건에서 한번 더 조건 분기 하는데, 남은 블록 수가 홀수라면 마지막 움직임은 가로 혹은 세로로 움직여야 최소 시간에 도착할 수 있다. 두번째 조건은 S가 2*W보다 작을 때, 세번째 조건은 나머지 조건을 제외한 경우이다.    solution     s 가 w 보다 작을때, s가 w2 보다 클 때 그리고 s가 w2 보다 작을 때로 조건을 나눈다.   s가 w*2 이하라면, x와 y중 최소값 만큼은 s로 움직인다. x와 y 차이값 만큼은 w로 움직인다.   s가 w보다 작다면, x와 y중 최소값 만큼은 s로 움직이고, x와 y의 차이값이 짝수라면 w만큼, 홀수라면 차이값-1 으로 s를 움직이고 마지막 w를 더해준다.   코드       def solution(x,y,w,s):         if s &lt;= w:             min_val = min(x, y)             if abs(x-y) % 2 == 0:                 result = ((min_val) * s) + (abs(x-y) * s)             else:                 result = ((min_val) * s) + ((abs(x-y)-1) * s) + w         elif s &gt; w*2:             result = (x+y) * w         else:             min_val = min(x,y)             result = ((min_val) * s) + (abs(x-y) * w)              return result               if __name__ == \"__main__\":         x, y, w, s = map(int, input().split())         print(solution(x,y,w,s)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_02/",
        "teaser": null
      },{
        "title": "[백준/Python] 1543 문서 검색(그리디)",
        "excerpt":"BOJ   그리디 1543 문서 검색  문제로 이동!   문제   세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다.   세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 문서가 주어진다. 문서의 길이는 최대 2500이다. 둘째 줄에 검색하고 싶은 단어가 주어진다. 이 길이는 최대 50이다. 문서와 단어는 알파벳 소문자와 공백으로 이루어져 있다.   예제 입력  입력: “ababababa” “aba”, 출력: 2  입력: “aaaaaaa” “aa”, 출력: 3    풀이     count 메서드를 사용하면 간단하게 해결할 수 있다.    solution     count 메서드를 사용한다.   코드       import sys          def solution(data, find):         return data.count(find)               if __name__ == \"__main__\":         data = sys.stdin.readline().rstrip()         find = sys.stdin.readline().rstrip()         print(solution(data, find)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_03/",
        "teaser": null
      },{
        "title": "[백준/Python] 2012 등수 매기기(그리디)",
        "excerpt":"BOJ   그리디 2012 등수 매기기  문제로 이동!   문제   2007년 KOI에 N명의 학생들이 참가하였다. 경시일 전날인 예비소집일에, 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다.   KOI 담당조교로 참가한 김진영 조교는 실수로 모든 학생의 프로그램을 날려 버렸다. 1등부터 N등까지 동석차 없이 등수를 매겨야 하는 김 조교는, 어쩔 수 없이 각 사람이 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다.                  자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 (       A - B       )로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다.           각 사람의 예상 등수가 주어졌을 때, 김 조교를 도와 이러한 불만도의 합을 최소로 하는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 500,000) 둘째 줄부터 N개의 줄에 걸쳐 각 사람의 예상 등수가 순서대로 주어진다. 예상 등수는 500,000 이하의 자연수이다.   예제 입력  입력: 5 1 5 3 1 2, 출력: 3    풀이     정렬 이후 abs 함수를 이용해서 순차별로 계산하면 해결할 수 있는 간단한 문제이다.    solution     학생들의 예상 점수가 저장되어 있는 리스트를 오름차순으로 정렬한다.   학생들의 점수를 차례대로 1,2,3 ~ 순서로 빼주고 절대값 처리를 해준다.   코드       def solution(n, expectations):         expectations.sort()         result = 0         for i in range(n):             result += abs(expectations[i]-(i+1))         return result               if __name__ == \"__main__\":         n = int(input())         expectations = [int(input()) for _ in range(n)]         print(solution(n, expectations)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_04/",
        "teaser": null
      },{
        "title": "[백준/Python] 2036 수열의 점수(그리디)",
        "excerpt":"BOJ   그리디 2036 수열의 점수  문제로 이동!   문제   n개의 정수로 이루어진 수열이 있다. 이 수열에서 한 정수를 제거하거나, 또는 두 정수를 제거할 수 있다. 한 정수를 제거하는 경우에는 그 정수가 점수가 되고, 두 정수를 제거하는 경우에는 두 정수의 곱이 점수가 된다. 이를 반복하여 수열에 아무 수도 남지 않게 되었을 때, 점수의 총 합의 최대를 구하는 프로그램을 작성하시오.   예를 들어 -1, 5, -3, 5, 1과 같은 수열이 있다고 하자. 먼저 1을 제거하고, 다음으로는 5와 5를 제거하고, 다음에는 -1과 -3을 제거했다고 하자. 이 경우 각각 점수가 1, 25, 3이 되어 총 합이 29가 된다.   입력   첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 절댓값이 1,000,000을 넘지 않는 정수가 n개 주어진다.   예제 입력       \"\"\"     입력     5     -1     5     -3     5     1     출력     29     \"\"\"  풀이     양수 부분과 음수 부분을 나누어서 해결해야한다. 우선 0은 양수 부분에 있으면 최대값을 찾는데 도움을 주지 않는다. 그렇기 때문에 0음 음수 부분으로 나누어 준다. 또한 나뉘어진 부분의 개수가 홀수라면 음수 중에서는 제일 큰 수가 더해져야하고, 양수 중에서는 제일 작은 수가 더해져야한다. 이후 이 모두를 합산하면 결과값이 나온다.    solution     우선 입력받은 numbers 리스트를 정렬해준다.   numbers를 반복문을 돌며 음수 부분과 양수 부분으로 나누어준다.   음수 부분이 짝수 개수라면 모두 두개씩 곱해준다.   음수 부분이 홀수 개수라면 negative_n-1에 위치한 값을 제외하고 모두 곱해준뒤 해당 값은 더해준다.   양수 부분이 짝수 개수라면 모두 두개씩 곱해준다.   양수 부분이 홀수 개수라면 0에 위치한 값을 제외하고 모두 곱해준뒤 해당 값은 더해준다.   코드       def solution(numbers):         numbers.sort()         result = 0         negative_list = []         positive_list = []         negative_n = 0         positive_n = 0              for n in numbers:             if n &lt;= 0:                 negative_list.append(n)                 negative_n += 1             else:                 positive_list.append(n)                 positive_n += 1              if negative_n % 2 == 0:             for i in range(0,negative_n, 2):                 result += negative_list[i] * negative_list[i+1]         else:             for i in range(0, negative_n-1, 2):                 result += negative_list[i] * negative_list[i+1]             result += negative_list[negative_n-1]              if positive_n % 2 == 0:             for i in range(0, positive_n, 2):                 if positive_list[i] &gt; 1 and positive_list[i+1] &gt;1:                     result += positive_list[i] * positive_list[i+1]                 else:                     result += positive_list[i] + positive_list[i+1]         else:             for i in range(1, positive_n, 2):                 if positive_list[i] &gt; 1 and positive_list[i+1] &gt;1:                     result += positive_list[i] * positive_list[i+1]                 else:                     result += positive_list[i] + positive_list[i+1]             result += positive_list[0]                   return result               if __name__ == \"__main__\":         n = int(input())         numbers = []         for _ in range(n):             numbers.append(int(input()))         print(solution(numbers)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_05/",
        "teaser": null
      },{
        "title": "[백준/Python] 2138 전구와 스위치(그리디)",
        "excerpt":"BOJ   그리디 2138 전구와 스위치  문제로 이동!   문제   N개의 스위치와 N개의 전구가 있다. 각각의 전구는 켜져 있는 상태와 꺼져 있는 상태 중 하나의 상태를 가진다. i(1 &lt; i &lt; N)번 스위치를 누르면 i-1, i, i+1의 세 개의 전구의 상태가 바뀐다. 즉, 꺼져 있는 전구는 켜지고, 켜져 있는 전구는 꺼지게 된다. 1번 스위치를 눌렀을 경우에는 1, 2번 전구의 상태가 바뀌고, N번 스위치를 눌렀을 경우에는 N-1, N번 전구의 상태가 바뀐다.   N개의 전구들의 현재 상태와 우리가 만들고자 하는 상태가 주어졌을 때, 그 상태를 만들기 위해 스위치를 최소 몇 번 누르면 되는지 알아내는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 전구들의 현재 상태를 나타내는 숫자 N개가 공백 없이 주어진다. 그 다음 줄에는 우리가 만들고자 하는 전구들의 상태를 나타내는 숫자 N개가 공백 없이 주어진다. 0은 켜져 있는 상태, 1은 꺼져 있는 상태를 의미한다.   예제 입력       \"\"\"     case 1:     입력     3     000     010     출력     3      case 2:     입력     7        1101000     1111111     출력     3      case 3:     입력         8     00000000     11011000     출력     2     \"\"\"  풀이     진짜 어려웠던 문제다… 전구를 키는 방법이 여러가지인데 어떻게 최소값을 찾는지 정말 아이디어가 떠오르지 않았다. 하지만, 이번 문제를 해결하고 또 이전에 이 문제와 비슷한 문제를 겪어 봤을 때 결론은, 최소값을 구할 때 어떻게 해야지 최소값이 나오는지 모를 때는 앞에서부터 차근차근 계산해 나가는 방법으로 접근 해봐야 한다. 하지만 이 문제는  양 끝을 키고 끌 때 다르게 작동된다. 그렇기 때문에 첫번째 전구를 킨 case와 키지 않은 case 두가지 case로 나누어 풀어야한다. 또한 마지막 테케가 계속 틀렸는데, 입렵값이 애초부터 같은 값인 것을 예외처리 해주어야 한다.    solution     change 함수를 정의해 준다. 0이면 1, 1이면 0, 양 끝이 변경 될 때의 조건을 포함한다.   입력값 두개가 서로 같으면 0으로 얼리 리턴 해준다.   전구를 누르는 로직은 현재 조사하는 위치의 왼쪽 전구(즉, 다음 전구를 조사하게 되면 해당 전구는 더이상 키거나 끌 수 없는 전구)가 결과 값과 다르다면 현재 위치의 전구를 누른다.   위의 로직을 첫번째 전구를 눌렀을 경우, 누르지 않았을 경우 두가지로 나누어 처리한다.   계산이 끝나면, 각 경우의 결과값중 최소값을 리턴하면 되지만, 정답을 도출할 수 없는 경우 count가 -1로 저장되기 때문에 해당 부분에 적절한 분기 처리를 해준다.   코드       import sys               def change(first, i, n):         if i != 0:             if first[i - 1] == \"0\":                 first[i - 1] = \"1\"             else:                 first[i - 1] = \"0\"         if first[i] == \"0\":             first[i] = \"1\"         else:             first[i] = \"0\"         if i != n - 1:             if first[i + 1] == \"0\":                 first[i + 1] = \"1\"             else:                 first[i + 1] = \"0\"               def solution(n, first, last):         if first == last:             return 0              first_f = list(first)         first_n = list(first)         last = list(last)         count_f, count_n = -1, -1              # 첫 번째 전구를 누르는 경우         change(first_f, 0, n)         count = 0         for i in range(1,n):             if first_f[i-1] != last[i-1]:                 change(first_f, i, n)                 count += 1         if first_f == last:             count_f = count+1              # 첫 번째 전구를 누르지 않을 경우         count = 0         for i in range(1,n):             if first_n[i-1] != last[i-1]:                 change(first_n, i, n)                 count += 1         if first_n == last:             count_n = count              if count_n == -1 and count_f != -1:             return count_f         elif count_n != -1 and count_f == -1:             return count_n         elif count_n != -1 and count_f != -1:             return min(count_f, count_n)         else:             return -1               if __name__ == \"__main__\":         n = int(input())         first = sys.stdin.readline().rstrip()         last = sys.stdin.readline().rstrip()         print(solution(n, first, last)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_06/",
        "teaser": null
      },{
        "title": "[백준/Python] 2785 체인(그리디)",
        "excerpt":"BOJ   그리디 2785 체인  문제로 이동!   문제   희원이는 그의 다락방에서 N개의 체인을 찾았다. 각각의 체인은 몇 개의 고리로 연결되어 있는데, 각각의 고리는 최대 두 개의 인접한 고리를 가질 수 있다. 각각의 고리는 열고 닫을 수 있다. 그래서, 체인을 분리하거나 두 체인을 연결하여 하나의 긴 체인으로 만들 수 있다. 희원이는 가능한 한 적은 고리를 열고 닫아서, 모든 체인을 하나의 긴 체인으로 연결하려고 한다.   예를 들어, 희원이가 세 개의 체인을 가지고 있고, 각 체인이 고리 하나로만 이루어져 있다면, 그 중 하나를 열어서 나머지 두 개를 연결하고 닫으면 된다.      체인의 개수와 각각의 체인의 길이가 주어지면, 하나의 긴 체인으로 모든 체인을 묶기 위해 희원이가 열고 닫아야할 최소한의 고리 수를 찾아라.   입력   첫 번째 줄에는 체인의 개수를 나타내는 양의 정수 N (2 ≤ N ≤ 500000)이 주어진다. 두 번째 줄에는 각각의 체인의 길이를 나타내는 N개의 양의 정수 Li(1 ≤ Li ≤ 1000000)가 주어진다.   예제 입력       \"\"\"     case 1:     입력     2     3 3     출력     1          case 2:     입력     5     4 3 5 7 9     출력     3     \"\"\"  풀이     문제 해석을 case1을 예를 들면, 체인 3개가 연결되어 있는 체인이 총 두개 존재하고 있는 것이다. 그렇다면 우선 연결된 체인이 제일 적은 체인을 소모 하는 것이 체인을 최소로 사용하고 모든 체인을 연결할 수 있는 key point가 된다. 이후 적게 연결된 체인부터 확인해가며 전체 체인을 연결하였는지 살펴보면 된다. 예를들어 3,4,5,7,9 가 있다면, 3을 소모해 4,5,7,9를 모두 연결할 수 있다. 또한 2,5,6,7,8 이라면 2를 소모해 6,7,8을 연결하면 5와 (6,7,8) 이렇게 두 체인만 남게된다. 이것의 관계를 전체 n 개수와 체인이 담겨진 리스트를 반복문을 돌며 둘의 관계를 따지며 해결한다.    solution     우선 체인이 담긴 리스트 chains를 오름차순으로 정렬한다.   하나의 체인에 연결된 모든 체인을 소모해도 하나의 전체 체인을 만들지 못했을 때 소모한 체인을 count하기 위한 use_chain 변수를 생성한다.   반복문을 돌며 chains에서 chain을 하나씩 검사한다.   만약 chain을 다 소모해도 체인을 만들지 못하면, 소모한 chain을 use_chain에 저장하고, 전체 개수 n에서 소모된 chain과 연결된 chain을 빼주어서 현재 전체 체인의 개수를 n에 저장한다.   만약 chain이 n-1보다 크면 해당 체인으로 자기 자신과 다른 모든 체인을 연결해야하기 때문에 use_chain + n - 1로 리턴한다.   만약 chain이 n-1과 같다면 자기 자신을 모두 소모하고 나머지 체인들이 연결되기 때문에 use_chain + chain으로 리턴한다.   solution2     solution2는 정답은 맞았지만, 시간초과가 뜬 풀이법이다. 내장함수를 자주 사용해서 코드를 작성하지 말자!    코드       def solution(n, chains):         count = 0         chains.sort()         use_chain = 0         for chain in chains:             if chain == n - 1:                 return use_chain + chain             elif chain &gt; n - 1:                 return use_chain + n - 1             else:                 n -= (chain + 1)                 use_chain += chain              return count          def solution2(n, length):         count = 0         length.sort()         while len(length) &gt; 1:             if length[0] == 0:                 length = length[1:]             if len(length) == 2:                 count += 1                 break             if len(length) == 1:                 break             length[0] -= 1             length.append(length.pop() + length.pop())             count += 1              return count          if __name__ == \"__main__\":         n = int(input())         chains = list(map(int, input().split()))         print(solution(n, chains)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_07/",
        "teaser": null
      },{
        "title": "[백준/Python] 2885 초콜릿 식사(그리디)",
        "excerpt":"BOJ   그리디 2885 초콜릿 식사  문제로 이동!   문제   학교 근처 편의점에 새 초콜릿이 들어왔다. 이 초콜릿은 막대 모양이고, 각 막대는 정사각형 N개로 이루어져 있다. 초콜릿의 크기(정사각형의 개수)는 항상 2의 제곱 형태이다. 즉, 1, 2, 4, 8, 16, …개의 정사각형으로 이루어져 있다.   상근이는 점심식사로 초콜릿을 먹는다. 이때, 적어도 K개 정사각형을 먹어야 남은 수업을 졸지 않고 버틸 수 있다. 상근이의 친구 선영이도 초콜릿을 좋아한다. 선영이는 초콜릿은 돈을 주고 사기 아깝다고 생각하기 때문에, 상근이가 주는 초콜릿만 먹는다.   상근이는 막대 초콜릿를 하나 산 다음에, 정확하게 K개 정사각형이 되도록 초콜릿을 쪼갠다. K개는 자신이 먹고 남는 것은 선영이에게 준다.   막대 초콜릿은 나누기 조금 어렵게 되어 있어서, 항상 가운데로만 쪼개진다. 즉, 정사각형이 D개 있는 막대는 D/2개 막대 두 조각으로 쪼개진다.   K개 정사각형을 만들기 위해서, 최소 몇 번 초콜릿을 쪼개야 하는지와 사야하는 가장 작은 초콜릿의 크기를 구하는 프로그램을 작성하시오. 상근이는 초콜릿을 하나만 살 수 있다. 꼭 한 조각이 K개일 필요는 없고, 여러 조각에 있는 정사각형을 합쳤을 때 K개이면 된다.   입력   첫째 줄에 K가 주어진다. (1 ≤ K ≤ 1,000,000)   예제 입력       \"\"\"     입력     6     출력     2     \"\"\"  풀이     문제를 이해하기가 조금 어려웠는데, 2의 제곱 형태인 초콜릿을 계속 반씩 나눈 값을 더해서 입력값인 k가 되게 만들면 되는 최소값을 구하면 된다. 우선 이 문제는 더할 수 있는  값이 2의 제곱수들이기 때문에 k값이 어떤 2의 제곱수끼리 더해졌는지를 알아내야 한다. 그렇기 때문에 2의 제곱수중 가장 큰 수부터 나누어서 나머지가 0으로 떨어지면  나눈 값까지만 초콜릿을 반씩 쪼개면 된다. 만약 k가 홀수라면 초콜릿을 1개 까지 나눠야하기 때문에 계산을 적게하기 위해 얼리리턴 해준다.    solution     우선 k값보다 큰 2의 제곱수가 무엇인지 반복문을 통해 찾아낸다.   2의 제곱수로 상근이가 사야할 초콜릿 크기를 구해준다.   가장 큰 2의 제곱수로 k를 나누었을 때 0이면 나누지 않아도 되기 때문에 얼리 리턴 해준다.   가장 큰 2의 제곱수로 k를 나누었을 때 1이면 마지막 까지 나눠야 하기 때문에 2의 제곱수로 리턴 해준다.   가장 큰 2의 제곱수부터 내림차순으로 k값을 나누어준다.   2의 제곱수로 나누어지면 (최대 제곱수 - 해당 2의 제곱수)로 리턴해준다.   코드       def solution(k):         degree = 0         while True:             if 2**degree &gt;= k:                 break             degree += 1              size = 2**degree         if k == size/2:             return 1         if k%2 == 1:              return size, degree         for s in reversed(range(degree+1)):             if k%(2**s) == 0:                 return size, degree - s               if __name__ == \"__main__\":         k = int(input())         m, n = solution(k)         print(m, n) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_08/",
        "teaser": null
      },{
        "title": "[백준/Python] 11501 주식(그리디)",
        "excerpt":"BOJ   그리디 11501 주식  문제로 이동!   문제   홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다.   주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.   예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.   입력   입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.   예제 입력       \"\"\"     입력     3     3     10 7 6     3     3 5 9     5     1 1 3 1 2     출력     0     10     5     \"\"\"  풀이     첫쨋날 부터 계산을 하지 않고, 마지막날 부터 계산 하는 것이 해당 문제의 key point다. 주식 가격이 들어 있는 리스트를 스택이라고 가정하고 문제를 푼다. 마지막 날 주식 가격을 pop 해와서 제일 높은 가격이라고 가정하고 max값에 저장한다. 그다음 주식을 pop 해왔을 때 max값보다 작으면 max와의 차이를 benefit 리스트에 더해준다. max보다 크다면 max값을 변경해준다.    solution     이익을 저장할 리스트를 [0] * n 으로 초기화한다.   먼저 주식 가격이 저장된 리스트를 pop 해서 max값에 저장한다.   주식 가격이 저장된 리스트의 원소가 없어질 때 까지 while 문을 돌며 조건별로 처리해준다.   코드       def solution(n, stocks):         benefit = [0] * n         for s in range(n):             max = stocks[s].pop()             while stocks[s]:                 item = stocks[s].pop()                 if item &lt;= max:                     benefit[s] += max - item                 else:                     max = item              return benefit               if __name__ == \"__main__\":         n = int(input())         stocks = []         for _ in range(n):             m = int(input())             stocks.append(list(map(int, input().split())))         result = solution(n, stocks)         for r in result:             print(r) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_09/",
        "teaser": null
      },{
        "title": "[백준/Python] 12018 Yonsei TOTO(그리디)",
        "excerpt":"BOJ   그리디 2012 등수 매기기  문제로 이동!   문제   연세대학교 수강신청이 얼마 전부터 바뀌어, 마일리지 제도로 바뀌었다. 이 제도는 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다. 그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다.   성준이는 연세대학교 재학 중인 학생이다. 성준이는 저번 수강신청에서 실패하여 휴학을 했기 때문에 이번 수강신청만은 필사적으로 성공하려고 한다. 그래서 성준이는 학교 홈페이지를 뚫어버렸다.   그 덕분에 다른 사람들이 신청한 마일리지를 볼 수 있게 되었다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다. (내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다.   입력   첫째 줄에는 과목 수 n (1 ≤ n ≤ 100)과 주어진 마일리지 m (1 ≤ m ≤ 100)이 주어진다. 각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li이 주어지고 그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. (1 ≤ Pi ≤100, 1 ≤ Li ≤ 100)   (단 마일리지가 같다면 성준이에게 우선순위가 주어진다고 하자.)   예제 입력       \"\"\"     입력     5 76     5 4      36 25 1 36 36     4 4     30 24 25 20     6 4     36 36 36 36 36 36     2 4     3 7     5 4     27 15 26 8 14          출력     4     \"\"\"  풀이     여러가지 요소들을 입력받고 어떻게 효율적으로 저장할지 고민을 좀 했던 문제이다. 수강신청 인원과 정원 그리고 학생들이 배팅한 마일리지를 하나의 set으로 묶어서 처리했고,  수강신청 인원과 정원 수를 비교한뒤 조건 분기로 나누었으며, 배팅한 마일리지를 정렬해서 문제를 해결했다.    solution     첫 번째 반복문은 해당 수업을 수강하기 위해서 필요한 마일리지를 mileage 리스트에 모두 저장하는 반복문이다.   수강 정원과 수강 신청 인원을 비교한 뒤 각각에 mileage 리스트에 필요한 마일리지를 append 해준다.   mileage 리스트를 정렬해준다.(마일리지가 적게 들어가는 수업을 우선 수강하기 위해서)   mileage 리스트를 하나씩 꺼내서 더해가며 총 마일리지인 m보다 커지면 반복문을 탈출한다.            성준이의 마일리지가 우선순위가 높은걸 주의하자! ex) [36, 36, 36, 36] 이라면 성준이가 36 마일리지를 쓴다면 수강할 수 있다.           코드       def solution(n, m, course):         mileage = []         for i in range(n):             if course[i][1] - course[i][0] &gt; 0:                 mileage.append(1)             else:                 course[i][2].sort()                 mileage.append(course[i][2][course[i][0] - course[i][1]])              mileage.sort()         sum_v = 0         count = 0         for v in mileage:             if v &gt; 36:                 continue             sum_v += v             if sum_v &gt; m:                 return count             count += 1              return count               if __name__ == \"__main__\":         n, m = map(int, input().split())         course = []         for _ in range(n):             register, possible = map(int, input().split())             course.append((register, possible, list(map(int, input().split()))))         print(solution(n, m, course)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_10/",
        "teaser": null
      },{
        "title": "[백준/Python] 17609 회문(그리디)",
        "excerpt":"BOJ   그리디 17609 회문  문제로 이동!   문제   회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.   여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.   입력   입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.   예제 입력       \"\"\"     입력     7     abba     summuus     xabba     xabbay     comcom     comwwmoc     comwwtmoc     출력     0     1     1     2     2     0     1     \"\"\"  풀이     회문은 양 끝부터 차례대로 확인해야 하기 때문에 투 포인터를 사용한다. 다른 문자를 만나게 되면 start 포인터를 pop 하는 경우와 end 포인터를 pop 하는 경우 두가지를  계산한다. 이 계산에서 한번 더 다른 문자를 만나게 되면 더 이상 계산할 필요가 없기 때문에 break를 걸어 전체 반복문을 탈출해서 답을 도출한다.    solution     start 포인터를 pop 할 때 계산하는 함수와 end 포인터를 pop 할 때 계산하는 함수를 정의한다. (함수를 사용하는 이유는 전체 반복문을 편리하게 탈출하기 위해서이다.)   스타트 포인터가 해당 string의 중간지점에 위치할 때 까지 while문을 돈다.   다른 문자를 만나게 되면 count를 1 올려주고 start_pop 함수와 end_pop 함수를 호출한다.   각각의 함수에서 다른 문자를 만나게 되면 count를 2로 설정해서 리턴한다.   각각 함수를 호출하고 난뒤 리턴 받은 count(count_sp, count_ep)중 최소값을 count에 저장한 뒤 break로 반복문을 빠져나온다.   count를 결과 리스트에 저장해서 return 한다.   코드       import sys               def start_pop(string, start, end):         start += 1         while start &lt; len(string)//2 + 1:             if string[start] != string[end]:                 return 2             start += 1             end -= 1         return 1               def end_pop(string, start, end):         end -= 1         while start &lt; len(string)//2:             if string[start] != string[end]:                 return 2             start += 1             end -= 1         return 1               def solution(strings):         result = []              for string in strings:             count = 0             start = 0             end = len(string)-1             while start &lt; len(string)//2:                 if string[start] != string[end]:                     count_sp = start_pop(string, start, end)                     count_ep = end_pop(string, start, end)                     count = min(count_ep, count_sp)                     break                 start += 1                 end -= 1             result.append(count)         return result                    if __name__ == \"__main__\":         n = int(input())         strings = []         for _ in range(n):             strings.append(sys.stdin.readline().rstrip())         results = solution(strings)         for result in results:             print(result) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_11/",
        "teaser": null
      },{
        "title": "[백준/Python] 10044 Project Teams(그리디)",
        "excerpt":"BOJ   그리디 20044 Project Teams  문제로 이동!   문제   코딩 프로젝트 수업을 가르치는 수찬이는 프로젝트 팀을 가능하면 공정하게 구성하려고 한다. 프로젝트 팀 하나는 두 명의 학생으로 구성되는데, 각 학생들의 코딩 역량은 모두 다르다. 각 학생은 한 팀의 팀원이어야 한다. 공정성을 높이기 위해 수찬이는 팀원 코딩 역량의 합을 최대한 일정하게 유지하려고 한다. 학생들이 코딩 역량이 주어졌을 때 수찬이가 팀을 구성하는데 도움이 되는 프로그램을 작성하라.                  문제를 간단하게 하기 위해, 학생 수는 2n이라 가정하자 (n은 양의 정수). 각 학생 si의 코딩 역량은 양의 정수 w(si)로 나타내면 한 i번째 팀 Gi의 코딩 역량은 w(Gi) = ∑s∈Giw(s)로 나타낼 수 있다. 작성할 프로그램 목적은 Sm = min{w(Gi)       1 ≤ i ≤ n}이 최대화되도록 n개의 팀 G1, G2, …, Gn 을 구성하고 이때 Sm을 출력하는 것이다.           예를 들어, 학생들의 코딩 역량이 {1, 7, 5, 8}로 주어졌다면 (8, 1), (7, 5)로 2개의 조를 짤 수 있으며 프로그램은 9를 출력해야 한다.   입력   입력은 표준입력을 사용한다. 입력의 첫 번째 행에는 팀 수를 나타내는 양의 정수 n(1 ≤ n ≤ 5,000)이 주어진다. 그 다음 행에 학생 si 의 코딩 역량 w(si)를 나타내는 2n개의 양의 정수가 공백으로 분리되어 주어진다 (1 ≤ w(si) ≤ 100,000). 학생들의 코딩 역량은 모두 다르다. 즉, i ≠ j이면 w(si) ≠ w(sj)이다.   예제 입력  입력: 2 [1, 7, 5, 8], 출력: 9  입력: 3 [1, 7, 3, 5, 9, 2], 출력: 8    풀이     정렬 후 양 index마다 양 끝을 더한 뒤 최소값을 출력하면 된다.    solution     정렬 후 양 index마다 양 끝을 더한 뒤 최소값을 출력하면 된다.   코드       def solution(n, students):         students.sort()         result = min([students[i]+students[(n*2)-1-i] for i in range(n)])         return result               if __name__ == \"__main__\":         n = int(input())         students = list(map(int, input().split()))         print(solution(n, students)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_12/",
        "teaser": null
      }]
