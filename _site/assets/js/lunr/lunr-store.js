var store = [{
        "title": "블로그를 다시 시작해 보자",
        "excerpt":"4학년 1학기 졸업작품을 3월부터 6월까지 열심히 달렸다. 졸업작품을 끝마치고 나니 현업의 욕심이 생겨 열심히 인턴 지원을 진행하였다. 그렇게 자소서를 쓰고 대학생활을 하며 잰힝했던 포트폴리오를 정리하고 7월 11일에 ‘스페이스워크’라는 회사에 인턴 포지션으로 입사하게 되었다. 인턴 포지션에 입사한 이후로 코딩에 대한 열정이 팍 식은거 같다. 회사일은 내가 졸업작품을 했을 때 처럼 큰 열정을 쏟아 붓지 못한 채 시키는 일만 하는 수동적 인간이 되었다. 그렇게 거의 5개월을 따로 공부도 하지 않고 열정이 없는 채로 살아왔던 것 같다. 당장 내 앞에 펼쳐져 있는 숙제들도 해결하지 않고 뒤로 미뤄두고 기상 - 회사 일 쪼금 - 게임 - 취침의 쳇바퀴의 반복적 인생을 살아왔다.   인턴 포지션 종료일은 1월 11일이다. 이후 나는 졸업요건을 하나 충족하지 않아 초과학기를 해야하며 다음 취업을 준비해야 한다. 인턴 포지션 종료까지는 약 2개월 정도 남았다. 지금은 욕심이지만, 인턴 종료 이후 곧바로 다른 회사의 인턴 포지션으로 들어가거나 현재 있는 회사에 잔류 하는 것이 목표이다. 현재 다니고 있는 회사에서 열심히 하지 못했던 이유는 나에게 목표의식이 조금 사라졌다는 변명을 들 수 있을 것 같다. 다시금 목표가 생긴 현재 이를 정확히 인지하고 행동으로 실천할 때가 온 것 같다.   인턴 생활을 하기 전까지는 모두 뇌피셜로 코딩을 해오고 공부를 해왔다. 그 때는 BE와 FE의 차이점도 몰랐고 DE가 요즘 핫하다는 이야기만 듣고 무슨 일을 하는지도 모른채로 DE포지션으로 인턴을 지원했었다. 하지만, 현업 생활을 약 4개월정도 하고 난 뒤 내 주변에 현업 생활을 하고 있는 지인들의 이야기가 궁금해졌고 많은 사람들의 이야기를 듣고 싶어 일명 DevTalk을 요청하였다. 그리고 이제는 정확하지는 않지만, 개발자라는 직군이 어떻게 돌아가는지 그리고 내가 어떤 일을 할 수 있고 어떤 일을 하고 싶은지 조금은 알 수 있게 되었다.   우선 나의 문제점을 발견했다. 간단하고 명확하게 말하자면, 나는 현재 ‘코싸개’이다. 생각하지 않고 주어진 문제를 해결하기 위해 수단과 방법을 가리지 않고 그저 코드만을 작성했던 굉장히 질 나쁜 개발자였던 것이다. 생각해보면 내가 이 프로그래밍에 관해 진지하게 공부했던 적이 없다. 학문을 가르치는 대학에서 소프트웨어학과를 진학하고 전공 과목은 집중하지 않고 프로젝트를 어떻게든 이쁘게 만들기 위해서 프로젝트를 위한 공부만 했던 것 같다. 현재 사용하고 있는 기술들은 모두 근본이 되는 알고리즘과 컴퓨터구조론에서부터 비롯된 기술임을 몰랐던 것이다. 나에게 가장 부족한 점은 ‘근본 지식’을 모르는 것이다. 많이 늦었다고 말할 수 있지만, 오늘부터 ‘근본 지식’에 관련하여 몇가지를 체계적으로 공부할 생각이다.   첫번째, 알고리즘이다. 알고리즘을 제대로 배워본 적이 없다. 사실 우리학교의 전공 필수 과목이지만, 너무 어렵고 공부하기도 싫어서 대충 했던 기억이 있다. 그리고 모르는 지식이 있으면 그 때 그 때 구글링으로 일시적으로 지식의 빈자리를 매꿀 뿐이었다. 근본이 되는 알고리즘 서적으로 공부할 계획이다. 두번째, 컴퓨터구조론이다. 컴퓨터구조론 또한 우리학교의 전공 필수 과목이지만, 족보를 바탕으로 공부해서 학점은 좋게 받았지만 남아있는 지식은 없다. 알고리즘과 컴퓨터구조론을 우선 공부하여 인턴 포지션 종료 전 까지 어느정도의 지식을 확보하고 싶은 계획이다.   이후 나는 BE나 DE 직군으로 나아갈 예정이다. 현재 내가 사용하는 주 언어는 python이지만, java에도 관심이 조금씩 가고 있다. 알고리즘과 컴퓨터구조론 공부를 마치고 나면 DE의 근본책과 BE의 근본책 두가지를 구매해서 공부할 예정이다. 이 열정이 언제 식을지 모르겠지만, 현재 내 발등에는 불이 그것도 존나게 뜨거운 불이 떨어졌다.   화이팅이다 홍구야  ","categories": ["Doodle"],
        "tags": ["Doodle"],
        "url": "/doodle/doodle_01/",
        "teaser": null
      },{
        "title": "2022년 초보 개발자의 취업 계획",
        "excerpt":"   곧 2022년이다. 2021년 한해를 마무리해보자.     2021년 : 마무리   3月-6月 졸업작품    7月-12月 인턴생활    졸업작품 하얗게 불태우고 바로 인턴 생활을 했다. 현업이 되게 궁금했는데 이 부분에 대해서는 굉장히 많은 도움이 된 것 같다. 그리고 Data Engineering 직무도 굉장히 관심 있었는데 직접 경험할 수 있어서 좋았다. 나는 조금 더 다양한 경험을 하고 싶어서  Back End 직무를 공략할 생각이다. 언어는 아무래도 java가 강력하다고 생각해서 java 공부를 시작할 것 같다.    2022년 : 11월 전까지 아래 서류들을 준비해보자      졸업요건 맞추기    토익 또는 오픽    정보처리기사    CS    Algorithm    Java 스킬    ~2022년 포트폴리오 정리    코딩 캠프(네이버부캠,우테코 등등…) 준비      Java Backend Roadmap   ","categories": ["Doodle"],
        "tags": ["Doodle"],
        "url": "/doodle/doodle_02/",
        "teaser": null
      },{
        "title": "Docker는 대충 이런 느낌인가?",
        "excerpt":"Docker   내가 느낀 전체적인 도커의 메커니즘 : 어떠어떠한 것을 빌드해서 이미지를 만들고  -&gt; 이미지를 도커로 띄운 뒤 -&gt; 이미지를 받아서 로컬에서 개발작업을 진행   !!많은 시행착오를 거쳐 도커의 메커니즘에 대해 이해가 조금 되었다.     Dockerfile을 만든다.   해당 디렉토리 위치에서 docker build를 한다.   docker build을 하면 이미지가 생성된다.   이미지가 생성됐으면, 해당 이미지로 docker run을 한다.   docker run을 하면 컨테이너가 만들어지고 해당 이미지를 컨테이너 안으로 넣는다?띄운다?   그럼 환경셋팅이 된다…?   틀린 부분도 있겠지만 아주 조오금 조오오오오금 메커니즘이 이해가 됐다.   앗 참고로 음… 저런 run이니 이미지 파일들이니 어떤 컨테이너가 실행중인지를 GUI로 확인할 수 있는 프로그램이 Docker Desktop 같다 ㅎㅎ..   추가적으로 환경세팅을 완료한 것 같다. 음… 위의 6번까지 진행한 후에          컨테이너를 만들면 어떠한 가상환경이 만들어지는 것 같다.            그럼 그 컨테이너에가 파이썬 환경으로 이루어져있고 추가로 다양한 패키지들이 들어있다.            그럼 그 환경을 내가 사용하고 있는 Pycharm과 연동을 하는 거다.       어떻게 하냐면 파이참 프로젝트의 인터프리터를 해당 컨테이너에 있는 파이썬path로 설정해주는거다. *https://i-am-eden.tistory.com/13        그리고 코딩하면 된다 ㅎㅎ ***            도커엔진 - 도커를 실행하면 Dockered라는 데몬 프로그램이 서버로 실행.   **여기서 잠깐! 데몬 프로그램이 뭘까?   https://blogger.pe.kr/770  (포그라운드, 백그라운드, 데몬 프로세스)    https://haruhiism.tistory.com/9            도커실행 : 도커 이미지를 받아서 컨테이너로 실행   ** -it 라는 명령어는 -i와 -t 옵션이 합쳐진 옵션, -i는 호스트와 컨테이너 상호 입출력을 맞추고, -t는 TTY를 활성화해서 컨테이너에 터미널로 입력이 가능하게 한다.   ** TTY가 뭐지?!   https://cosmosproject2015.tistory.com/143 (TTY, PTS, PTY)            도커 volume : 데이터를 컨테이너에 저장하지 않고 호스트에 저장하는 방식   https://www.daleseo.com/docker-volumes-bind-mounts/       도커빌드 : Dockerfile로 사용자 정의 이미지를 만듬   *공부하기 : 도커 아키텍쳐, 컨테이너-OS 간의 통신 구조   ** Docker의 개념 및 핵심 설명 :  https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90    Docker 예제 실습중 갱장히 이상한 오류가 발생했다.   failed to solve with frontend dockerfile.v0: failed to read dockerfile: open /var/lib/docker/tmp/buildkit-mount174403522/Dockerfile: no such file or directory   구글링을 계속 해봤지만 dockerfile -&gt; Dockerfile 로 이름을 바꾸라는 답변밖에 없었다.   하지만, 오류가 고쳐지지 않았고 터미널을 Open한 디렉토리 경로를 상위 폴더 위치로 open을 해서 났던 오류였다 ㅎㅎ  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/docker_01/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Google's Neural Machine Translation System : Bridging the Gap between Human and Machine Translation 논문 리뷰",
        "excerpt":"Introduction     Neural Machine Translation            End-to-End 학습 접근 방식의 자동 번역       기존 구문 기반 번역의 약점을 극복           Neural Machine Translation 단점            데이터 양과 매개변수가 많아 훈련과 추론 속도가 느림       Rare Word 처리의 문제점       가끔씩 모든 단어에 대해 번역하지 못함           Google’s Neural Machine Translation            LSTM으로 이루어져 있는 8개의 ENCODER와 8개의 DECODER       병렬 처리 개선을 위해 DECODER의 최하층과 ENCODER의 최상층을 ATTENTION으로 연결       번역속도를 높이기 위해 low-precision arithmetic, Rare Word 처리를 위해 WordPiece 사용            Model Architecture       Model Parallelism            모델 병렬화와 데이터 병렬화 모두 사용함       Downpour SGD를 사용하여 데이터 병렬화                    여러개의 모델로 나누어, 여러개의 머신에서 동시에 학습함, 각각 학습된 gradient를 평균내어 모델에 적용           실험에서는 10개의 머신에서 128개의 문장을 Mini-batch로 사용                       모델 병렬화                    머신당 8개의 GPU 사용 ( 각 층 마다 서로 다른 GPU에 할당 )           i번째 레이어의 작업이 종료전에 i+1번째 작업 진행 가능                            Segmentation Approches     Wordpiece Model            띄어쓰기는 _, 단어는 내부단어 통계에 기반하여 띄어쓰기로 분리       띄어쓰기를 _로 치환한 이유는 차후에 문장 복원을 위해       실험에서는 wordpiece를 8K~32K에서 좋은 결과 얻음       wordpiece로도 얻을 수 없었던 rare word는 copy model을 사용                 Mixed Word/Character Model            OOV 처리를 로 하지 않고 문자 단위로 나누어 처리함       시작 문자 , 중간 문자 , 끝 문자        전체 작업 과정에서 유지한 채로 학습한 후 태그를 삭제함             Training Criteria     Maximum-liklihood 학습 방식은 로그 확률 값을 최대화하는 목적 함수 ( BLUE 평가 지표와 부합되지 않음 )        Reward개념의 목적함수 사용        r은 문장 단위 점수 ( 출력 문서와 실제 문서의 차이 계산 )   GLEU 점수 지표 사용 ( 출력 문장과 정답 문장을 1~4 토큰으로 만든 뒤 recall과 precision을 구한 뒤 더 작은 값을 GLEU로 정함 )   ML방식과 RL 방식 혼합하여 사용 이 때, a는 0.017        Quantizable Model And Quantized Inference     NMT은 연산량이 많아 Inference 시간이 오래 걸리는 것이 큰 단점   해결하기 위하여 Quantized inference 수행!        Decoder     Beam Search를 사용하여 점수 함수를 최대화 하는 시퀀스 Y를 찾음   Length normalization            길이가 더 긴 문장의 확률이 떨어지기 때문에 이를 보정하기 위하여 사용       하이퍼 파라미터 a 사용 ( 실험에서는 0.6 ~ 0.7 사용 )           Coverage Panelty            source word xi로 부터 attention weight의 합을 구함       로그를 취했기 때문에 attention weight이 편중되지 않은 source word의 값이 매우 작음 음수를 가지게 됨       실험에서는 a는 0.6 b는 0.2 사용                Experiments And Results     Data set            WMT En -&gt; Fr 36M       WMT En -&gt; De 5M           Evaluation Metrics            BLUE       implicit human evaluation ( BLUE는 번역 점수 잘 못메김 )           Training Procederue            TensorFlow 사용하여 구현       12개의 머신으로 병렬화       [-0.04, 0.04] 사이로 매개변수를 균일하게 초기화       Adam Optimizer와 SGD 혼합하여 사용 ( 첫 60k는 Adam으로 그 후로는 SGD 사용)           Learning Rate는 0.5 ( 1.2M 이후부터 200k 단위마다 반씩 줄여가며 학습 )          Conclusion     Wordpiece 모델은 번역 품질과 inference 속도를 효과적으로 높힘   모델과 데이터의 병렬화는 sequence-to-sequence NMT 모델을 일주일 안으로 효율적으로 훈련시킬 수 있음   Model quantization은 inference 속도를 가속화할 수 있어 대형 모델에 사용하기 용이함   Length-normalization, coverage penalty 등과 같은 추가 세부 사항이 NMT 시스템을 잘 작동시키게 도와줌  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_01/",
        "teaser": null
      },{
        "title": "TDD와 each map",
        "excerpt":"TDD   TDD(Test Driven Development)란 본격적인 개발에 들어가기 전에 테스트 계획 및 코드를 작성하는 것을 의미한다. 테스트가 개발을 이끌어 나가는 것이다. 예를들어, 개발 중 에러가 발생했을 때 소규모 개발에서는 큰 문제가 되지는 않지만, 대규모의 개발 상황에서는 수 많은 모듈과 함수간 종속성들이 굉장히 많은 시간을 괴롭히게 된다. 이러한 문제점을 해결하기 위해서 테스트 주도 개발이 등장했다.   나는 pytest를 사용할 것이다. https://binux.tistory.com/47   일단, monkeypatch.setattr 살펴보자.  이것은 어떤것을 하냐면, mocking이다. Mocking은 실제 값이 아닌 가짜 값을 만들어내는 것이다.   음 예를들면 Upload 클래스가 있다.   Class Upload    |_ Def Extract   |_ Def Transform   |_ Def Load   이렇게 되어있을 때 나는 Transform 부분만 테스트하고 싶다. 하지만 함수의 종속성으로 인하여 Transform에서 사용되는 data는 Extract로 부터 참조되며 Extract에서 추출되는 data는  특정 라이브러리의 기능을 참조한다. 나는 Transform 부분만 테스트하고 싶지만 이런 경우에 Extract부터 특정 라이브러리으 기능까지 테스트해야되는 상황에 처한 것이다. 이런 경우에 이제 Mocking이라는 기술을 쓴다. pytest에서도 제공하는 function이 있지만, 단순한 예를 하나 들자면 정답과 인풋값을 csv파일이나 등등으로 미리 만들어서 로컬에서 참조하도록 코드를 작성하면 된다.   하지만 이때, 테스트 코드에서 원코드를 실행할 때 원코드의 Extract가 실행 되기 때문에 monkeypatch.setattr 같은 기능으로 해당 function을 사용하지 않고 넘겨주는 기능을 넣어줘야한다.    each map  each map을 알아야한다.  음 지금 내가 하는 것은 DB -&gt; transform -&gt; DB 적재이다. transform에서 전처리 및 parsing을 해주는데, transform에서 이뤄지는 작업은 모든 Dataframe이 메모리 상으로 올라가게 된다. 작은 task면 문제없이 실행 되겠지만, 큰 규모의 task는 메모리를 많이 차지하게 되어 에러가 날 수 있다. 이럴 때 사용 하는 것이 each map이다. each map은 dataframe에서 row 별로 메모리 상으로 올린다. 이후 해당 row에서 특정 처리를 진행 후에 buffer로 옮긴 뒤 DB로 적재를 한다. 이 때 조심해야 하는 부분은 seperate다. row에서 컬럼으로 구분하는 seperate값을 잘 이용해야지 에러가 나지 않을 것이다.    즉! pytest 부분을 더 공부하고 적절한 testset을 생각해보고, testcode를 작성해보자!  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행",
        "excerpt":"CS:APP  Computer Systems A Programmer’s Perspective, CSAPP로도 잘 알려져있는 컴퓨터 구조론의 바이블이다. 이 책을 통해서 컴퓨터구조론을 다시 공부해볼 생각이다. 군대 전역 직후 2학년 2학기로 복학해서 컴퓨터 구조론 전공 수업을 들었지만 학점을 위한 공부만 해서 남아있는게 없는 것 같다. 인턴 생활을 하면서 다양한 부분에서 어려움을 겪었는데 기초를 몰라서 헤메고 있다는 느낌을 굉장히 많이 받았다.   첫 페이지를 읽었을 때 이 책으로 정하길 정말 잘했다는 생각이 들었다. 전공 수업때 사용했던 컴퓨터구조론 책은 제작자의 관점에서 기술 되었다는 느낌을 강하게 받았었다. 하지만, CSAPP는 프로그래머의 관점에서 기술하였고, 컴퓨터구조론의 시스템들을 어떻게 사용해서 좋은 프로그램을 개발할 수 있는지를 배울 수 있다고 한다.  인턴 생활을 하면서 실제 현업을 겪고 느꼇던 강한 의문들을 해결할 수 있을 것 같은 느낌이다.   책의 목차는 정보의 표현과 처리로 시작하여 프로그램의 기계어 표현, 프로세서 구조, 프로그램 성능 최적화, 메모리 계층구조, 링커, 예외적인 제어흐름, 가상메모리, 시스템 수준 입출력, 네트워크 프로그래밍, 동시성 프로그래밍  순서로 이어져 있다. 많은 사람들은 6장 메모리 계층구조, 7장 링커의 전까지 읽어도 좋다고 하지만, 가능하다면 12장 동시성 프로그래밍까지 읽어볼 생각이다.   Chapter 01. 컴퓨터 시스템으로의 여행     시스템 구현방식은 변하지만 근본적인 개념들은 변하지 않는다.   프로그래머들로 하여금 컴포넌트들이 어떻게 동작하고 프로그램 성능과 정확성에 어떤 영향을 주는지 알 수 있다.   1.1 정보는 비트와 컨텍스트로 이루어진다.     텍스트 문자 -&gt; 아스키(ASCII) 표준 사용하여 표현 -&gt; 각 문자를 바이트 길이의 정수 값으로 표현 -&gt; 연속된 바이트 파일 저장   1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.     hello.c 실행 -&gt; 저급 기계어 인스트럭션들로 번역 -&gt; (실행가능 목적 프로그램)으로 합쳐져 바이너리 디스크 파일로 저장  -&gt; 컴파일러 드라이브는 유닉스 시스템에서 소스파일에서 오브젝트 파일로 변경 -&gt; 4개의 단계를 거쳐서 실행            4개의 단계:                    전처리기           컴파일러           어셈블러           링커                           1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.     프로그램 성능 최적화하기            eg1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?       eg2) while 루프는 for 루프보다 더 효율적일까?       eg3) 포인터 참조가 배열 인덱스보다 더 효율적인가?           링크 에러 이해하기            eg1) 정적변수와 전역변수의 차이는 무엇인가?       eg2) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?           보안 약점 피하기            eg1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?           1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.     인스트럭션이란 : 컴퓨터에게 일을 시키는 단위(기계어)       시스템의 하드웨어 조직            버스 : 시스템 내를 관통하는 전기적 배선군       입출력 장치 : 시스템과 외부세계외의 연결 담당       메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치       프로세서 : 인스트럭션들을 해독(실행)하는 엔진                    인스트럭션의 요청에 의해 CPU(프로세서)가 실행하는 단순한 작업의 예                            적재(load), 저장(store), 작업(operate), 점프(jump)                                                        프로그램의 실행              1.5 캐시가 중요하다.     hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다.   프로그램이 로딩될 때 이들은 메인 메모리로 복사된다.   이 작업이 시간이 너무 오래 걸려서 “단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하는” 캐시 메모리가 설계 되었다.   캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성을 활용하였다.   1.6 저장장치들은 계층구조를 이룬다.          모든 컴퓨터 시스템의 저장장치즈들은 메모리 계층구조로 구성되어 있다.              1.7 운영체제는 하드웨어를 관리한다.     운영체제는 두 가지 주요 목적을 가지고 있다.            제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해       응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해           위 두가지 목표를 위해 근본적인 추상화를 통해 달성하고 있다.   추상화 결과            프로세스 : 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과       가상 메모리 : 메인 메모리와 디스크 입출력 장치의 추상화       파일 : 입출력장치의 추상화           1.8 시스템은 네트워크를 사용하여 다른 시스템과 통신한다.     네트워크는 또 다른 입력장치로 볼 수 있다.   시스템이 메인 메모리로부터 네트워크 어댑터로 일련의 바이트를 복사할 때, 데이터는 로컬디스크 드라이브 대신에 네트워크를 통해서 다른 컴퓨터로 이동된다.   1.9 중요한 주제들     Amdahl의 법칙            우리가 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 구 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계된다.           동시성과 병렬성            동시성 : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념       병렬성 : 동시성을 사용해서 시스템을 보다 더 빠르게 동작하도록 하는 것       쓰레드 수준 동시성                    쓰레드를 이용하면 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수 있음                       인스트럭션 수준 병렬성                    프로세서들은 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있음                           컴퓨터 시스템에서 추상화의 중요성            추상화의 사용은 전산학에서 가장 중요한 개념!           1.10 요약     컴퓨터 내의 정보는 비트들의 그룹으로 표시   컴파일러와 링커에 의해 바이너리 실행파일들로 번역   프로세서는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석   컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간에 데이터를 복사하고 쓰는 데 사용   위와 같은 이유로 시스템의 저장장치들은 계층구조 형성   운영체제 커널은 응용프로그램과 하드웨어 사이에서 중간자 역할 수행   네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법 제공   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.   비트 패턴            이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.       표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.           인코딩            비부호형 : 전통적인 이진수 표시 사용       부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법       부동소수점 : 2진수 버전의 소수 표시방법           이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.        2.1 정보의 저장     기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급   메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음   모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름   2.1.1 16진수 표시     1바이트는 8비트로 이루어짐        이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&gt; 16진수 사용              16진수 &lt;-&gt; 10진수 &lt;-&gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음            2.1.2 데이터의 크기     모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨            w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐       프로그램은 최대 2^w 바이트에 접근 가능                최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임              2.1.3 주소지정과 바이트 순서     여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정            객체의 주소가 무엇이 되어야 하는지       메모리에 바이트들을 어떻게 정렬해야 하는지           비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.            가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]       가장 덜 중요한 바이트 : [x7, x6, . . . , x0]           바이트 저장 방법            리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는       빅 엔디안 : 가장 중요한 바이트가 먼저 오는       대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작           바이트 순서가 이슈가 되는 경우            이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때                    리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜                       정수 데이터를 나타내는 바이트들을 살펴볼 때       프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때           2.1.4 스트링의 표시      그냥 ASCII를 사용한다는 내용,,,    2.1.5 코드의 표현          인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름                   컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것       2.1.6 부울 Boolean 대수     NOT : ~   AND : &amp;   OR : |        EXCLUSIVE-OR : ^              2.1.7 C에서의 비트수준 연산          C에서는 비트들 간의 부울 연산을 지원                   비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.             마스크: 비트 연산에 사용되는 데이터            2.1.9 C에서의 쉬프트 연산     비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공   x « k            x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.           x » k            좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.       논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움       산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움           부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용        2.2 정수의 표시          컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것              2.2.1 정수형 데이터 타입     서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.   64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위            음수의 범위가 양의 범위보다 1 더 넓은 것에 주목                  2.2.2 비부호형의 인코딩     음수 값을 포함하지 않음        B2U는 Binary 에서 Unsigned의 줄임말               2.2.3 2의 보수 two’s complement 인코딩     음수 값을 포함        B2T는 Binary 에서 Two’s complement의 줄임말                  모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며,  부호형 수에 대해서 특정 표시를 가정해서도 안된다.    2.2.4 비부호형과 부호형 간의 변환     C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.   2의 보수에서 비부호형으로의 변환            TMin ≤ x ≤ TMax를 만족하는 x에 대해  x가 0보다 크거나 같으면 x x가 0보다 작으면 x+2^w                  이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.            비부호형에서 2의 보수로의 변환            0 ≤ u ≤ UMax를 만족하는 u에 대해 u가 TMax보다 작거나 같으면 u u가 TMax보다 크면 u-2^w                  이유는 T2U의 이유와 동일하다.  이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)            2.2.5 C에서 부호형과 비부호형의 비교     C에서는 부호형과 비부호형 산술연산을 지원한다.            C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.            2.2.6 수의 비트 표시를 확장하기     비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.            영의 확장 zero extension 이라고 알려짐           2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.            부호 확장 sign extension 이라고 알려짐                  2.2.7 숫자의 절삭     진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.       비트의 개수를 줄이는 경우이다.            eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.           비부호형 수의 절삭            x’ = x mod 2^k 이다.                    삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.           자리값들은 모듈(mod) 계산으로 모두 0이 된다.                           2의 보수 숫자의 절삭            x’ = U2T(x mod 2^k) 이다.                    가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.                           2.2.8 Signed와 Unsigned에 관한 조언     부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.   비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.      2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다. 위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수                2.3 정수의 산술연산     두 개의 양수를 더해서 음수가 나오는 경우, x&lt;y와 x-y&lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,            그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.               2.3.1 비부호형 덧셈  x,y, 0≤x, y≤e^w가 있다고 하자, 두 합의 계산 범위는 0≤x+y≤2^(w+1)-2를 갖는다. 이 합의 크기를 표현 하기 위해서는 w+1개의 비트가 필요하게 된다.     “워드 크기 증가”는 산술연산의 결과를 완벽하게 표시하려면 필요한 워드 크기를 제한할 수 없다는 것을 의미한다.   프로그래밍 언어들은 고정길이 산술연산을 지원하며 따라서 “덧셈”과 “곱셈”같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.        x,y에 대해 x+y 정수합을 w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타낸다.                   정상적인 경우에는 x+y값을 유지하지만, 오버플로우의 경우에는 2^w만큼 줄어드는 효과를 낸다.                 산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때 이 연산은 “오버플로우한다”고 한다.         2.3.2 2의 보수의 덧셈  2의 보수 덧셈의 결과값이 너무 크거나(양수) 또는 너무 작아서(음수) 표시할 수 없을 때 우리는 어떻게 해야 할지 결정해야 한다.          x+y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산이다.                    2의 보수의 합이 2^(w-1)을 넘어간다면 양수 오버플로우가 생기고, -2^(w-1) 미만으로 내려간다면 음수 오버플로우가 생겨 각각에 2^w을 더해주거나 빼준다.         2.3.3 2의 보수에서의 비트반전 Negation          비부호형 비트반전                   2의보수 비트반전                   2.3.4 비부호형 곱셈     비부호형 곱셉은 2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것으로 정의된다.        비부호형 수를 w비트로 절삭하는 것은 해당 값을 2^w로 나눈 나머지를 계싼하는 것과 같다.                  2.3.5 2의 보수 곱셈          2^w로 나눈 나머지를 취하고 비부호형에서 2의 보수형태로 변환하는 것과 같다.                  2.3.6 상수를 사용한 곱셈     정수 곱셉은 매우 느리다. 컴파일러에서 수행되는 중요한 최적화는 상수를 곱하게 되는 경우들을 쉬프트와 덧셈의 조합으로 대체한다.   2의 제곱을 곱하는 경우            k≥0인 모든 k에 대해 x2^k의 w+k 비트수준 표현은 우측에 k개의 0을 추가한 것이다.       eg) 11은 w=4인 경우 [1011]이다. 이것을 왼쪽으로 k=2 쉬프트 하면 [101100]이 되며 이것은 11*4=44를 인코딩한 것이다.           2의 제곱을 곱하면 비부형이건 2의 보수 산술연산이건 오버플로우가 발생할 수 있다.            eg) 위의 예제를 예로 들자면, [101100]을 4비트로 절삭하면 1100을 얻는다.              정수 곱셈이 쉬프트와 덧셈을 사용하는 것보다 훨씬 비용이 많이 드는 연산이기 때문에 C 컴파일러들은 정수가 상수와 곱해지는 경우에 이들을 쉬프트, 덧셈, 뺄셈 등의 조합을 사용해서 제거하려고 노력한다.        2.3.7 2의 제곱으로 나눗셈하기     정수 나눗셈은 정수 곱셉보다 훨씬 느리다. 2의 제곱으로 나누는 것은 오른쪽 쉬프트를 사용한다.   비부호형은 논리 쉬프트, 2의 보수는 산술 쉬프트를 사용한다.   2의 보수 음수에서는 보정값을 더해서 결과값을 0 방향으로 근사하도록 한다.       2.3.8 정수 산술연산에 대한 마지막 고찰  컴퓨터에서 실행되는 “정수” 산술연산은 실제로는 modular 산술연산의 형태로 수행된다. 숫자를 표현하기 위해 유한한 길이의 워드를 사용하기 때문에 가능한 값의 범위가 제한되며 연산의 결과가 오버플로우될 수 있다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_03/",
        "teaser": null
      },{
        "title": "[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성",
        "excerpt":"IntelliJ  학교에서는 java를 배울 때 이클립스(Eclipse)를 사용했다. 하지만 python을 주로 다루면서 파이참(Pycharm)에 익숙해졌다.  java 공부를 하면서 좀 더 친숙한 JetBrains 회사의 개발도구를 사용하려고 한다. 정보를 조금 찾아보니 IntelliJ가 현재 내가 사용하고 있는 환경인 Mac Os에서 이클립스보다 오류가 덜 발생한다고 한다. 통합 개발 환경도 제공한다고 하니 이보다 더 좋을 수가 없다!    해당 포스트는 Mac Os 환경에서 진행되었다.   1. IntelliJ 설치  우선 IntelliJ Mac Os 버전을 설치하려면  IntelliJ 설치 링크 에 접속한다.  각자 Mac 환경에 맞는 파일을 다운로드한다.          java 학습을 위해선 Community Edition으로도 충분하다고 한다. 하지만 본인이 학생 신분이라면 학생 라이센스를 이용한 Ultimate 버전을 추천한다.          아래와 같은 창이 뜨면 설치 성공!      2. Java Project 만들기  위의 창에서 Create New Project를 누르면 아래와 같은 창이 열린다.   왼쪽의 리스트에서는 Java 선택, 오른쪽 리스트에서는 아무것도 선택하지 않고, 오른쪽 아래의 “Next” 버튼을 누른다.          Java 프로젝트를 생성할 때 샘플코드를 생성할지 여부.   본인이 직접 생성할 것이기 때문에 아무것도 선택하지 않고 “Next” 버튼을 누른다.          프로젝트 이름을 정하고 “Next” 버튼을 누른다.      3. Hello World 출력하기  프로젝트 생성이 완료되면, main 메소드가 있는 새로운 Java 클래스를 생성하기 위해 src 폴더를 우클릭한다.  New &gt; Java Class 를 선택한다.          새로 생성할 Java Class 이름을 설정하고 Enter를 친다.          Hello World 출력 코드를 작성한다.  상단의 망치 버튼을 클릭하여 빌드하거나 “control + option + R”키를 눌러 빌드한다.          혹은 out &gt; production &gt; “project_name” &gt; “Class_name” 우클릭 후 Run을 선택해도 된다.          이제 IntelliJ와 함께 Java 공부를 시작해보자,,,!  ","categories": ["IntelliJ"],
        "tags": ["Java","IntelliJ"],
        "url": "/intellij/java_01/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산",
        "excerpt":"Part1 자바 시작하기  Java     객체지향언어   C,C++ 문법을 기본으로 개발            C언어에 객체지향 특성 확장           플랫폼에 독립적임            JVM으로 인해서 어떤 플랫폼에서도 실행 가능함           Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌   JDK : Java Development Kit        JAVA 개발순서     코드 작성   코드 컴파일   컴파일한 소스를 JVM을 이용하여 실행        주석문     // : 행단위 주석   /* */ : 블럭단위 주석   /** ..*.. */ : 문서화 주석       Part2 변수와 계산   변수  변수 값(Data)을 저장할 수 있는 메모리 공간     java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨   java 식별자 명명 규칙            첫 번째 글자는 문자 이거나 $,_ 이어야 함       $,_ 이외의 특수문자는 사용 불가능       키워드는 식별자로 사용할 수 없음           java 변수 명명 관례            첫 번째 문자가 소문자인 명사로 정함       여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)       _를 쓰지 않음               상수  상수란 수식에서 변하지 않는 값을 의미     상수의 선언            final 상수타입 상수명;                    eg) final int J;                           상수 명명 관례            대문자로만 구성된 명사로 정함       여러 단어로 구성된 이릠의 경우 단어 사이에 _을 써서 구분함           상수를 사용해야 하는 경우            값이 변하면 위험한 경우에 상수 사용       값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용               기본형 타입  기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.     논리형            boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음           문자형            char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능           정수형            int 4byte, long 8byte           실수형            float 4byte, double 9byte           리터럴            CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어       리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함           사용 방법            long : 값을 적을 때 뒤에 l이나 L 적어야함       float : 값을 적을 때 뒤에 f나 F를 적어야함               기본형 타입변환     묵시적 형변환            크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌           명시적 형변환            크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함       eg) long x = 20; int y = (int) x;               연산자 우선순위     최우선연산자 ( ., [], () )   단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&gt;부호&gt;증감)            단, 후위연산자(a++)은 우선순위가 낮음       eg) a=5, x = a++ - 5 라면 x는 0, a는6           산술연산자 ( *,/,%,+,-,shift) &lt; 시프트연산자 ( »,«,»&gt; ) &gt;   비교연산자 ( &gt;,&lt;,&gt;=,&lt;=,==,!= )   비트연산자 ( &amp;,|,,~ )   논리연산자 (&amp;&amp; , || , !)   삼항연산자 (조건식) ? :   대입연산자 =,*=,/=,%=,+=,-=  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_02/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 제어문",
        "excerpt":"Part3 제어문   if 조건문  조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.     if 문   if - else 문   if - else if - else 문       논리 연산자  논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.                                     OR :                                       AND : &amp;&amp;   NOT : !   EXCLUSIVE-Or : ^       삼항 연산자     조건식 ? 피연산자1 : 피연산자2            조건식의 결과가 true 라면 결과는 피연산자1       조건식의 결과가 false 라면 결과는 피연산자2               switch문  switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.   switch(변수){         case 값1 :              실행문;              break;         case 값2 :              실행문;              break;           default;         }     break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.   JDK7 이후에는 문자열 타입의 변수도 가능함      당연한걸 수도 있지만, case 에 조건문을 달면 오류가 난다 하하,,,        while문  조건문의 실행 결과가 true일 동안 반복해서 실행한다.   while(조건문){         실행문;      }      do while문  while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.      do{         실행문;     }while(조건문);     실행문을 한번은 실행하고 싶을 경우에 사용됨       for 반복문  for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨       for(초기화식; 조건식; 증감식){         실행문;         실행문;     }  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 배열",
        "excerpt":"Part4 배열   배열 만들기  배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다.   int[] array1 = new int[4]; int[] array2 = new int[]{1,2,3,4}; int[] array3 = {1,2,3,4};      배열 사용하기     배열에 접근할 때에는 인덱스를 통해서 접근한다.   배열의 길이를 알아내는 방법 : array.length        2차원 배열  2차원 배열이란 배열의 배열이다.   int[][] array4 = new int[3][4];  int[][] array5 = new int[3][]; //위와 같이 선언하면 array5는 3개짜리 배열을 참조한다. 3개짜리 배열은 아직 참조하는 배열이 없다는 것을 의미. array5[0] = new int[1]; //정수를 하나 담을 수 있는 배열을 생성해서 array5 의 0 번째 인덱스가 참조한다.   array5[1] = new int[2]; //정수를 두개 담을 수 있는 배열을 생성해서 array5 의 1 번째 인덱스가 참조한다.   array5[2] = new int[3]; //정수를 세개 담을 수 있는 배열을 생성해서 array5 의 2 번째 인덱스가 참조한다.       for each  for문 안에 (value:array), array의 값 하나씩 value로 매칭된다.     python for in 이랑 똑같은거 같아서 너무 반갑다!    int[] iarr = {10,20,30,40,50};  for(int value:iarr){     System.out.println(value); } ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_04/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수           2.3 정수의 산술연산            비부호형 및 2의보수의 덧셈,뺄셈,곱셉,나눗셈                2.4 부동소수점     부동소수점 표현은 V = x*2^y 형태의 소수를 인코딩한다.   거의 모든 컴퓨터가 IEEE 부동소수점이라고 알려지게 된 방식을 지원한다.        2.4.1 비율이진수(Fractional Binary Numbers)     부동소수점에 대해서 이해하기 위한 첫 단계는 비율 이진수에 대해 생각해보는 것이다.            숫자들의 자리값은 십진 소수점 부호(‘.’)에 상대적으로 정의된다.                  위와 같은 방식으로 binary 표기법으로 생각해보자.            부호 ‘.’는 이진 소수점이 되고, 좌측의 브트들은 비음수의 2의 제곱을 자리값으로 가지며, 우측은 2의 음의 제곱을 자리값으로 갖는다.       이진 소수점을 한 자리 우측으로 이동하면 2로 곱한 효과, 좌측으로 이동하면 2로 나눈 효과를 가진다.                  이진수 표기는 x*2^y로 나타낼 수 있는 수만 표시할 수 있다.   이진 표시를 길게 늘려서 정확도를 높이도록 근사해야 한다.        2.4.2 IEEE 부동소수점 표시     IEEE 부동소수점 표준은 수를 V = (-1)^sM2^E 형태로 나타낸다            s는 음수와 양수를 결정한다.       유효숫자 M은 비율 이진수다.       지수 E는 2의 제곱으로 자리값을 제공한다.           부동소수점 수의 비트 표시는 이 값들을 인코딩하기 위해 세 개의 필드로 나누어진다.            한 개의 부호 비트 s는 부호 s를 직접 인코딩한다.       k비트 지수 필드 exp = ek-1…e1e0는 지수 E를 인코딩한다.       n비트 비율 필드 frac = fn-1 … f1f0는 유효숫자 M을 인코딩한다.                 Case 1: 정규화 값 Normalized Values            가장 일반적인 경우       exp의 비트 패턴이 모두 0은 아니며, 모두 1이 아니어야 한다.       E = e - Bias (Bias = 2^(k-1) - 1)       비율 필드 frac은 비율 값 f       유효 숫자 M = 1 + f 로 정의           Case 2: 비정규화 값 Denormalized Values            지수 필드가 모두 0일 때 나타낸 수는 비정규화 형태를 갖는다.       E = 1 - Bias       M = f = 0       비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타냄                    이들은 점증적 언더플로우라고 알려진 특성을 제공 (가능한 숫자 값들이 0.0 근처에서 같은 간격을 갖는다는 의미)                           Case 3: 특수 값 Special Values            지수 필드가 모두 1인 경우                    비율 필드가 모두 0이면, 결과값은 무한대를 나타냄           비율 필드가 0이 아니면 NaN(not a numbuer)                                   2.4.3 숫자 예제      2.4.4 근사법 Rounding     부동소수점 산술연산은 표시방법이 제한된 범위와 정밀도를 갖기 때문에 실제 연산의 근사값을 사용할 수밖에 없다.   “가장 유사한” 값 x를 체계적으로 계산하는 방법을 근사rounding 연산이다.   네가지 근사 모드를 정의함            짝수근사법(round-to-even): 가장 가까운 값, 중간에 위치할 경우 짝수를 향해 근사함       영방향근사 모드(round toward-zero): 양수 값을 아래쪽으로, 음수를 위쪽으로 근사함       하향근사 모드(round-down): 양수와 음수를 모두 아래쪽으로 근사함       상향근사 모드(round-up): 양수와 음수를 모두 위쪽으로 근사함                2.4.5 부동소수점 연산     부동소수점 값 x,y를 실수로 보고, 일부 연산이 실수들에 대해 정의된다면 Round(x,y)가 되는데, 이것은 실수 연산의 정확한 결과 값을 근사한 것이다.   부동소수점 덧셈에서 결합법칙이 성립하지 않는 것은 그룹의 특징 중에서 빠진 가장 중요한 부분이다.   교환법칙은 성립하지만, 결합벅칙은 성립 되지 않는다.        C에서 부동소수점     C는 짝수 근사모드를 사용한다.   int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.   int나 float에서 double로, 정확한 수치 값은 보존될 수 있다.   double에서 float로 범위가 더 작아지기 때문에 값이 오버플로우하여 무한대가 될 수 있따.   float나 double에서 int로, 값은 0 방향으로 근사된다        2.5 요약     정보를 비트로 인코딩하며, 이들은 일반적으로 연속된 바이트들로 구성된다.   대부분의 머신들은 정수를 인코딩하기 위해 2의 보수를 사용하고 부동소수점을 인코딩하기 위해 IEEE 표준 754를 사용한다.   부호형 및 비부호형 정수를 캐스팅할 때 비트 패턴을 유지하려고 하는데, T2U, U2T 함수들에 의해 나타난다.   제한된 길이는 숫자들이 나타낼 수 있는 범위를 넘어설 때 오버플로우를 발생시킨다.   비부호형과 2의 보수 산술연산은 결합법칙, 교환법칙, 분배법칙 등의 정수 산술연산의 많은 특성을 만족한다.   결합법칙, 교환법칙, 분배법칙 특성을 쉬프트와 2의 제곱의 곱셈 간 관계와 함께 사용된다.   부동소수점 산술연산은 매우 조심스럽게 사용해야한다.            제한된 범위와 정밀도를 갖기 때문이며, 결합법칙 같은 일반적인 수학 법칙을 따르지 않기 때문이다.                   부동소수점을 마지막으로 Chapter2 정보의 표현과 처리를 마무리하였다. 데이터 엔지니어링 인턴 포지션에서 ETL 작업을 하며 소수점 데이터에 접근 했을 때  R코드와 Python의 소수 처리 방식이 달라서 해당 오류를 잡는데 많은 시간이 걸린 경험이 있었다. 그 때 당시에는 대충 방식이 다르구나~ 로 끝났지만, 이번 챕터를 공부하게 되면서 아 부동소수점의 표현 방식 때문에(책은 C를 기준으로 하고 있지만,,,) 그런 오류가 잡혔던 거구나 하고 시야가 조금 더 넓어진 것 같다.  2.2절의 캐스팅과 2.4절의 부동소수점을 공부하면서 꽤 많은 애를 먹었지만, 앞으로 코딩을 하면서 캐스팅이나 소수점을 다룰 때 더 주의 깊게 다룰 수 있을 것 같다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_04/",
        "teaser": null
      },{
        "title": "[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰",
        "excerpt":"Introduction     Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나   Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델   NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음            Machine Translation, Abstract Text Summarization           자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨   Encoder-Attention-Decoder       Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형   Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조       Related Works       Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train   GPT는 Language Modeling을 위해 Decoder를 Pre-train   이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음       MASS:Masked Sequence to Sequence Pre-training       새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자   Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking   마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴   Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공   Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선   Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨        K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터   하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능   BERT Masked LM            K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐           GPT Standard LM            하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨       Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐                m - Input sequence의 전체길이   u - Maskinge된 Fragment의 시작점   v - Masking된 Fragment의 끝점   X^u - u부터 v까지의 fragment   X^\\u:v - u부터 v까지 Making된 Input Sequence       Experiments     Model Configuration            1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer           Datasets            2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M       MASS의 효과 검증을 위한 low-resource language Romanian           Pre-training Details            Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험               Experiment:Unsupervised Machine Translation       Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행   Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델   MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록        Experiment:Low-resource Translation       Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역   Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트   MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가   데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남        Experiment:Abstractive Summarization       Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교   MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가        Experiment:Conversational Response Generation       Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교   MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌        The probability formulation       (a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL   하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과   실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨            문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공           K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증       Couclusion     MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록   Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정   또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%       Related Works     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.       Model     ELMO            ELMO word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM          Task-specific ELMo Embedding         Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.                  Evaluation         6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.        Analysis        기존에 top layer output만 사용 한 것 대비 성능 향상을 검증했다.   대부분의 경우 Regularization parameter λ 가 작을수록 성능이 더 좋아지는 경향이 있다.          일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.          GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.          biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다.          ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.       Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속되 바이트인 기계어 코드를 실행한다.   컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 기계어 코드를 생성한다.   어셈블러 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는 저급 인스트럭션들을 명시해야 한다.   기계어 코드를 배우면 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내제된 비효율성을 분석할 수 있다.   이 장은 X86-64에 기초하고 있다.        3.1 역사적 관점     x86이라고 통칭하는 인텔 프로세서 제품군은 오랜 기간 진화를 통한 개발을 해왔다.            대충 엄청 많은 프로세서들이 나열 되는데, 팬티엄4E(2004, 125M 트랜지스터) 하이퍼쓰레딩 기법의 추가와 AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T가 추가된 해당 모델을 x86-64라고 부른다고 한다.                 3.2 프로그램의 인코딩     C 언어에서 gcc 명령은 소스 코드(test.c)를 실행 코드로 변환하기 위해 일련의 프로그램들을 호출한다.            C 전처리가 #include로 명시된 파일을 코드에 삽입해 주고 #define으로 선언된 매크로를 확장해준다.       컴파일러는 소스파일의 어셈블러 버전(test.s)를 생성한다.       어셈블러는 어셈블리 코드를 바이너리 목적코드인(test.o)로 변환한다.                    목적코드는 기계어 코드의 한 유형이다. - 모든 인스트럭션과 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았다.                       마지막으로 링커가 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.           커맨드 라인 옵션으로 -0g를 주면 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적호 수준을 적용한다.            높은 수준의 최적화를 적용하면 만들어진 코드가 너무 많이 변경되어 본래의 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.                3.2.1 기계수준 코드     컴퓨터 시스템은 보다 간단한 추상화 모델을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.            기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조 즉 “ISA”에 의해 정의된다.                    프로세서의 상태, 인스트럭션의 형식, 프로세서 상태에 대한 각 인스트럭션들의 영향들을 정의한다.                       기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.           컴파일러는 추상화된 실행모델로 표현된 프로그램을 프로세서가 실행하는 매우 기초적인 인스트럭션들로 변환하는 대부분의 일을 수행한다.        3.2.2 코드 예제       기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현에 주목할 필요가 있다.            x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.       인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을 기계어 인스트럭션으로 유일하게 디코딩할 수 있도록 설계한다.       역어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다.                3.3 데이터의 형식     인텔 프로세서들이 근본적으로 16비트 구조를 사용하다가 추후에 32비트로 확장했기 때문에 인텔은 “워드”라는 단어를 16비트 데이터 타입을 말할 때 사용한다.           3.4 정보 접근하기     x86-64 주처리장치 CPU는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.            이들 레지스터는 정수 데이터와 포인터를 저장하는데 사용한다.                   3.4.1 오퍼랜드 식별자 specifier     대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다.   오퍼랜드는 연산을 수행할 소스 값과 그 결과를 저장할 목적지의 위치를 명시한다.   소스 값은 상수로 주어지거나 레지스터나 메모리로부터 읽을 수 있다. 결과 값은 레지스터나 메모리에 저장된다.   세가지 타입으로 나뉘어짐            immediate로, 상수값을 말한다.       register는 레지스터의 내용을 나타내며       Memory, 메모리 참조로 유효주소라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.                   3.4.2 데이터 이동 인스트럭션     가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 복사하는 명령어다.            MOV 클래스 : 소스 위치에서 데이터를 목적지 위치로 어떤 변환도 하지 않고 복사한다.           소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다.   목적 오퍼랜드는 레지스터 또는 메모리 주소의 위치를 지정한다.   x86-64는 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다.              3.4.3 코드 예제           C언어에서 “포인터”라고 부르는 것이 어셈블리어에서는 단순히 주소를 나타낸다.     포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 과정으로 이루어진다.     지역변수들은 메모리에 저장되기보다는 종종 레지스터에 저장된다.           3.4.4 스택 데이터의 저장과 추출 push,pop     push와 pop은 프로그램 스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다.   스택은 프로시저 호출을 처리하는 데 중요한 역할을 한다.   프로그램 스택은 메모리의 특정 영역에 위치한다.   스택의 탑top 원소가 모든 스택 원소 중에서 가장 낮은 주소를 갖는 형태다.   스택은 pop이 되어도 stack의 top을 표현하는 주소가 올라간거지 값은 여전히 pop이 된 위치에 남아있다.   스택이 프로그램 코드와 다른 형태의 프로그램 데이터와 동일한 메모리에 저장되기 때문에 프로그램들은 표준 메모리 주소지정 방법을 사용해서 스택 내 임의의 위치에 접근할 수 있다.      ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_05/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.5 산술연산과 논리연산       위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.   인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.            addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.           연산들은 네 개의 그룹으로 나누어진다.            유효주소 적재, 단항unary, 이항binary, 쉬프트                    이항 연산은 두 개의 오퍼랜드를 가진다.           단항 연산은 한 개의 오퍼랜드를 가진다.                           3.5.1 유효주소 적재 Load Effective Address     유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.   메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.   가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.   이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.   또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다            ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.           목적 오퍼랜드는 반드시 레지스터만 올 수 있다.   3.5.2 단항 및 이항 연산     단항 연산            하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.       오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.       ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자           이항 연산            첫 번째 오퍼랜드는 상수나 레지스터, 메모리 위치가 올 수 있고 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.       C에서 x -= y와 유사하다.       두 개의 오퍼랜드가 모두 메모리 위치가 될 수 없다.       두 번째 오퍼랜드가 메모리 위치일 때 프로세서가 메모리에서 값을 읽고, 연산을 하고, 그 결과를 다시 메모리에 써야 한다는 점에 유의해야 한다.           3.5.3 쉬프트 연산     쉬프트하는 크기를 먼저 주고, 쉬프트할 값을 두 번째로 준다.   산술과 논리형 우측 쉬프트가 모두 가능하다.   쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 명시할 수 있다.   좌측 쉬프트 인스트럭션에는 두 가지 이름이 있다.            SAR: 산술 쉬프트, 부호비트를 복사해서 채운다       SHR: 논리 쉬프트, 0으로 채운다           쉬프트 연산의 목적 오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.   3.5.4 토의     인스트럭션들은 비부호형과 2의 보수 산술연산에 사용될 수 있다.   오직 우측 쉬프트만이 부호형과 비부호형 데이터를 구분하는 인스트럭션을 요구한다.   이것이 부호형 정수 산술연산을 구현하는 방식으로 2의 보수 산술연산을 선호하는 주요 특징이다.   3.5.5 특수 산술연산       두 개의 64비트 부호형 또는 비부호형 정수들 간의 곱셈 결과값을 표시하기 위해 128비트를 필요로한다.   x86064 인스트럭션 집합은 128비트 숫자와 관련된 연산에 대해서는 제한적인 지원을 제공한다.            워드(2바이트), 더블워드(4바이트), 쿼드워드(8바이트), 인텔은 16바이트 워드를 옥트워드oct word라고 명명한다.           IMUL 인스트럭션 클래스의 멤버인 형태            이 형식은 두 개의 64비트 오퍼랜드로부터 64비트 곱을 생성하는 “2 오퍼랜드” 곱셈 인스트럭션을 제공한다.           추가적으로 x86-64는 두 개의 다른 “단일 오퍼랜드” 곱셈 인스트럭션을 제공하며 64비트 값의 완전한 128비트 곱을 계산한다.            하나는 비부호형(mulq), 다른 하나는 2의 보수(imulq) 곱셈이다.       이들 모두 한 개의 인자는 레지스터 %rax에 보관해야 하고 다른 하나는 인스트럭션 소스 오퍼랜드로 주어진다.       곱은 레지스터 %rdx(상위 64비트)와  %rax(하위 64비트)에 저장된다.           곱을 저장하기 위해서는 아래의 그림처럼 두 개의 movq 인스트럭션이 필요하다.        단일 오퍼랜드 곱셈 인스트럭션과 비슷한 단일 오퍼랜드 나눈셈 인스트럭션으로 제공된다.   나눗셈 인스트럭션 idviq은 피제수dividened를 128비트로 레지스터 %rdx(상위 64비트)와 %rax(하위 64비트)에 저장한다.   제수divisor는 인스트럭션의 오퍼랜드로 주어진다.   인스트럭션은 몫은 레지스터 %rax에, 나머지는 레지스터 %rdx에 저장한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_06/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰",
        "excerpt":"Introduction     Multi-Task Learning(MTL)은 새로운 Task를 학습하는 데 도움이 되도록 이전 작업에서 학습된 지식을 적용하는 인간 학습 활동에서 영감을 받음   Deep neural networks(DNN)를 이용한 representation learning에 MTL을 적용하는 것에 대한 관심이 높아지고 있음            DNN을 이용한 representation learning은 많은 양의 데이터를 요구함, MTL은 많은 task에서의 supervised labeled data를 제공함       MTL은 특정 Task에 Overfitting 되지 않도록 Regularization 효과를 줌           MTL과 대조적으로, Language Model은 대용량의 unsupervised dataset을 활용하여 모델을 학습함            ELMo, GPT, BERT           MT-DNN은 Language Model Pre-Training을 활용한 BERT에 Multi-task learning을 적용하여 성능을 개선한 모델      Tasks     GLUE의 9개 task를 MTL에 활용   Single Sentence Classification            하나의 문장이 주어졌을 때 문장의 Class를 분류하는 Task       CoLA : 문장이 문법적으로 맞는지 분류 (True/False)       SST-2 : 영화 Review 문장의 감정 분류 (Poistive/Negative)           Text Similarity            문장 쌍이 주어졌을 때, 점수를 예측하는 Regression Task       STB-B : 문장 간의 의미적 유사도를 점수로 예측           Pairwise Text Classification            문장 쌍이 주어졌을 때, 문장의 관계를 분류하는 Task       RTE, MNLI : 문장 간의 의미적 관계를 3가지로 분류 (Entailment, Contradiction, Neutral) – QQP, MRPC : 문장 간 의미가 같음 여부를 분류 (True/False) – Relevance Ranking – QNLI : 질문과 해당 지문 중 한 문장이 쌍으로 주어졌을 때 해당 지문 문장에 질문의 답이 있는지 여부를 분류 (True/False) – MT-DNN에서는 이를 Rank 방식으로 바꾸어 모든 지문 문장에 정답이 있을 가능성을 Scoring 하여 가장 Score가 높은 지문 문장을 True로 분류하는 방식으로 Task 수행              Model Architecture         Lexicon Encoder            Token Embedding                    맨 앞에 [CLS] 토큰을 추가. 추후 Output에서 Classification 등을 위해 사용됨           만약 문장쌍이 들어온다면 각 문장은 Wordpiece로 Toenization 되며 [SEP] Token이 두 문장 사이의 구분자로 사용됨                       Sentence Embedding - 1번째 혹은 2번째 문장임을 표현하는 Vector       Positional Embedding - 각 Token의 위치 정보를 표현하는 Vector                 Transformer Encoder            Lexicon Encoder로 부터 각 Token의 Input Vector를 입력으로 받아 Ouput Vector 추출       BERT 모델과 달리 task별로 fine-tunning하지 않고 MTL로 fine-tunning 함                 Single-Sentence Classification Ouput            [CLS] Token과 Task Specific Parameter의 곱에 Softmax를 취하여 Ouput 추출                  Text Similarity Ouput            [CLS] Token을 활용하여 Task Specific Parameter와 곱한 후 sigmoid function을 사용하여 Score를 예측                  Pairwise Text Classification Ouput            BERT와 다르게 Stochastic Answer Network(SAN)를 이용함                    NLI의 기존 SOTA 모듈, 주어진 문장들에 대한 Multi-step Reasoning을 모델링하는 구조 (한번에 classification 결과를 예측하지 않고 여러번의 예측을 통한 Reasoning으로 결과를 예측)           SAN은 GRU모듈에 주어진 문장쌍의 representation을 Input 및 hidden state로 넣는 과정을 k번 반복함으로써 정제된 representation을 얻고 이를 이용하여 최종 예측                                 각 step을 진행할때마다 linear classifier를 거쳐 각 클래스에 대한 확률 분포 계산         모든 K-step output을 평균하여 클래스에 대한 최종 확률 분포를 계산, averaging 연산 전에 stochastic prediction droput을 적용         Relevance Ranking Ouput            Question과 문장 Pair Input으로 넣어 생성한 [CLS] Token에 Sigmoid를 취하여 문장 별로 점수를 Scoring하고 가장 높은 점수 만 Question에 해당하는 정답이 있다고 예측하는 방식              Training Procedure      Experiments     Datasets            GLUE 벤치마크는 QA, Sentiment Analysis, Text Similarity, Textual Entailment를 포함한 NLU task       SNLI 데이터셋은 570K개의 문장 쌍       SciTail은 Science Question Answering 데이터셋에서 파생된 Textual Entailment 데이터셋임                    주어진 전제가 주어진 가설을 수반하는지 여부를 평가                                  Implementation details            Optimizer : Adamax       learning rate : 5e-5       Batch Size : 32       Maximum number of epoch : 5       Fine-tuning layer dropout : task마다 다르게 설정(MNLI:0.3, CoLA:0.05, Else:0.1)       Tokenizer : WordPiece           Experiments - GLUE Results         MT-DNN이 BERT보다 전체 성능이 약 1.8% 향상됨   각각의 Task 결과가 대부분 SOTA임        Dataset이 적은 Task(MRPC, RTE)의 경우 비교적 높은 성능 향상이 있음              Specific layer로 SAN 사용, pairwise ranking을 한 효과를 보여주는 실험   BERT vs ST-DNN            ST-DNN은 BERT처럼 single-task로 fine-tunning함       MNLI, QQP, MRPC, QNLI에서 BERT보다 성능이 좋음           ST-DNN vs MT-DNN            데이터가 적은 실험에서 더 큰 성능향상이 있음           Experiments - Domain Adaptation Results         SNLI와 SciTail에 MT-DNN을 적용한 실험   MT-DNN은 데이터를 0.1%만 써도 성능이 잘나옴   MT-DNN이 BERT보다 데이터가 적을 때, 압도적인 성능을 보여줌   Conclusion      Multi-task learning model과 pre-training을 결합한 MT-DNN 모델 제안   MT-DNN은 SNLI, SchiTail 및 GLUE에서 10가 NLU task에 높은 성능 향상 결과를 얻음   MT-DNN은 Domain Adaption 실험에서도 탁월한 일반화 기능을 보여줌   MT-DNN 개선을 위해 MTL에서의 모델 구조 공유에 더 깊은 이해, fine-tuning과 pre-training을 위한 더 효과적인 훈련 방법을 더 연구해야함  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 클래스와 객체",
        "excerpt":"Part5 클래스와 객체   클래스 선언     클래스            자바는 객체를 만들기 위해 반드 클래스를 먼저 만들어야 한다. 클래스는 객체를 만들기 위한 일종의 틀이다.                    붕어빵이 객체라면, 붕어빵 틀은 클래스           자동차 클래스 생성           컴파일하여 디스크에 Car라는 클래스를 생성한다.           자동차 클래스가 생성되었다고 해서 자동차가 만들어 진것은 아니다.                                   public class Car{         }        Car객체 생성하기 (자동차 만들기)            new 연산자는 new 연산자 뒤에 나오는 생성자를 이용하여 메모리에 객체를 만들라는 명령.       메모리에 만들어진 객체를 인스턴스(instance)라고도 한다.       이렇게 만들어진 객체를  참조하는 변수가 c1, c2 이다.       아래의 코드가 실행되면 Car라는 객체가 2개가 만들어지고 각각의 객체를 참조하는 c1과 c2변수가 선언된다.                   public class CarExam{              public static void main(String args[]){                 Car c1 = new Car();                 Car c2 = new Car();             }          }  참조타입  참조형 타입은 기본형 타입을 제외한 모든 타입입니다. 앞서 배웠던, 배열도 참조형이고, 클래스도 모두 참조 타입이다.     기본형 타입: boolean, char, byte, short, int, long, float, double   참조형 타입: 기본형 타입을 제외한 모든 타입   참조형 변수            Stirng str = new String(“Hello);                    str 변수 앞에 기본형 타입이 아닌 String 클래스가 적혀있다.           이퀄(=) 뒤에는 new 다음에 생성자라는 것이 있다.           new 라는 키워드는 객체를 메모리에 올려준다. 이렇게 메모리에 올라간 객체를 인스턴스라고 말한다.                       메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 레퍼런스 하는 변수가 str 이다. 레퍼런스 한다라는 것은 변수가 인스턴스를 가지고 있는게 아니라 말 그대로 가리킨다는 의미이다.       str이라는 변수에는 메모리의 위치 값이 저장되는 것이다. 메모리의 위치값이 저장된다고 하더라도,  어떤 메모리에 저장되는지 그 정보를 알 수 있는 방법은 없다. 그렇기 때문에 str변수는 String 인스턴스를 참조한다라고만 알면 된다.           String 클래스  문자열을 표현하는 자바에서 가장 많이 사용하는 클래스    자바 인스턴스 생성 방법     new 연산자를 이용하지 않고 인스턴스를 만드는 경우            “hello”라는 문자열이 메모리 중에서 상수가 저장되는 영역에 저장된다. 상수는 변하지 않는 값을 의미.       String str2 = “hello”; 이 문장이 실행될 때에 hello 라는 문자열 상수는 이미 만들어져 있으므로 str1이 참조하는 인스턴스를 str2도 참조한다.               String str1 = \"hello\";     String str2 = \"hello\";      new 연산자를 이용해서 인스턴스를 만드는 경우            new연산자를 이용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어진다.       String str4 = new String(“hello”); 이 문장이 실행될때도 새롭게 만들게 되므로, str3 과 str4는 서로 다른 인스턴스를 참조한다.       변수끼리 == 로 비교하면 서로 같은 것을 참조하는지 비교한다.       String은 다른 클래스와 다르게 new를 사용하지 않고 사용할 수 있다. 메모리를 아끼려면 String은 new를 사용하지 않고 사용하는 것이 좋다.       String은 불변 클래스이다. 불변이란 String이 인스턴스가 될때 가지고 있던 값을 나중에 수정할 수 없다.       String은 문자열과 관련된 다양한 메소드를 가지고 있다. 메소드를 호출한다 하더라도 String은 내부의 값이 변하지 않는다.       String이 가지고 있는 메소드중 String을 반환하는 메소드는 모두 새로운 String을 생성해서 반환한다.               String str3 = new String(\"hello\");     String str4 = new String(\"hello\");  필드(filed) 선언  자동차는 자동차 이름, 자동차 번호를 가지고 있고, 자동차는 달리고 멈추는 기능이 있따. 여기에서 가지고 있는 것을 속성이라고 한다. 자바에서는 이러한 속성을 필드(Field)라는 용어로 사용한다.     이름과 번호를 필드로 가지고 있는 Car 클래스 선언       public class Car{         String name;             int number;     }     Car 클래스를 인스턴스화 하기       Car c1 = new Car();     Car c2 = new Car();     //Car라는 인스턴스가 메모리에 2개 만들어 진다. 객체별로 name과 number라는 속성을 가진다.     속성 이용하기            참조 변수 다음에 나오는 점(dot)은 참조변수가 참조하는 객체가 가지고 있는 것을 사용할 때 사용               //c1.name은  c1이 참조하는 객체의 name 을 의미.      c1.name = \"소방차\";  //c1이 참조하는 객체의 name을 소방차로 설정      c1.number = 1234;   // c1.number = 1234란 c1이 참조하는 객체의 number를 1234 로 설정       c2.name = \"구급차\"  //c2가 가리키는 객체의name을 구급차로 설정     c2.number = 1004;  //c2가 가리키는 객체의 number를 1004로 설정       System.out.println(c1.name);  //콘솔에 c1이 참조하는 객체의 name 을 출력합니다.      System.out.println(c1.number); //콘솔에 c1이 참조하는 객체의 number 를 출력합니다.       String name = c2.name;   //c2가 참조하는 객체의 name 을 String 타입 변수 name 도 참조하게 합니다.  메소드란?     필드가 물체의 상태라면, 물체의 행동에 해당하는게 메소드다. car에 이름과 번호가 있기도 하지만, car는 앞으로 전진할 수도 있고 후진하는 행동도 할 수 있다.            메소드는 입력값이 있고, 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념이다.       이때 입력값을 매개변수라고 하고, 결과값을 리턴값이라고 한다.                    인자(Argument)는 어떤 함수를 호출시에 전달되는 값을 의미한다.           매개 변수(Parameter)는 그 전달된 인자를 받아들이는 변수를 의미한다.                       메소드란 클래스가 가지고 있는 기능이다. 클래스 안에 선언된다.           메소드(Method) 선언     매개변수도 없고 리턴하는 것도 없는 형태의 메소드            리턴하는 것이 없을 경우 void라고 작성합니다.               public class MyClass{         public void method1(){             System.out.println(\"method1이 실행됩니다.\");         }     }          정수를 받아들인 후, 리턴하지 않는 메소드            받아 들이는 값은 어떤 타입이라도 상관없다.       받아 들이는 값의 수는 여러개 일 수 있다. 여러개일 경우 콤마(,)로 구분한다.               public class MyClass{                public void method2(int x, int y){             System.out.println(x + \" 를 이용하는 method2입니다.\");         }        }          정수를 받아들인 후, 정수를 반환하는 메소드       public int method3(int y){         System.out.println(y + \" 를 이용하는 method5입니다.\");         return 5;     }       String 클래스의 메소드     문자열 길이 구하기            str.length()는 str이 참조하는 문자열의 길이를 구해서 int 타입으로 리턴해주는 메소드이다.           문자열 붙이기(concat)            str.concat(“world”) 메소드는 str이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world를 붙여서 String 타입으로 리턴하는 메소드다.       String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.           문자열 자르기(subString)            str.subString(1,3)은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.       str.subString(2)는 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.           변수의 scope와 static  변수의 scope: 프로그램상에서 사용되는 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의스코프라고 한다.     변수가 선언된 블럭이 그 변수의 사용범위이다.            클래스의 속성으로 선언된 변수 globalScope의 사용 범위는 클래스 전체이다.       매개변수로 선언된 int value는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭 내이다.       메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭 내이다.               public class ValableScopeExam{          int globalScope = 10;   // 인스턴스 변수           public void scopeTest(int value){                int localScope = 10;             System.out.println(globalScope);             System.out.println(localScpe);             System.out.println(value);         }     }          main메소드에서 사용하기            같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.       main은 static한 메소드이다. static한 메소드에서는 static 하지 않은 필드를 사용 할 수 없다.               public class VariableScopeExam {         int globalScope = 10;           public void scopeTest(int value){             int localScope = 20;                         System.out.println(globalScope);             System.out.println(localScope);             System.out.println(value);         }            public static void main(String[] args) {             System.out.println(globalScope);  //오류             System.out.println(localScope);   //오류             System.out.println(value);        //오류           }        }          static            같은 클래스 내에 있음에도 해당 변수들을 사용할 수 없다.       main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메소드를 static 한 메소드라고 한다.       static한 필드(필드 앞에 static 키워드를 붙임)나, static한 메소드는 Class가 인스턴스화 되지 않아도 사용할 수 있다.               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }          static한 변수는 공유된다.            static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.       globalScope같은 변수(필드)는 인스턴스가 생성될 때 생성되기 때문에 인스턴스 변수라고 한다.       staticVal같은 static한 필드를 클래스 변수라고 한다.       클래스 변수는 레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는 것이 더 바람직하다.                    VariableScopeExam.staticVal                               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }       열거형(enum)     자바는 열거타입을 이용하여 변수를 선언할 때 변수타입으로 사용할 수 있다.            열거형은 JDK5에서 추가되었다.       JDK5 이전에는 상수를 열거형 대신 사용                    상수를 이요한는 방법                               public class EnumExam {         public static final String MALE = \"MALE\";         public static final String FEMALE = \"FEMALE\";          public static void main(String[] args) {             String gender1;              gender1 = EnumExam.MALE;             gender1 = EnumExam.FEMALE;                           }     }          상수를 사용했을 때의 문제점            String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에   gender1 = “소년”; 이렇게 수행 되어도 전혀 문제가 되지 않는다.       실행할 때 원했던 값인 MALE,FEMALE이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.           해결 방법            이런 문제를 발생시키지 않게 하기 위해 열거형을 사용한다.       열거형 정의 및 사용 방법               // 정의 방법     enum Gender{         MALE, FEMALE;     }            // 사용 방법     Gender gender2;      gender2 = Gender.MALE;     gender2 = Gender.FEMALE;      //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.            enum에 대해서 좀 더 궁금하다면!! enum의 뿌리   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part6 클래스 다듬기 ",
        "excerpt":"Part6 클래스 다듬기   생성자  모든 클래스는 인스턴스화 될 때 생성자를 사용한다.      생성자의 특징            생성자는 리턴타입이 없다.       생성자를 프로그래머가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어진다.       매개변수가 없는 생성자를 기본생성자라고 한다.       생성자를 하나라도 프로그래머가 만들었따면 기본생성자는 자동으로 만들어지지 않는다.           생성자의 역할            생성자가 하는 일은 객체가 될 때 필드를 초기화 하는 역할을 수행한다.       자동차가 객체가 될 때 반드시 이름을 가지도록 하려면, Car 클래스를 다음과 같이 만들어야 한다.               public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }            // 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법     public class CarExam2{         public static void main(String args[]){                  Car c1 = new Car(\"소방차\");             Car c2 = new Car(\"구급차\");             //Car c3 = new Car(); // 컴파일 오류가 발생합니다.                  System.out.println(c1.name);                  System.out.println(c2.name);         }     }     // Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.       this  this는 현재 객체, 자기 자신을 나타낸다.      this의 사용       public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }                 Car 클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽게 알 수 없다.       n 으로 쓰기 보다는 name 으로 사용하는 것이 좋다.               public Car(String name){         name = name;     }                 “name=name”이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 “name=name”이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.       즉, 필드는 바뀌지 않는다. 이런 경우 필드라는 것을 컴파일러와 JVM에게 알려주기 위해서 this 키워드를 사용해야 한다.               public Car(String name){         this.name = name;     }                 앞의 this.name은 필드 name을 말하고 =(이퀄) 뒤의 name은 매개변수를 의미한다.       즉 매개변수의 값을 필드에 대입하라는 의미가 된다.           클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.   메소드 오버로딩     매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게하는 기술   메소드 오버로딩            이름은 같지만 매개변수가 다른 메소드       메소드 오버로딩은 매개변수 부분이 달라야 한다.       매개변수의 타입과 개수가 동일한 메소드를 또 정의 할 수는 없다.           오버로딩된 메소드 이용하기            메소드의 인자에 어떤 값이 쓰이냐에 따라서 각기 다른 메소드가 호출된다.               public MethodOverloadExam{         public static void main(String args[]){             MyClass2 m = new MyClass2();             System.out.println(m.plus(5,10));             System.out.println(m.plus(5,10,15));             System.out.println(m.plus(\"hello\" + \" world\"));         }     }  생성자 오버로딩과 this     생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.            생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.       매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.               public class Car{         String name;         int number;          public Car(){          }          public Car(String name){             this.name = name;         }          public Car(String name, int number){             this.name = name;             this.number = number;         }     }     오버로딩된 생성자 이용하기   public class CarExam4{     public static void main(String args[]){         Car c1 = new Car();         Car c2 = new Car(\"소방차\");         Car c3 = new Car(\"구급차\", 1234);     } }     자기 생성자 호출하는 this()            기본생성자를 호출하였을 때 name을 “이름없음”, 숫자를 0으로 초기화 하기               public Car(){         this.name = \"이름없음\";         this.number = 0;     }       -     - 위처럼 작성했을 경우 코드의 중복이 일어난다.     - 자신이 가지고 있는 다른 생성자를 이용할 수 있다.       public Car(){         this(\"이름없음\", 0);     }       패키지  패키지(package)란 서로 관련이 있는 클래스 또는 인터페이스들을 묶어 놓은 묶음이다. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록 하고, 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 관리를 편하게 해준다.     패키지 정의방법            package이름은 보통 도메인 이름을 거꾸로 적은 후, 그 뒤에 프로젝트 이름을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.       package이름은 폴더명 점 폴더명 점 폴더명 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.       도메인 이름이 8cruz.com 이고 프로젝트 이름이 javastudy 라면 com.eightcruz.javastudy.Hello 로 패키지를 지정 할 수 있다.                    도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.           도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.                           패키지에 생성된 클래스 사용하기            java.lang 패키지를 제외하고는 다른 패키지에 있는 클래스를 사용하려면 import라는 구문을 적어줘야 한다.                    import com.eightcruz.javastudy.Hello;           import com.eightcruz.javastudy.*;                            해당 패키지에 있는 모든 클래스를 사용한다는 의미                                                   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_06/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 상속",
        "excerpt":"Part7 상속   상속     상속이란? 부모가 가진것을 자식에게 물려주는 것을 의미한다.            노트북은 컴퓨터의 한 종류다.       침대는 가구의 한 종류다. 혹은 침대는 가구다.       소방차는 자동차다.           이렇게 말할 수 있는 관계를 is a 관계 혹은 kind of 관계라고 한다.      Car를 상속받은 Bus를 class로 표현하는 방법            자바는 클래스 이름 뒤에 extends 키워드를 적고 부모 클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.       상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있께 된다.               public class Car{      }      public class Bus extends Car{      }     부모 클래스와 자식 클래스의 메소드            자식 클래스는 부모 클래스에 선언된 메소드를 사용할 수 있다.       자식 클래스는 부모가 가지고 있는 메소드 외에 추가로 메소드를 선언할 수 있다.                    이것을 확장하였다고 표현한다.                           접근제한자  접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.      접근 제한자의 종류            public                    어떤 클래스든 접근할 수 있다는 것을 의미                       protected                    자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속받은 자식 클래스에서는 접근할 수 있다는 것을 의미                       private                    자기 자신만 접근할 수 있다는 것을 의미                       접근제한자를 적지 않으면 default 접근 지정자                    자기자신과 같은 패키지에서만 접근할 수 있다는 것을 의미(상속X)                       public &gt; protectd &gt; default &gt; private           추상클래스  추상 클래스란 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하는데 새, 포유류 같은 것은 구체적이지 않다.     추상 클래스 정의하기            추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.       추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.                    추상 메소드란, 내용이 없는 메소드이다. 즉 구현이 되지 않은 메소드이다.           추상 메소드는 리턴 타입 앞에 abstract라는 키워드를 붙여야 한다.                       추상 클래스는 인스턴스를 생성할 수 없다.               public abstract class Bird{         public abstract void sing();          public void fly(){             System.out.println(\"날다.\");         }     }     추상 클래스를 상속받는 클래스 생성하기            추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 반드시 구현해야 한다.       추상 클래스를 상속받고, 추상 클래스가 갖고 있는 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다.           super와 부모생성자     class가 인스턴스화 될 때 생성자가 실행되면서 객체의 초기화를 한다. 그 때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.            new 연산자로 자식 객체를 생성하면, 자식객체가 메모리에 올라갈 때 부모인 객체도 함께 메모리에 올라간다.       생성자는 객체를 초기화 하는 일을한다.       생성자가 호출될 때 자동으로 부모의 생성자가 호출되면서 부모객체를 초기화 하게된다.           super            자신을 가리키는 키워드가 this 라면, 부모를 가리키는 키워드는 super       super()는 부모의 생성자를 의미한다.       부모의 생성자를 임의로 호출하지 않으면, 부모 class의 기본 생성자가 자동으로 호출된다.           부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법            클래스는 기본 생성자가 없는 경우도 존재한다.               public Bus(){         super(\"소방차\"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.         System.out.println(\"Bus의 기본생성자입니다.\");     }  super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용한다.   오버라이딩  오버라이딩이란 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것이다. 즉 오버라이딩이란 메소드를 재정의 하는 것이다.     메소드 오버라이딩            메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출된다.       오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.                    super 키워드를 이용하면, 부모의 메소드를 호출 할 수 있다.                               //run 메소드를 가지고 있는  Car클래스      public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      //Car 를 상속받는 Bus 클래스      public class Bus extends Car{      }          //오버라이딩     public class Bus extends Car{         public void run(){             System.out.println(\"Bus의 run메소드\");         }     }        //super 키워드     public class Bus extends Car{         public void run(){             **super.run();**  // 부모의  run()메소드를 호출              System.out.println(\"Bus의 run메소드\");         }     }     오버라이딩 vs 오버로딩  오버로딩(Overloading) : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술  오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용    클래스 형변환  부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.     형변환       public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      public class Bus extends Car{         public void ppangppang(){             System.out.println(\"빵빵.\");         }        }  상속 관계란 is a 관계다. “Bus는 Car다.”라는 관계가 성립된다.      부모타입으로 자식객체를 참조할 수 있다.            부모타입으로 자식객체를 참조하게 되면 부모가 있는 메소드만 사용할 수 있다.               public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             car.ppangppang(); // 컴파일 오류 발생         }     }     ppangppang()메소드를 호출하고 싶다면 Bus 타입의 참조변수로 참조 해야한다.       public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             //car.ppangppang(); // 컴파일 오류 발생              Bus bus = (Bus)car;  //부모타입을 자식타입으로 형변환              bus.run();             bus.ppangppang();         }     }     객체들 끼리도 형변환이 가능하다. 단 상속관계에 있었을 때만 가능하다.   부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환이 일어난다.   부모타입의 객체를 자식타입으로 참조하게 할 때는 명시적으로 형변환 해주어야 한다. 단, 이렇게 형변활 할때에는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능하다.      과연 이 형변환을 왜 언제 사용할까! 라는 의문을 가졌다면,,,, 이런 상황들을 생각해보자  첫번째, VIP 회원을 VVIP 회원으로 등급을 올려줄 때  두번째, 모험가 직업을 가진 플레이어가 전사 직업을 가지게 되었을 때…  보통 다형성을 활용하려고 사용한다고 한다… 코드 한줄만 바꿔도 돌아갈수 있도록…?   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.6 제어문)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.6 제어문     일부 구문인 반복문, 스위치문들은 데이터에 적용된 시험결과에 따라 일련의 연산이 실행되는 조건부 실행이 요구된다.   기계어 코드에서는 조건부 동작을 구현하기 위해 두 개의 기본적인 낮은 수준의 방법을 제공한다.            데이터 값들을 시험해서 이 시험 결과에 따라 데이터흐름이나 제어흐름을 변경한다.           기계어 인스트럭션들의 실행 순서는 점프jump 인스트럭션으로 변경할 수 있다.   점프 인스트럭션은 때에 따라서는 어떤 시험의 결과에 따라 프로그램의 다른 일부분으로 제어를 넘겨준다.   3.6.1 조건 코드     정수 레지스터들과 함께 CPU는 가장 최근 산술 또는 논리연산의 특성을 설명하는 단일 비트 조건 코드로 구성된 레지스터들을 운영한다.   이 레지스터들은 조건부 분기를 수행하기 위해서 시험될 수 있다.            CF: 캐리 플래그Carry flag. 가장 중요한 비트로부터 받아 올림이 발생한 것을 표시. 비부호형 연산에서 오버플로우를 검출할 때 사용       ZF: 영 플래그Zero flag. 연산의 결과가 0인 것을 표시       SF: 부호 플래그Sign flag. 연산이 음수를 생성한 것을 표시       OF: 오버플로우 플래그Overflow flag. 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시           leaq 인스트럭션은 주소계산에 사용하기 위한 것이므로 조건 코드를 변경하지 않는다.           반면에, 위의 그림에 나열된 모든 인스트럭션들은 조건 코드 값을 변경한다.            XOR 같은 논리연산에서는 캐리와 오버플로우 플래그가 0으로 세팅된다.       쉬프트 연산에서는 캐리 플래그가 쉬프트되어 없어지는 마지막 비트로 설정되며, 오버플로우 플래그는 0으로 세팅된다.           위의 그림의 인스트럭션들에 의해 조건 코드 값이 변경될 뿐만 아니라, 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 두 개의 인스트럭션 클래스가 있다.(아래의 그림 참조)    CMP 인스트럭션들은 만일 두 오퍼랜드가 같으면 영 플래그르 1로 설정한다. 다른 플래그들은 두 오퍼랜드의 순서관계를 결정하는 데 사용될 수 있다.   TEST 인스트럭션은 목적지 오퍼랜드를 변경하지 않으면서 조건 코드를 설정하는 점만 제외하고는 AND 인스트럭션과 같은 방식으로 동작한다.   3.6.2 조건 코드 사용하기     조건 코드를 이용하는 보편적인 세 가지 방법이 있다.            조건 코드의 조합에 따라 0 또는 1을 한 개의 바이트에 기록       조건에 따라 프로그램의 다른 부분으로 이동하는 방법       조건에 따라 데이터를 전송하는 방법              SET 인스트럭션         첫 번째 경우의 인스트럭션의 클래스를 SET 인스트럭션이라고 부른다.   이 인스트럭션들은 접미어를 이용해서 오퍼랜드의 크기를 나타내는 것이 아니라, 조건 코드의 어떤 조합을 사용할 것인지를 나타낸다.            ex) setl, setb -&gt; long word와 byte를 의미하지 않고 less와 below를 의미한다.           SET 인스트럭션은 목적지로 하위 단일 바이트 레지스터 가운데 한 개나 단일 바이트 메모리 주소를 사용하며, 이 바이트를 0이나 1로 기록한다.            32비트나 64비트 결과를 만드려면, 다른 상위 비트들을 0으로 만들어줘야 한다.           a&lt;b를 계산하는 전형적인 인스트럭션은 아래의 그림과 같이 작성된다.    3.6.3 점프jump 인스트럭션     일반적인 실행의 경우, 인스트럭션들은 나열된 순서에 따라 순차적으로 실행된다.   점프 인스트럭션은 프로그램이 완전히 새로운 위치로 실행을 전환하도록 한다.   점프의 목적지는 일반적으로 어셈블리 코드에서는 레이블label로 표시한다.        인스트럭션 jmp .L1은 프로그램이 movq 인스트럭션을 건너뛰는 대신에 popq로 실행을 다시 시작하게 한다.   어셈블러는 모든 레이블이 붙은 인스트럭션들의 주소를 결정하고, 점프 인스트럭션의 일부분인 “점프 목적지jump target”을 인코딩한다.        위 그림은 여러 가지 점프 인스트럭션을 보여준다.   jmp 인스트럭션은 무조건적으로 점프한다.            점프 목적지가 인스트럭션의 일부로 인코딩 되는 경우에는 직접 점프       점프 대상을 레지스터나 메모리 위치로부터 읽어들여야 하는 경우에는 간접 점프           3.6.4 점프 인스트럭션 인코딩     점프 인스트럭션의 대상이 어떻게 인코딩 되는지 이해하는 것은 7장의 링커를 공부할 때 중요한 역할을 하게 된다.   어셈블리 코드에서, 점프 목적지는 심벌 레이블을 사용해서 작성한다.   점프를 인코딩하는 가장 일반적인 방법은 PC 상대적PC relative 방법이다.            대상 인스트럭션과 점프 인스트럭션 바로 다음에 오는 인스트럭션 주소와의 차이를 인코딩한다.                첫 번째 점프 인스트럭션의 목적지가 0x03으로 인코딩, 다음 인스트럭션의 주소인 0x05에 더하면 점프 목적지 주쇤 0x8을 얻을 수 있다.   PC-상대 주소지정을 수행할 때 프로그램 카운터의 값은 점프 인스트럭션 자신의 주소가 아니라, 점프 다음에 나오는 인스트럭션의 주소가 된다.   PC-상대 방식으로 점프 목적지를 인코딩하면, 인스트럭션들이 간결하게 인코딩(2바이트만 필요)될 수 있고, 목적코드는 수정 없이 메모리 상의 다른 위치로 이동될 수 있다.   3.6.5 조건부 분기를 조건제어로 구현하기     C에서 조건부 수식과 문장을 기계어 코드로 번역하는 가장 일반적인 방법은 조건부 및 무조건 점프를 함께 사용하는 것이다.   어셈블리 코드에서의 무조건 점프와 유사한 C의 goto문을 사용한다.            어셈블리 코드의 제어흐름을 설명하는 C 프로그램을 구성하는 방법으로 사용됨                     위의 그림은 조건문의 컴파일이다.            if-else             컴파일러는 else-문과 then-문에 대해 별도의 코드 블록을 생성한다.       정확한 블록이 실행되도록 조건부와 무조건 분기를 삽입한다.             3.6.6 조건부 이동으로 조건부 분기 구현하기     조건부 동작을 구현하는 전형적인 방법은 조건이 만족되면 프로그램의 한 가지 실행경로를 따르고, 아닌 경우에는 다른 경로를 따라가도록 하는 제어의 조건부 전환을 통해 이루어진다.            이 방법은 간단하고 일반적이지만 최신 프로세서들에서는 매우 비효율적일 수 있다.           또 다른 전략은 데이터의 조건부 전송을 이용하는 것이다.            이 방법은 조건부 동작의 산출물 모두를 계싼하고 조건에 따라 하나만 선택하는 방식이다.       최신 프로세서의 성능특성과 잘 일치하는 간단한 조건부 이동move 인스트럭션으로 구현될 수 있다.                C버전을 공부하면, 이것이 y-x와 x-y 모두를 계산해서 rval, eval로 명명한다는 것을 알 수 있다.            x가 y보다 크거나 같은지 테스트하고, 만일 그렇다면, eval을 Rval로 명명한다는 것을 알 수 있다.           조건부 제어 이동 기반 코드보다 조건부 데이터 이동 코드가 성능이 우수한 이유를 이해하기 위해서는 최신 프로세서들이 어떻게 동작하는지 이해해야 한다.            프로세서들은 각 인스트럭션을 일련의 단계로 처리하며, 이 단계들은 각각 요구된 동작의 작은 부분만을 실행하는 파이프라인을 통해 높은 성능을 얻는다.       이를 위해서는 파이프라인을 실행할 인스트럭션들로 미리 채우기 위해 실행할 인스트럭션들의 순서를 훨씬 일찍 결정할 수 있어야 한다.       결과적으로 분기의 예측오류 손실이 함수의 성능을 결정한다.                    위의 그림은 x86-64로 가능한 조건부 이동 move 인스트럭션을 보여준다.   이들 인스트럭션은 두 개의 오퍼랜드를 갖는다.            소스 레지스터 또는 메모리 위치 S, 그리고 목적지 레지스터 R.           인스트럭션들의 결과는 조건 코드 값에 따라 달라진다.   소스 값은 메모리나 소스 레지스터로부터 읽히지만, 목적지에는 명시된 조건이 만족될 때만 복사된다.      이 이후로 조건부 분기의 “분기의 예측 오류”에 관한 내용이 나온다.   조건부 이동은 조건부 점프와는 달리 결과를 예측하지 않고서도 해당 인스트럭션을 실행할 수 있다.  조건부 이동을 사용한다고 해서 언제나 코드 효율성을 개선할 수 있는 것은 아니다.  컴파일러는 낭비되는 계산량과 분기 예측오류에 의한 잠재적 성능 손실 사이의 상대적 성능을 고려해야 한다.   등의 내용이 담겨져 있는데 이해하기 조금 힘들다….   3.6.6은 뒷부분을 좀 더 읽고 다시 읽으러 돌아오자!!!!!!!    조건부 분기에 따른 실제 어셈블리 코드     조건부 분기를 구하는 방법은 3.6.2에서 세가지 방법이 있다고 했으며, 3.6.5절과 3.6.6절에 조건제어와 조건부이동 두가지로 더욱 자세한 설명으로 풀어냈다. 두 가지의 방법은 예제코드를 활용하여 설명해줬는데 다음의 예제코드와 같다. (C 언어로 작성 되어있다.)    long absdiff(long x, long y){   long result;   if(x&lt;y) result = y - x;   else reuslt = x - y;   return result; }     이 코드를 가지고 if문의 여러가지 어셈블리어로 표현할 수 있다고 표현하는데, 나는 같은 코드인데 기계는 어떻게 알고 다른 어셈블리어들을 생성해내는지가 너무 긍금했다.  다시말해 기계는 언제 조건부 이동을 하여 컴파일을하고, 언제 조건제어를 하여 컴파일을 하는지 너무 궁금했다!!!  궁금증을 참지 못하고 윈도우 환경에서 gcc 컴파일을 진행하였다.          tdm-gcc를 설치했다.     터미널에 gcc -v 명령어를 입력하면 설치 완료를 확인할 수 있다.     위 예제의 코드를 txt 파일로 작성했다.(파일 이름은 p1으로 하였다.)     gcc -S p1.c 명령어를 입력하면 어셈블리 코드를 생성할 수 있다.     gcc -S -Og p1.c 명령어를 입력하면 컴파일 최적화를 진행한다.     -Og, -O1, -O2 …으로 설정하면 단계별로 최적화를 적용한다.        다음의 그림은 default, -Og, -O1, -O2 의 결과다.  가독성을 위해서 main문과 디렉티브문은 삭제하였다.(*디렉티브: 어셈블러와 링커에 지시하기 위한 문장)       //최적화 없음 absdiff:    pushq   %rbp    .seh_pushreg   %rbp    movq   %rsp, %rbp    .seh_setframe   %rbp, 0    subq   $16, %rsp    .seh_stackalloc   16    .seh_endprologue    movl   %ecx, 16(%rbp)    movl   %edx, 24(%rbp)    movl   16(%rbp), %eax    cmpl   24(%rbp), %eax    jge   .L2    movl   24(%rbp), %eax    subl   16(%rbp), %eax    movl   %eax, -4(%rbp)    jmp   .L3 .L2:    movl   16(%rbp), %eax    subl   24(%rbp), %eax    movl   %eax, -4(%rbp) .L3:    movl   -4(%rbp), %eax    addq   $16, %rsp    popq   %rbp    ret  //Og로 최적화함 absdiff:    cmpl   %edx, %ecx    jge   .L2    movl   %edx, %eax    subl   %ecx, %eax .L1:    ret .L2:    movl   %ecx, %eax    subl   %edx, %eax    jmp   .L1   //O1으로 최적화함 absdiff:    movl   %edx, %r8d    subl   %ecx, %r8d    movl   %ecx, %eax    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret   //O2으로 최적화함 absdiff:    movl   %edx, %r8d    movl   %ecx, %eax    subl   %ecx, %r8d    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret     Og가 본문의 조건제어, O1이 조건이동에서 설명한 어셈블리어로 표현되어있다.  유레카를 발견한 것처럼…. 너무 속이 시원했다….  컴파일 명령어에서 최적화의 수준에 따라 어셈블리어 인코딩이 달라진다는 것을 직접 확인할 수 있었다.    3.6.7 반복문     C에서는 여러가지 반복문 구문을 제공한다.            do-while, while, for       기계어에는 반복문에 대응되는 인스트럭션이 없다.       그렇기 때문에 조건부 테스트와 점프를 함께 사용해서 반복문의 효과를 구현한다.                 do-while            body-statement를 반복적으로 실행하고, test-expr를 계산하여 조건에 따라 반복 수행을 계속한다.       body-statement가 적어도 한 번은 실행되는 점이 특이사항이다.               do         body-statement         while (test-expr);        while            while문은 test-expr를 먼저 계산해서, body-statement를 실행하기 전에 종료될 수 있다.       do-while 루프에서 우리가 본 것과 루프 구조가 동일하고, 초기 테스트의 구현방법에서만 다르다.               while (test-expr)         body-statement                     while문은 두가지 번역 방법이 있다.                    중간으로-점프jump-to-middle            조건부 do 번역 사용guarded-do                            for       while (test-expr)         body-statement           init-expr;     while (test-expr){         body-statement         update-expr;     }                 두 반복문이 동일한 동작을 한다.       먼저 초기화 수식인 init-expr를 계산한다.       테스트 조건인 test-expr를 계산하는 곳에서 루프에 들어가며       테스트가 실패하면 루프를 빠져나오고, 반복문 body-statement를 실행한다.       마지막으로 update-expr를 계산한다.       for 루프에 대해 생성된 어셈블리 코드는 최적화 수준에 따라 while 루프의 번역 전략중 하나를 따른다.           3.6.8 Switch문     Switch문은 정수 인덱스 값에 따라 다중분기 기능을 제공한다.   C 코드를 읽기 쉽게 해줄 뿐만 아니라 점프 테이블이라는 자료구조를 사용해서 효율적인 구현을 간응하게 한다.   switch문을 실행하는 데 걸리는 시간이 case의 수에 관계없다는 점이 장점이다.   switch문을 실행하는 데 있어서 핵심 단계는 점프 테이블을 통해서 코드의 위치로 접근하는 것이다.      ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.7 프로시져)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.7 프로시저      프로시저 호출은 소프트웨어에서의 주요 추상화다.   이들은 지정된 인자들과 리턴 값으로 특정 기능을 구현하는 코드를 감싸주는 방법을 제공한다.   프로그램의 여러 지점으로부터 호출될 수 있게 된다. 프로그램 상태에 무슨 효과를 갖는지에 대한 명쾌하고 간결한 인터페이스 정의를 제공한다.   프로시저는 서로 다른 프로그래밍 언어에서 여러가지 다른 모습으로 사용된다.            함수, 메소드, 서브루틴, 핸들러등       이 모두는 일반적인 특징들을 공유한다.           프로시저에 대한 기계어수준 지원을 제공할 떄 처리되어야 하는 여러가지 많은 특성들이 존재한다.   프로시저P가 프로시저Q를 호출하고, 다시 리턴할 경우            제어권 전달: PC는 Q에 대한 코드의 시작주소로 설정되고, 리턴할 때 P에서 Q를 호출하는 인스트럭션 다음의 인스트럭션으로 설정       데이터 전달: P는 하나 이상의 매개변수를 Q에 제공할 수 있어야 하며, Q는 다시 P로 하나의 값을 리턴할 수 있어야 한다.       메모리 할당과 반납: Q는 시작할 때 지역변수들을 위한 공간을 할당, 리턴할 때 이 저장소를 반납할 수 있다.           X86-64에서의 프로시저 구현은 레지스터와 프로그램 메모리 같은 머신의 자원들을 사용하는 방법에 관한 특수 인스트럭션들과 일련의 관습들과 연관되어있다.   프로시저가 요구하는 메커니즘만을 최소한으로 구현하는 최소주의자 전략으로 볼 수 있는 방식들을 따른다.   3.7.1 런타임 스택      프로시저 호출 동작방식의 주요 특징은 스택 자료구조가 제공하는 후입선출 메모리 관리 방식을 활용할 수 있다는 점이다.   프로시저 P가 프로시져 Q를 호출하는 에를 들 때            Q가 실행되고 있는 동안 P까지의 연속된 호출 중의 프로시저 P는 일시적으로 정지되는 것을 볼 수 있다.       Q가 실행되는 동안에는 자신의 지역변수를 위한 새로운 저장공간을 할당할 수 있는 능력이나 다른 프로시저로의 호출을 설정하는 능력만을 필요로 한다.       Q가 리턴할 때는 자신이 할당받은 로컬 저장장소는 반납될 수 있다.       따라서 프로그램은 스택을 사용해서 프로시저들이 요구하는 저장장소를 관리할 수 있으며, 스택과 프로그램 레지스터들은 제어와 데이터를 전송하기 위해, 그리고 메모리를 할당하기 위해 필요한 정보를 제공한다.           x86-64의 스택은 작은 주소 방향으로 성장하며, 스택 포인터 %rsp는 스택의 최상위 원소를 가리킨다.   데이터는 pushq와 popq 인스트럭션을 이용해서 스택에 저장되고 읽어올 수 있다.          아래 그림은 일반적인 스택 프레임 구조. 스택을 프로시저의 인자를 전달하고, 리턴 정보를 저장하며, 레지스터를 저장하고, 지역 저장공간의 목적으로 사용한다. 필요하지 않은 경우 일부분은 생략될 수 있다.             프로시저가 레지스터들에 저장할 수 있는 개수 이상의 저장공간을 필요로 할 때는 공간을 스택에 할당한다.            이 영역을 이 프로시저의 스택 프레임이라고 부른다.           현재 실행 중인 프로시저에 대한 프레임은 항상 스택의 맨 위에 위치한다.   대부분의 프로시저의 스택 프레임들은 프로시저가 시작될 때 할당되는 고정 크기를 갖는다.   시간과 공간 효율성을 위해 x86-64 프로시저는 요청받은 스택 프레임의 부분만을 할당한다.      스택 프레임에 대해서 조금 더 조사할 필요가 있으며, 공간 효율성에 대해서도 조사해보자.    3.7.2 제어의 이동      제어를 함수 P에서 함수 Q로 전달하는 것은 단순히 프로그램 카운터를 Q를 위한 코드의 시작주소로 설정하는 것과 관련된다.   나중에 Q가 리턴해야할 때가 오면 프로세서는 P의 실행을 다시 시작해야하는 코드 위치의 일부 기록을 갖고 있어야한다            인스트럭션 call Q로 프로시저 Q를 호출해서 기록된다.       주소 A를 스택에 푸시하고 PC를 Q의 시작으로 설정한다.       푸시된 주소 A는 리턴주소라고 불리며, call인스트럭션 바로 다음 인스트럭션의 주소로 계산된다.       ret는 주소 A를 스택에서 pop해오고 PC를 A로 세팅한다.        call 인스트럭션은 호출된 프로시저가 싲가하는 인스트럭션의 주소를 목적지로 갖는다.                  아래의 그림은 call과 ret 기능의 에제다. call 인스트럭션은 함수의 시작 부분으로 제어를 이동하는 반면, ret 인스트럭션은 call 다음에 오는 인스터럭션으로 제어를 되돌린다.           아래의 그림은 프로시저 콜과 리턴에 연관된 프로그램의 상세한 실행이다.           리턴 주소를 스택에 푸시하는 간단한 방법을 사용해서 함수가 나중에 프로그램이ㅡ 적절한 위치로 리턴이 가능하게 된다는 것을 알 수 있다.   스택이 제공하는 후입, 선출 메모리 관리 방식과 편리하게 일치한다.   3.7.3 데이터 전송      호출될 때, 그리고 프로시저가 다시 리턴하게 될 때 프로시저로 제어를 전달하는 것 뿐만 아니라, 프로시저 콜은 데이터를 인자로 전달하는 것과 관련되어 있으며, 프로시저에서 리턴하는 것도 어떤 값을 리턴하는 것과 관련되어 있을 수 있따.   대부분의 이들 프로시저로, 프로시저로부터의 데이터 전달은 레지스터를 통해서 일어난다.   x86-64에서는 최대 여섯 개의 정수형(즉, 정수와 포인터) 인자가 레지스터로 전달될 수 있다.   함수가 여섯 개 이상의 정수형 인자를 가질 때, 다른 인자들은 스택으로 전달된다.            인자 1~6은 적절한 레지스터들에 복사하고, 인자 7에서 n까지는 인자 7을 스택 탑에 넣는 방법으로 저장한다.                 3.7.4 스택에서의 지역저장공간      지역 데이터가 메모리에 저장되어야 하는 경우가 있다.            지역 데이터 모두를 저장하기에는 레지스터의 수가 부족하다.       지역변수에 연산자 ‘&amp;’가 사용되었으며, 이 변수의 주소를 생성할 수 있어야 한다.       배열 또는 구조체여서 이들이 배열이나 구조체 참조로 접근되어야 한다.       위 세가지의 경우에 “Local variables”로 명명된 스택 프레임의 일부분이 생겨난다           3.7.5 레지스터를 이용하는 지역저장소      프로그램 레지스터들은 모든 프로시저들이 공유하는 단일 자원의 역할을 한다.   피호출자는 호출자가 나중에 사용할 계획인 일부 레지스터 값은 덮어쓰지 않는다.   레지스터 %rbx, %rbp, %r12-%r15는 피호출자-저장 레지스터로 구분한다.   리턴하기 전에 스택에서 이전 값을 팝해오는 방식으로 레지스터를 보존한다.   레지스터 값들을 푸시하는 것은 “Saved registers”로 이름 붙인 스택 프레임의 일부분을 생성하는 효과를 갖는다.    3.7.6 재귀 프로시저     레지스터와 스택을 사용하는 것에 대해 설명한 관습으로 프로시저들이 이들을 재귀적으로 호출하는 것을 설명할 수 있다.   각 프로시저 콜은 스택상에 자신만의 사적인 공간을 가지며, 따라서 다수의 별도의 호출들의 지역변수들은 서로 간섭하지 않는다.   스택 운영방식은 프로시저가 호출될 때 지역저장소를 할당하고, 리턴하기 전에 이것을 반환하는 적절한 정책을 자연스럽게 제공한다.   스택 기법을 사용해서 함수의 각 호출 시에 상태정보를 위한 자신만의 개별적 저장곤간을 제공한다.   필요한 경우에는 지역변수를 위한 저장공간도 제공할 수 있다.   스택의 할당과 반환 동작은 자연스럽게 함수의 호출-리턴 순서와 일치한다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_08/",
        "teaser": null
      },{
        "title": "[GitBlog] GitBlog 글 포스팅 후 커밋은 했지만, github.io에 적용이 안될 때",
        "excerpt":"사건의 개요    지금은 새벽 한시… csapp 공부가 조금 밀려서 공부를 하던 중에…   3.7절 프로시져에 대한 포스팅을 하려고 미리 csapp 포스트 탭을 만들고 커밋을 해두었다..  하지만, 아무리 새로고침을 해도 새로 포스팅한 글이 github.io에 업데이트가 안된다..    삽질    처음 깃블로그를 만들 때도 github.io에 업데이트가 되지 않는 끔찍함을 겪어서  몇번이고 레포를 새로 만들었던 끔찍한 기억이 떠올랐다.   지금까지 열심히 블로그에 글을 포스팅 했는데 이 글들을 다 날리는건가…?  무슨 캐시 충돌…? 뭐 서버 오류…? 어디선가 꼬였나…?  등등의 오만가지 생각이 들면서 지금까지 포스팅한 글을 지켜야겠다는 생각에 하던 공부를 올스탑했다..    새로운 레포도 파보고,, 글을 하나씩도 올려보고,, config파일을 수정도 해보고,, 캐시도 삭제해보고,,  커밋도 돌려보고,,, 별에 별짓을 다해보았다,,,l   사건 해결    한가지의 특징을 알게 되었다.   포스팅 날짜가 오늘 1월 31일로 되어있는 글만 업데이트가 되지 않는 것이었다.  오늘은 1월 31일 오전 1시였다.  드디어 알게되었다….  현재 날짜는 1월 31일이지만, 아직 새벽이기 때문에? (git 서버 시간의 기준이 다른 나라인가…?)   1월 31일로 작성된 글은 아직 github.io에 업데이트 되지 않는 것이구나!   결론  깃블로그를 처음 만들 때 글이 업데이트 되지 않는 오류 때문에 굉장히 힘들었었다.  하지만, 해당 오류는 서버와의 시간과 포스팅 시간이 맞지 않기 때문이었다!   다음부터 시간이 애매(새벽)하면 어제 날짜로 포스팅 하자!  이제부터 맘편히 깃블로그 포스팅을 하자!!!!      시간 날린게 너무 아깝다ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ  다시는 이런 바보같은 짓은 하지 말자…!   ","categories": ["Doodle"],
        "tags": ["Doodle","GitBlog"],
        "url": "/doodle/doodle_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 인터페이스와 다른 형식의 클래스",
        "excerpt":"Part8 인터페이스와 다른 형식의 클래스   인터페이스 만들기  인터페이스: 서로 관계까 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템     인터페이스 정의하는 방법            추상 메소드와 상수를 정의 할 수 있다.               public interface TV{         public int MAX_VOLUME = 100;         public int MIN_VOLUME = 0;          public void turnOn();         public void turnOff();         public void changeVolume(int volume);         public void changeChannel(int channel);     }     인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.       public static final int MAX_VOLUME = 100;     public static final int MIN_VOLUME = 0;     인터페이스에서 정의된 메소드는 모두 추상 메소드이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.       public abstract void on();     public abstract void off();     public abstract void volume(int value);     public abstract void channel(int number);  인터페이스 사용하기     인터페이스 사용하는 방법            인터페이스는 사용할 때 해당 인터페이스를 구현하는 클래스에서 implements 키워드를 이용한다.               public class LedTV implements TV{         public void on(){             System.out.println(\"켜다\");         }         public void off(){             System.out.println(\"끄다\");            }         public void volume(int value){             System.out.println(value + \"로 볼륨조정하다.\");           }         public void channel(int number){             System.out.println(number + \"로 채널조정하다.\");                  }     }     인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.(추상클래스는 인스턴스를 만들 수 없음)       public class LedTVExam{         public static void main(String args[]){             TV tv = new LedTV();             tv.on();             tv.volume(50);             tv.channel(6);             tv.off();         }     }     참조변수의 타입으로 인터페이스를 사용할 수 있다. 이 경우 인터페이스가 가지고 있는 메소드만 사용할 수 있다.   만약 TV인터페이스를 구현하는 LcdTV를 만들었따면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것이다. 동일한 인터페이스를 구현 한다는 것은 클래스 사용법이 같다는 것을 의미한다.   클래스는 이러한 인터페이스를 여러개 구현할 수 있다.   인터페이스의 default method  JAVA 8이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.      default 메소드     인터페이스가 default키워드로 선언되면 메소드가 구현될 수 있다. 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.             return i + j;         }     }      //Calculator인터페이스를 구현한 MyCalculator클래스     public class MyCalculator implements Calculator {          @Override         public int plus(int i, int j) {             return i + j;         }          @Override         public int multiple(int i, int j) {             return i * j;         }     }      public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);         }     }     인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.      static 메소드     인터페이스에 static 메소드를 선언함으로써, 인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){             return i + j;         }         public static int exec2(int i, int j){   //static 메소드              return i * j;         }     }      //인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.        public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);              int value2 = Calculator.exec2(5, 10);  //static메소드 호출              System.out.println(value2);         }     }  내부클래스  내부 클래스란 클래스 안에 선언된 클래스    어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.     첫번째는 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언되는 경우. 보통 중첩클래스 혹은 인스턴스 클래스라고 한다.            내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 InnerExam1의 객체를 만든 후에 InnerExam1.Cal cal -= t.new Cal();과 같은 방법으로 Cal 객체를 생성한 후 사용한다.               public class InnerExam1{         class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam1 t = new InnerExam1();             InnerExam1.Cal cal = t.new Cal();             cal.plus();             System.out.println(cal.value);          }     }     두번째는 내부 클래스가 static으로 정의된 경우, 정적 중첩 클래스 또는 static 클래스라고 한다.            필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 InnerExam2 객체를 생성할 필요없이 new InnerExam2.Cal()로 객체를 생성할 수 있다.               public class InnerExam2{         static class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam2.Cal cal = new InnerExam2.Cal();             cal.plus();             System.out.println(cal.value);          }     }     세번째로는 메소드 안에 클래스를 선언한 경우, 지역 중첩 클래스 또는 지역 클래스라고 한다.            메소드 안에서 해당 클래스를 이용할 수 있다.               public class InnerExam3{         public void exec(){             class Cal{                 int value = 0;                 public void plus(){                     value++;                 }             }             Cal cal = new Cal();             cal.plus();             System.out.println(cal.value);         }                public static void main(String args[]){             InnerExam3 t = new InnerExam3();             t.exec();         }     }     네번째로는 익명클래스가 있다.            아래의 절로 이동하여 설명하겠다!           익명클래스  익명 중첩 클래스는 익명 클래스라고 보통 말하며, 내부 클래스이기도 하다.       //추상클래스 Action      public abstract class Action{         public abstract void exec();     }      //추상클래스 Action을 상속받은 클래스 MyAction     public class MyAction extends Action{         public void exec(){             System.out.println(\"exec\");         }     }      //MyAction을 사용하는 클래스 ActionExam      public class ActionExam{         public static void main(String args[]){             Action action = new MyAction();             action.exec();         }     }      //MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.     public class ActionExam{         public static void main(String args[]){             Action action = new Action(){                 public void exec(){                     System.out.println(\"exec\");                 }             };             action.exec();         }     }     생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻한다.   괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다. 이렇게 생성된 이름 없는 객체를 action이라는 참조변수가 참조하도록 하고, exec() 메소드를 호출한다.   익명클래스를 만드는 이유는 Action을 상속받는 클래스를 만들 필요가 없을 경우이다.   Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우이다.   ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_08/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part9 예외처리",
        "excerpt":"Part9 예외처리   Exception  프로그램 실행중 예기치 못한 사건을 예외라고 한다. 예외 상황을 미리 예측하고 처리할 수 있는데, 이렇게 하는 것을 예외 처리라고 한다.       public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 5;             int k = i / j;             System.out.println(k);             System.out.println(main 종료!!);         }     }     위 코드에서 j를 0으로 바꾸면 Exception 발생            j를 0으로 바꾸면 Arithmetic Exception이 발생하면서 프로그램이 종료된다.       Java는 정수를 정수로 나눌 때 0으로 나누면 오류가 발생한다.           예외 처리            프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.           예외 처리하는 문법            오류가 발생할 예상 부분을 try라는 블록으로 감싼 후, 발생할 오류와 관련된 Exception을 catch라는 블록에서 처리한다.       오류가 발생했든 안했든 무조건 실행되는 finally라는 블록을 가질 수 있다.       finally 블록은 생략가능하다.               public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = i / j;                 System.out.println(k);             }catch(ArithmeticException e){                 System.out.println(\"0으로 나눌 수 없습니다. : \" + e.toString());             }finally {                 System.out.println(\"오류가 발생하든 안하든 무조건 실행되는 블록입니다.\");             }         }     }     실행결과            0으로 나눌 수 없습니다. :java.lang.ArithmeticException:/by zero  오류가 발생하든 안하든 무조건 실행되는 블록입니다.           Exception 처리하지 않았을 때는 프로그램이 강제 종료되었는데 catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행되는 것을 알 수 있다.   try 블록에서 여러종류의 Exception이 발생한다면 catch라는 블록을 여러개 둘 수 있다.   Exception 클래스들은 모두 Exception 클래스를 상속받으므로, 예외 클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 하나의 catch 블록에서 모든 오류를 처리 할 수 있다.   Throws  throws는 예외가 발생했을 때 예외를 호출한 쪽에서 처리하도록 던져준다.       public class ExceptionExam2 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j){             int k = i / j;             return k;         }     }  정수를 매개변수로 2개를 받아들인 후 나눗셈을 한 후 그 결과를 반환하는 divide 메소드  main 메소드에서는 divide 메소드를 호출   다음과 같이 divide 메소드를 수정       public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }     }  메소드 선언 뒤에 throws ArithmeticException이 적혀있는 것을 알 수 있다. 이렇게 적어놓으면 divide 메소드는 ArithmeticException이 발생하니 divide 메소드를 호출하는 쪽에서 오류를 처리하라는 뜻이다.       package javaStudy;     public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             } catch(ArithmeticException e){                 System.out.println(\"0으로 나눌수 없습니다.\");             }          }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }      }  Exception 발생시키기  강제로 오류를 발생시키는 throw   throw는 오류를 떠넘기는 trhows와 보통 같이 사용된다.       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j){             int k = i / j;             return k;         }        }     divide 메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.      위의 코드를 에러가 발생하지 않게 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);               }          public static int divide(int i, int j){             if(j == 0){                 System.out.println(\"2번째 매개변수는 0이면 안됩니다.\");                 return 0;             }             int k = i / j;             return k;         }     }     j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴   이렇게 할 경우 main 메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.   0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할 수도 있다.      에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     j가 0일 경우에 new연산자를 통하여 IllegalArgumentException 객체가 만들어 진다.   new 앞에 throw는 해당 라인에서 Exception이 발생한다는 의미이다.   즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌 수 없습니다. 라는 오류가 발생한 것이다.   Exception 클래스 이름을 보면 argument가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.      divide 메소드를 호출한 쪽에서의 오류 처리       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             }catch(IllegalArgumentException e){                 System.out.println(\"0으로 나누면 안됩니다.\");             }                    }          public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     divide 메소드 뒤에 throws IllegalArgumentException은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미한다.   사용자 정의 Exception     Exception 클래스를 상속 받아 정의한 checked Exception            반드시 오류를 처리 해야만 하는 Exception       예외 처리하지 않으면 컴파일 오류를 발생 시킨다.           RuntimeException 클래스를 상속 받아 정의한 unChecked Exception            예외 처리하지 않아도 컴파일 시에는 오류를 발생시키지 않는다.              RuntimeException을 상속받은 BizException 객체       public class BizException extends RuntimeException {         public BizException(String msg){             super(msg);         }                public BizException(Exception ex){             super(ex);         }     }     BizSerice 클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.       public class BizService {         public void bizMethod(int i)throws BizException{             System.out.println(\"비지니스 로직이 시작합니다.\");             if(i &lt; 0){                 throw new BizException(\"매개변수 i는 0이상이어야 합니다.\");             }             System.out.println(\"비지니스 로직이 종료됩니다.\");         }     }     앞에서 만든 BizService를 이용하는 BizExam 클래스     매개변수 값을 -1을 넘길 때는 Exception이 발생하기 때문에 try catch 블록으로 처리한다.       public class BizExam {           public static void main(String[] args) {             BizService biz = new BizService();             biz.bizMethod(5);             try{                 biz.bizMethod(-3);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }      프로그래머스 자바 입문을 마무리하며  강의 자체는 굉장히 깔끔했다. 개념 설명 이후 실습을 진행하고, 해당 개념에 대한 의문점도 강의에서는 미리 지적하여 설명해준다. 입문 강의를 들으니 대학 2학년 때 들었던 java 강의가 생각났다. 그 때 이정도 수준의 이해도를 얻었다면 어땠을까… 라는 생각이 스쳐 지나갔다. 이제 입문 강의를 들은 것 뿐이지만, java의 j정도 알게 되었다. 인터페이스나 내부클래스 같은 개념은 실제로 사용해봐야지 더 확실하게 개념이 와닿을 것 같다.   강의를 모두 수강하고도 개념이 조금 헷갈리는 것들을 적어두고 한번 더 복습을 해야할 것 같다.     인스턴스를 만들 때 Parents c = new Child(); &lt;- Parents와 Child가 정확히 어떤 역할을 하는지   인터페이스와 추상클래스의 차이점   내부 클래스들 각각의 쓰임   사용자 정의 Exception   java의 얕은 복사와 깊은 복사   super()   클래스 형변환     해당 강의와 강의 노트는 프로그래머스 자바 입문에서 언제든지 다시 들을 수 있다!  ","categories": ["프로그래머스 자바 입문"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%9E%85%EB%AC%B8/java_09/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 Object 클래스, Part2 java.lang 패키지",
        "excerpt":"Part1 Object 클래스   Object와 오버라이딩     Object 클래스는 모든 클래스의 최상위 클래스   아무것도 상속받지 않으면 자동으로 Object를 상속   Object가 가지고 있는 메소드는 모든 클래스에서 다 사용할 수 있다는 것을 의미   대표적인 예            equals : 객체가 가진 값을 비교할 때 사용       toString : 객체가 가진 값을 문자열로 반환       hashCode : 객체의 해시코드 값 반환           Part2 java.lang 패키지   java.lang 패키지/오토박싱  자바는 기본적으로 다양한 패키지를 지원 그중에서 가장 중요한 패키지     java.lang 패키지의 클래스는 import를 하지 않고도 사용할 수 있다.   java.lang 패키지에는 기본형 타입을 객체로 변환시킬 때 사용하는 Wrapper 클래스가 있다.            Boolean, Byte, Short, Integer, Long, Double 클래스           모든 클래스의 최상위 클래스인 Object도 java.lang 패키지   문자열과 관련된 String StringBuffer, StringBuilder도 모두 java.lang 패키지   화면에 값을 출력할 때 사용했던 System 클래스도 java.lang 패키지   수학과 관련된 Math 클래스도 java.lang 패키지   Thread와 관련된 중요 클래스들이 java.lang 패키지   이외에도 다양한 클래스와 인터페이스가 java.lang 패키지에 속해 있다.   public class WrapperExam {     public static void main(String[] args) {         int i = 5;          Integer i2 = new Integer(5);         Integer i3 = 5;     //오토박싱         int i4 = i2.intValue();         int i5 = i2;       //오토언박싱     } }     오토박싱(Auto Boxing)            Integer i3 = 5; 숫자 5는 원래 기본형이지만 자동으로 Integer 형태로 변환된다.           오토 언박싱(Auto Unboxing)            int i5 = i2; Integer 객체타입의 값을 기본형 int로 자동으로 변환되어 값을 할당한다.           오토박싱, 오토 언박싱은 JAVA 5부터 지원한다. 이 때 내부적으로 Wrapper 클래스들이 사용된다.   스트링버퍼  아무 값도 가지고 있지 않은 StringBuffer 객체를 생성   StringBuffer sb = new StringBuffer(); // 해당 스트링 버퍼에 \"hello\", 공백, \"world\"를 차례대로 추가  sb.append(\"hello\"); sb.append(\" \"); sb.append(\"world\"); // StringBuffer에 추가된 값을 toString()메소드를 이용하여 반환  String str = sb.toString();     출력결과 : hello world   StringBuffer가 가지고 있는 메소드들은 대부분 자기 자신, this를 반환   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     자기 자신의 메소드를 호출하여 자기 자신의 값을 바꿔나가는 것을 메소드체이닝 이라고 한다.   StringBuffer 클래스는 메소드 체인 방식으로 사용할 수 있도록 만들어져 있다.   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     앞에서 5줄로 작성했던 코드를 위와 같이 한 줄로 수정할 수 있다.   StringBuffer는 append 메소드 외에도 길이를 구하거나, 자르거나 등의 다양한 메소드들을 가지고 있다.   스트링 클래스의 문제점  String 클래스는 문자열을 다룰 때 사용하는 클래스   String 클래스는 불변클래스이다.   String str1 = \"hello world\"; String str2 = str1.substring(5); System.out.println(str1); System.out.println(str2);     실행결과            hello world  world           기존의 str1은 전혀 변화 없다.   substring 메소드는 5번째부터 문자열을 잘라서 새로운 문자열을 반환하는 메소드   str1 자체는 전혀 변화가 없다.   String 클래스를 사용할 때 가장 문제가 발생하는 경우는 다음과 같은 코드를 사용할 때이다.   String str3 = str1 + str2; System.out.println(str3);     실행결과            hello world world           문자열과 문자열을 더하게 되면 내부적으로는 다음과 같은 코드가 실행   String str4 = new StringBuffer().append(str1).append(str2).toString(); System.out.println(str4);     java 에서는 new 연산자가 많을 수록 성능이 저하된다. 위와 같은 str3 = str1 + str2; 코드를 반복문에서 사용하게 된다면, new 연산자가 내부에서 계속해서 생성되고 성능이 저하될 수 있다.    Math  Math클래스는 이름 그대로 수학계산을 위한 클래스   코싸인, 싸인, 탄젠트, 절대값, 랜덤값등을 구할 수 있는 클래스     Math 클래스는 생성자가 private으로 되어 있기 때문에 new 연산자를 이용하여 객체를 생성할 수 없다.   객체를 생성할 수는 없지만 모든 메소드와 속성이 static으로 정의되어 있기 때문에 객체를 생성하지 않고도 사용할 수 있다.   public class MathExam {     public static void main(String[] args) {         int value1 = Math.max(5, 20);         int value2 = Math.min(5, -5);         int value3 = Math.abs(-10);         double value4 = Math.random();         double value5 = Math.sqrt(25);       } }  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_10/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 java.util 패키지",
        "excerpt":"Part3 java.util 패키지   java.util 패키지  java.util 패키지는 유용한 클래스들을 많이 가지고 있는 패키지     날짜와 관련된 클래스인 Date, Calendar 클래스   자료구조와 관련된 컬렉션 프레임워크와 관련된 인터페이스와 클래스   deprecated란 더이상 지원하지 않으니 사용하지 않는 것이 좋다란 의미   Date 클래스는 지역화를 지원하지 않는다. 지역화란 국가별로 현재 날짜와 시간은 다룰 수 있는데, 그 부분을 지원하지 못한다.            이런 문제를 해결하기 위하여 나온 클래스가 Calendar 클래스. Calendar 클래스는 자바 1.1에 등장           지역화와 관련된 클래스들은 Locale로 시작되는 일므을 가진 클래스다.   List, Set, Collection, Map은 자료구조 즉 컬렉션 프레임워크와 관련된 인터페이스   컬렉션 프레임워크  java.util 패키지에는 자료를 다룰 수 있는 자료구조 클래스가 다수 존재한다. 자료구조 클래스들을 컬렉션 프레임워크라고 한다.     자료구조란 자료를 저장할 수 있는 구조   책을 보관하기 위해 책장을 이용하는 것 처럼 다양한 자료들을 다양한 방식으로 관리하기 위한 방법이 필요한데, 이러한 방법을 제공하는 것을 자료구조, 컬렉션 프레임워크이다.   컬렉션 프레임워크에서 가장 기본이 되는 interface는 Collection 인터페이스            Collection 인터페이스는 여기에 자료가 있다라는 것을 표현       중복도 허용하고, 자료가 저장된 순서도 기억하지 못하는 것이 Collection 인터페이스       Collection이 가지고 있는 대표적인 메소드는 add(), size(), iterator() 메소드       Collection은 저장된 순서를 기억하지 못하기 때문에, 하나씩 하나씩 꺼낼 수 있는 Iterator라는 인터페이스를 반환한다.                    Iterator는 꺼낼것이 있는지 없는지 살펴보는 hasNext() 메소드와 하나씩 자료를 꺼낼때 사용하는 next() 메소드를 가지고 있다.                           Set 자료구조는 중복을 허용하지 않는 자료구조를 표현하는 인터페이스            Collection 인터페이스를 상속받는다.       Set 인터페이스가 가지고 있는 add 메소드는 같은 자료가 있으면 false, 없으면 true를 반환하는 add 메소드를 가지고 있다.           List 자료구조는 중복은 허용하면서 순서를 기억하는 자료구조를 표현            Set 인터페이스와 마찬가지로 Collection 인터페이스를 상속받고 있다.       List는 순서를 기억하고 있기 때문에 n번째의 자료를 꺼낼 수 있는 get(int) 메소드를 가지고 있다.           Map 자료구조는 Key와 Value를 가지는 자료구조이다.            저장할 때 put() 메소드를 이용하여 key와 value를 함께 저장한다.       원하는 값을 꺼낼 때는 key를 매개변수로 받아들이는 get() 메소드를 이용하여 값을 꺼낸다.       Map에 저장되어 있는 모든 Key들은 중복된 값을 가지면 안된다.       Key의 이런 특징 때문에 Map은 자신이 가지고 있는 모든 Key들에 대한 정보를 읽어들일 수 있는 Set을 반환하는 KeySet() 메소드를 가지고 있다.           Generic  Box 클래스   public class Box {     private Object obj;     public void setObj(Object obj){     this.obj = obj;     }      public Object getObj(){     return obj;     } }  BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box box = new Box();         box.setObj(new Object());         Object obj = box.getObj();          box.setObj(\"hello\");         String str = (String)box.getObj();         System.out.println(str);          box.setObj(1);         int value = (int)box.getObj();         System.out.println(value);     } }     Box는 매개변수 Object를 하나 받아들이고, Object를 반환한다.   Object를 받아들일 수 있다는 것은 Object의 후손이라면 무엇이든 받아들일 수 있다는 것이다.   하지만 반환을 할 경우에는 반환 값에 맞는 형변환을 해주어야한다.            이 귀찮음(?)을 해결하기 위하여 Java5에 Generic이라는 문법이 사용됨           Generic을 이용하여 Box 클래스 수정   public class Box&lt;E&gt; {     private E obj;     public void setObj(E obj){         this.obj = obj;     }      public E getObj(){         return obj;     } }     클래스 이름 뒤에 가 제네릭을 적용한 것이다. Box는 가상의 클래스 E를 사용한다는 의미   Object를 받아들이고, 리턴하던 부분이 E로 변경. E는 실제로 존재하는 클래스는 아니다.   Generic을 이용하여 수정한 Box를 이용하는 BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box&lt;Object&gt; box = new Box&lt;&gt;();         box.setObj(new Object());         Object obj = box.getObj();          Box&lt;String&gt; box2 = new Box&lt;&gt;();         box2.setObj(\"hello\");         String str = box2.getObj();         System.out.println(str);          Box&lt;Integer&gt; box3 = new Box&lt;&gt;();         box3.setObj(1);         int value = (int)box3.getObj();         System.out.println(value);     } }     참조타입에 &lt;Object&gt;, &lt;String&gt;, &lt;Integer&gt;가 있는 것을 볼 수 있다.   첫번째는 Object를 사용하는 Box를 인스턴스로 만들겠다는 의미   두번째는 String을 사용하는 Box 인스턴스를 만들겠다는 의미   세번째는 Integer를 사용하는 Box 인스턴스를 만든다는 의미      Generic을 사용함으로써 선언할 때는 가상의 타입으로 선언하고, 사용시에는 구체적인 타입을 설정함으로써 다양한 타입의 클래스를 이용하는 클래스를 만들 수 있다. Generic을 사용하는 대표적인 클래스는 컬렉션 프레임워크와 관련된 클래스다.    Set  set은 중복이 없고, 순서도 없는 자료구조. HashSet과 TreeSet이 있다.   import java.util.HashSet; import java.util.Iterator; import java.util.Set;  public class SetExam {     public static void main(String[] args) {         Set&lt;String&gt; set1 = new HashSet&lt;&gt;();          boolean flag1 = set1.add(\"kim\");         boolean flag2 = set1.add(\"lee\");         boolean flag3 = set1.add(\"kim\");          System.out.println(set1.size());   //저장된 크기를 출력합니다. 3개를 저장하였지만, 이미 같은 값이 있었기 때문에 2개가 출력         System.out.println(flag1);  //true         System.out.println(flag2);  //true         System.out.println(flag3);  //false          Iterator&lt;String&gt; iter = set1.iterator();          while (iter.hasNext()) {   // 꺼낼 것이 있다면 true 리턴.                       String str = iter.next(); // next()메소드는 하나를 꺼낸다. 하나를 꺼내면 자동으로 다음것을 참조한다.             System.out.println(str);         }     } }  List  list는 데이터의 중복이 있을 수 있고, 순서도 있다.   import java.util.ArrayList; import java.util.List;  public class ListExam {      public static void main(String[] args) {         List&lt;String&gt; list = new ArrayList&lt;&gt;();          // list에 3개의 문자열을 저장합니다.         list.add(\"kim\");         list.add(\"lee\");         list.add(\"kim\");          System.out.println(list.size()); //list에 저장된 자료의 수를 출력 (중복을 허용하므로 3 출력)          for(int i = 0; i &lt; list.size(); i++){             String str = list.get(i);             System.out.println(str);         }     }    }  Map  Map은 key와 value를 쌍으로 저장하는 자료구조. 키는 중복될 수 없고, 값은 중복될 수 있다.   import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;    public class MapExam {       public static void main(String[] args) {         // Key, Value가 모두 String 타입인 HashMap인스턴스를 만듭니다.         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();          // key와 value값을 put으로 저장합니다.         map.put(\"001\", \"kim\");         map.put(\"002\", \"lee\");         map.put(\"003\", \"choi\");         // 같은 key가 2개 있을 수 없습니다. 첫번째로 저장했던 001, kim은 001, kang으로 바뀐다.         map.put(\"001\", \"kang\");          // map에 저장된 자료의 수를 추력합니다. 3이 출력됩니다.         System.out.println(map.size());          // 키가 001, 002, 003인 값을 꺼내 출력합니다.         System.out.println(map.get(\"001\"));         System.out.println(map.get(\"002\"));         System.out.println(map.get(\"003\"));          // map에 저장된 모든 key들을 Set자료구조로 꺼냅니다.         Set&lt;String&gt; keys = map.keySet();         // Set자료구조에 있는 모든 key를 꺼내기 위하여 Iterator를 구합니다.         Iterator&lt;String&gt; iter = keys.iterator();         while (iter.hasNext()) {             // key를 꺼냅니다.             String key = iter.next();             // key에 해당하는 value를 꺼냅니다.             String value = map.get(key);             // key와 value를 출력합니다.             System.out.println(key + \" : \" + value);         }     } } ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.8 배열의 할당과 접근)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.8 배열의 할당과 접근   C에서 배열은 스칼라 데이터를 보다 큰 자료형으로 연계시키는 수단이다.   3.8.1 기본 원리      자료형 T와 정수형 상수 N에 대해서 다음과 같은 선언에 대해 생각해보자.            T A[N];            시작하는 위치를 Xa로 표시하자. 이 선언은 두가지 효과를 갖는다.            이것은 L*N 바이트의 연속적인 공간을 메모리에 할당하며, 여기서 L(바이트 단위)은 자료형 T의 크기를 나타낸다.       새로운 식별자 a를 통해서 배열이 시작하는 위치의 포인터로 사용한다.           배열의 각 원소는 0에서 N-1 사이의 정수형 인덱스를 사용해서 접근할 수 있다.   배열의 원소 i는 주소 Xa +L*i에 저장된다.   3.8.2 포인터 연산      C는 포인터 간에 연산을 허용하며, 계산된 값은 포인터가 참조하게 되는 자료형의 크기에 따라 그 값이 확대된다.   어떤 객체를 나타내는 식 Expr에 대해 &amp;Expr는 그 객체의 주소를 주는 포인터이다.   주소를 나타내는 식 A Expr에 대해 *A Expr는 그 주소에 위치한 값을 준다.   3.8.3 다중 배열      배열 할당과 참조에 관한 일반적인 원칙들은 심지어 배열의 배열을 생성할 때도 적용된다.   배열의 원소들은 메모리에 “행 우선row major” 순서로 저장된다.    3.8.4 고정크기의 배열      C 컴파일러는 고정크기의 다차원 배열을 위한 코드에 대해 다양한 최적화를 수행할 수 있다.   아래의 그림은 고정길이 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.    3.8.5 가변크기의배열      가변크기 배열을 원하는 프로그래머는 배열들을 위한 저장공간을 mallock이나 calloc 같은 함수를 사용해서 할당해야한다.   아래의 그림은 가변크기 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.       다중배열의 원소들을 접근할 때 발생하는 패턴을 인식할 수 있다는 것을 살펴보았다.  곱셈을 회피하는 코드를 생성할 수 있다.  이런 최적화들은 프로그램 성능을 상당히 개선하게 된다   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_09/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 K번째수 Java 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 첫 문제였다. 배열 생성도 어색하고 디버깅 하는 것도 너무 어려웠다. 몇가지 문법은 구글링을 해가면서 풀었다. 나는 지금까지 python으로만 알고리즘 문제를 해결했었다. python과 java는 너무나도 다르다… 우선 변수들간의 전송과 출력 모두 python과 달랐다. 여튼 java는 거의 모든 기능을 모듈을 import하여 사용한다는 것이다. 예를들어 Arrays 모듈을 import하여 배열을 한번에 출력하고, ArrayList를 import하여 연결리스트를 만든다.       2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.   commands에 포함된 1차원 배열에서 index 0,1에 위치한 value로 Arrays.copyOfRange(arr,startIndex,endIndex)를 사용하여 array를 slicing 한다.            ex) arr = {10,20,30,40,50} Arrays.copyOfRange(arr, 2, 4) -&gt; returns {20,30,40}           Arrays.sort()를 사용하여 slicing된 배열을 정렬한다.   정렬된 배열에서 commands index 2에 위치한 value에 해당하는 위치를 answer arrayList에 add한다.   return answer   코드       import java.util.ArrayList;     import java.util.Arrays;          public class Main {         public static void main(String[] args){             int[] array = {1,5,2,6,3,7,4};             int[][] commands =  {{2,5,3},{4,4,1},{1,7,3}};                  int[] answer = solution(array,commands);             System.out.println(Arrays.toString(answer));         }              public static int[] solution(int[] array, int[][] commands){             ArrayList&lt;Integer&gt; arrList = new ArrayList&lt;&gt;();                  for(int i=0; i&lt;commands.length; i++){                 int[] k = Arrays.copyOfRange(array,commands[i][0]-1,commands[i][1]);                 Arrays.sort(k);                 arrList.add(k[commands[i][2]-1]);             }                  int size = arrList.size();             int[] answer = new int[size];                  for(int i=0; i&lt;size; i++){                 answer[i] = arrList.get(i);             }                  return answer;         }     } ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_01/",
        "teaser": null
      },{
        "title": "[키보드/해피해킹] 해피해킹 하이브리드 type-s 리뷰",
        "excerpt":"이게뭐지?!      이건 바로 “해피해킹”이 들어있는 택배다. 무려 일본에서 2주일을 기다려서 받게 된 기다리고 기다리던 나의 첫 내돈내산 키보드이다.(매직키보드는 제외하도록 하겠다.. 왜냐면 매직키보드는… 애플… 이니깐… 꼭 사야하는… 물건중 하나…) 사실 나는 키보드에 그렇게 관심이 있던 사람은 아니였지만 동기들이 자꾸 꼬셨다. 그 중 가장 강렬했던 말은 “민석이형도 몇년동안 계속 키보드 바꾸다가 리얼포스로 정착했는데 너가 해피해킹 사면 한번에 다 뛰어넘고 대장급 되는거다” 이 말에 혹해 그날 저녁먹고  집에 오자마자 바로 “해피해킹 하이브리드 type-s”를 일본에서 직구하였다. 배송 기간 동안 설 연휴가 끼는 바람에 주문을 하고 약 2주뒤에 도착한 것 같다. 그 후로 동기들 집가서 여러 키보드도 타건해보면서 생전 관심도 없던 키보드를 사랑하게 돼버렸다..(사실 아직 뭐가 다른지 크게는 잘 모르겠따…)   택배박스를 열어보자..   회사 퇴근시간에 배송 완료 됐다는 카톡을 받자마자 칼퇴하고 집으로 곧장 달려갔다. 나의 해피해킹을 언능 영접하고 싶어서 호다닥 박스를 열었다.      완충제가 아주 가득 차있어서 일본에서부터 서울까지 다친데 하나 없이 아주 잘 도착한 것 같다 ㅎㅎ 완충제까지도 이쁘다.         완충제를 걷어내면 해피해킹 본체와 같이 주문한 정품 루프가 보인다. 정품 루프가 6만원인건 안비밀이다;;(그냥 아크릴일뿐인데 6만원이나 받아간다 ㅋ…)         이렇게 상자 안에 있는 물건을 다 꺼내면 해피해킹 본체, 전용 루프, 전용 키캡이 들어있다. 모두 다 옵션이고 키캡은 너무 이뻐서 살 수 밖에 없게 만들어놨다.      대망의 해피해킹 하이브리드 type-s   먼저 해피해킹 본체를 살펴보겠다.      “영롱 그 자체” 정말 영롱 그 자체다… 너무 이쁘다… 저 모던하지만 클래식한 디자인.. 투박하지만 미세하게 느껴지는 유려한 곡선.. 이 둘이 함꼐 탱고를 추는듯한 화려함… 가히 키보드의 왕이라 칭하기에 한점 부끄러움 없는 자태를 뽐내고 있다…         키보드를 꺼내고 나면 사용 설명서와 키보드에 들어갈 AA건전지 두개가 함께 들어있다. 건전지가 없을 줄 알고 집오는 길에 편의점에 들려서 AA건전지를 샀는데 여분용으로 남겨놔야할 것 같다. 무려 40만원이 넘는 키보드인데 왜 이런 구식용 건전지를 사용하는지 의문이었는데  구글링을 몇번 하고나니 납득이 되었다. 내장 배터리는 수명이 있기 때문에 키보드를 오래 쓰기에는 이런 건전지를 사용하는 것이 더 좋다고 한다.         다시 비닐을 벗긴 해피해킹을 보자. 글이 길어지면 진심은 흐려지는 법이라고 하였다. 후훗..      전용루프와 전용키캡      전용루프와 전용키캡은 이렇게 생겼다. 참.. 이쁘다.. 돈값 한다..!!         ㅎㅎ 키캡까지 장착해보았다. 키캡은 무각과 일반 두개가 있다. 정말 이쁘죠? ㅎㅎ         루프도 덮어보았다!       간단 후기   간단 후기를 남겨 보겠다. 우선 나는 키보드는 매직키보드, 맥북키보드 그리고 게이밍용 청축키보드만 사용해본 키린이라는걸 인지해줬으면 좋겠다,,,!   해피해킹 하이브리드 type-s 는 토프레 무접점 키보드라고 한다. 소음은 확실히 적다. 그리고 굉장히 부드럽다. 하지만, 키압이 생각보다 있어 그렇게 가볍지만은 않다. 그리고 해피해킹은 방향키가 없어 커맨드로 사용해야하고, 컨트롤 키도 캡스락에 있어 맥북 한영키와 굉장히 헷갈린다. 백스페이스도 기존 키보드보다 한단계 아래에 위치해 있다. 이러한 부분들이 아직은 익숙하지 않아서 버벅거리는데, 확실히 익숙해진다면 손의 움직임이 기존 키보드보다 적어서 효율적일 것 같다. 키보드를 좀 더 사용해보고 과연 배송비 10만원, 전용루프와 전용키캡 7만원, 본체 35만원 값어치를 하는지 깊은 후기를 남겨보겠다.   ","categories": ["Doodle"],
        "tags": ["키보드","해피해킹"],
        "url": "/doodle/doodle_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 날짜와 시간",
        "excerpt":"Part4 날짜와 시간   Date  날짜와 시간을 구하기 위한 클래스 Date 클래스     Date 클래스는 JDK 1.0때 만들어졌고, Calendar 클래스는 JDK1.1에 만들어졌따.   Date는 지역화에 대한 부분이 고려되지 않았다.            지역화란, 지역에 따라서 시간, 통화(원, 달러, 엔 등) 언어등에 고려하는 프로그래밍을 지역화에 맞춘 프로그래밍이라고 한다.           Date 클래스를 보면 대부분의 생성자와 메소드가  Deprecated 되어 있다.            Deprecated된 것은 앞으로 지원을 안하거나 문제가 있을 수 있으니 사용하지 말란 뜻이다.           기본 생성자를 이용한 Date 클래스 생성            기본 생성자로 Date인스턴스를 만들게 되면 현재 시간과 날짜 정보를 Date인스턴스가 가지게 된다                 Date date = new Date();     toString() 메소드를 이용하여 현재 시간을 문자열로 구한다.            출력 결과 : Wed Jan 06 18:36:56 KST2016                 System.out.println(date.toString());     java.util.SimpleDateFormat 클래스를 이용해서 원하는 형태로 출력하는 방법            yyyy는 년, MM은 월, dd는 일을 표현       hh는 시간, mm은 분, ss는 초를 표현하며 a는 오전/오후를 표현한다.       zzz는 TimeZone을 나타낸다. 한국의 겨우 한국ㅁ표준시 KST가 TimeZone에 해당하는 값이다.               SimpleDateFormat ft = new SimpleDateFormat (\"yyyy.MM.dd 'at' hh:mm:ss a zzz\");     System.out.println(ft.format(date));     현재 시간을 Long값으로 구하는 방법       System.out.println(date.getTime());     // System이 가지고 있는 currentTimeMillis()메소드를 이용해도 됩니다.     long today = System.currentTimeMillis();     System.out.println(today);  Calendar  Date의 단점을 해결하고 등장한 것이 Calendar 클래스     Calendar 클래스 생성 방법            Calendar 클래스는 추상클래스이다.       Calendar 클래스에 대한 인스턴스를 생성하려면 Calendar가 가지고 있는 클래스 메소드 getInstance()를 사용해야 한다.       getInstance() 메소드를 호출하면 내부적으로 java.util.GregorianCalendar 인스턴스를 만들어서 리턴한다.       GregorianCalendar는 Calendar의 자식 클래스다.                 Calendar cal = Calendar.getInstance();     Calendar 클래스를 이용해서 현재 날짜와 시간에 대한 정보를 알아내는 방법            Calendar는 현재 날짜와 시간에 대한 정보를 가진다.       Calendar가 가지고 있는 get메소드에 Calendar의 상수를 어떤 것을 넣어주느냐에 따라서 다른 값이 나온다.                 int yyyy = cal.get(Calendar.YEAR);       int month = cal.get(Calendar.MONTH) + 1; // 월은 0부터 시작       int date - cal.get(Calendar.DATE);       int hour = cal.get(Calendar.HOUR_OF_DAY);       int minuate = cal.get(Calendar.MINUTE);     Calendar 클래스를 이용해서 원하는 날짜나 시간에 대한 정보 얻어오는 방법            Calendar가 가지고 있는 add 메소드를 이용하면 쉽게 다음 날짜나 이전 날짜를 구할 수 있다.       현재 캘린더에 시간을 5시간 더하는 방법.                 cal.add(Calendar.HOUR,5);  java.time 패키지  Java에서 제공하는 ㅇate, Time API는 부족한 기능 지원을 포함한 여러가지 문제점을 가지고 있었다. JDK 코어에서 이런 문제점들을 해결하고 더 좋고 직관적인 API들을 제공하기 위해 새롭게 재 디자인한 date, Time API를 Java SE 8 부터 제공한다.     새로운 API의 핵심 클래스는 오브젝트를 생성하기 위해 다양한 factory 메서드를 사용   오브젝트 자기 자신의 특정 요소를 가지고 오브젝트를 생성할 경우 of 메서드를 호출하면 되고, 다른 타입으로 변경할 경우에는 from 메서드를 호출하면 된다.   LocalDateTime 클래스를 이용해서 현재 시간 time 객체 만드는 방법            now는 현재 시간을 구한다.                 LocalDateTime timePoint = LocalDateTime.now();  // 현재의 날짜와 시간     원하는 시간으로 time 객체 생성하는 방법       // 2012년 12월 12일의 시간에 대한 정보를 가지는 LocalDate객체를 만드는 방법       LocalDate ld1 = LocalDate.of(2012, Month.DECEMBER, 12); // 2012-12-12 from values          // 17시 18분에 대한 LocalTime객체를 구한다.     LocalTime lt1 = LocalTime.of(17, 18); // 17:18 (17시 18분)the train I took home today      // 10시 15분 30초라는 문자열에 대한 LocalTime객체를 구한다.     LocalTime lt2 = LocalTime.parse(\"10:15:30\"); // From a String     현재와 날짜와 시간정보를 getter 메소드를 이용하여 구하는 방법       LocalDate theDate = timePoint.toLocalDate();     Month month = timePoint.getMonth();     int day = timePoint.getDayOfMonth();     int hour = timePoint.getHour();     int minute = timePoint.getMinute();     int second = timePoint.getSecond();     // 달을 숫자로 출력한다 1월도 1부터 시작하는 것을 알 수 있습니다.      System.out.println(month.getValue() + \"/\" + day + \"  \" + hour + \":\" + minute + \":\" + second);  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_12/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 IO, Part6 어노테이션",
        "excerpt":"Part5 IO   자바IO  입출력을 위한 인터페이스와 클래스들     자바 IO는 크게 byte단위 입출력과 문자 단위 이출력 클래스로 나뉜다.            byte단위 입출력클래스는 모두 InputStream과 OutputStream이라는 추상클래스를 상속받아 만들어진다.       문자(char)단위 입출력클래스는 모두 Reader와 Writer라는 추상클래스를 상속받아 만들어진다.           4가지 추상클래스(InputStream, OutputStreamReader,Reader,Writer)를 받아들이는 생성자가 있다면, 다양한 입출력방법을 제공하는 클래스다.   4가지 클래스를 받아들이는 생성자가 없다면, 어디로부터 입력받을 것인지, 어디에 쓸것인지를 나타내는 클래스다.   파일로부터 입력받고 쓰기 위한 클래스 : FileInputStream, FileOutputStream, FileReader, FileWriter   배열로부터 입력받고 쓰기 위한 클래스 : ByteArrayInputStream, ByteArrayOutputStream, CharReader, CharWriter            해당 클래스들은 어디로부터, 어디에라는 대상을 지정할 수 있는 IO클래스다. 이런 클래스를 장식대상 클래스라고 한다.           DataInputStream, DataOutputStream같은 클래스를 보면 다양한 데이터 형을 입력받고 출력한다.   PrintWriter는 다양하게 한줄 입력받는 readLine() 메소드를 가진다.   BufferedReader는 한줄 입력받는 readLine() 메소드를 가진다.            이런 클래스들은 다양한 방식으로 입력하고, 출력하는 기능을 제공한다. 이런 클래스를 장식하는 클래스라고 한다.                    데코레이터 패턴(Decorator Pattern) : 하나의 클래스를 장식 하는 것처럼 생성자에서 감싸서 새로운 기능을 계쏙 추가 할 수 있도록 클래스를 만드는 방식    Byte 단위 입출력  Byte 단위 입출력 클래스는 클래스의 이름이 InputStream 이나 OutputStream으로 끝난다.     파일로부터 1byte씩 읽어들여 파일에 1byte씩 저장하는 프로그램을 작성            파일로부터 읽어오기 위한 객체 - FileInputStream       파일에 쓸 수 있게 해주는 객체 - FileOutputStream           read() 메소드            byte를 리턴한다면 끝을 나타내는 값을 표현할 수가 없기때문에, byte가 아닌 int를 리턴한다.       음수의 경우 맨 좌측 비트가 1이 된다. 읽어들일 것이 있다면 항상 양수를 리턴한다고 볼 수 있다.           FileInputStream과 FileOutputStream을 이용하여, 1바이트씩 읽어들여 1바이트씩 저장            read()메소드가 리턴하는 타입은 정수인데, 정수 4바이트중 마지막 바이트에 읽어들인 1바이트를 저장한다.       read()메소드는 더이상 읽어들일 것이 없을 때 -1을 리턴한다.               public class ByteIOExam1 {         public static void main(String[] args){                  FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readData = -1;                  while((readData = fis.read())!= -1){                     fos.write(readData);                 }                        } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         }     }  Byte 단위 입출력 심화  Byte단위 입출력 클래스는 클래스의 이름이 InputStream이나 OutputStream으로 끝난다.      파일로부터 512byte씩 읽어들여 파일에 512byte씩 저장하는 프로그램을 작성            byte[] buffer = new byte[512];       512byte만큼 읽어 들이기 위해 byte배열을 사용               public class ByteIOExam1 {         public static void main(String[] args){                  //메소드가 시작된 시간을 구하기 위함             long startTime = System.currentTimeMillis();                     FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readCount = -1;                  byte[] buffer = new byte[512];                 while((readCount = fis.read(buffer))!= -1){                     fos.write(buffer,0,readCount);                 }             } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         //메소드가 끝났을때 시간을 구하기 위함.          long endTime = System.currentTimeMillis();         //메소드를 수행하는데 걸린 시간을 구할 수 있음.          System.out.println(endTime-startTime);          }     }  다양한 타입의 출력     try-with-resources 블럭 선언            java io 객체는 인스턴스를 만들고, 모두 사용하면 close()메소드를 호출해야 한다.       close() 메소드를 사용자가 호출하지 않더라도, Exxception이 발생하지 않았다면 자동으로 close()가 되게 할 수 있는 방법                   try(                 //io객체 선언         ){                 //io객체 사용         }catch(Exception ex){             ex.printStackTrace();         }     다양한 타입으로 저장할 수 있는 DataOutputStream            writeInt() - 정수값으로 저장       writeBoolean() - boolean값으로 저장       writeDouble() - double값으로 저장               import java.io.DataOutputStream;     import java.io.FileOutputStream;         public class ByteExam3 {             public static void main(String[] args) {             try(                     DataOutputStream out = new DataOutputStream(new FileOutputStream(\"data.txt\"));             ){                 out.writeInt(100);                 out.writeBoolean(true);                 out.writeDouble(50.5);             }catch (Exception e) {                 e.printStackTrace();             }         }        }  다양한 타입의 입력     data.dat로부터 값을 읽어들여 화면에 출력하는 클래스   다양한 타입의 데이터를 읽어낼 수 있는 DataInputStream            readInt() - 정수를 읽어들이는 메소드       readBoolean() - boolean 값을 읽어들이는 메소드       readDouble() - double 값을 읽어들이는 메소드               import java.io.DataInputStream;     import java.io.FileInputStream;      public class ByteIOExam4 {          public static void main(String[] args) {             try(                     DataInputStream out = new DataInputStream(new FileInputStream(\"data.dat\"));             ){                 int i = out.readInt();                           boolean b = out.readBoolean();                           double d = out.readDouble();                  System.out.println(i);                 System.out.println(b);                 System.out.println(d);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }     파일에 저장된 순서대로 읽어 들여야한다.    Char 단위 입출력(Console)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     char 단위 입출력 클래스를 이용해서 키보드로부터 한줄 입력 받아서 콘솔에 출력            System.in - 키보드를 의미(InputStream)       BufferedReader - 한줄씩 입력 받기위한 클래스       BufferedReader 클래스의 생성자는 InputStream을 입력받는 생성자가 없다.       System.in은 InputStream 타입이므로 BufferedReader의 생성자에 바로 들어갈 수 없으므로 InputStreamReader 클래스를 이용해야함               import java.io.BufferedReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.InputStreamReader;     import java.io.PrintWriter;      public class CharIOExam01 {         public static void main(String[] args) {             BufferedReader br = new BufferedReader(new InputStreamReader(System.in));             //키보드로 입력받은 문자열을 저장하기 위해 line변수를 선언                            String line = null;                  try {                 line = br.readLine()             } catch (IOException e) {                 e.printStackTrace();             }             //콘솔에 출력              System.out.println(line);         }     }  Char 단위 입출력(File)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     파일에서 한 줄씩 입력 받아서 파일에 출력            파일에서 읽기 위해서 FileReader 클래스 이용       한 줄 읽어 들이기 위해서 BufferedReader 클래스 이용                    BufferedReader 클래스가 가지고 있는 readLine() 메소드가 한줄씩 읽게 해준다.           readLine() 메소드는 읽ㅇ낼 때 더 이상 읽어 들일 내용이 없ㅇ르 때 mnull을 리턴한다.                       파일에 쓰게하기 위해서 FileWriter 클래스 이용       편리하게 출력하기 위해 PrintWritier 클래스 이용               import java.io.BufferedReader;     import java.io.FileReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.PrintWriter;      public class CharIOExam02 {         public static void main(String[] args) {             BufferedReader br = null;              PrintWriter pw = null;             try{                         br = new BufferedReader(new FileReader(\"src/javaIO/exam/CharIOExam02.java\"));                 pw = new PrintWriter(new FileWriter(\"test.txt\"));                 String line = null;                 while((line = br.readLine())!= null){                     pw.println(line);                 }             }catch(Exception e){                 e.printStackTrace();             }finally {                 pw.close();                 try {                     br.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }     }  Part6 어노테이션   어노테이션  어노테이션은 Java5에 추가된 기능     어노테이션은 클래스나 메소드 위에 붙는다. @(at)기호로 이름이 시작한다.   어노테이션을 클래스나 메타코드에 붙인 후, 클래스가 컴파일되거나 실행될 때 어노테이션의 유무나 어노테이션에 설정된 값을 통하여 클래스가 좀 더 다르게 실행되게 할 수 있다. 이런 이유로 어노테이션을 일정의 설정파일처럼 설명하는 경우도 있다.   어노테이션은 자바가 기본으로 제공해주는 것도 있고, 사용자가 직접 만들 수도 있다.            사용자가 직접 작성하는 어노테이션을 Custom 어노테이션이라고 한다.           커스텀 어노테이션을 이용하는 방법            어노테이션을 정의한다.       어노테이션을 클래스에서 사용한다. (타겟에 적용)       어노테이션을 이용하여 실행           패키지 익스플로러에서 [new - Annotation]을 이용하여 Count100이라는 어노테이션 생성            Count100어노테이션을 JVM 실행시에 감지할 수 있도록 하려면 @Retention(RetentionPolicy.RUNTIME)를 붙여줘야 한다.               import java.lang.annotation.Retention;     import java.lang.annotation.RetentionPolicy;      @Retention(RetentionPolicy.RUNTIME)     public @interface Count100 {      }     “hello”를 출력하는 hello() 메소드를 가지는 MyHello라는 클래스를 작성            hello 메소드 위에 @Count100어노테이션을 붙힌다               public class MyHello {         @Count100         public void hello(){             System.out.println(\"hello\");         }     }     MyHello 클래스를 이용하는 MyHelloExam클래스를 작성            MyHello의 hello 메소드가 @Count100어노테이션이 설정되어 있을 경우, hello()메소드를 100번 호출하도록 한다.               import java.lang.reflect.Method;      public class MyHelloExam {         public static void main(String[] args) {             MyHello hello = new MyHello();              try{                 Method method = hello.getClass().getDeclaredMethod(\"hello\");             if(method.isAnnotationPresent(Count100.class)){                     for(int i = 0; i &lt; 100; i++){                         hello.hello();                     }                 }else{                     hello.hello();                 }             }catch(Exception ex){                 ex.printStackTrace();             }                }     }  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_13/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.9 이기종 자료구조 ~ 3.10 기계수준 프로그램에서 제어와 데이터의 결합)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.9 이기종 자료구조      C는 서로 다른 유형의 객체를 연결해서 자료형을 만드는 두 가지 방법을 제공한다.            struct 키워드를 사용해서 선언하는 구조체                    다수의 객체를 하나의 단위로 연결한다.                       union으로 선언하는 공용체                    하나의 객체를 여러 개의 다른 자료형으로 참조될 수 있도록 한다.                           3.9.1 구조체      서로 다른 유형의 객체들을 하나의 객체로 묶어주는 자료형을 생성한다.   구조체의 구현은 구조체의 모든 컴포넌트들이 메모리의 연속된 영역에 저장된다.   구조체의 포인터가 첫 번째 바이트의 주소라는 점에서 배열과 유사하다.      3.9.2 공용체      C언어의 자료형 체제를 회피해서 하나의 객체가 다수의 자료형에 따라 참조될 수 있도록 해준다.   공용체를 선언하는 문법은 구조체와 동일하나 그 의미는 매우 다르다.            다른 필드들이 메모리의 다른 블록을 참조하는 것이 아니라 동일한 블록을 참조한다.           3.9.3 데이터의 정렬      많은 컴퓨터 시스템들은 기본 자료형들에 대해 사용 가능한 주소를 제한하고 있어서 어떤 객체의 주소는 어떤 값 K의 배수가 되도록 요구한다.   이러한 정렬제한은 프로세서와 메모리 시스템 간의 인터페이스를 구성하는 하드웨어의 설계를 단순화한다.   이들의 정렬 규칙은 모든 K의 원시 객체들은 K의 배수를 주소로 가져야 한다는 원칙에 기초한다.   정렬은 자료형 내의 모든 객체들이 각각의 정렬 제한사항을 만족하는 방법으로 조직되고 할당되도록 강요된다.   아래의 그림처럼 컴파일러는 c와 j 사이에 3바이트 공간을 삽입한다.            추가로, 컴파일러는 구조체의 마지막에 0을 채워서 구조체 배열에서 각 원소가 각각의 정렬 요건을 만족하도록 해준다.   3.10 기계수준 프로그램에서 제어와 데이터의 결합      데이터와 자료가 상호작용 하는 방식을 살펴본다.   C 프로그래밍 언어에서 가장 심오한 개념인 포인터를 자세히 살펴본다.   기계수준 프로그램의 상세한 동작을 심벌 디버거인 GDB를 사용해서 검토한다.   실제 시스템에서 중요한 보안취약성인 버퍼 오브펄로우를 어떻게 이해할 수 있는지 살펴본다.   함수가 요구하는 스택 저장공간의 양이 실행때마다 달라지는 경우를 기계수준 프로그램이 어떻게 구현하는지 살펴본다.   3.10.1 포인터 이해하기      다른 자료구조 내 원소들에 대한 참조를 생성하는 통일된 방법으로서의 역할을 수행한다.   포인터의 일부 주요 원리            포인터는 연관된 자료형을 갖는다.       모든 포인터는 특정 값을 가진다.       포인터는 &amp;연산자를 사용해서 만든다.       ㅍ포인터는 *연산자를 사용해서 역참조한다.       배열과 포인터는 밀접한 관련이 있다. 배열의 이름은 마치 포인터 변수처럼 참조될 수 있다.       한 종류의 포인터에서 다른 종류로의 자료형 변환은 그 종류만 바뀔 뿐 값은 변화가 없다.       포인터는 함수를 가리킬 수도 있. 이것은 프로그램의 다른 부분에서 호출할 수 있는 코드에 대한 참조를 저장하거나 넘겨줄 수 있는 강력한 기능을 제공한다.           3.10.2 실제 적용하기: GDB 디버거 사용하기      GNU 디버거인 GDB는 기계어 프로그램의 런타임 평가 및 분석에 유용한 기능을 제공한다.            GNU는 운영체제의 하나이자 컴퓨터 소프트웨어의 모음집이다.            GDB를 사용하면, 프로그램의 실행을 정교하게 제어하면서 실행되는 프로그램을 관찰하여 프로그램의 동작을 분석할 수 있다.   일반적인 방법은 브레이크포인트를 프로그램에서 관심이 있는 부분 근처에 설정하는 것이다.   프로그램 실행중에 브레이크포인트를 만나게 되면, 프로그램은 실행을 중단하고, 제어를 사용자에게 넘긴다.   3.10.3 범위를 벗어난 메모리 참조와 버퍼 오버플로우      C에서는 배열참조 시 범위를 체크하지 않으며, 지역변수들이 스택에 보존용 레지스터들과 리턴 주소 같은 상태정보와 함께 스택에 저장된다는 것을 배웠다.   에를들어 배열에 문자열이 저장될 때 stack top인 return address 범위까지 저장이 되면 심각한 오류를 발생시킨다.             버퍼 오버플로우의 보다 치명적인 사용은 일반적으로 프로그램이 하지 않을 기능들을 실행하도록 하는 것이다.   일반적으로 탐색코드exploit code 라고 하는 실행코드를 바이트 인코딩한 탐색코드를 가리키는 포인터 리턴 주소를 덮어쓰는 약간의 추가적인 바이트들을 포함하는 스트링을 입력한다. ret 인스트럭션을 실행하면 탐색코드로 점프하게된다.            인터넷 상의 많은 컴퓨터에 접속을 획득한 FINGER 데몬인 fingerd로의 버퍼 오버플로우 공격이 있다.           3.10.4 버퍼 오버플로우 공격 대응 기법      이들 공격이 실행되기 어렵게 하는 방법과 침입자가 버퍼 오버플로우 공격을 통해서 시스템의 제어권을 획득할 수 있는 방법을 제한하는 방법을 구현하였다.      스택 랜덤화            공격자는 탐색코드를 시스템에 삽입하기 위해서 공격 스트링 내에 코드뿐만 아니라 코드로의 포인터까지 집어넣어야한다. 이 포인터를 만들기 위해서는 스트링이 위치하게 될 스택의 주소를 알아야 한다. 역사적으로 프로그램의 스택 주소는 쉽게 에측할 수 있었다.              스택 랜덤화의 아이디어는 스택의 위치를 프로그램의 매 실행마다 다르게 해주는 것이다.   ASLR을 사용하면 프로그램 코드, 라이브러리 코드, 스택, 전역변수, 힙 데이터를 포함하는 여러 프로그램의 부분들이 프로그램이 매번 실행할 때마다 메모리의 다른 지역에 로딩된다.   하지만, 이런 방법은 공격자가 반복적으로 주소를 바꿔가며 무지막지한 공격을 하면 랜덤화를 극복할 수 있다.      스택 손상 검출            두번째 방법은 스택이 손상되는 것을 감지하는 것이다.       아래의 그림은 스택 보호기가 작동될 때 해당 함수의 스택 구성이다. 특별 “canary” 값이 배열 buf와 저장된 상태 값 사이에 위치한다. 코드는 스택 상태가 손상되었는지 여부를 결정하기 위해 canary 값을 체크한다.                 실행코드 영역 제한하기            마지막 방법은 공격자가 실행코드를 시스템에 추가할 가능성을 제거하는 것이다.       어느 메모리 영역이 실행코드를 저장할지를 제한하는 거시앋. 다른 부분들은 읽기와 쓰기만 허용하도록 제한할 수 있다.           3.10.5 가변크기 스택 프레임 지원하기      공통적으로 할당되어야 하는 스택 프레임의 크기를 컴파일러가 미리 결정할 수 있다는 특징이 있었다. 하지만 일부 함수들은 가변적인 지역저장공간 크기를 필요로 한다.     ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_10/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 쓰레드",
        "excerpt":"Part7 쓰레드   쓰레드란   동시에 여러가지 작업을 동시에 수행할 수 있게 하는것     동시에 여러가지 작업을 수행할 수 있다.   프로세스란 현재 실행되고 있는 프로그램을 말한다.   자바 프로그램은 JVM에 위해 실행된다. 이 JVM도 프로그램중에 하나이다.   운영체제 입장으로 보면 자바도 하나의 프로세스로 실행 하는 것이다.   워드프로세서가 하나의 프로세스라면, 하나의 프로세스 안에서도 여러개의 흐름이 동작할 수 있다. 이것은 Thread라고 말한다.   쓰레드 만들기   자바에서 Thread를 만드는 방법은 크게 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.     Thread를 상속 받아서 쓰레드를 생성하는 방법            java.lang.Thread 클래스를 상속받는다. 그리고 Thread가 가지고 있는 run() 메소드를 오버라이딩한다.       10번 반복하면서 str를 찍는다.               public class MyThread1 extends Thread {         String str;         public MyThread1(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     //컴퓨터가 너무 빠르기 때문에 수행결과를 잘 확인 할 수 없어서 Thread.sleep() 메서드를 이용해서 조금씩                      //쉬었다가 출력할 수 있게한다.                      Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Thread 클래스를 상속받은 MyThread1을 사용하는 클래스            Thread를 상속 받았으므로 MyThread1은 Thread 이다.       쓰레드를 생성하고, Thread 클래스가 가지고 있는 start() 메소드를 호출 한다.               public class ThreadExam1 {         public static void main(String[] args) {             // MyThread인스턴스를 2개 만듭니다.              MyThread1 t1 = new MyThread1(\"*\");             MyThread1 t2 = new MyThread1(\"-\");              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }     Runnable 인터페이스를 구현해서 쓰레드를 만드는 방법            Runnable 인터페이스가 가지고 있는 run() 메소드를 구현한다.               public class MyThread2 implements Runnable {         String str;         public MyThread2(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Runnable 인터페이스를 구현한 MyYhread2 사용하는 방법            MyThread2는 Thread를 상속받지 않았기 때문에 Thread가 아니다.       Thread를 생성하고, 해당 생성자에 MyThread2를 넣어서 Thread를 생성한다.       Thread 클래스가 가진  start() 메소드를 호출한다.               public class ThreadExam2 {           public static void main(String[] args) {             MyThread2 r1 = new MyThread2(\"*\");             MyThread2 r2 = new MyThread2(\"-\");              Thread t1 = new Thread(r1);             Thread t2 = new Thread(r2);              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }  쓰레드와 공유객체   하나의 객체를 여러개의 Thread가 사용한다는 것을 의미   MusicBox 라는 클래스가 있다고 가정한다. 해당 클래스는 3개의 메소드를 가지고 있다. 각각의 메소드는 1초 이하의 시간동안 10번 반복하면서,  어떤 음악을 출력한다. 이러한 MusicBox를 사용하는 MusicPlayer를 3명 만들어 보겠다.   MusicPlayer 3명은 하나의 MusicBox를 사용할 것이다. 이 때 어떤 일이 발생하는지 살펴보겠다.      공유객체 MusicBox       public class MusicBox {          //신나는 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicA(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"신나는 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicA          //슬픈 음악!!!이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicB(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"슬픈 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicB         //카페 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicC(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"카페 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicC       }     MusicBox를 가지는 Thread 객체 MusicPlayer       public class MusicPlayer extends Thread{         int type;         MusicBox musicBox;           // 생성자로 부터 musicBox와 정수를 하나 받아들여서 필드를 초기화         public MusicPlayer(int type, MusicBox musicBox){             this.type = type;             this.musicBox = musicBox;         }                // type이 무엇이냐에 따라서 musicBox가 가지고 있는 메소드가 다르게 호출         public void run(){             switch(type){                 case 1 : musicBox.playMusicA(); break;                 case 2 : musicBox.playMusicB(); break;                 case 3 : musicBox.playMusicC(); break;             }         }            }     MusicBox와 MusicPlayer를 이용하는 MusicBoxExam1 클래스       public class MusicBoxExam1 {          public static void main(String[] args) {             // MusicBox 인스턴스             MusicBox box = new MusicBox();              MusicPlayer kim = new MusicPlayer(1, box);             MusicPlayer lee = new MusicPlayer(2, box);             MusicPlayer kang = new MusicPlayer(3, box);              // MusicPlayer쓰레드를 실행합니다.              kim.start();             lee.start();             kang.start();                    }        }  동기화 메소드와 동기화 블록      고유객체가 가진 메소드를 동시에 호출 되지 않돚록 하는 방법            메소드 앞에 synchronized 를 붙힌다.       여러개의 Thread 들이 공유객체의 메소드를 사용할 때 메소드에 synchronized가 붙어 있을 경우 먼저 호출한 메소드가 객체의 사용권(Monitoring Lock)을 얻는다.               public synchronized void playMusicA(){         for(int i = 0; i &lt; 10; i ++){             System.out.println(\"신나는 음악!!!\");             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicA     메소드 앞에 synchronized 를 붙혀서 실행해 보면, 메소드 하나가 모두 실행된 후에 다음 메소드가 실행된다.   해당 모니터링 락은 메소드 실행이 종료되거나, wait() 와 같은 메소드를 만나기 전까지 유지된다.   다른 쓰레드들은 모니터링 락을 놓을 때 까지 대기한다.   synchronized를 붙히지 않은 메소드는 다른 쓰레드들이 synchronized메소드를실행하면서 모니터링 락을 획득했다 하더라도, 그것과 상관없이 실행된다.   synchronized를 메소드에 붙혀서 사용 할 경우, 메소드의 코드가 길어지면, 마지막에 대기하는 쓰레드가 너무 오래 ㅣㄱ다리는 것을 막기 위해서 메소드에 synchronized를 붙이지 않고, 문제가 있을 것 같은 부분만 synchronized 블록을 사용한다.       public void playMusicB(){         for(int i = 0; i &lt; 10; i ++){             synchronized(this){                 System.out.println(\"슬픈 음악!!!\");             }             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicB  쓰레드와 상태제어   쓰레드가 3개가 있다면 JVM은 시간을 잘게 쪼갠 후에 한번은 쓰레드1을, 한번은 쓰레드 2를, 한번은 쓰레드3을 실행한다. 이것을 빠르게 일어나다 보니 쓰레드가 모두 동작하는 것처럼 보이는 것이다.      쓰레드는 실행가능상태인 Runnable과 실행상태인 Running상태로 나뉜다.   실행되는 쓰레드 안에서 Thread.sleep() 이나 Object가 가지고 있는 wait() 메소드가 호출이 되면 쓰레드는 블록상태가 된다.   Thread.sleep() 은 특정시간이 지나면 자신 스스로 블록상태에서 빠져나와 Runnable 이나 Running상태가 된다.   Object가 가지고 있는 wait() 메소드는 다른 쓰레드가 notify()나 notifyAll() 메소드를 호출하기 전에는 블록상태에서 해체되지 않는다.   wait()메소드는 호출이 되면 모니터링 락을 놓게 된다. 그래서 대기중인 다른 메소드가 실행한다.   쓰레드의 run메소드가 종료되면, 쓰레드는 종료된다. 즉 Dead상태가 된다.   Thread의 yeild메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 된다.   Thread가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료될 때까지 대기하게 된다.   쓰레드와 상태제어 (join)   join() 메소드는 쓰레드가 멈출 때까지 기다리게 한다.      일단 0.5초씩 쉬면서 숫자를 출력하는 MyThread5를 작성해 보겠다.       public class MyThread5 extends Thread{         public void run(){             for(int i = 0; i &lt; 5; i++){                 System.out.println(\"MyThread5 : \"+ i);                 try {                     Thread.sleep(500);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }         } // run     }     해당 쓰레드를 실행하고, 해당 쓰레드가 종료될 때 까지 기다린 후, 내용을 출력하는 joinExam 클래스       public class JoinExam {          public static void main(String[] args) {             MyThread5 thread = new MyThread5();             // Thread 시작              thread.start();              System.out.println(\"Thread가 종료될때까지 기다립니다.\");             try {                 // 해당 쓰레드가 멈출때까지 멈춤                 thread.join();             } catch (InterruptedException e) {                 e.printStackTrace();             }             System.out.println(\"Thread가 종료되었습니다.\");          }        }     실행 결과           Thread가 종료될때까지 기다립니다.         MyThread5 : 0         MyThread5 : 1         MyThread5 : 2         MyThread5 : 3         MyThread5 : 4         Thread가 종료되었습니다.  쓰레드와 상태제어 (wait, notify)   wait과 notify는 동기화된 블록 안에서 사용해야 한다. wait를 만나게 되면 해당 쓰레드는 해당 객체의 모니터링 락에 대한 권한을 가지고 있다면 모니터링 락의 권한을 놓고 대기한다.      Thread를 상속받는 ThreadB 클래스 작성       public class ThreadB extends Thread{        // 해당 쓰레드가 실행되면 자기 자신의 모니터링 락을 획득        // 5번 반복하면서 0.5초씩 쉬면서 total에 값을 누적        // 그후에 notify()메소드를 호출하여 wiat하고 있는 쓰레드를 깨움          int total;         @Override         public void run(){             synchronized(this){                 for(int i=0; i&lt;5 ; i++){                     System.out.println(i + \"를 더합니다.\");                     total += i;                     try {                         Thread.sleep(500);                     } catch (InterruptedException e) {                         e.printStackTrace();                     }                 }                 notify();             }         }     }     이번에는 ThreadB 를 사용하며 wait 하는 클래스 작성       public class ThreadA {         public static void main(String[] args){             // 앞에서 만든 쓰레드 B를 만든 후 start              // 해당 쓰레드가 실행되면, 해당 쓰레드는 run메소드 안에서 자신의 모니터링 락을 획득             ThreadB b = new ThreadB();             b.start();              // b에 대하여 동기화 블럭을 설정             // 만약 main쓰레드가 아래의 블록을 위의 Thread보다 먼저 실행되었다면 wait를 하게 되면서 모니터링 락을 놓고 대기                    synchronized(b){                 try{                     // b.wait()메소드를 호출.                     // 메인쓰레드는 정지                     // ThreadB가 5번 값을 더한 후 notify를 호출하게 되면 wait에서 깨어남                     System.out.println(\"b가 완료될때까지 기다립니다.\");                     b.wait();                 }catch(InterruptedException e){                     e.printStackTrace();                 }                  //깨어난 후 결과를 출력                 System.out.println(\"Total is: \" + b.total);             }         }     }     실행 결과           b가 완료될때까지 기다립니다.         0를 더합니다.         1를 더합니다.         2를 더합니다.         3를 더합니다.         4를 더합니다.         Total is: 10  데몬 쓰레드   데몬(Daemon)이란 보통 리눅스와 같은 유닉스계열의 운영체제에서 백그라운드로 동작하는 프로그램을 말한다.     데몬쓰레드를 만뜨는 방법은 쓰레드에 데몬 설정을 하면 된다.            이런 쓰레드는 자바프로그램을 만들 때 백그라운드에서 특별한 작업을 처리하게 하는 용도로 만든다.           데몬쓰레드는 일반 쓰레드(main 등)가 모두 종료되면 강저젝으로 종료되는 특징을 가지고 있다.       // Runnable을 구현하는 DaemonThread클래스를 작성     public class DaemonThread implements Runnable {          // 무한루프안에서 0.5초씩 쉬면서 데몬쓰레드가 실행중입니다를 출력하도록 run()메소드를 작성         @Override         public void run() {             while (true) {                 System.out.println(\"데몬 쓰레드가 실행중입니다.\");                  try {                     Thread.sleep(500);                  } catch (InterruptedException e) {                     e.printStackTrace();                     break; //Exception발생시 while 문 빠찌도록                  }             }         }          public static void main(String[] args) {             // Runnable을 구현하는 DaemonThread를 실행하기 위하여 Thread 생성             Thread th = new Thread(new DaemonThread());             // 데몬쓰레드로 설정             th.setDaemon(true);             // 쓰레드를 실행             th.start();              // 메인 쓰레드가 1초뒤에 종료되도록 설정.              // 데몬쓰레드는 다른 쓰레드가 모두 종료되면 자동종료.             try {                 Thread.sleep(1000);             } catch (InterruptedException e) {                 e.printStackTrace();             }                System.out.println(\"메인 쓰레드가 종료됩니다. \");             }        } ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_14/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 완주하지 못한 선수 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 해시 완주하지 못한 선수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 두번째 문제이다. 처음 풀어본 문제보다는 자바 문법이 조금 익숙했다. 하지만, 해시를 어떻게 선언하는지 조차 모르고 있어서, 이 부분은 구글링을 하며 풀었다. 이번 문제를 통해서 자바의 해쉬맵을 사용할 수 있게 되었다. 해쉬맵의 여러가지 method들을 숙지하고 있으면 코테에 많은 도움이 될 것 같다.       참가자들이 저장되어 있는 String 배열을 HashMap에 옮겨 담는다.   이 때 참가자들의 이름은 Key값으로 Value는 참가자들의 중복의 유무를 포함하기 위해 default 값을 0으로, 중복된 참가자가 있으면 value를 1씩 증가시킨다.   완주한 참가자들의 이름을 containsKey를 사용하여 해당 Key값의 Value를 1씩 감소시킨다.   해쉬맵의 모든 키를 순회하면서 value값이 0보다 큰 값을 찾는다.   해당 키값을 answer에 저장한다.   return answer   코드       import java.util.*;          public class Main {         public static void main(String[] args){             String[] participant = {\"mislav\", \"stanko\", \"mislav\", \"ana\"};             String[] completion = {\"stanko\", \"ana\", \"mislav\"};                  String answer = solution(participant, completion);             System.out.println(answer);         }              public static String solution(String[] participant, String[] completion){             //정답 문자열 변수 선언             String answer = \"\";             //해쉬맵(딕셔너리) 변수 선언 -&gt; participant 키값으로 넣고 value 값에 Integer 선언해서 completion이랑 비교할거임             Map&lt;String, Integer&gt;ht = new HashMap&lt;String,Integer&gt;();             //해쉬맵에 participant를 키값으로 밸류는 default로 0씩, 키값 중복되면 1씩 추가             for(int i=0; i&lt;participant.length; i++){                 if(ht.containsKey(participant[i])){                     ht.put(participant[i],ht.get(participant[i])+1);                 }                 else{                     ht.put(participant[i],1);                 }             }             //completion을 키값으로 찾아서 밸류값 1씩 감소             for(int i=0; i&lt;completion.length; i++){                 if(ht.containsKey(completion[i])){                     ht.put(completion[i],ht.get(completion[i])-1);                 }             }             //해쉬맵 모든 키를 순회하면서 0보다 큰거 answer에 저장             for(String key:ht.keySet()) {                 if(ht.get(key)&gt;0){                     answer=key;                 }             }                  return answer;         }     }  ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_02/",
        "teaser": null
      },{
        "title": "[프로그래머스/Java] Level1 모의고사 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동   문제풀이     완전 탐색 문제다. 완전 탐색은 “컴퓨터의 빠른 계산을 이용하여 가능한 모든 경우의 수를 구하는 알고리즘”이다.  문제를 어떻게 해결할지 방향을 잡고 최대한 빠른 로직으로 코드를 구현하는 것이 관건으로 보인다.       사용자들의 정답 패턴을 각각의 배열에 저장한다.   사용자들이 정답을 맞추는 개수를 저장하는 배열을 선언한다. (0으로 초기화한다.)   사용자들의 정답 패턴의 length를 answers와의 나머지를 구하여 패턴을 일치시킨다.   사용자들의 정답의 개수를 저장하고, 해당 배열의 max값을 찾는다.   max값과 일치하는 사용자들의 정답 개수를 갖는 index를 answer 배열에 저장한다.   return answer      BadSolution을 보면 Solution보다 더 많은 조건문이 존재하는 것을 알 수 있다. 이렇듯, 완전 탐색 문제에서는 로직을 최대한 간결하게 작성하는 것이 중요하다.    코드         import java.util.*;              public class Main {       public static void main(String[] args){       int[] answers = {1,2,3,4,5};                      int[] answer = solution(answers);               System.out.println(Arrays.toString(answer));           }           public static int[] solution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};                      int[] answerList = {0,0,0};                      for(int i=0; i&lt;answers.length; i++){                   if(user1[i%user1.length]==answers[i]){                       answerList[0]++;                   }                   if(user2[i%user2.length]==answers[i]){                       answerList[1]++;                   }                   if(user3[i%user3.length]==answers[i]){                       answerList[2]++;                   }               }               int max=answerList[0];               for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]&gt;max) {                       max = answerList[i];                   }               }                      ArrayList&lt;Integer&gt; arrList = new ArrayList();                      for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]==max){                       arrList.add(i);                   }               }                      int size = arrList.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = arrList.get(i)+1;               }               return answer;           }                  public static int[] BadSolution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};               int j1=0,j2=0,j3=0;               int[] user_answer ={0,0,0};               List&lt;Integer&gt; answer_list = new ArrayList&lt;Integer&gt;();               for(int i=0; i&lt;answers.length; i++){                   if(j1&gt;=user1.length){                       j1=0;                   }                   if(answers[i] == user1[i]){                       user_answer[0]++;                   }                   j1++;                   if(j2&gt;=user2.length){                       j2=0;                   }                   if(answers[i] == user2[i]){                       user_answer[1]++;                   }                   j2++;                   if(j3&gt;=user3.length){                       j3=0;                   }                   if(answers[i] == user3[i]){                       user_answer[2]++;                   }                   j3++;               }               int max=user_answer[0];               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]&gt;max){                       max = user_answer[i];                   }               }               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]==max){                       answer_list.add(i);                   }               }                      int size = answer_list.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = answer_list.get(i)+1;               }               return answer;           }       }  ","categories": ["programmers"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/programmers/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 람다",
        "excerpt":"Part8 람다   람다식   람다식은 다른말로 익명 메소드라고도 한다.      인터페이스 중에서 메소드를 하나만 가지고 있는 인터페이스르함수형 인터페이스라고 한다.            쓰레드를 만들 때 사용하는 Runnable 인터페이스의 경우 run() 메소드를 하나만 가지고 있다.           Runnable을 이용하여 쓰레드를 만드는 방법       public class LambdaExam1 {          public static void main(String[] args) {             new Thread(new Runnable(){public void run(){                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }}).start();         }        }     쓰레드가 실행되면 쓰레드 생성자 안에 넣은 run()메소드가 실행된다.   자바는 메소드만 배개변수로 전달할 방법이 없다. 인스턴스만 전달할 수 있다.   그렇기 때문에 run()메소드를 가지고 있는 Runnable 객체를 만들어서 전달한다.   메소드만 전달할 수 있다면, 좀 더 편리하게 프로그래밍할 수 있을텐데, 자바는 메소드만 전달할 수 있는 방법은 없었기 때문에 매번 객체를 생성해서 매개변수로 전달해야 했다. 이러한 부분을 해결한 것이 람다 표현식이다.      람다식을 이용해서 수정한 코드       public class LambdaExam1 {           public static void main(String[] args) {             new Thread(()-&gt;{                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }).start();         }        }     ()-&gt;{……} 부분이 람다식, 다른말로 익명 메소드   JVM은 Thread생성자를 보고 ()-&gt;{} 이 무엇인지 대상을 추론한다.   Thread 생성자 api를 보면 Runnable 인터페이스를 받아들이는 것을 알 수 있다.   JVM은 Thread 생성자가 Runnable 인터페이스를 구현한 것이 와야 하는 것을 알게 되고 람다식을 Runnable을 구현하는 객체로 자동으로 만들어서 매개변수로 넣어준다.        프로그래머스 자바 중급을 마무리하며  자바 초급 강의보다는 조금 덜 직관적으로 와닿은 강의였다. 자바 중급 강의에서 배우는 다양한 패키지와 IO 그리고 쓰레드와 람다를 정확히 어느 경우에 사용 하는지 모호하기 때문인 것 같다. 이러한 부분들은 향후 java 언어를 자주 사용하게 됨으로써 해당 기능들을 사용하게 되었을 때 더 직관적으로 이해할 수 있을 것 같다. 해당 기능들을 사용할 때 이해가 되지 않는다면, 이번에 포스팅한 프로그래머스 자바 중급 강의를 사용하면 좋을 것 같다.     해당 강의와 강의 노트는 프로그래머스 자바 중급에서 언제든지 다시 들을 수 있다!  ","categories": ["프로그래머스 자바 중급"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4%20%EC%9E%90%EB%B0%94%20%EC%A4%91%EA%B8%89/java_15/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.11 부동소수점 코드 ~ 3.12 요약)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.11 부동소수점 코드   3.12 요약   3.11 부동소수점 코드      프로세서의 부동소수점 아키텍처는 부동소수점 데이터로 연산하는 방법이 기계에 매피되는 방법에 영향을 주는 다음과 같은 여러 가지 개념들로 구성된다.            부동소수점 값들이 저장되고 접근되는 방법                    이것은 대개 레지스터들의 일부 형태로 이뤄진다.                       부동소수점 데이터로 연산하는 인스트럭션       함수들의 인자와 리턴 값으로 부동소수점 값들을 전달하기 위해 이용되는 관례들       함수를 호출하는 동안에 레지스터들을 보존하는 관례들           x86-64 부동소수점 아키텍처를 이해하기 위해선 간략한 역사적 고찰을 해보는 것이 유용하다.            1997년에 펜티엄/MMX를 발표한 이래, 인텔과 AMD는 그래픽과 영상처리를 지원하기 위해 일련의 미디어 인스트럭션 세대들을 포함해왔다.       이들에 대한 확장현태가 진행되었고 MMX로부터 SSE, AVX로 개선되어갔다.       AVX 부동소수점 아키텍처는 %ymm0-%ymm15로 이름 붙인 16개의 YMM 레지스터들에 저장된다.       스칼라 데이터로 연산할 때, 이 레지스터들은 부동소수점 데이터만을 보관하며, 하위 32비트(float), 64비트(double)만이 사용된다.              3.11.1 부동소수점 이동 및 변환 연산      XMM 레지스터에서 다른 레지스터로 이동하는 것뿐만 아니라 메모리와 XMM 레지스터들 간의 부동소수점 데이터를 이동하는 인스트럭션들을 보여준다.   메모리를 참조하는 인스트럭션들은 스칼라 인스트럭션들이다.            이것은 이들이 묶인 데이터 값들이 아닌 개별 값들에 대해 연산한다는 것을 의미한다.           GCC는 데이터를 메모리에서 XMM 레지스터로,또는 XMM 레지스터에서 메모리로 이동하기 위해서만 스칼라 이동연산을 이용한다.        두 개의 XMM 레지스터들 간의 데이터 이동을 위해서는 한 개의 XMM 레지스터의 내용 전체를 다른 레지스터로 복사하기 위해 두 개의 인스트럭션 중 하나를 이용한다.       아래의 그림은 부동소수점 이동 명령. 이 연산들은 레지스터들 간, 레지스터와 메모리 간에 값을 이동한다.         아래의 그림은 두 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 부동소수점 데이터를 정수로 변환한다.         아래의 그림은 세 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 첫번째 소스의 자료형으로부터 목적지의 자료형으로 변환한다. 두번째 소스 값은 결과의 하위 바이트에는 영향을 주지 않는다.      3.11.2 프로시저에서 부동소수점 코드      XMM 레지스터들이 함수로 부동소수점 인자를 전송하고 부동소수점 값들을 리턴할 때 사용된다.            최대 여덟 개의 부동소수점 인자들이 %xmm0-%xmm7 XMM 레지스터들로 전달될 수 있다.       한개의 부동소수점 값을 리턴하는 함수는 레지스터 %xmm0를 이용한다.       모든 XMM 레지스터들은 호출자 저장방식이다.           어떤 함수가 포인터, 정수, 부동소수점 인자들의 조합을 가지고 있을 때, 포인터와 정수들은 범용 레지스터로 전달되지만, 부동소수점 값들은 XMM 레지스터들로 전달된다.      3.11.3 부동소수점 산술연산      스칼라 부동소수점 산술연산. 이 인스트럭션들은 한 개 또는 두 개의 소스 오퍼랜드와 하나의 목적지 오퍼랜드를 갖는다.   첫번빼 소스 오퍼랜드 S1은 XMM 레지스터나 메모리 위치일 수 있다.   두번째 소스 오퍼랜드와 목적지 오퍼랜드는 XMM 레지스터만 가능하다.      3.11.4 부동소수점 상수의 정의 및 이용      AVX 부동소수점 연산은 즉시값immediate value을 오퍼랜드로 가질 수 없다.   그 대신, 컴파일러는 상수 값들을 위해 저장공간을 할당하고 초기화해야 한다.        그리고 나서 코드는 메모리에서 값들을 읽어들인다.       아래의 그림을 보면 값 1.8을 .LC2로 명명된 메모리 위치에서 읽어들이고, 32.0을 메모리 위치 .LC3에서 읽어들이는 것을 알 수 있다.      3.11.5 부동소수점 코드에서 비트연산 사용하기      아래의 그림은 통합데이터에 대한 비트 연산이다. 이 인스트럭션들은 XMM 레지스터에 들어 있는 128비트들에 대한 부울연산을 수행한다.      3.11.6 부동소수점 비교 연산      AVX2는 부동소수점 값들을 비교하기 위해 두 개의 인스트럭션을 제공한다.         부동소수점 비교 인스트럭션은 세 개의 조건코드를 설정한다: zero 영 플래그 ZF, 캐리 플래그 CF, 패리티 플래그 PF            패리티 플래그는 가장 최근 산술 또는 논리연산이 최소중요바이트를 짝수 패리티를 갖는 값을 생성했을 때 설정된다.                    패리티 플래그 무슨소린지 하나도 모르겠다… 이건 좀더 조사해보자!                            3.11.7 부동소수점 코드에 대한 관찰      AVX2로 부동소수점 데이터에 대해 연산하기 위해 생성된 머신코드의 일반적인 스타일이 정수데이터에 연산하는 경우에 대해 살펴본 것과 유사하다는 것을 알았다.   이 둘은 모두 값을 보관하고 연산하기 위해 레지스터들을 사용하며, 이들은 이 레지스터를 사용해서 함수의 인자를 전달한다.   3.12 요약     이 장에서는 기계어 수준 프로그래밍의 시각을 얻기 위해 C언어에서 제공하는 추상화 계층 아래를 살펴보았다.        컴파일러가 기계어 수준 프로그램의 어셈블리 코드 표현을 생성하게 해서 프로세서, 자료형, 인스트럭션 집합과 함께 컴파일러와 컴파일러의 최적화 능력에 대한 통찰을 얻을 수 있었다.       기계어 수준 프로그램들과 이들의 어셈블리 코드 표시는 C 프로그램들과는 여러모로 다른다.   서로 다른 자료형들 사이에 차이는 거의 없다.   프로그램은 인스트럭션들의 연속으로 표시되고, 각각은 한 개의 연산을 수행한다.   컴파일러는 여러 가지 자료구조를 생성하고 처리하기 위해서, 조건문, 루프, 프로시저 같은 제어문을 구현하기 위해서 다수의 인스트럭션들을 사용해야 한다.        C에서 경계 값을 체크하지 않기 때문에 많은 프로그램들이 버퍼 오버플로우의 위험에 놓인다는 것을 알게 되었다.       자바는 ‘자바 바이트 코드’라고 알려진 특별한 이진 표현이다.      Chapter3 또한 부동소수점을 마지막으로 마무리 하였다. 기계어 표현인 어셈블리어에 대한 내용이 한가득 있었던 챕터였다. 간단한 이동과 연산부터 배열, 조건문, 프로시저, 부동소수점 까지의 기계어 인스트럭션들을 살펴보았고, 이러한 인스트럭션을 통해서 컴퓨터는 연산 명령을 받게 된다. 이해하기 어려운 기계어는 실제로 C언어를 기계어 단계에서 디버깅 하면서 이해를 도왔다. &lt;- 이부분이 이해가 직관적으로 되어서 참 좋았다. Chapter2~3은 Chapter4의 빌드업이라고도 한다. 확실히 이해하고 Chapter 4로 넘어가자!   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.1 Y86-64 인스트럭션 집합 구조)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조      3장까지는 컴퓨터 시스템을 기계어 프로그램의 수준까지만 내려가서 살펴보았다.   프로세서가 일련의 명령어들을 샐힝하고, 각 명령으들은 두 개의 수를 더한다든지의 기본적인 기능을 수행하는 것을 알게 되었다.   한 개의 인스트럭션은 연속된 바이트들로 이진수의 형태로 인코딩된다.   인스트럭션들은 특정 프로세서에 의해 지원되며, 바이트수준의 인코딩을 인스트럭션 집합 구조instruction set architecture(ISA)라고 한다.   ISA는 어떤 인스트럭션들이 허용되고, 어떻게 그들이 인코딩되었는지 알고 있는 컴파일러 작성자와 이들 인스트럭션을 실행해야 하는 머신을 만들어야 하는 프로세서 설계자들에게 개념적 추상화 계층을 제공하고 있다.      4장에서는 프로세서 하드웨어의 설계를 간단히 살펴본다.   하드웨어 시스템이 어떻게 특정 ISA의 인스트럭션들을 실행할 수 있는지를 학습한다.   이러한 관점은 어떻게 컴퓨터들이 동작하는지와 컴퓨터 제작자들이 직면하고 있는 기술적인 도전들을 더 잘 이해할 수 있게 해준다.   왜 프로세서 설계를 공부해야 하는 것인가?            지적으로 흥미롭고 중요하기 때문이다.       프로세서의 동작방법을 이해하면 전체 컴퓨터 시스템의 동작 방법을 이해하는 데 도움을 준다.       비록 적은 수의 사람들만이 프로세서를 설꼐하지만 많은 사람들이 프로세서를 포함하는 하드웨어 시스템을 설계한다.              4장에서는 인스트럭션 집합을 정의한다 : “Y86-64” 인스트럭션 집합   x86-64에 비해서 적은 자료형, 인스트럭션, 주소지정 모드를 갖는다.   디지털 하드웨어 설계에 관한 약간의 배경지식을 제공한다.            기초 설계 블록과 이들이 어떻게 서로 연결되고 동작하는지 설명한다.       불 대수와 비트수준 연산에 관한 논의에 기초한다.       간단한 언어인 HCL : 하드웨어 시스템의 제어 부분을 설명하는 데 사용된다.           순차 설계를 기초로 해서 파이프라인형pipelined 프로세서를 만드는 일련의 변환을 적용한다.            각 인스트럭션의 실행단계를 5단계로 나누어서 각각 별도의 부분 또는 하드웨어 단계에서 처리되도록 한다.           4.1 Y86-64 인스트럭션 집합  인스트럭션 집합을 설계하기 위해서는 여러 가지 상태요소들, 인스트럭션 집합과 이들의 인코딩, 프로그래밍 관습들, 예외적 사건들의 처리 등에 대한 정의를 해야 한다.   4.1.1 프로그래머-가시성 상태programmer-visible state     Y86-64의 각 인스트럭션은 프로세서 상태의 일부를 읽거나 변경할 수 있다.            이것을 프로그래머-가시성상태programmer-visible state라고 한다.           프로세서를 구현할 때는 기계수준 프로그램이 프로그래머 가시 상태에 접근하는 것을 확실히 할 수만 있다면 이 상태를 ISA가 의미하는 방식대로 정확히 표시하거나 구성할 필요가 없다는 것을 알게 될 것이다.        아래의 그림은 Y86-64 프로그래머-가시성 상태이다. 프로그램 레지스터, 조건코드, 프로그램 카운터(PC), 메모리를 접근하고 수정할 수 있다. 상태코드는 이 프로그램이 정상적으로 실행되고 있는지, 어떤 특수한 사건이 발생했는지를 나타낸다.                     레지스터 %rsp는 push, pop, call, return 인스트럭션을 사용할 때 스택 포인터로 이용된다.       메모리는 개념적으로 커다란 바이트의 배열이다.                    Y86-64 프로그램들은 가상주소를 사용해서 메모리 위치를 참조한다.           운영체제와 하드웨어가 함께 이 가상주소를 실제주소, 즉 물리 주소로 번역한다.                       프로그램 상태의 마지막 부분은 상태코드 Stat이다.                    프로그램 실행의 전체적인 상태를 나타낸다.                           4.1.2 Y86-64 인스트럭션      아래의 그림은 Y86-64 인스트럭션 집합이다.            인스트럭션 인코딩은 1에서 10바이트가 쇼요된다.       한개의 인스트럭션은 1바이트의 인스트럭션 식별자와 1바이트 레지스터 식별자, 8바이트 상수 워드로 구성될 수 있다.       필드 fn은 특정 연수 연산(OPq), 데이터 이동 조건(cmovXX), 분기조건(jxx)을 나타낸다.       모든 숫자 값은 16진수로 나타낸다.                         movq 인스트럭션은 네 개의 인스트럭션으로 나누어진다.                    irmovq, rrmovq, mrmovq, rmmovq           소스와 목적지를 명시적으로 나타낸다.           소스는 상수 immediatde(i), 레지스터(r), 메모리(m) 중의 하나가 될 수 있다.                       OPq로 나타낸 것처럼 네 개의 정수 연산이 있다.                    addq, subq, andq, xorq           이 인스트럭션 집합은 ZF, SF, OF(zero, sign, overflow) 조건코드를 결정한다.                       일곱개의 jump 인스트럭션이 있다.                    jmp, jle, jl, je, jne, jge, jg                       여섯 개의 move 인스트럭션이 있다.                    cmovle, cmovl, cmove, cmovne, cmovge, cmovg           목적지 레지스터는 조건코드가 요구된 조건을 만족할 때에만 갱신된다.                       call 인스트럭션은 리턴주솔들 스택에 넣고 목적지 주소로 이동한다.       ret 인스트럭션은 call에서 리턴해준다.       pushq와 popq 인스트럭션은 push와 pop을 구현한다.       halt 인스트럭션은 인스트럭션의 실행을 정지시킨다.           4.1.3 인스트럭션 인코딩          아래의 그림은 인스트럭션들의 바이트 수준 인코딩을 보여준다.                     각 인스트럭션은 인스트럭션의 타입을 의미하는 첫 번째 바이트를 사용한다.                아래의 그림은 인스트럭션들에 대한 특정 인코딩을 보여준다.                     rrmovq가 조건부 이동과 동일한 인스트럭션 코드를 갖는 점에 유의하라.                    jmp 인스트럭션이 무조건적 점프인 것과 마찬가지로 이것은 “무조건적 move”로 생각 할 수 있다.                                아래의 그림은 Y86-64 프로그램 레지스터 식별자이다.                     15개의 프로그램 레지스터들은 0에서 0xE 사이의 식별자를 갖는다.       프로그램 레지스터들은 CPU 내의 레지스터 파일에 저장된다.       레지스터 파일은 레지스터 ID가 주소로 이용되는 작은 크기의 RAM이다.       식별자 0xF는 레지스터에 접근하지 말아야 한다는 것을 나타낼 필요가 있을 때, 인스트럭션 인코딩에서, 우리의 하드웨어 설계 내에서 이용된다.       일부 인스트럭션들은 1바이트 길이를 사용하지만, 오퍼랜드를 필요로 하는 경우에는 좀 더 긴 인코딩을 사용한다.       하나 또는 두 개의 레지스터를 명시하기 위해 추가적인 레지스터 식별자 바이트를 사용할 수 있다.       어떤 인스트럭션들은 추가로 8바이트 상수 워드를 필요로 한다.                    이 워드는 irmovq의 즉시 데이터가 될 수 있다.           rmmovq와 mrmovq 주소 지시자를 위한 변위값으로 그리고 분기와 call 명령의 목적지로 사용될 수 있다.                           모든 인스트럭션 집합에 있어서 한 가지 중요한 특성은 바이트 인코딩이 유일한 해석을 가져야 한다는 것이다.   모든 인스트럭션이 첫 번째 바이트에 코드와 기능의 유일한 조합을 갖기 때문이며, 바이트만 주어지면 추가적인 바이트들의 의미와 길이를 결정할 수 있다.   4.1.4 Y86-64 예외상황     프로그래머가 볼 수 있는 상태는 현재 실행하고 있는 프로그램의 전체적인 상태를 나타내는 Stat 상태코드를 포함한다.        아래의 그림은 Y86-64 상태코드이다.. 우리의 설계에서 프로세서는 AOK 이외의 모든 코드에서 정지한다.                     코드1, AOK라고 이름 붙인 이 프로그램이 정상적으로 실행되고 있음을 나타낸다.       코드2, HLT 인스트럭션을 실행한 것을 나타낸다.       코드3, ADR 인스트럭션을 선입하거나 데이터를 읽거나 쓰는 경우에 잘못된 메모리주소 읽어오거나 쓰려고 한 것을 나타낸다.       코드4, 잘못된 인스트럭션 코드를 만났다는 것을 의미한다.           4.1.5 Y86-64 프로그램          아래의 그림은 Y86-64 어셈블리 코드로 작성한 에제 프로그램이다. Sum함수는 4개의 원소를 갖는 배열의 합을 계산하기 이해 호출된다.                     이 프로그램은 데이터와 인스트럭션 모두를 가지고 있다.       지시자들은 코드나 데이터를 어느 위치에 저장하고 이것을 어떻게 정렬할지를 나타낸다.       스택 위치, 데이터 초기화, 프로그램 초기화, 프로그램 종료 같은 이슈들을 보여주고 있다.       ”.”로 시작하는 단어들은 어셈블러 지시자directive들로 어셈블러가 만드는 코드의 주소를 조정하고 일부 데이터 워드를 추가하도록 어셈블러에게 지시한다.                아래의 그림은 위의 그림을 YAS라고 하는 어셈블러를 사용해서 어셈블한 결과를 보여준다. == 어셈블러, 목적코드                     목적코드는 인스트럭션이나 데이터를 포함하는 어셈블리 파일의 각 줄에서 주소를 가지며, 다음에 1에서 10바이트의 값들이 따라온다.          ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_12/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.2 논리 설계와 하드웨어 제어 언어 HCL)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.2 논리 설계와 하드웨어 제어 언어 HCL      하드웨어를 설계할 때 전자회로를 사용해서 비트들의 함수를 계산하고 여러 가지 메모리 원소들에 비트들을 저장한다.   디지털 시스템을 만들기 위해서는 다음과 같은 세 개의 주요 컴포넌트가 있어야 한다.            비트연산을 위한 조합회로 combinational logic       비트를 저장하는 메모리 소자       메모리 소자의 갱신을 조절하는 클럭 신호           4.2.1 논리 게이트     논리 게이트는 디지털 회로에서 기초 연산 소자들이다.   아래의 그림은 AND, OR, NOT 논리 게이트의 유형이다. 각 게이트는 입력들의 불 함수 같은 출력을 만든다.      4.2.2 조합회로와 HCL 불 수식      여러 가지 논리 게이트를 모아서 네트워크를 만들면 조합회로라고 알려진 계산 블록을 만들 수 있다.   어떻게 네트워크가 구성되는지와 관련해서 몇가지 제한이 있다.            모든 논리 게이트 입력은 정확히 다음 중의 하나에 연결되어야 한다.                    시스템 입력중의 하나(주요입력이라고 알려진)           일부 메모리 소자의 출력 연결           일부 논리게이트의 출력                       두 개 이상의 논리 게이트의 출력은 서로 연결될 수 없다.       네트워크에는 순환회로가 없어야 한다.           아래의 그림은 비트 동일성을 시험하기 위한 조합회로이다. 출력은 입력이 모두 0이거나 1이면 1이된다.         아래의 그림은 멀티플렉서multiplexor로 알려진 간단하지만 유용한 조합회로의 에를 보여준다.            멀티플렉서는 제어 입력 신호 값에 따라 여러 데이터 신호 중에서 한 값을 선택한다.       제어신호 s가 1이면 출력은 a가 되고, s가 0이면 입력 b가 출력이된다.                 HCL 수식들은 조합논리회로와 C에서의 논리 수식 간에 분명한 연관관계를 보여준다.            이들은 모두 입력에 대한 함수를 계산하기 위해 불 연산을 사용한다. 계산을 표현하는 이들 간의 차이를 살펴보는 것은 의미가 있다.                    조합회로가 일련의 논리 게이트로 이루어지기 때문에 출력들이 입력 변화에 연속적으로 반응하는 특성을 갖는다.                            반대로 C 수식은 프로그램 실행 중에 이 식을 마난야 계산이 이루어진다.                                   C에서 논리 수식을 0을 거짓으로, 다른 값들을 참으로 해석한다.                            반대로 논리 게이트는 비트 값 0과 1에 대해서만 연산을 한다.                                                   4.2.3 워드수준 조합회로와 HCL 정수 수식     논리 게이트들의 커다란 네트워크를 연결해서 보다 복잡한 함수를 계산하는 조합회로를 구성할 수 있다.   데이터 워드를 가지고 동작하는 회로를 설계 하게 된다.   HCL에서 워드 크기를 명시하지 않고 모든 워드수준 신호를 int로 선언한다.            이것은 단순성을 위한 것이다.           아래의 그림은 워드수준 동일성 시험 회로다.         아래의 그림은 워드수준 멀티플렉서 회로다.         멀티플렉서 함수는 HCL의 case 수식을 사용해서 기술된다.            case 수식은 다음과 같은 일반 형태를 갖는다.       이 수식은 여러 개의 case를 가지고 있으며, 각 case i는 언제 이 case가 선택되어야 하는지를 나타내는 불 수식 selecti와 결과 값을 나타내는 정수수식 expri로 구성된다.               [         select1 : expr1;         select2 : expr2;           .           .           .         selectk : exprk;     ]     아래의 그림은 4입력 멀티플렉서이다. 제어신호 s1과 s2의 여러가지 조합에 의해 어떤 데이터 입력이 출력에 전송될지가 결정된다.            그 아래의 수식은 그림에 해당하는 수식이다.                  ex = [         !s1 &amp;&amp; !s0  : A; #00         !s1         : B; #01         !s0         : C; #10         1           : D; #11     ]     조합논리회로는 워드수준 데이터에 대해 여러 가지 많은 연산을 수행하도록 설계될 수 있다.   아래의 그림은 산술/논리 유닛 ALU이다. 함수 입력의 설정에 따라 이 회로는 4개의 서로 다른 산술 및 논리연산을 실행하게 된다.            제어 값들이 이 인스트럭션들을 위한 함수코드와 일치한다.              4.2.4 집합의 원소 관계     집합의 원소 여부를 시험하는 일반적인 형태는 다음과 같다.            iexpr in {iexprq, iexpr2, … , iexprk}           4.2.5 메모리와 클럭     조합회로들은 근본적으로 정보를 저장하지 않는다.   이들은 단순히 입력 신호들에 반응하여 그 입력을 갖는 함수와 동일한 출력을 만들어 낸다.   순차회로, 즉 상태를 가지며 이 상태에 대해 계산을 하는 회로를 만들기 위해서는 비트로 표시된 정보를 저장하는 장치를 이용해야한다.   저장장치들은 로딩되는 때를 결정하는 주기적 신호인 한 개의 클럭에 의해 새 값들이 모두 제어된다.            클럭을 사용하는 레지스터들 : 워드나 개별 비트를 저장한다.       랜덤 액세스 메모리 : 워드를 읽거나 쓰기 위해 주소를 사용해서 여러 워드를 저장한다.                    ex) 가상메모리 시스템, 레지스트 파일                           “레지스터”라는 단어는 하드웨어와 기계어 프로그램에서 사용할 때 다르다.            하드웨어에서 레지스터는 입력과 출력 전선들로 회로의 나머지 부분과 직접 연결된다.       기계어 수준 프로그래밍에서 레지스터는 주소가 레지스터의 ID인 CPU 내의 주소지정이 가능한 워드들의 작은 집합을 나타낸다.                아래의 그림은 레지스터 연산이다. 레지스터 출력은 클럭 신호가 상승할 때까지 현재 레지스터 상태를 유지한다. 클럭이 상승할 때, 레지스터의 입력 값들이 새로운 레지스터의 상태로 저장된다.                     하드웨어 레지스터의 보다 상세한 모습이다.       레지스터는 어떤 고정된 상태(x로 나타냄)로 남는데, 자신의 현재 상태와 동일한 출력을 낸다.       클럭이 올라가면 입력 신호들이 다음 상태(y)로 레지스터에 로딩되고, 이것이 다음 상승 클럭 에지edge까지 새로운 레지스터의 출력이된다.       레지스터들이 회로의 여러 부분에서 조합논리 간에 장벽으로의 역할을 수행한다는 것이다.                아래의 그림은 전형적인 레지스터 파일을 보여준다.                     다중포트 랜덤 액세스 메모리는 여러 번의 읽기와 쓰기 연산이 동시에 일어날 수 있도록 해준다.       레지스터 파일에서 이 회로는 두 프로그램 레지스터의 값을 읽을 수 있고 세 번째 레지스터의 상태를 갱신 할 수 있다.       두 개의 읽기 포트는 주소 입력 srcA, srcB와 데이터 출력 valA, valB를 갖는다.       쓰기 포트는 주소 입력 dstW, 데이터 입력 valW를 갖는다.       레지스터 파일은 조합회로는 아닌데, 이는 레지스터 파일이 내부 저장장치를 가지고 있기 때문이다.       데이터는 주소를 입력으로 가지며, 데이터를 출력으로 갖는 조합논리 블록인 것처럼 데이터가 레지스터 파일로부터 읽을 수 있다.       srcA, srcB가 어떤 레지스터 ID로 설정되었을 때, 해당 프로그램에 저장된 값은 valA, valB에 나타난다.       레지스터 파일에 워드를 쓰는 작업은 클럭이 있는 레지스터에 값을 로딩하는 것과 비슷하게 클럭 신호에 의해 제어된다.                아래의 그림은 프로세서는 다음과 같이 도식적으로 나타낸 것처럼 프로그램 데이터를 저장하기 위해 랜덤 액세스 메모리를 갖는다.                     한 개의 주소 입력, 쓰기를 위한 데이터 입력, 읽기를 위한 데이터 출력을 갖는다.       레지스터 파일처럼 우리의 메모리에서의 읽기 작업은 조합회로와 유사한 방식으로 동작한다.          ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_13/",
        "teaser": null
      },{
        "title": "[Python/Pandas] Python Pandas Cheat Sheet을 한번 만들어 보겠습니다.",
        "excerpt":"Cheat Sheet! 왜 필요할까?   Data Engineering 인턴을 경험하면서 나는 ETL 작성을 주업무로 맡게 되었다. R 코드로 작성된 레거시 파일을 Python 코드로 마이그레이션 하는 업무인데, 가끔씩 data 요청사항이 있으면 직접 로직을 구현하는 경우도 있었다. 보통 data 가공을 DataFrame으로 만들어 Pandas 문법을 사용하는데, 자주 사용했던 문법도 기억이 안나서 구글링으로 시간을 낭비했던 경험이 꽤 있다. 그래서! “구글링의 속도를 높여줄 혹은 구글링이 필요 없을 정도의 Cheat Sheet을 만들어두면 굉장히 편할 것 같다!” 라고 생각한다. 약 8개월간의 인턴생활중 자주 사용했던 Pandas 문법을 정리해보겠다.   우선 Pandas 문법을 크게 세가지로 분류하겠다.     Input/output            pandas의 input output 관련 문법       ex) read_csv,to_json…           General functions            DataFrame 자체를 가공하는 문법..?       ex) pd.merge(), pd.concat()…           DataFrame            DataFrame 이 갖고있는 메소드..?       ex) DataFrame.astype, DataFrame.pop…           Input/output      read_csv   to_csv   General functinons   DataFrame 합치기 관련           pandas.merge             n개의 dataframe을 merge 또는 join                pandas.concat             n개의 dataframe을 단순히 합침           DataFrame 중복제거 관련           pandas.unique             중복된 값을 제거           DataFrame Nan값 관련           pandas.isna             Nan인 값 True                pandas.notna             Nan이 아닌 값 True              isnull, notnull 도 있음   DataFrame   DataFrame Info 관련           pandas.DataFrame.dtypes             column들의 type 출력                pandas.DataFrame.shape             df의 column과 row수 출력                pandas.DataFrame.head             df의 상위 n개의 정보 출력           DataFrame value 관련           pandas.DataFrame.values             df의 value들을 출력       ex) df[“A”].values.to_list() -&gt; A컬럼의 value들을 list로 변경함                pandas.DataFrame.value_counts             df의 value 수 출력                pandas.DataFrame.sort_values             df의 값을 df의 X column value 기준으로 정렬           DataFrame index 관련           pandas.DataFrame.reset_index             df의 index를 reset                pandas.DataFrame.set_index             df의 X column으로 index 설정           DataFrame column 관련           pandas.DataFrame.rename             column 명을 변경                pandas.DataFrame.astype             column의 type 변경           DataFrame 조건 추출 관련           pandas.DataFrame.where             특정 조건을 만족하지 않은 값, False인 값을 특정 값으로 변경                pandas.DataFrame.mask             특정 조건을 만족하는 값, True인 값을 특정 값으로 변경                pandas.DataFrame.equals             DataFrame과 DataFrame을 비교하여 True of False 추출           DataFrame Nan 관련           pandas.DataFrame.dropna             Nan값 drop           DataFrame 중복제거 관련           pandas.DataFrame.drop_duplicates             중복된 값 drop           DataFrame groupby 관련           pandas.DataFrame.groupby             특정 컬럼으로 groupby 후 min(),max() 등의 함수 적용하여 새로운 DataFrame 생성                pandas.DataFrame.agg             특정 컬럼으로 groupby 후 커스텀 함수 적용하여 새로운 DataFrame 생성                groupby에는 추가 메소드가 존재함!   DataFrame 특정 함수 적용 관련           pandas.DataFrame.apply             axis 기준으로 row 또는 column의 value들이 인자 값으로 넘어가는데, 해당 인자 값을 커스텀 함수로 변경 후 return 가능.           DataFrame col &lt;-&gt; row 변형 관련           pandas.DataFrame.stack            pandas.DataFrame.T       ETC…           DataFrame의 간단한 조건 추출             A라는 Data Frame이 있다고 가정해보자       A[A[“pnu”]==”123”] -&gt; pnu가 123인 값들로 새로운 df를 생성한다.                DataFrame과 Series의 차이             Series는 contains나 .str을 적용할 수 없다.       DataFrame은 df.str.contains(“x”) 사용 가능하지만, Series는 pd.Series([1,2]) in [1] 로 사용해야한다.                DataFrame.str             python string 관련 메소드를 df에 적용하고 싶을 때 사용, df에 적용하면 vector값으로 계산이 가능하다.           사용하기 어려운 문법  사용하기 어려운 문법은, 다음에 더 자세히 정리해서 포스팅하겠다. 우선 갑자기 어떤 문법을 사용해야하는데 생각이 안난다! 싶으면 해당 문법이 어떤 카테고리인지 생각해보고 Cheat Sheet에 와서 ctrl+F를 해보자! Cheat Sheet에 각각의 문법에 해시태그를 추가해서 키워드로 검색이 가능해서 구글링의 편의성을 늘려보자!   pandas doumentation API reference &lt;- 여기에 다~~ 있다!   이제부터 공식문서를 보는 힘을 기르자! 아자아자 화이팅!  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.1 작업을 단계로 구성하기      인스트럭션을 처리하는 데는 다수의 연산이 관련되어 있다.   이들은 특정한 단계들Stages로 구성해서 비록 인스트럭션들의 동작은 다를지라도 모든 인스트럭션들이 일정한 순서를 따르도록 한다.   각 단계에서의 세부 처리내용은 실행하는 인스트럭션에 따라 달라진다.            선입 fetch                    프로그램 카운터 PC를 메모리주소로 사용해서 메모리로부터 인스트럭션 바이트들을 읽어들인다.           icode(인스트럭션 코드)와 ifun(instruction function)을 추출한다.           한 개의 레지스터 지시자 바이트를 선입해서 한 개 또는 두 개의 레지스터 오퍼랜드 지시자 rA와 rB를 얻어내는 경우도 있다. 또한 8바이트 상수 워드 valC를 선입할 수도 있다.           이것은 지금 실행 중인 인스트럭션의 순차적인 다음 인시트럭션의 주소가 되는 valP를 계산한다.                       해독 decode                    레지스터 파일에서 최대 두 개의 오퍼랜드를 읽어서 valA, valB를 얻어온다.           일부 인스트럭션에 대해서는 레지스터 %rsp를 읽어온다.                       실행 excution                    산술/논리 연산 유닛(ALU)이 인스트럭션이 지시하는 연산을 수행하거나(ifun 값에 따라), 메모리 참조 시 유효주소를 계산하거나, 스택 포인터 값을 변경한다. 이 결과를 valE라고 부른다.           조건 코드들은 이 경우에 설정될 수 있다. 조건부 이동 인스트럭션에 대해서 조건코드와 분기 조건(ifun에서 주어진)을 평가하고 조건이 참이 되는 경우에만 목적지 레지스터를 갱신한다. 점프 인스트럭션도 마찬가지이다.                       메모리                    데이터를 메모리에 쓰거나 메모리에서 데이터를 읽어올 수 있다. 이 값을 valM이라고 한다.                       재기록 write back                    두 결과를 레지스터 파일에 기록한다.                       PC 갱신                    PC는 다음 인스트럭션의 주소로 설정된다.                           프로세서는 위의 사항들을 무한히 반복하면서 이 단계들을 실행한다.   한 개의 인스트럭션을 실행하는 데는 놀라운 양의 작업을 요구한다.            각 인스트럭션에 대해 기술한 연산을 싫애해야하고       주소를 계산하고       스택 포인터를 갱신하고       다음 인스트럭션을 결정해야 한다.           Y86-64 인스트럭션 처리과정        위의 그림은 Y86-64 인스트럭션 예제이다. 해당 코드를 사용해서 여러가지 Y86-64 인스트럭션들의 처리과정을 그림으로 나타낸다.           OPq 인스트럭션 타입(정수와 논리연산), rrmovq(레지스터-레지스터 이동), irmovq(상수-레지스터 이동)에 대해 요구되는 작업을 보여준다.   선입 단계에서 상수 워드는 필요하지 않기 때문에 valP는 PC+2로 계산된다.   해석 단계에서 두 개의 오퍼랜드를 읽어들인다.   실행단계에서 함수 지시자 ifun과 함께 ALU에 제공된다.   valE는 인스트럭션 결과가 된다.   rrmovq인스트럭션을 실행하면 산술연산과 매우 비슷하게 진행한다.   irmovq의 경우에도 첫 번째 ALU 입력 대신에 상수 값 valC를 사용한다는 점을 제외하고는 유사한 처리가 발생한다.            프로그램 카운터를 10 증가시켜야 하는데, 그 이유는 irmovq가 긴 인스트럭션 형식을 가지기 때문이다.                   메모리 쓰기와 읽기 인스트럭션인 rmmovq와 mrmovq를 위해 필요한 처리작업을 보여준다.   valC를 valB에 더하기 위해 ALU를 사용해서 메모리 연산을 위한 유효주소를 만들어 낸다.           pushq와 popq 인스트럭션을 처리하기 위해 요구되는 단계들을 보여준다.   메모리에 접근 하면서 동시에 스택 포인터를 변경한다.   pushq 인스트럭션은 해석단계에서 %rsp를 두 번째 레지스터 오퍼랜드의 식별자로 사용해서 스택 포인터를 valB로 만든다.           세 개의 제어 전환 인스트럭션에서의 처리과정을 나타낸다: jump, call, ret   정수연산에서처럼 분기를 할지 말지 결정할 때에만 이들이 다르기 때문에 모든 점프를 통합된 방법으로 처리할 수 있다.   점프 인스트럭션은 선입에서 해독까지는 레지스터 명시자를 필요로 하지 않는다.   실행단계에서 조건코드와 점프 조건을 체크해서 분기를 할지 말지 결정하고, 1비트 신호 Cnd를 만든다.   PC갱신단계 동안에 이 플래그를 시험하고, 만일 플래그가 1이면 PC를 valC(점프 목적지)로 설정하고, 만일 0이면 valP(다음 인스트럭션의 주소)로 설정한다.   인스트럭션 call과 ret은 프로그램 카운터 값을 push, pop한다는점 외에는 pushq, popq와 약간의 유사성을 갖는다.   call할 때는 call 인스트럭션의 다음 인스트럭션의 주소인 valP를 push한다.   PC 갱신 단계 동안에 PC를 call 목적지인 valC로 설정한다.   ret 인스트럭션에서 스택에서 pop한 값인 valM을 PC 갱신 단계에서 PC에 저장한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_14/",
        "teaser": null
      },{
        "title": "[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리",
        "excerpt":"Data Development      Crawler   ETL   Docker   k8s   airflow      Data Platform     Data Orchestration   Data Storage            Data Lake       Data Warehouse           Data Catalog   Data Monitoring            Data Validation       Data Notification              Data Governance         하둡 스파크 카프카 스칼라…? 알아야할게 산더미군..!!!  ","categories": ["DataEngineering"],
        "tags": ["DataEngineering"],
        "url": "/dataengineering/de_01/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%   Related Work     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.   Model     ELMo            ELMo word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM            Task-specific ELMo Embedding            Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.              Evaluation        6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.   Analysis        일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.           GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.           biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다           ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.   Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_05/",
        "teaser": null
      },{
        "title": "[NLP/CS224n]CS224n Lecture 17: Multitask Learning",
        "excerpt":"   lecture 5, 7, 13 ,17 을 리뷰 했는데,,, 17강 밖에 안남아있다…T.T    The Limits of Single-task Learning     Great performance improvements in recent years given            dataset       task       model       metric           Models typically start from ranbdom or are only partly pre-trained   Pre-training and sharing knowledge is great!     Computer Vision            ImageNet + CNN이 큰 성공을 거두었음       Classification task가 과거에 큰 장벽이었음       이 문제가 해결되고 많은 문제들을 푸는 것이 가능해짐           Natural Language Processing            Word2Vec, Glove       최근 CoVe, ELMo, BERT 성공을 거두기 시작함           Why has weight&amp;model sharing not happened as much in NLP?     NLP는 많은 종류의 추론이 요구됨            logical, linguistic, emotional, visual           Short and long term memory가 요구됨   NLP는 중간 단계 또는 분리된 Task로 많이 나누어져 있음   하나의 Unsupervised Task가 전체 문제를 해결할 수 없음   언어는 현실적으로 분명한 Supervision이 필요함   Why a unified multi-task model for NLP     Multi-task learning은 General NLP system이 넘어야할 장벽임   하나의 통합된 모델은 지식을 어떻게 전달할지 결정 가능            Domain adaptation, weight sharing, transfer and zero shot learning           하나의 통합된 Multi-task 모델은            새로운 task가 주어졌을 때 쉽게 적응할 수 있음       실제 production을 위해 deploy하는 것이 매우 간단해짐       더 많은 사람들이 새로운 task를 해결할 수 있도록 도와줌       잠재적으로 Continual learning으로 나아갈 수 있음       모든 프로젝트를 계속 다시 시작하게 된다면 자연 언어의 복잡성을 점점 더 많이 포함하는 하나의 모델에 도달하지 못함           인공지능이 대화를 가능하게 하는 task를 진행할 때 사람의 언어처럼 순차적으로 처리하는 것 만큼 비효율적인 것은 없음. 컴퓨터가 인간의 언어를 supervision하지 않다면 훨씬 더많은 언어로 의사소통 가능.   How to express many NLP tasks in the same framework?     Sequence tagging            Named Entity Recognition, aspect specific sentiment           Text classification            Dialogue state tracking, sentiment classification           Seq2seq            Machine Translation, Summarization, Question Answering           Three equivalent Supertasks of NLP     Language Modeling            다음 단어를 예측하는 것은 질문의 일종이다.           Question Answering            말 그대로 Question &amp; Answering 이다.           Dialogue System            질문 답변, 답변에 대한 답변 형태이다.              The Natural Language Decathlon(decaNLP)     The Natural Language Decathlon : Multitask Learning as Question Answering            10개의 NLP Task를 하나의 Question Answering모델 학습만으로 풀 수 있도록 디자인       이를 위해 모든 데이터 셋에 대하여 question, context, answer 형태로 전처리              Multitask Question Answering Network(MQAN)            Fixed Glove+Character n-gram embeddings -&gt; Linear -&gt; Shared BiLSTM with skip connection   Attention summations from one sequence to the other and back again with skip connections   Separate BiLSTMs to reduce dimensionality, two transformer layers, another BiLSTM   Auto-regressive decoder :            Fixed GloVe, character n-gram embeddings       Two transformer layers       LSTM Layers (attend last 3 layers of encoder)                             Training Strategies: Fully Joint        Curriculum learning : 모델 학습시 전체 데이터를 한번에 학습시키지 않고 쉬운것-&gt;어려운 것 순서로 학습함   Batch를 Sampling할 때, Fixed order로 계속 Round Robin하여 수집함   많은 양이 돌아 Converge되는 Task들은 잘 동작하지 않음   Training Strategies: Anti-Curriculum Pre-training         Training Strategies: CoVe      What’s next for NLP?     ","categories": ["NLP"],
        "tags": ["cs224n","nlp"],
        "url": "/nlp/NLP_06/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.2 SEQ 하드웨어 구조     인스트럭션을 구현하는 데 필요한 계산들은 여섯 개의 순차적인 기본 단계로 구성될 수 있다.            선입       해독       실행       메모리       재기록       PC 갱신           SEQ에서는 하드웨어 유닛에 처리되는 모든 일들은 하나의 클럭 사이클 내에서 일어난다.             위 그림은 순차적인 구현인 SEQ의 추상적인 모습이다.            인스트럭션을 실행하는 동안 처리된 정보는 그림의 좌측 하단 구석에 있는 PC를 사용해서 인스트럭션 선입으로 시작해서 시계방향을 따라 진행한다.           하드웨어 유닛들은 여러가지 처리 단계들과 연계되어있다.            선입                    프로그램 카운터 레지스터를 주소로 사용해서 인스트럭션 메모리는 인스트럭션의 바이트들을 읽어들인다.           PC 가산기는 valP, 증가된 프로그램 카운터를 계산한다.                       해독                    레지스터 파일은 두 개의 읽기 포트 A,B를 가지고 있다.           이를 통해서 레지스터 값 valA, valB를 동시에 읽어들일 수 있다.                       실행                    인스트럭션의 종류에 따라 여러 가지 목적을 위해 산술/유닛 유닛(ALU)을 사용한다.           조건코드 레지스터(CC)는 세 개의 조건코드 비트를 저장한다. 목적지 레지스터를 갱신할지 여부를 결정하는 조건코드와 이동 조건에 의해 계산된다.                       메모리                    메모리 인스트럭션을 실행할 때 메모리 워드를 읽거나 쓴다.           인스트럭션과 데이터 메모리는 같은 메모리 위치에 접근하지만, 목적은 서로 다르다.                       재기록                    레지스터 파일은 두 개의 쓰기 포트를 가지고 있다.           E 포트는 ALU가 계산한 값을 기록하기 위해 사용된다.           M 포트는 데이터 메모리에서 읽어온 값을 기록할 때 사용한다.                       PC 갱신                    프로그램 카운터의 새로운 값은 다음 인스트럭션의 주소 valP, call이나 점프 인스트럭션에 의해 지정된 목적지 주소, 또는 메모리에서 읽어온 리턴주소 valM 중에서 선택된다.                                위 그림은 SEQ, 순차적 구현의 하드웨어 구조이다.           위 표는 순차적 구현에서 여러가지 계산 단계 식별 표이다.            두번째 열은 SEQ의 단계에서 계산되는 값 또는 수행되는 연산을 나타낸다.           4.3.3 SEQ 타이밍      SEQ는 조합논리회로와 두 가지 형태의 메모리 장치로 이루어진다.            레지스터(프로그램 카운터와 조건코드 레지스터)       랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)           조합논리회로는 순차처리나 제어를 필요로 하지 않는다.            입력이 바뀔 때마다 논리 게이트의 네트워크를 통해 값들이 전파된다.           랜덤 액세스 메모리를 읽는 것은 출력 워드가 주소 입력에 따라 생성되는 방식으로 조합논리회로와 매우 유사하게 동작한다.   순차실행을 위해 명시적인 제어를 필요로 하는 네 개의 하드웨어 유닛            프로그램 카운터, 조건코드 레지스터, 데이터 메모리, 레지스터 파일       이들은 새로운 값을 레지스터에 로딩하는 것과 값들을 랜덤 액세스 메모리에 기록하는 작업을 만드는 한 개의 클럭 신호를 통해서 제어된다.       프로그램 카운터 : 매 클럭 사이클마다 새로운 인스트럭션 주소를 적재한다.       조건코드 레지스터 : 정수연산 인스트럭션이 실행될 때에만 값이 적재된다.       데이터 메모리 : rmmovq, pushq, call 인스트럭션이 실행될 때에만 값이 기록된다.       레지스터 파일 : 두 개의 쓰기 포트를 통해서 두 개의 프로그램 레지스터가 매 사이클마다 갱신될 수 있다.           위와 같이 레지스터들과 메모리에 클럭을 공급하는 것은 프로세서에서 여러 동작들을 순서대로 제어하기 위해 필요한 모든 거싱다.   프로세서는 인스트럭션의 처리를 완료하기 위해 어떤 인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 절대 없다.           위 그림은 SEQ의 두 실행 사이클 추적이다.            각 사이클은 이전 인스트럭션에 의해 설정된 상태 원소들(프로그램 카운터, 조건코드 레지스터, 레지스터 파일, 데이터 메모리)을 가지고 시작된다.       신호들은 이 상태 원소들을 위한 새로운 값을 만들면서 조합회로를 지나면서 전파된다.       이 값들은 다음 사이클을 시작하기 위해 상태 원소들에 적재된다.           상태 원소들의 갱신을 제어하기 위해서 조합회로를 통한 값들의 전파와 함께 클럭을 사용하면 SEQ에서 각 인스트럭션을 위해 수행한 계산들을 충분히 제어할 수 있다.   클럭이 low에서 high로 전환이 이루어지는 매 시점마다 프로세서는 새 인스트럭션의 실행을 시작한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_15/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.3 순차적sequential Y86-64 구현      SEQ : sequential 프로세서를 의미   매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.   SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.   4.3.4 SEQ 단계의 구현      SEQ를 구현하는 데 필요한 제어로직 블록을 위한 HCL작성방법을 설명한다.   여러가지 인스트럭션 코드, 함수코드, 레지스트 이름, ALU 연산, 상태코드 등을 위한 상수 값뿐만 아니라 여러가지 하드웨어 신호의 이름이 포함된다.             위의 표는 HCL 문장에 사용된 상수 값들이다.   선입 단계        선입 단계는 인스트럭션 메모리 하드웨어 유닛을 포함한다.   유닛은 PC를 첫 바이트(0번 바이트)의 주소로 사용해서 메모리로부터 한 번에 10바이트를 읽어들인다.   이 바이트는 인스트럭션 바이트로 해석되고, 두 개의 4비트 값으로 나누어진다.(“Split”이라고 표시된 유닛에 의해 icode와 ifun으로 나뉜다.)   icode 값에 따라 세 개의 1비트 신호를 계산할 수 있다.            instr_valid: 이 신호는 부정 인스트럭션을 검출하기 위해 사용된다.       need_regids: 레지스터 지정 바이트를 포함하는가       need_valC: 상수 워드를 포함하는가           instr_valid, imem_error 신호(인스트럭션 주소가 범위를 벗어날 때 만들어지는)는 메모리 단계에서 상태코드를 만들기 위해 사용된다.   need_regids를 위한 HCL 표현은 icode 값이 레지스터 지정자 바이트를 갖는 인스트럭션인지를 결정한다.     bool need_regids =           icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,                      IIRMOVQ, IRMMOVQ, IMRMOVQ };     인스트럭션 메모리에서 읽은 나머지 바이트는 레지스터 지정자와 상수 워드들이다.            Align 이라고 이름 붙인 하드웨어 유닛이 레지스터 필드들과 상수 워드에 대해 처리작업을 수행한다.       계산된 need_regids가 1이면, 레지스터 지정자 rA와 rB로 나누어진다.       상수 워드 valC도 만든다.           PC 증가 하드웨어 유닛은 현재의 PC 값, need_regids, need_ValC에 따라 valP를 만든다. (p+1+r+8i)   해동과 재기록 단계        SEQ에서 해독과 재기록 단계 모두를 구현하는 로직의 상세한 모습을 보여준다.            해동과 재기록 단계 모두 레지스터 파일에 접근하기 때문이다.           레지스터 파일은 네 개의 포트를 가지고 있다.            두 개의 동시 읽기(포트 A와 B), 두 개의 동시 쓰기(포트 E와 M)           각 포트는 한 개의 주소 연결과 데이터 연결을 모두 갖는다.            주소 연결은 레지스터 ID, 데이터 연결은 레지스터 파일의 출력 워드 이거나 입력워드로 사용           두 개의 읽기 포트는 주소 입력 srcA와 srcB를 가진다.   두 개의 쓰기 포트는 dstE와 dstM을 주소 입력으로 갖느다.   네 개의 블록은 인스트럭션 코드 icode, 레지스터 지정자 rA, rB, 실행 단계에서 계산된 조건신호 Cnd에 기초하여 네 개의 레지스터 ID를 만들어 낸다.   레지스터 ID dstE는 쓰기 포트 E를 위한 목적지 레지스터를 나타내며 계싼된 valE가 저장된다.   실행 단계       실행 단계는 산술/논리 유닛(ALU)을 포함한다.   이 유닛은 ADD, SUBTRACT, AND, EXCLUSIVE-OR를 입력 aluA, aluB에 alufun 신호의 설정에 따라 실행한다.   ALU가 대부분의 경우에 덧셈기로 사용된다.            OPq 인스트럭션에 대해서는 인스트럭션의 ifun 필드에 인코딩된 연산을 사용해야 한다.           실행 단계는 조건코드 레지스터를 포함한다.            조건코드 레지스터가 갱신되어야 할지 여부는 제어하는 set_cc 신호를 생성한다.           “cond”로 명명된 하드웨어 유닛은 조건부 분기나 데이터 이동이 일어나야 할지를 결정하기 위한 조건코드들과 함수코드의 조합을 사용한다.   메모리 단계       메모리 단계는 프로그램 데이터를 읽거나 쓰는 일을 수행한다.   두 개의 제어 블록이 메모리주소와 메모리 입력 데이터(쓰기 연산을 위한)를 위한 값을 만들어낸다.   메모리 단계에서 마지막 기능은 icode, imem_error, 선입 단계에서 만들어진 instr_valid, 데이터 메모리에서 만든 dmem_error 신호에 따라 인스트럭션 실행에서 결정되는 상태코드 Stat을 계산하는 것이다.   PC 갱신 단계       SEQ의 최종 단계는 새로운 프로그램 카운터 값을 생성하는 것이다.   새로운 PC 값은 인스트럭션 타입과 분기를 택할지 여부에 따라 valC, valM, valP가 될 수 있다.   SEQ 현황 조사     여러 인스트럭션을 통일된 흐름으로 실행하기 위해 필요한 단계를 구성하면서 프로세서 전체를 적은 수의 여러 하드웨어 유닛들과 계산을 순서화하기 위한 한 개이의 클럭으로 구현할 수 있다.   SEQ에서 유일한 문제는 매우 느리다.            그 이유는 각 유닛들이 전체 클럭 사이클의 일부 동안만 사용되기 때문이다.       그렇기 때문에 파이프라인을 사용해서 보다 좋은 성능을 얻을 수 있다.              프로세서의 구조를 자세히 살펴보았는데, 굉장히 이해하기 어려운 부분이 많았다. 이번 챕터는 자주 보고 다른 자료도 더 찾아봐야겠다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_16/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.4 파이프라이닝의 일반 원리     파이프라인 시스템의 일반적인 특징과 원리들을 생각해보자.            파이프라인 시스템에서 수행해야 할 일은 여러 개의 일련의 단계뜰로 나누어진다.       식당의 예를들면, 샐러드를 먼저 제공하고, 메인 음식, 디저트 그리고 음료의 순으로 제공하는 것과 비슷하다.       컨베이어 벨트와 비슷하게 여러 고객이 동시에 시스템을 진행하도록 한다.       비록 어떤 사람은 일부 음식만을 원할지라도 모든 단계를 통과해 간다.           파이프라이닝의 주요 특징            시스템 처리량(단위시간당 처리하는 고객의 수)을 증가시킨다.       지연시간(고객을 지원하는 데 걸리는 시간)을 증가시킨다.           4.4.1 계산용 파이프라인     위의 식당의 예를 계산용 파이프라인으로 초점을 옮기면            “고객들”은 인스트럭션       단계들은 인스트럭션 실행의 일부분을 수행한다.                   위의 그림은 간단한 비파이프라인 하드웨어 시스템의 예이다.            계산을 수행하는 일부 로직으로 이루어진다.       계산 결과를 저장하는 레지스터가 따라온다.       클럭 신호는 규칙적인 시간간격으로 레지스터에 로딩되는 것을 제어한다.           이 예제에서는 조합로직은 300ps를 필요로하고 레지스터 로딩은 20ps를 필요로 한다.            이 시스템에서 처리량은 1/320 * 1,000 = 3.12       이 시스템에서 지연시간은 320ps                   위 그림은 3단계 파이프라인 계산 하드웨어이다.            시스템에서 수행하는 계산을 세 단계 A,B,C로 나눌 수 있다고 가정한다.       파이프라인 레지스터들을 단계 사이에 배치해서 각 인스트럭션이 3단계로 시스템을 통해 이동한다.       시작부토 종료할 때까지 세 개의 클럭 사이클이 소요된다.           이 예제에서는 클럭을 매 100+20=120ps이고 한 개의 인스트럭션을 처리하는 데 3클럭 사이클이 필요하다.            이 시스템에서 처리량은 1/120 * 1,000 = 8.33       이 시스템에서 지연시간은 360ps           비파이프라인 보다 처리량은 빠르지만 지연시간이 증가한 이유는 추가된 파이프라인 레지스터에 의한 오버헤드 때문이다.   4.4.2 파이프라인 연산의 상세한 고찰     파이프라인 단계들 간에 인스트럭션의 이동은 위의 파이프라인 다이어그램에 나타낸 것과 같이 클럭 신호에 의해 제어된다.           위 그림은 한 사이클 동안의 파이프라인 동작이다.            신호들은 파이프라인 레지스터 입력들로 전달되지만, 클럭이 상승할 때까지 레지스터의 상태는 바뀌지 않는다.       클럭을 늦추는 것이 파이프라인의 동작을 변화시키지 않는다는 것을 알 수 있다.           4.4.3 파이프라이닝의 한계     파이프라인의 효과를 축소시키는 여러 요소들이 종종 발생한다.   비균일 분리 Nonuniform Partitioning       위의 그림은 계산을 이전처럼 세 단계로 나눈 시스템이지만 각 단계에서 발생하는 지연시간은 50에서 150 ps까지 변화한다.   우리가 구동할 수 있는 클럭의 속도는 가장 늦은 단계의 시간지연 값에 의해 결정된다.   실제 시스템 설계에서는 타이밍을 최적화하는 것이 중요하다.   줄어드는 깊은 파이프라이닝의 효과       위의 그림은 계산을 여섯 단계로 나누었고, 각각은 50ps를 소모한다.   이 시스템의 클럭 주기는 50+20=70ps, 처리량은 14.29, 지연시간은 480이다.   각 계산 블록에서 소요되는 시간을 2분의 1로 줄였지만 파이프라인 레지스터를 통과하는 시간지연으로 인해 처리량은 두 배를 얻지 못했다.   이 지연시간은 파이프라인의 처리량에 있어서 제한요소가 된다.   최신 프로세서들은 프로세서의 클럭속도를 최대로 올리기 위해 매우 깊은(15단계 이상) 파이프라인을 사용한다.   4.4.4 피드백을 갖는 파이프라인 시스템     기계어 프로그램을 실행하는 시스템에서는 연속적인 인스트럭션들 간에는 잠재적인 의존성이 있다.        예를들어 위의 코드 배열은 각각의 연속되는 인스트럭션들 간에 원으로 표시한 레지스터 이름에 데이터 의존성이 존재한다.           위의 그림은 피드백을 갖는 시스템에 파이프라인을 추가할 때의 위험을 보여준다.            피드백이 있는 파이프라인을 사용하지 않는 시스템(a)에서 파이프라인 시스템(c)으로 전환하기 위해서 두 파이프라인 다이어그램에서 보는 바와 같이 계산적인 동작을 변경한다(b와d)           ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_17/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.3 순차적sequential Y86-64 구현   4.4 파이프라이닝의 일반 원리   4.5 파이프라인형 Y86-64의 구현   4.5 파이프라인형 Y86-64의 구현     순차적 프로세서 SEQ를 약간 변형해서 PC의 계산을 선입 단계로 이동하는 것으로 프로세서를 변경한다.   이후 파이프라인 레지스터들을 단계별로 추가한다.      결국은 이 파이프라인형 Y86-64 “PIPE”를 만들기 위해 2장부터 4장까지 달려온 것이다.  우선 컴퓨터가 해석할 수 있는 정수와 부동소수점 표현과 기본 산술에 대해서 2장에서 배웠고,  3장에서는 프로그래머가 작성한 코드를 컴퓨터가가 해석할 수 있는 기계어로 변경하는 것을 배웠고,  4장 초반에서는 해당 기계어를 컴퓨터가 해석할 수 있도록 인스트럭션 집합으로 변경하는 것을 배웠고,  4장 후반 SEQ 구현에서는 해당 인스트럭션을 컴퓨터가 어떻게 해석하는지를 배웠고,  4장 후반 파이프라인 구현에서는 인스트럭션을 해석하는데에 있어 속도를 증가시키기 위해서 SEQ에 파이프라인을 구축하고, 파이프라인 구축할 때의 예외처리를 다룬 뒤 프로세서를 완성시킨다.    4.5.1 SEQ+: 계산 단계들을 재배치하기     PC 갱신 단계가 클럭 사이클의 마지막이 아니라 맨 처음에 오도록 한다.            파이프라인 단계에서의 순차적인 동작을 더 잘 수행할 수 있다.       수정된 설계를 “SEQ+”라고 부른다.                   위의 그림은 PC 계산 타이밍의 변경이다.            SEQ+에서 인스트럭션 실행의 첫 단계로 현재 상태에 대한 프로그램 카운터 값을 계산한다.           4.5.2 파이프라인 레지스터의 삽입     SEQ+의 단계들간에 파이프라인 레지스터들을 삽입하였으며 신호들을 재배치해서 PIPE- 프로세서를 만들었다.   파이프라인 레지스터들은 다음과 같이 명명하였다            F : 프로그램 카운터의 예측 값을 저장한다.       D : 선입과 해동 단계 사이에 위치한다. 해독 단계가 처리하기 위해서 가장 최근에 선입한 인스트럭션에 관한 정보를 저장한다.       E : 해독과 실행 단계 사이에 위치한다. 실행 단계가 처리하기 위해서 레지스터 파일로부터 읽어들인 값과 가장 최근에 해독한 인스트럭션에 관한 정보를 저장한다.       M : 실행과 메모리 단계 사이에 위치한다. 메모리 단계가 처리하기 위한 가장 최근에 실행 인스트럭션 결과와 조건부에 관한 정보를 저장한다.       W : 레지스터 파일에 기록을 위한 결과, 리턴주소, PC 선택 로직을 저장한다.                   위의 그림은 SEQ+ 하드웨어 구조           위의 그림은 PIPE- 의 하드웨어 구조, 초기 파이프라인 구현           위의 그림은 코드 배열이 어떻게 5단계 파이프라인을 통해 흘러가는지를 보여준다.   4.5.3 신호의 재배치와 재명명     SEQ에서는 한 번에 한 개의 인스트럭션만을 처리했지만, 파이프라인 설계에서는 인스트럭션에 연계된 여러 버전의 값이 존재한다.   PIPE-의 상세 설계에서 네 개의 서로 다른 인스트럭션을 위한 상태코드를 저장하는 “Stat”이 있다.   파이프라인 레지스터의 이름은 대문자를 사용한다. D_stat, E_stat, M_stat, W_stat   계산된 일부 신호의 이름은 소문자를 사용한다 f_stat, m_stat   전체 프로세서의 실제 상태 Stat이 파이프라인 레지스터 W에 기록된 상태값에 따라 재기록 단계에서 계산된다.   일반적인 원칙으로 특정 인스트럭션에 관한 모든 정보를 한 개의 파이프라인 단계 내에 유지하는 것을 원한다.   4.5.4 다음 PC 값의 추정     파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이며, 새 인스트럭션이 실행 단계로 진행해서 궁극적으로는 완료되는 것을 의미한다.   리턴이나 조건부 점프 인스트럭션은 선입 단계에 계산된 정보를 사용해서 다음 인스트럭션의 주소를 결정할 수 없다.   따라서 매 클럭 사이클마다 하나의 새 인스트럭션을 실행하려는 우리의 목표를 달성하기 위해서 대부분의 경우에 PC의 새로운 값을 예측해야 한다.            이부분이 처음에 조금 이해가 안됐지만, 파이프라인 해저드를 공부하고 이해가 됐다. 해저드를 통해 이러한 분기예측을 제어한다.            분기의 방향을 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술을 분기예측branch prediction 이라고 한다.   4.5.5 파이프라인 해저드     피드백이 있는 시스템에 파이프라인을 도입하면 연속되는 인스트럭션들 간에 의존성이 존재할 때 문제가 발생할 수 있다.   의존성은 두 가지 형태를 띈다.            데이터 의존성: 한개의 인스트럭션이 계산한 결과가 다음에 오는 인스트럭션을 위한 데이터로 사용되는 경우       제어 의존성: jump, call, ret와 같이 한 개의 인스트럭션이 다음에 따라오는 인스트럭션의 위치를 결정하는 경우           의존성들이 파이프라인으로 인해 잘못된 계산을 야기할 가능서이 있을 때 해저드라고 부른다.   해저드 또한 데이터 해저드, 제어 해저드로 구분할 수 있다.       특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러X)     특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러O)     스톨을 사용한 데이터 해저드의 회피             해저드를 회피하는 매우 일반적인 기술은 프로세서가 하나 또는 여러 인스트럭션을 해저드 조건이 사라질 때까지 파이프라인 내에 유지하는 스톨과 관련된다.   해독 단계에서 인스트럭션을 소스 오퍼랜드를 생성하는 인스트럭션들이 재기록 단계를 통과할 때까지 스톨시키는 방법으로 데이터 해저드를 회피할 수 있다.   스톨링은 한 그룹의 인스트럭션들을 이들의 단계에 붙잡아두지만, 다른 인스트럭션들은 파이프라인을 계속 흘러가도록 한다.   인스트럭션을 해독단계에 붙잡아 놓을 때마다 실행 단계에 버블을 삽입하는 방식으로 처리한다.   버블은 동적으로 생성된 nop 인스트럭션과 비슷하다.   포워딩Forwarding을 이용한 데이터 해저드의 회피             재기록 단계에서 이들 소스 레지스터 중의 하나에 대기하고 있는 쓰기 작업이 존재할 수 있다.   쓰기 작업이 완료될 때까지 스톨하기보다는 소스 오퍼랜드로 파이프라인 레지스터 E에 기록될 값을 단순히 전달할 수 있다.   데이터 포워딩은 메모리 단계에서 대기하고 있는 레지스터 쓰기 작업이 있을 때에도 사용될 수 있다.   위 그림은 해독 단계 로직이 레지스터 파일에서 온 값을 사용할지, 포워딩된 값을 사용할지 여부를 어떻게 결정할 수 있는지 보여준다.            레지스터 파일에 재기록되는 모든 값과 관련된 것은 목적지 레지스터 ID이다.       이 로직은 이 ID들을 소스 레지스터 ID인 srcA, srcB와 비교해서 포워딩을 위한 경우를 검출할 수 있다.           다섯개의 포워딩 소스가 해독 단계에 “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.   로드/사용 데이터 해저드          메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 데이터 해저드는 순수하게 포워딩만 가지고는 처리할 수 없다.   해당 경우는 스톨링과 포워딩을 함께 사용해서 로드/사용 데이터 해저드를 회피할 수 있다.   로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것을 로드 인터록load interlock이라고 부른다.   포워딩과 결합된 로드 인터록은 가능한 모든 형태의 데이터 해저드를 충분히 처리할 수 있다.   제어 해저드의 회피     제어 해저드는 프로세서가 선입 단계에서 현재 인스트럭션에 기초하여 다음 인스트럭션의 주소를 안정적으로 결정할 수 없을 때 발생한다.   제어 해저드는 ret와 점프 인스트럭션에 대해서만 발생할 수 있다.          위의 그림은 ret 인스트럭션 처리과정이다.            파이프라인은 ret가 해독, 실행, 메모리 단계를 통과하며 세개의 버블을 삽입하는 동안 스톨해야한다.       PC 선택 로직은 ret가 재기록 단계에 도착하면(사이클 7) 인스트럭션 선입 주소로 리턴주소를 선택하게 된다.                  위의 그림은 잘못 예측한 분기 인스트럭션의 처리이다.            파이프라인은 분기를 할 것이라고 예측하고, 따라서 점프 목적지에서 인스트럭션 선입을 시작한다.       점프 인스트럭션이 실행 단계를 통해 흘러갈 때 두 인스트럭션은 사이클 4에서 예측오류가 검출되기 전에 선입된다.       사이클 5에서 파이프라인은 해독과 실행단계에 버블을 삽입해서 두 목적지 인스트럭션을 취소하고, 점프 다음에 오는 인스트럭션을 선입한다.                 간단히 두 개의 잘못 선입한 인스트럭션을 취소할 수 있다.            인스트럭션 스쿼싱squashing이라고 불린다.           programmers-visible state에는 아무런 영향을 주지 않지만 단점은 두 클럭 사이클 만큼의 인스트럭션 처리 능력이 낭비된다는 점이다.   스톨링과 파이프라인에 버블을 삽입하는 기술들은 특수한 상황이 발생할 때 파이프라인의 흐름을 동적으로 조절한다.   4.5.6 예외처리     프로세서의 다양한 동작은 예외적인 제어흐름을 발생시키며, 이 경우 정상적인 프로그램 실행의 연결은 끊어진다.   예외들은 프로그램 실행에 의해 내부적으로 발생하거나 외부 신호에 의해 외부적으로 생성될 수 있다.   세 가지 서로 다른 내부 생성 예외            halt 인스트럭션에 의한 예외       인스트럭션과 함수코드의 잘못된 조합을 갖는 인스트럭션       인스트럭션 선입 또는 데이터 읽기나 쓰기를 위해 유효하지 않은 주소에 접근하려 하는 경우           프로세서가 예외를 만나면 정지하고 적절한 생태코드를 설정한다.   프로세서는 운영체제의 일부인 예외핸들러라는 프로시저를 계속 호출한다.   파이프라인과 예외처리     파이프라인을 사용한 시스템에서 예외처리는 여러 가지 미묘한 부분들이 관계되어 있다.      예외상황이 다수의 인스트럭션들에 의해 동시에 발생할 수 있다.            기본 규칙은 파이프라인에서 가장 멀리 있는 인스트럭션이 유발한 예외상황에 우선순위를 둔다.           어떤 인스트럭션이 선입되고, 실행을 시작해서 예외를 발생시키고, 나중에 잘못 예측한 분기명령으로 인해 취소할 때 발생한다.            파이프라인 제어로직은 인스트럭션을 취소한다.           파이프라인 프로세서가 서로 다른 단계에서 시스템 상태의 서로 다른 부분을 갱신하기 때문에 발생한다.         파이프라인 제어로직은 메모리나 재기록 단계의 인스트럭션이 예외를 발생시켰을 때 데이터 메모리나 조건코드 레지스터를 갱신하는 것을 김지한다.   파이프라인의 하나 이상의 단계에서 예외가 발생할 때 정보는 단순히 파이프라인 레지스터의 상태 필드에 저장된다.   4.5.7 PIPE 단계의 구현     파이프라인 레지스터, 재구성 가능한 로직 블록, 추가적인 파이프라인 제어로직을 추가하고, 이전의 순차적 설계 같은 하드웨어 유닛들을 사용한다.   PC 선택과 선입 단계        프로그램 카운터의 현재 값을 선택해야하며, 다음 PC 값을 예측해야 한다.   메모리에서 인스트럭션을 읽고 여러 가지 인스트럭션 필드들을 추출하기 위한 하드웨어 유닛들은 SEQ를 위해 고려한 것과 동일하다.   하나의 사이클 시간의 범위 내에 프로세서는 다음 인스트럭션의 주소를 예측만 할 수 있다.   해독 및 재기록 단계       valP와 레지스터 포트 A로부터 읽은 값을 동시에 요구하는 인스트럭션은 없으며 따라서 이들은 다음 단계를 위한 신호 valA를 구성하기 위해 통합할 수 있따.            “Sel+FwdA” 블록이 해당 일을 수행하고 valA를 위한 포워딩 로직을 구현한다.       “FwdB” 블록은 소스 오퍼랜드 valB를 위한 포워딩 로직을 구현한다.           레지스터 쓰기 위치는 해독 단계보다는 재기록 단계에서 가져온 dstE와 dstM으로 나타낸다.            해독 단계가 현재 재기록 단계에 있는 인스트럭션의 결과를 기록하고 있기 때문이다.                    위 HCL 코드에서 다섯 개의 포워딩 소스에 주어진 우선순위는 매우 종요하다.   우선순위는 HCL코드에서 다섯 개의 목적지 레지스터 ID가 시험되는 순서에 의해 결정된다.   실행 단계       PIPE 실행 단계 로직이다. 이 부분의 설계는 SEQ의 로직과 매우 유사하다.   메모리 단계       PIPE 메모리 단계 로직이다.            파이프라인 레지스터 M, W의 많은 신호들이 앞 단계들로 전달되어 재기록한 결과, 인스트럭션 주소, 포워드된 값들을 제공한다.           4.5.8 파이프라인 제어로직     데이터 포워딩과 분기예측과 같이 다른 방법들로는 처리할 수 없는 다음과 같은 네 개의 제어 경우를 처리해야 한다.            로드/사용 해저드 : 메모리에서 값을 읽은 인스트럭션과 이 값을 사용하는 인스트럭션 사이에 한 사이클 동안 스톨해야한다.       잘못 예측한 분기 : 예측으로 인해 잘못 선입된 인스트럭션들은 취소되어야 하며, 선입 단계는 점프 인스트럭션 다음의 인스트럭션에서 시작해야한다.       예외 : 어떤 인스트럭션이 예외를 발생시키면 programmer-visible state가 갱신되는 것을 막아야 한다.           특수한 제어 상황들의 바람직한 처리       위의 그림은 ret 인스트럭션의 상세한 처리과정이다.            선입 단계는 ret 인스트럭션 다음의 rrmovq 인스트럭션을 반복적으로 선입하지만, 파이프라인 제어회로는 rrmovq 인스트럭션이 진행하는 것을 허용하는 대신에 해독 단계에 한 개의 버블을 삽입한다.                  위의 그림은 유효하지 않은 메모리 참조 예외의 처리이다.            사이클 6에서 pushq 인스트럭션으로 인한 유효하지 않은 메모리 차몾는 조건코드 갱신을 금지시킨다.       파이프라인은 메모리 단계에 버블을 삽입하기 시작하고 재기록 단계에 있는 예외 인스트럭션을 스톨시킨다.           특수 제어 조건의 감지     ret 인스트럭션이 파이프라인을 통과해 갈 때 검출하려면 해독, 실행, 메모리 단계에 있는 인스트럭션들의 인스트럭션 코드를 단순히 체크하면 된다.   로드/사용 해저드를 검출하려면 실행 단계에 있는 인스트럭션의 종류(mrmovq, popq)를 체크해야 하고, 해독 단계에 있는 인스트럭션의 소스 레지스터들과 목적지 레지스터들을 비교해야 한다.   파이프라인 제어로직은 인스트럭션이 해독 단계에 있는 동안 잘못 예측한 분기를 검출해야 한다.   파이프라인 제어 과정        위의 그림은 파이프라인 레지스터 동작이다.            a. 정상 조건 시 레지스터의 상태와 출력은 클럭이 상승할 때 입력 값으로 설정된다.       b. 스톨 모드에서 동작할 때, 상태는 이전 값으로 고정된다.       c. 버블 모드에서 동작할 때 상태는 연산의 결과로 기록된다.           제어 조건들의 조합        위의 그림은 특수한 제어 조건들에 대한 파이프라인 상태이다.            표시한 두 쌍은 동시에 발생할 수 있다.           제어 로직의 구현        위의 그림은 PIPE 파이프라인 제어로직이다.            이 로직은 프로시저 리턴, 잘못 예측한 분기, 로드/사용 해저드, 프로그램 예외 같은 특수한 조건들을 처리하기 위해서 정상적인 인스트럭션 흐름이 파이프라인을 통과하는 것을 정지시킨다.           4.5.9 성능 분석     인스트럭션마다 걸리는 평균 클럭 사이클 수는 CPIcycles per instruction라는 단위로 추정값을 계산한다.            Ci 인스트르럭션, Cb 버블을 처리한다면, 프로세서는 Ci + Cb개의 클럭 사이클을 필요로한다.       CPI = 1.0 + Cb/Ci 이다.       오직 세개의 인스트럭션 타입만이 버블을 추가하기 때문에                    CPI = 1.0 lr(load penalty) + mp(mispredicted branch penalty) + rp(return penalty)                           4.5.10 남아 있는 작업     다중 사이클 인스트럭션            다중 인스트럭션을 구현하는 한 가지 간단한 방법은 실행 단계 로직의 성능을 정수와 부동 소수점 산술연산 유닛들을 포함하도록 단순히 확장하는 것이다.                    한 개의 인스트럭션이 해독 단계에 들어갈 때 특수 유닛으로 보낸다.(ex. 부동소수점 유닛)                           메모리 시스템과의 인터페이스   4.6 요약      해당 장을 통해 인스트럭션 집합 아키텍처 ISA는 프로세서의 동작과 프로세서가 어떻게 구현되는지 간에 추상화 계층을 제공한다는 것을 알 수 있었다.   ISA는 프로그램 실행을 하나의 인스트럭션이 다음 인스트럭션이 시작되기 전에 실행되어 종료되는 순차적인 프로그램 실행의 모습을 제공한다.   여러 가지 인스트럭션들이 요구하는 처리작업을 5단계로 구성하였으며, 전체 인스트럭션이 다섯 단계를 통해 들어가서 매 클럭 사이클마다 실행된다.   파이프라인은 여러 단계들이 동시에 동작하도록 하여 시스템의 처리량 성능을 개선한다.   예외를 적절히 처리하는 것은 높은 파이프라인 단계와 병렬성을 사용하는 시스템에서 보다 복잡해진다.   교훈            복잡성을 관리하는 것이 최우선순위를 갖는다.                    모든 인스트럭션 타입을 처리하기 위한 매우 간단하고 통일된 프레임워크를 만들어서 구현하였다.                       ISA를 직접 구현할 필요는 없다.                    파이프라인 설계를 사용하였고 파이프라인 해저드를 처리할 수 있었다.                       하드웨어 설계자는 꼼꼼해야 한다.              2장부터 4장이 하드웨어까지의 모든 부분들을 살펴본 것 같다. 4장은 꼭 한번 더 읽어보자.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_18/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 05 프로그램 성능 최적화하기",
        "excerpt":"Chapter 05. 프로그램 성능 최적화하기     프로그램을 작성하는 주목적은 모든 가능한 조건에서 프로그램이 정확하게 동작하도록 하는 것이다.   프로그래머는 명확하고 간결한 코드를 작성해야하고, 이해하기 쉽고, 코드를 검토할 때와 수정할 때 다른사람들도 코드를 읽고 이해할 수 있어야 한다.   효율적인 프로그램을 작성하는 방법            적절한 알고리즘과 자료구조를 선택해야한다.       컴파일러가 효과적으로 최적화해서 효율적인 실행코드로 바꿀 수 있는 소스코드를 작성해야 한다.       작업을 부분으로 나누어 멀티코어와 멀티프로세서의 조합을 갖는 컴퓨터에서 병렬로 계산한다.           프로그래머는 컴파일러를 도와서 쉽게 최적화될 수 있는 코드를 작성해야한다.            불필요한 작업 제거                    불필요한 함수호출 제거           조건 테스트 제거           메모리 참조 제거                       인스트럭션-수준 병렬성을 제공           5.1 최적화 컴파일러의 능력과 한계     컴파일러는 프로그래머의 코드를 자동으로 최적화 해준다.   하지만 특정 코드는 컴파일러가 자동으로 최적화해줄 수 없다.            두 개의 포인터가 같은 메모리 위치를 가리킬 수 있는 경우(메모리 연결memory aliasing)       함수 호출                    ex) 호출되는 횟수에 따라 프로그램의 동작이 변경 되는 경우(부가효과 side effect)                           위 항목들이 ‘최적화 장애물blocker’이 되는데, 이것은 컴파일러가 최적화된 코드를 생성하기 위한 기회를 제한한다.   5.2 프로그램 성능의 표현     CPE : 요소당 측정 사이클metric cycle      5.3 프로그램 예제     코드를 최적화하는 방법은 다음과 같은 방법들이 존재한다.            타깃 머신의 특징을 고려하지 않은 최적화 기법                    루프 비효율성 제거하기           프로시저 호출 줄이기           불필요한 메모리 참조 제거                       최신 프로세서의 인스트럭션 수준 병렬성을 고려한 최적화 기법                    루프풀기           병렬성 높이기           재결합 변환                              최신프로세서의 인스트럭션 수준 병렬성을 고려하기 위해 5.7절에서 최신프로세서에 대해서 조금 다루고 넘어간다.    5.4 루프 비효율성 제거하기     테스트 조건이 루프의 매 실행마다 평가된다.           lower1은 n^2        lower2는 n       겉보기에는 의미 없는 코드가 감춰진 잠재적 비효율성을 갖고 있다.   적은 데이터 셋으로 시험하고 분석되지만, 프로그램이 궁극적으로 배포되면, 프로시저가 백만 개 문자들의 스트리에 적용될 수 있다.            이러한 상황에 안전했던 코드조각이 주요 성능 병목이 되게된다.           경쟁력 있는 프로그래머 역할의 한 부분은 지속적으로 소개되는 그러한 잠재적 비효율성을 피하는것이다   5.5 프로시저 호출 줄이기     프로시저 호출은 오버헤드를 발생시키고 대부분의 프로그램 최적화 작업을 방해할 수 있다.   경계값을 체크하는 것은 배열의 임의로 접근하는 경우를 처리할 때에는 유용할 수 있지만, 특정 경우에는 모든 참조 시도가 유효하다.   예제에서 각 벡터의 원소를 가져오기 위해서 작성된 함수(벡터 경계값 체크 함수)를 매번 호출하는 대신 배열에 직접 접근한다.            결벽주의자들은 이렇게 변환하는 것이 프로그램 모듈성을 심각하게 훼손한다고 말할 수 있다.       실용적인 프로그래머라면 이러한 변환과정이 고성능 결과를 얻기 위해서 필요한 단계라고 주장할 것이다.           5.6 불필요한 메모리 참조의 제거           결과값을 임시로 누적한다.            누적값을 지역변수 acc에 저장하면 매 루프 반복실행마다 메모리에서 가져오고 갱신된 값을 다시 기록할 필요가 없어진다.           5.7 최신 프로세서 이해하기     코드의 성능을 더 개선하기 위해서는 프로세서의 마이크로구조, 즉 프로세서가 인스트럭션을 실행하도록 하는 하부 시스템 설계를 활용하는 최적화 기법을 고려해야한다.   실제 프로세서에서 많은 인스트럭션들이 동시에 처리된다.            이것을 인스트럭션 수준 병렬성이라고 부른다.       두 개의 서로 다른 하위 경계값lower bounds가 프로그램의 최대 성능을 결정한다.                    지연시간 경계값 : 일련의 연산들이 엄격하게 순서를 준수하여 수행되어야 할 때 발생           처리량 경계값: 프로세서의 기능 유닛들의 기본 계산 능력을 결정한다.                           5.7.1 전체적인 동작     최신 프로세서는 인스트럭션이 실행되는 순서가 기계어 수준 프로그램에서의 순서와 일치할 필요가 없다.            무순서 out-of-order라고 한다.                위의 그림은 최신 프로세서의 블록 다이어그램이다.            인스트럭션 제어 유닛(ICU)은 인스트럭션들을 메모리에서 읽고 일련의 기본연산들을 생성하는 역할을 수행한다.       그 이후 실행 유닛(EU)은 연산을 수행하여 분기가 정확히 예측되었는지 여부를 나타낸다.           최신 프로세서들은 ‘분기 예측branch prediction’이라는 기술을 사용한다.   ‘추정 실행speculative execution’이라는 기술을 사용해서 분기가 이동해야 하는 위치에 있는 인스트럭션을 선입하고 해독한다.   Fetch control 블록은 분기예측과 연동해서 어떤 인스트럭션을 선입할지를 결정한다.   추정 실행을 사용해서 연산들이 계산되지만, 확실할 때까지 최종 결과값들은 데이터 메모리나 레지스터에 저장되지 않는다.      결국 최신 프로세서들은 ‘무순서로 연산들을 병렬로 진행한다.’라고 말하는 것 같다. 하지만, 데이터 의존성이 있는 경우에는 병렬로 진행할 수 없기 때문에 지연이 발생하고, 이런 데이터 의존성은 컴파일러가 최적화를 할 수 없다.(다른 코드로 변경시 무조건적으로 무결성하다는 것을 입증할 수 없어서) 그렇기 때문에 우리는 데이터 의존성을 줄일 수 있는 코드를 작성하여 최적화를 한다.    5.7.2 함수유닛의 성능     발급시간 issue time: 두 연산 사이에 소요되는 최소 사이클 수   용량 capacity: 해당 연산을 수행할 수 있는 함수 유닛의 수   지연 latency: 실제 연산을 수행하는 데 걸린 클럭 사이클 수        위의 그림은 인텔 코어 i7의 지연시간과 발급시간 특성이다.   기계수준 코드로부터 데이터흐름 그래프로의 변환          combine4에 대한 내부 루프의 그림            인스트럭션들은 동적으로 하나 또는 두 개의 연산으로 번역된다.       각각은 다른 연산들 또는 레지스터들로부터 값들을 받고 다른 연산과 레지스터를 위한 값들을 생성한다.           루프를 구성하는 코드부분에 대해서 접근하게 되는 레지스터들을 다음의 네 종류로 구분할 수 있다.            읽기전용 Read-only : 데이터 또는 메모리 주소를 계산하기 위한 소스 값들로 사용된다.       쓰기전용 Write-only : 데이터 이동 연산의 목적지로 사용된다.       지역적 Local : 루프 내에서 사용되고 갱신되지만, 한 번의 반복 실행에서 다른 실행으로의 의존성은 없다.                    ex) cmp에 의해 갱신되며 jne 연산에 의해 사용된다.                       루프 Loop : 한 번의 반복실행에서 생성된 값은 다른 실행에서 사용되는 방식으로 소스 값들로 사용되며 루프의 목적지로도 사용된다.           루프 레지스터들 간의 연산들의 연결이 성능을 제한하는 데이터 의존성을 결정한다.        위의 그림은 combine4 연산들을 데이터 흐름 그래프로 추상화하였다.            (b)를 보면 데이터의존성을 확인할 수 있다.           5.8 루프풀기     루프 풀기는 루프의 매 반복실행마다 계산되는 원소의 수를 증가시켜 루프에서의 반복 실행 횟수를 줄이는 방법이다.   루프 풀기는 두가지 측면에서 성능을 개선할 수 있다.            루프 인덱스 계산과 조건부 분기와 같이 프로그램의 결과와는 직접적으로 관련 없는 연산들의 수를 줄인다.       전체 계산의 핵심 경로에 있는 연산의 수를 줄이기 위한 추가적인 코드변환을 할 수 있는 방법들을 적용할 수 있게 된다.           /* default */ for(i=0; i&lt;limit; i+=1){     acc = acc OP data[i] }  /* Combine 2 elements at a time (2X1 루프풀기)*/ for(i=0; i&lt;limit; i+=2){     acc = acc OP data[i] OP data[i+1] }     위 코드와 같이 반복 횟수를 줄인다.            kX1로 가능하다.           5.9 병렬성 높이기     데이터 의존성을 줄이고자 병렬성을 높이는 방법이다.   다수의 누산기 사용   /* default */ for(i=0; i&lt;limit; i+=1){     acc = acc OP data[i] }  /* Combine 2 elements at a time (2X1 루프풀기)*/ for(i=0; i&lt;limit; i+=2){     acc0 = acc0 OP data[i]      acc1 = acc1 OP data[i+1] }     위 코드와 같이 홀수와 짝수를 나누면 데이터 의존성이 사라진다.   재결합 변환   /* default */ acc = (acc OP data[i]) OP data[i+1];  /* reassociation transform (2X1a 루프풀기) */ acc = acc OP ( data[i] OP data[i+1] );  5.11 일부 제한 요인들     최적화중 프로그램의 성능을 제한하는 다른 요소들이 존재한다.   5.11.1 레지스터 넘기기     프로그램이 사용 가능한 레지스터의 수를 넘어가는 병렬성을 가지면, 메모리에 저장하게 되는 레지스터 넘기기 spilling 방법이 사용된다.            이 때 런타임 스택에 공간을 할당하기 때문에 성능이 저하된다.           5.11.2 분기예측과 예측비용     if문보다 삼항연산자가 더 빠르다.            if문은 statement, 삼항연산자는 expression이다.            5.12 메모리 성능의 이해     Load의 성능            반복실행에 대한 로드 연산은 이전 반복실행에 대한 로드 연산이 완료되었을 때까지는 시작할 수 없다.           Store의 성능            store 연산은 레지스터 값을 메모리로 기록한다.       store 연산은 데이터 의존성을 발생시키지 않는다.           load 연산만이 store 연산의 결과에 영향을 받는다.   5.13 실제상황: 성능개선 기술     프로그램 성능의 최적화하는 기본적인 전략들            상위수준 설계 : 적절한 알고리즘과 자료구조를 선택       기본 코딩원칙 : 최적화 장애물 피하기                    함수 호출 제거           계산은 루프 밖으로 이동           불필요한 메모리 참조 제거           중간 값들을 저장하는 임시 변수 사용(데이터 의존성 피하기)           최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)                       하위수준 최적화 : 하드웨어의 성능을 활용할 수 있는 코드 작성                    루프풀기           다중누산기와 재결합 기법 사용           statement보다 expression 사용하기                           마무리     2장부터 4장까지 컴퓨터가 해석할 수 있는 언어들과 해당 언어들을 컴퓨터가 어떻게 해석하는지를 공부했다. 해당 방법들을 통해서 5장에서는 프로그래머들이 어떻게 코드를 작성해야 하는지를 배웠다.  만약 컴퓨터가 코드를 해석하는 방법을 몰랐더라면, 코드 최적화 방법을 공부할 때 정확히 이해할 수 없었을 것이다. 작성한 코드에서 인스트럭션 조합과 기계어가 어떻게 동작하는지를 항상 생각하자.     추가적으로, CSAPP 포스팅 방식을 조금 변경해야할 것 같다. 4장 초반까지는 솔직히 굉장히 어려웠다. “무슨 말을 하는지 이걸 도대체 컴퓨터가 어떻게 해석한다는거지?” 라고 생각하며 의문으로 가득차 거의 모든 내용을 포스팅한 것 같다. 하지만, 4장 후반 SEQ와 파이프라이닝을 공부하고 “아! 이래서 지금까지 이런 내용들을 공부했구나!” 그리고 5장을 공부하면서 뭔가 “득도”를 하게 된 것 같다. 다양한 부분들의 이해가 빨라졌다. 앞으로 챕터를 공부하고 나의 방식으로 녹인 후 포스팅을 하는 것으로 포스팅 방향을 바꿀 것이다.     6장은 드디어 메모리 파트이다. 너무 기대된다!   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_19/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)",
        "excerpt":"Chapter 06. 메모리 계층구조     메모리 시스템은 용량, 비용, 접근시간을 갖는 저장장치들의 계층구조다.            캐시메모리는 CPU 부근에서 비교적 느린 메인메모리에 대한 준비장소       메인메모리는 크고 느린 디스크들에 대한 준비장소       디스크들은 네트워크로 연결된 다른 머신들의 준비장소           메모리의 계층별로 접근 속도가 상이하다.            레지스터가 가장 빠르고, 그 다음은 메인메모리, 그 다음은 디스크이다.           데이터를 계층의 상부에 저장시켜서 CPU가 보다 빨리 접근할 수 있도록 프로그램을 작성해야한다.            이 개념은 지역성locality라고 알려진 컴퓨터 프로그램의 근본특징에 근거를 두고 있다.           6.1 저장장치 기술   6.1.1 랜덤-접근 메모리     랜덤-접근 메모리(RAM)은 두 종류를 가진다.            정적 SRAM : 동적램 DRAM 보다 더 빠르고 훨 씬 비싸다. 캐시메모리로 사용된다.       동적 DRAM : 메인메모리와 그래픽 시스템의 프레임 버퍼로도 사용된다.           정적 SRAM     SRAM은 각 비트를 이중안정bistable 메모리 셀cell에 저장한다.   SRAM은 전원이 공급되는 한 지속성을 갖는다.   리프레시가 필요없다.   DRAM보다 트랜지스터를 더 많이 사용하여 밀도가 낮으며 비싸고 전력을 많이 사용한다.   동적 DRAM     DRAM은 각 비트를 전하로 캐패시터에 저장한다.   리프레시가 필요하다.            메모리 시스템은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식           일반 DRAM       위의 그림은 DRAM 칩의 구조이다.   DRAM 칩 내의 셀들은 d 슈퍼셀들로 나누어지며, 각각은 w DRAM 셀들로 이루어진다.   슈퍼셀 (i,j)의 내용을 읽으려면 메모리 컨트롤러는 행 주소 i를 DRAM에 보내고, 다음에 열 주소 j를 보낸다.        위의 그림은 DRAM 슈퍼셀의 내용을 읽는 과정이다.   메모리 모듈     DRAM 칩은 메인 시스템(머더보드)의 확상슬롯에 꽂을 수 있는 메모리 모듈 형태로 패키징 된다.   DRAM을 여러개 추가하여 바이트를 순서대로 저장한다.   비휘발성 메모리     DRAM과 SRAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.   비휘발성 메모리는 이들의 전원 꺼져도 정보를 유지한다.   Read-only memory : ROM 이라고 부른다.   ROM 디바이스에 저장된 프로그램들은 종종 펌웨어firmware라고 부른다.   메모리에 접근하기     데이터는 ‘버스’라고 하는 공유된 전기회로를 통해서 프로세서와 DRAM메인메모리간에 앞뒤로 교환한다.   CPU와 메모리 간의 매 전송은 버스 트랜잭션bus transaction이라고 부르는 일련의 단계들을 통해 이뤄진다.             위의 그림은 CPU와 메인메모리를 연결하는 버스 구조다.       읽기 트랜잭션(movq A,%rax)            CPU는 주소 A를 시스템 버스에 보낸다. I/O브릿지는 신호를 메모리 버스를 따라 보낸다.       메인메모리는 메모리 버스에서 주소 신호를 감지하고, 메모리 버스로부터 주소를 읽고 DRAM에서 데이터 워드를 선입, 데이터를 메모리 버스에 쓴다.       I/O 브릿지는 신호를 시스템 버스 신호로 변환해서 시스템 버스를 따라 보낸다. CPU는 시스템 버스에서 데이터를 감지하고 %rax에 복사한다.           쓰기 트랜잭션(movq %rax,A)            CPU는 주소를 시스템 버스에 보낸다. 메모리는 메모리 버스에서 주소를 읽고 데이터가 도착하기를 기다린다.       CPU는 %rax에 있는 데이터를 시스템 버스에 복사한다.       메인메모리는 데이터를 메모리 버스에서 읽고 비트들을 저장한다.           6.1.2 디스크 저장장치     디스크는 RAM 메모리의 수천 메가바이트 단위에 비해 수백에서 수천 기가비이트 단위의 엄청난 양의 데이터를 저장하는 대표적인 저장장치다.   디스크 용량            기록밀도: 1인치의 트랙에 집어넣을 수 있는 비트의 수       트랙밀도: 원판 중심에서 반지름의 1인치 길이에 넣을 수 있는 트랙의 수       면적밀도: 기록밀도와 트랙밀도의 곱           디스크의 동작            탐색시간: 섹터의 내용을 읽기위해 헤드를 타깃 섹터를 보유한 트랙 위로 위치시키는 시간       회전 지연시간: 헤드가 트랙 위에 위치하면 타깃 섹터의 첫번째 비트가 헤드 아래로 지나가는 것을 기다리는 시간.(헤드의 위치와 디스크의 회전 속도 모두 관련됨)       전송시간: 하나의 섹터를 전송하는 시간(회전속도와 트랙당 섹터 수에 관련됨)           디스크 접근하기(디스크 섹터 읽기)            CPU는 명령어, 논리블록 번호, 목적지 메모리 주소를 디스크와 관련된 메모리 매핑한 주소에 써주어서 디스크 읽기를 개시한다.       디스크 컨트롤러는 이 섹터를 읽고 메인메모리로 DMA 전송을 수행한다.       DMA 전송이 완료될 때, 디스크 컨트롤러는 CPU에 인터럽트로 알려준다.           6.2 지역성     잘 작성한 컴퓨터 프로그램은 좋은 지역성locality를 보여준다.            최근에 참조했던 데이터 아이템 근처의 데이터 아이템이나 최근에 자신을 참조했던 데이터 아이템을 참조하려는 경향이 있다.           지역성은 두가지 형태가 있다.            시간 지역성 : 한번 참조된 메모리 위치는 여러 번 참조될 가능성이 높다.       공간 지역성 : 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.           캐시 메모리 : 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장            캐시 메모리라는 작고 빠른 메모리를 도입하여 메인메모리를 빠르게 돌릴 수 있게 됐다.           6.2.1 프로그램 데이터 참조의 지역성   int i, j, sum=0; for(i=0; i&lt;M; i++){   for(j=0; j&lt;N; j++){     sum += a[i][j];   } }     위의 코드는 좋은 지역성을 갖는다.            행 우선 순서로 접근되기 때문이다.           int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];   } }     위의 코드는 나쁜 지역성을 갖는다.   int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];   } }  int i, j, sum=0; for(i=0; j&lt;M; i++){   for(j=0; i&lt;N; j++){     sum += a[i][j];     sum1 += b[i][j];   } }     위의 코드도 썩 좋은 지역성을 갖고 있지는 않다.            보폭이 존재하기 때문           6.2.2 지역성 요약     동일한 변수들을 반복적으로 참조하는 프로그램은 좋은 시간 지역성   Stride-k참조 패턴에서 stride가 적으면 적을수록 공간 지역성도 좋아진다.   루프는 인스트럭션 선입에 대해 좋은 시간 및 공간 지역성을 갖는다.   6.3 메모리 계층구조     아래 두가지를 보완하기 위해 ‘메모리 계층구조’라고 알려진 메모리 시스템 조직을 위한 접근 방법을 사용한다.            저장장치 기술 : 다양한 저장장치 기술들은 매우 광범위한 접근시간을 갖는다.       컴퓨터 소프트웨어 : 잘 작성한 프로그램들은 좋은 지역성을 나타내는 경향이 있다.                위의 그림은 메모리 계층구조이다.   6.3.1 메모리 계층구조에서의 캐시     캐시는 보다 크고 느린 디바이스에 저장된 데이터 객체를 위한 준비 영역으로 사용하는 작고 빠른 저장장치다.   메모리 계층구조의 중심 개념은, 레벨 k에 있는 보다 빠르고 더 작은 장치가 레벨 k+1을 위한 캐시 서비스를 제공한다는 것이다.        위의 그림은 메모리 계층구조에서 캐싱의 기본 원리이다.   캐시 적중     레벨 k+1로부터 특정 데이터 객체 d를 필요로 한다.   현재 레벨 k에 저장된 블록들 중의 하나에서 d를 찾는다.   만일 d가 레벨 k에서 우연히 캐시되어 있다.   캐시 미스     만일 d가 레벨 k에서 캐시되지 않는다면 ‘캐시 미스’가 발생한 것이다.   k+1에 있는 캐시로부터 d를 포함하는 블록을 가져온다.   만일 레벨 k 캐시가 이미 꽉 찬 상태full라면 기존 블록에 덮어쓴다.            축출 : 기존 블록을 덮어쓰는 과정       희생블록 : 축출되는 블록       교체정책 : 어떤 블록을 교체할지에 관한 결정           캐시 미스 종류     cold cache : 캐시가 비어있을 때   충돌미스conflict miss : 캐시의 배치 정책으로 인한 캐시 미스   캐시 관리     메모리 계층 구조의 핵심은 각 레벨에 있는 저장장치가 다음 낮은 레벨을 위한 캐시   레벨 L1,L2,L3의 캐시들은 캐시에 구현된 하드웨어 로직으로 전적으로 관리된다.   가상모메리를 사용하는 시스템에서 DRAM메인메모리는디스크에 저장된 데이터 블록에 대한 캐시 서비스를 제공한다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_20/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 06 메모리 계층구조(캐시)",
        "excerpt":"Chapter 06 메모리 계층구조     저장장치 기술   지역성   메모리 계층구조   캐시메모리   캐시 친화적 코드 작성하기   프로그램 성능에 대한 캐시의 영향   요약   6.4 캐시 메모리     CPU와 메인메모리 사이의 성능 격차가 커짐에 따라 L1 캐시 및 L2 캐시를 삽입하였다.   캐시는 SRAM이다.        위의 그림은 캐시 메모리를 위한 일반적인 버스 구조이다.   6.4.1 기본 캐시 메모리 구조     캐시의 구성은 순서쌍 S,E,B,m 으로 규정할 수 있다.            S : 2^s개의 캐시 집합       E : 집합에 포함되는 캐시 라인       B : 2^b 바이트의 데이터 블록       m : M = 2^m 개의 교유의 주소를 구성하는 m비트       C : 모든 블록의 크기 SEB           캐시는 요청된 워드를 간단히 주소비트만 조사해서 찾아ㅓ낼 수 있도록 구성되어있다.            해당 방식은 해시 함수를 사용하는 해시 테이블과 유사하다.                위의 그림은 캐시의 일반적인 구조이다.   6.4.2 캐시 종류     직접매핑 캐시            집합당 정확히 한개의 라인을 갖는 경우           집합결합성 캐시            집합당 k개의 라인을 갖는 경우           완전결합성 캐시            모든 캐시 라인들을 갖는 하나의 집합으로 구성된 경우           6.4.3 캐시 동작 방법     캐시의 동작 방법은 세 단계로 이루어진다.            집합 선택       라인 매칭       워드 추출                  위와 같은 방법으로 캐시가 어떤 요청이 적중인지 미스인지 결정하고, 요청한 워드를 뽑아내기 위해 작업을 수행한다.              집합 선택            s개의 집합 인덱스 비트를 w의 주소 중에서 뽑아낸다.           라인 매칭            워드 w의 사본이 집합 i에 포함된 캐시 라인에 들어 있는지 결정한다.       유효비트 valid가 1이고, 태그비트들이 일치해야한다. -&gt; 캐시 적중           워드 선택            캐시 적중이 발생하면 원하는 워드가 블록 내 어디에서 시작하는지 결정한다.                        위의 그림은 집합 선택과 라인 매칭 그리고 워드 선택이다.(직접매핑 캐시)       Thrashing : 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는 경우            해결 방법 : 예를들어 x배열, y배열에서 쓰레싱이 일어나면 x배열에 패딩을 주어 x[i]와 y[i]가 서로 다른 집합에 매핑되도록 한다.           인덱스를 중간 비트로 사용하는 이유            연속적인 메모리 블록들은 동일한 캐시 집합으로 매핑된다. -&gt; 어떠한 특정 순간에 한 개의 블록 크기의 배열 묶음만을 저장하게 되며 캐시를 비효율적으로 사용하게 된다.                     위의 그림은 중간 비트로 캐시 인덱스를 사용하는 이유다.       집합결합성 캐시에서의 동작 방법            직접매핑 캐시와 동작이 비슷하지만,       라인 매칭에서 캐시 내 태그와 주소의 태그가 일치하는 라인을 찾기위해 탐색을 한다.       캐시에서 미스 발생시 : LFU(최소 빈도 사용), LRU(최소 최근 사용) 정책 활용           완전결합성 캐시            집합결합성 캐시와 동작이 비슷하지만,       많은 수의 태그를 병렬로 검색해야 한다.           6.4.4 쓰기와 관련된 이슈     Write-through: 즉시 w의 캐시 블록 전체를 다음 하위 레벨로 써준다.            버스 트래픽을 발생시키는 단점이 있다.           Write-back : 갱신을 지연시켜 이 블록이 블록 교체 알고리즘에 의해 캐시에서 축출될 때에만 하위 레벨에 써준다.            캐시 블록이 수정되었는지 여부를 나타내는 dirty bit 을 각 라인마다 추가로 유지해야 한다.           Write-allocate : 해당 블록을 다음 하위 레벨에서 캐시로 가져오고 난 뒤에 캐시 블록을 갱신한다.   No-write-allocate : 캐시를 통과하고 워드를 직접 다음 하위 레벨에 써준다.   Write-through &amp; no-write-allocate, Write-back &amp; Write-allocate   6.4.5 실제 캐시 계층구조의 해부     i-cache : 인스트럭션만을 보관하는 캐시   d-cache : 데이터만 보관하는 캐시   6.4.6 캐시 매개변수의 성능에 대한 효과     미스 비율 Miss rate : 미스하는 메모리를 참조하는 비율   적중 비율 Hit rate : 1 - miss rate   적중 시간 Hit Time : 캐시에 있는 워드를 CPU 로 전달하는 데 걸리는 시간   미스 비용 Miss Penalty : 미스로 인해서 추가적으로 요구되는 시간   캐시 크기의 영향     큰 캐시는 적중비율을 높여주지만 더 적중시간이 길어진다.   블록 크기의 영향     적중 비율을 높여주지만 전송시간이 길어진다.   시간 지역성이 더 많은 프로그램에서 적중 비율에 타격을 줄 수 있다.   결합도의 영향     집합당 캐시 라인 수의 선택이 미치는 영향   충돌미스로 인해 쓰레싱하는 위험성을 감소시킨다   라인당 더 많은 태그비트 필요, LRU 상태비트 필요   6.5 캐시 친화적 코드 작성하기     좋은 프로그래머란 항상 캐시 친화적으로, 즉 좋은 지역성을 가지도록 프로그램을 작성해야 한다.            공통적인 경우를 빠르게 동작하게 만들어야한다.       각 내부 루프의 캐시 미스 수를 최소화 해야한다.       지역변수들에 대한 반복적인 참조는 좋다.(시간 지역성)       Stride-1 참조 패턴은 좋다.(공간 지역성)           6.6 프로그램 성능에 대한 캐시의 영향     읽기 처리량 or 읽기 대역폭 : 프로그램이 메모리 시스템에서 데이터를 읽는 비율   6.7 요약     이렇게 메모리까지 하드웨어와 프로그램 사이의 상호작용에 대해 공부했다. 메모리에 대해서 좀 더 자세히 살펴볼 필요가 있어 보인다. 대학 2학년 때 컴구 수업에서 캐시 매핑 관련 내용이 생각나는데, 이 책에는 수록되어 있지 않은 것 같다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_21/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 K번째수 (정렬)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 파이썬(Python) 풀이      풀이로 이동!   문제풀이     반복문과 slicing, sort 함수를 사용하면 간단하게 해결되는 가장 기초적인 정렬 문제이다.       2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.   1차원 배열인 command에서 0번 index와 1번 index에 해당되도록 slicing 한다.   slicing된 배열을 정렬한다.   정렬된 배열에서 index 2번에 해당되는 인자값을 answer 배열에 append 한다.   return answer   코드   def solution(array, commands):     answer = []     for command in commands:         answer.append(sorted(array[command[0]-1:command[1]])[command[2]-1])     return answer  if __name__ == \"__main__\":     array = [1, 5, 2, 6, 3, 7, 4]     commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]]     print(solution(array, commands)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_01/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 모의고사 (완전탐색)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 완전탐색 모의고사 파이썬(Python) 풀이      풀이로 이동!   문제풀이     반복문의 횟수를 줄이는 것이 핵심인 문제인 것 같다. 반복문의 횟수를 줄이기 위해 접근하는 index를 학생들의 정답 패턴의 길이로 나누는 아이디어를 채택하였다.       정답의 길이로 반복문을 돌린다.   학생 a,b,c의 정답 패턴의 길이로 현재 반복문의 index를 나누어 각 학생의 정답 패턴에 접근한다.   정답이 각각 일치하면, answer_list의 a-&gt;0, b-&gt;1, c-&gt;2 인덱스에 맞게 +1을 해준다.   answer_list를 enumerate를 사용하여 인덱스와 밸류값으로 함께 반복문을 돌린다.   answer_list의 max값을 찾아 해당 max값과 밸류값이 같은 인덱스값을 answer배열에 저장한다.   return answer   코드   def solution(answers):     answer = []     answer_list = [0,0,0]     a = [1, 2, 3, 4, 5]     b = [2, 1, 2, 3, 2, 4, 2, 5]     c = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]     for i in range(len(answers)):         if a[i%len(a)]==answers[i]:             answer_list[0]+=1         if b[i%len(b)]==answers[i]:             answer_list[1]+=1         if c[i%len(c)]==answers[i]:             answer_list[2]+=1      for i,val in enumerate(answer_list):         if val == max(answer_list):             answer.append(i+1)     return answer  if __name__ == \"__main__\":     answers = [5, 5, 4, 2, 3]     print(solution(answers)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_02/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level2 가장 큰 수 (정렬)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level2 정렬 가증 큰 수 파이썬(Python) 풀이      풀이로 이동!   문제풀이     가장 큰 수를 만드려면, 예를 들어 9와 91이 있을 때 991이 919보다 더 큰 수가 된다. 수의 가장 큰 값이 1000이기 때문에, ‘9’3, ‘91’3을 해서 비교를 하면, ‘999’ &gt; ‘919191’ 이다. 그렇기 때문에 int-&gt;str-&gt;*3을 하여 비교를 하여 정렬을 하고 해당 숫자들을 원래 숫자로 변경하여 return 해준다.       배열의 값들을 str type으로 변경해준뒤 *3을 해준다.   이후 sorted 함수를 사용하여 정렬한다.(내림차순으로 정렬하기 위해 reverse=True로 설정해준다.)   다시 배열의 값들의 길이를 1/4로 나누어 slicing해준다.   해당 배열들을 ‘‘로 join해준다.   return answer   코드   def solution(numbers):     if sum(numbers)==0:         return '0'     numbers = sorted([str(number)*3 for number in numbers],reverse=True)     answer = ''.join([numbers[i][:int(len(numbers[i])/4)] for i in range(len(numbers))])     return answer  if __name__ == \"__main__\":     numbers = [6,2,10]     print(solution(numbers)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Part 1 프로그램의 구조와 실행 리뷰",
        "excerpt":"2 정보의 표현과 처리     컴퓨터가 실제로 해석하는 비트들과 연산들이 무엇이 있는지 배운다.       컴퓨터는 두 개의 값을 갖는 신호로 정보를 처리한다.   이러한 비트를 이진수 체계를 사용해서 양수들로 인코딩하여 사용한다.            비부호형       부호형(2의 보수)       부동소수점           정보의 저장     2진수: 컴퓨터의 비트 표현   16진수: 비트 패턴을 표시하는데 사용됨(2진수와 10진수는 불편함)   비트 표시 방법(xw-1,xw-2,…,x1,x0)            리틀 엔디안: 가장 덜 중요한 바이트가 먼저 온다.(x0,x1…)       빅 엔디안: 가장 중요한 바이트가 먼저 온다.(xw-1,xw-2…)           비트 수준 연산            부울 대수: ~(not),&amp;(and),|(or),^(exclusive-or)       쉬프트                    좌측 쉬프트: « 우측에는 k개의 0 채워짐           논리 우측 쉬프트 » 좌측에는 k개의 0 채워짐           산술 우측 쉬프트 » 좌측에는 k개의 중요한 비트들이 채워짐                           정수의 표시     비부호형과 부호형(2의보수)의 표현 방법에 차이점에 포인트를 두어야 한다.       부호형(2의 보수) : 맨 앞자리의 비트가 0이면 양수, 1이면 음수로 표현한다.            ex) 1101 -&gt; 앞자리가 1이므로 -8, 앞자리를 제외한 값이 5 -&gt; -8+5=-3 이렇게 계산한다.           비부호형과 부호형 간의 변환과 확장, 절삭에서 부호형의 오버플로우가 발생한다.   정수의 계산     부호형의 덧셈, 곱셈에서 음의 오버플로우와 양의 오버플로우가 발생한다.   쉬프트를 사용해서 곱셈이 가능하다.(비용이 훨씬 적게 듬)            ex) 11(1011[2])*4 = 44(101100[2])           부동소수점     부동소수점 V = x*2^y 형태로 인코딩한다. y는 1/2, 1/4… 와 같은 값   근사법 rounding            부동소수점은 정확한 값을 얻을 수 없다. 그렇기 때문에 근사 연산을 한다.                    짝수근사법, 영방향근사, 하향근사, 상향근사 모드가 있다.                           3 프로그램의 기계수준 표현     우리가 코드를 작성하면 컴파일러는 소스파일의 어셈블러 버전을 생성한다. 어셈블러는 해당 어셈블리 코드를 바이너리 목적코드로 변환한다. 이후 목적코드를 컴퓨터가 해석한다. 이번 챕터에서는 어셈블리 코드에 대해 배운다. 이것을 배우게 되면 컴파일러의 최적화 방법을 알 수 있고 코드의 비효율성을 분석할 수 있게된다.    프로그램의 인코딩     프로그램 호출방법(c언어 기)            C 전처리가 #include와 #define을 확장해준다.       컴파일러는 소스파일의 어셈블리 코드를 생성한다.(test.c -&gt; test.s)       어셈블러는 어셈블리 코드를 바이너리 목적코드로 변환한다.(test.s -&gt; test.o)       링커가 목적코드를 라이브러리 함수와 함꼐 최종 실행 파일인 test.p를 생성한다.           ISA(Instruction Set Architecture): 인스트럭션 집합구조, 프로세서의 상태 및 인스트럭션 형식과 영향을 정의한다.   인스트럭션 특성 요약            오퍼랜드: 데이터와 목적지 위치를 명시한다.       레지스터나 메모리로부터 읽고 저장한다.       immediate(상수값), register, memory 세가지 타입이 존재한다.           인스트럭션 종류     데이터 이동: mov            두 개의 오퍼랜드 모두 메모리 위치에 올 수 없다.           스택의 저장과 추출: push, pop   산술연산: add, sub, imul, idiv, sal(left shift), inc(++1), or, and…   유효주소 적재: leaq            포인터 생성하기 위한 인스트럭션           조건코드: CF(carry flag), ZF(zero flag), SF(sign flag), OF(overflow flag)            cf: 중요한 비트로부터 받아올림이 발생한 것을 표시(오버플로우 검출)           제어문: cmp, test, set            cmp는 두 오퍼랜드가 같으면 zf를 1로 설정       test는 조건 코드만 설정       set은 비교후 조건코드를 설정해줌           점프: jmp, je, jle…   조건부 이동: cmove, cmovg…   콜 리턴: call, ret   조건부 분기(if else)     조건제어: cmp와 jump를 사용함   조건부이동: cmove등을 사용함(더 빠름)            경우를 다 계산하고 이동만함           반복문(for, while)     cmp와 jump를 사용   프로시저     call: call하게 되면 이전 주소와 함께 스택 메모리에 올라감   return: 후입선출 구조이기 때문에 스택에 있던 이전 주소가 pop되며 retrun 하게됨   데이터 전송: 인자는 레지스터로 전송되지만, 6개 이상의 인자를 가지면 초과되는 인자는 스택으로 전달된다.   지역 변수: 지역변수 또한 스택 프레임 내에서 생성된다.   레지스터: 레지스터는 프로시저 모두가 굥유함. 기존에 사용하던 레지스터를 새로 호출한 함수에서 “saved registers”라는 스택의 일부분을 할당해서 저장하고 보존한다.      데이터의 정렬     사용 가능한 주소를 k의 배수가 되도록 요구한다.      버퍼 오버플로우     스택의 saved registers와 return address 범위를 침범하면 심각한 오류를 발생시킨다.   대응 방법            스택 랜덤화: 스택의 위치를 프로그램 실행마다 다르게 해준다.       스택 손상 검출: 스택에 canary값을 추가하여 손상되는 것을 감지한다.       실행코드 영역 제한           부동소수점     정수 연산과 유사하다.   부동소수점을 위한 레지스터를 따로 사용한다.   4 프로세서 구조     하드웨어 시스템이 ISA의 인스트럭션들을 어떻게 실행할 수 있는지를 학습한다. ISA인 “Y86-64”를 직접 만들어보며 학습한다. 이후 SEQ를 기초로 파이프라인형 프로세서 PIPE를 만들어본다. 프로세서는 각 인스트럭션의 실행단계를 5단계로 나누어 처리한다.       프로그래머-가시성 상태(programmer-visible state) : 프로그램 레지스터, CC(조건코드), PC, 메모리, Stat(상태코드)를 포함한다.   인스트럭션 집합(Y86-64)        위의 그림처럼 인스트럭션이 인코딩된다.            인코딩에 1에서 10바이트가 소요된다.       OPq는 정수연산이며 ZF,SF,OF 조건코드를 결정한다.                위의 그림처럼 인스트럭션에 대한 상세한 특정 인코딩으로 변환된다.   예외상황(Y86-64)     Stat(상태코드)를 나타낸다.            AOK: 정상 실행       HLT: halt 인스트럭션 실행(정지 인스트럭션)       ADR: 잘못된 메모리 주소를 읽거나 쓸 때       INS: 잘못된 인스트럭션을 만났을 때           어셈블러를 사용해 어셈블한 결과 == 목적코드      SEQ 설계 1 (레지스터 파일)     SEQ는 sequential 프로세서를 의미한다. SEQ를 설계하기 위해서는 SEQ 내에 있는 레지스터 파일을 이해해야 한다. 레지스터 파일을 이해하기 위해서는 논리게이트와 클럭을 이해해야한다.(레지스터 파일이 논리게이트로 이루어져있다.)     논리게이트 -&gt; 조합회로 -&gt; (레지스터 연산 = 클럭) -&gt; 레지스터 파일 -&gt; SEQ -&gt; SEQ+ -&gt; PIPE       논리게이트: AND, OR, NOT등의 입력들의 불 함수 출력을 만들어낸다.            출력과 입력은 0과 1이다.           조합회로: 여러 논리 게이트를 모아 네트워크를 만들어 계산 블록을 만든다.다   클럭: 주기적 신호인 한 개의 클럭에 의해 새 값들이 제어된다.            클럭을 사용하는 레지스터: 워드나 개별 비트 저장       RAM: 주소를 사용해서 여러 워드를 저장           레지스터 연산: 클럭이 상승할 때 레지스터의 입력값이 새값을 가진다.   레지스터 파일:      SEQ 설계 2 (하드웨어 구조)             위의 그림은 SEQ 하드웨어 구조다.       작업 단계            선입 fetch: PC를 메모리주소로 사용해 인스트럭션 바이트를 읽어들인다.       해독 decode: 레지스터 파일에서 오퍼랜드를 읽어서 valA, valB를 얻는다.       실행 excution: ALU(산술/논리 연산)이 인스트럭션이 지시하는 연산을 수행하거나 유효주소 계산 및 스택 포인터 값 변경한다. 조건 코드 및 점프 인스트럭션도 갱신한다. valE       메모리 memory: 데이터를 메모리에서 쓰거나 읽어온다. valM       재기록 write back: 두 결과를 레지스터 파일에 기록한다.       PC 갱신 PC update: PC는 다음 인스트럭션의 주소로 설정된다.           SEQ 타이밍            메모리와 레지스터에 클럭을 공급하며 프로세서의 여러 동작들을 순서대로 제어한다.       인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 없다.           파이프라이닝 원리     SEQ에서는 하나의 인스트럭션을 처리하는데 3~5 클럭정도 소요된다. 하지만, 다양한 단계에서 하나의 인스트럭션이 끝날 때 까지 쉬고 있는 단계가 많다. 이를 사용하기 위해 파이프라이닝 개념을 도입하였다.       파이프라이닝 주요 특징 : 시스템 처리량, 지연시간을 증가 시킨다.            위의 그림은 비파이프라인과 파이프라인            수행 시간을 계산하면 파이프라인이 약 2.5배 빠르지만, 지연시간은 40ps정도 늘어났다.           파이프라이닝의 한계     각 단계별로 처리 시간이 다르면, 가장 늦은 단계의 시간지연 값에 의해 클럭의 속도가 결정된다.   인스트럭션들 간에 데이터 의존성이 존재하면 파이프라이닝이 제한된다.            피드백을 갖는 파이프라인 시스템이라고도 한다.           PIPE 설계     SEQ 구조에서 PC갱신 단계를 맨 처음으로 바꾼 SEQ+를 설계한 후 파이프라인을 적용하여 PIPE구조를 설계한다.         위의 그림은 PIPE-의 하드웨어 구조이다.   다음 PC값의 추정     파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이다.   목표를 달성하기 위해서 PC의 새로운 값을 예측해야 한다.            조건제어나 분기등으로 인해서           분기 방향을 추측하는 기술을 branch prediction이라고 한다.   파이프라인 해저드     피드백이 있는 시스템에 파이프라인을 도입하면 인스트럭션들 간에 의존성으로 인해 문제가 발생한다.            데이터 의존성: 현재의 계산의 결과가 다음 인스트럭션을 위한 데이터로 사용되는 경우       제어 의존성: jump, call, ret과 같은 인스트럭션을 처리할 경우           해저드: 의존성들이 파이프라인으로 인해 잘못된 계산을 하는 것   스톨을 사용한 데이터 해저드 회피     해저드 조건이 사라질 때 까지 파이프 라인 내에 유지한다.   스톨링동안 실행 단계에 버블을 삽입한다.   버블은 동적으로 생성된 nop인스트럭션과 비슷하다.   포워딩을 이용한 데이터 해저드 회피     소스 오퍼랜드로 이전에 실행된 인스트럭션 결과 값을 전달할 수 있다.   “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.   로드/사용 데이터 해저드 회피     메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 포워딩으로 처리할 수 없다.   스톨링과 포워딩을 함께 사용한다.   load interlock: 로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것   제어 해저드의 회피     ret: 스톨을 사용한다.   jump: 분기할 것을 예측한다. -&gt; 잘못 예측된 것을 확인한다. -&gt; 버블을 삽입하여 인스트럭션을 취소한다. -&gt; 점프 다음에 오는 인스트럭션을 선입한다.   instruction squashing: 잘못 선입한 인스트럭션을 취소하는 것   파이프라인 예외처리       제어로직을 사용하여 예외처리를한다.   5 프로그램 성능 최적화하기     상위 수준 설계: 적절한 알고리즘과 자료구조 선택   최적화 장애물 피하기            함수 호출제거       계산은 루프 밖으로 이동       불필요한 메모리 참조 제거       중간 값을 저장하는 임시 변수 사용(데이터 의존성 피하기)       최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)           하위수준 최적화: 병렬성 이용            루프풀기       다중누산기와 재결합 기법 사용       statement 보다 expression 사용하기           6 메모리 계층구조     랜덤-접근 메모리(RAM)            SRAM: 캐시메모리로 사용                    메모리셀에 저장한다.           지속성을 갖는다.           리프레시가 필요없다.                       DRAM: 메인메모리로 사용                    캐패시터에 저장한다.           리프레시가 필요하다.           메모리 컨트롤러는 행 주소 -&gt; 열 주소를 보낸다.                       RAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.           비휘발성 메모리            전원이 꺼져도 정보를 유지한다.       Read-only memory ROM이라고 부른다.           버스            프로세서와 메인메모리간에 데이터를 교환한다.       버스 트랜잭션이라고 부르는 일련의 단계들을 통해 이뤄진다.       읽기와 쓰기 트랜잭션이 있다.           지역성     최근에 참조했던 데이터 아이템 근처나 자신을 참조하려는 경향이 있다.   종류            시간 지역성: 한번 참조된 메모리 위치는 여러번 참조될 가능성이 높다.       공간 지역성: 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.           캐시 메모리: 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장한다.   캐시     캐시 종류            직접매핑 캐시       집합결합성 캐시       완전결합성 캐시           캐시 동작 방법            집합 선택       라인 매칭       워드 추출                    Thrashing: 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는경우                            해결법: 패딩을준다.                                   인덱스를 중간비트로 쓰는 이유: 연속적인 메모리의 동일한 캐시 집합으로의 매핑을 피하기 위해                           캐시 쓰기            Write-through: 즉시 하위 레벨로 쓴다. 버스 트래픽 일으키는 단점 있다.       Write-back: 갱신을 지연시켜 교체 알고리즘에 의해 축출될 때 쓴다. dirty bit을 라인마다 추가로 유지해야한다.       Write-allocate: 하위 레벨에서 캐시로 가져오고 난 뒤 캐시 블록을 갱신한다.       No-write-allocate: 캐시를 통과하고 직접 하위 레벨에 써준다.           Part1 프로그램의 구조와 실행 리뷰  처음 csapp 책을 읽기 시작한 날이 1월 21일이다. 총 세파트로 나뉘어져 있는데, 파트1을 1회독한 시점이 3월 29일 대략 2개월정도 걸렸다. CS부터 공부하기로 다짐했을 때 매일매일 공부하려고 노력했지만, 부트캠프 지원 이슈로 인해 대략 2-3주정도는 공부를 안한 것 같다.  또 어려운 내용이 나오기 시작하면, 예를들어 부동소수점, 프로시저, SEQ구현 등… 책을 덮게되었던 것 같다.  하루빨리 CS, OS, 네트워크, 디비 이론적인 부분들에 대해 공부를 마치고 지식적으로 성장하고 싶다. 컨디션 조절을 하되 2-3주동안 공부를 안했던 것은 반성하자.   SEQ 설계 단원을 공부하기 전까지는 공부하는 내용들이 머리속에서 잘 그려지지 않았다. 하지만 SEQ 설계를 공부하고 나니 그 이전에 공부했던 부분들에 대해 조금 더 이해가 되었고, 그 이후에 최적화 부분에서 정말 말 그대로 신이났다. CS의 매력에 흠뻑 빠지게 된 것 같다. 대학에서 컴구를 공부할 때는 이론적인 부분 또는 하드웨어적인 부분에서의 설명만 하고  추가 설명은 없었다. 그래서, 나는 이런 하드웨어와 프로그램들이 어떻게 상호작용이 되는지 이해하지 못했고 재미도 못 느꼈던 것 같다. 하지만, csapp에서는 하드웨어와 프로그램의 상호작용에 대해 설명을 하면 그 이후에 실제 c코드로 예시를 들어준다. 이러한 예시코드가 프로그래밍과 접목도 되고 이해의 수준이 상승하는 것 같다.   앞으로 남은 part2,3를 4월 중순 안으로 끝마치고 운영체제 공부를 빨리 하고 싶다. 화이팅이다! 아자아자!  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_22/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 체육복 (그리디)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 그리디 체육복 파이썬(Python) 풀이      풀이로 이동!   문제풀이     그리디 문제는 ‘현재 상황에서 지금 당장 좋은 것만 고르는 방법’을 의미한다. 알고리즘의 패턴보다는 풀이하는 사람의 아이디어가 더 중요한 알고리즘이다. 우선 체육복 문제는 인접한 index의 학생들만 여벌의 옷을 받을 수 있으므로 인접한 index에 대해서만 생각해주면 된다. 또한 도난당한 학생이 여벌의 옷을 가지고 올 수 있기 때문에 이 부분에서 예외처리를 해주어야한다.       lost와 reserve를 set형식으로 변경해준뒤 각각의 차집합을 구해준다.(도난당한 학생과 여벌옷을 가져온 학생이 중복된 경우를 제거하기 위해)   reserve를 기준으로 인접한 lost를 조회하여 존재하면 reserve에서 해당 value를 삭제해주고 count(옷을 빌린 학생 수)를 1 올려준다.   전체에서 lost에 남아있는 값들의 길이를 빼주고 count(옷을 빌린 학생 수)를 더해준다.   위에 값을 answer로 return한다.   코드       def solution(n, lost, reserve):         count = 0         lost, reserve = list(set(lost)-set(reserve)), list(set(reserve)-set(lost))         for lost_v in lost:             for reserve_v in reserve:                 if lost_v - 1 == reserve_v or reserve_v == lost_v + 1:                     reserve.remove(reserve_v)                     count += 1                     break              answer = n - len(lost) + count              return answer          if __name__ == \"__main__\":         n = 5         lost = [1,2,4]         reserve = [2,3,4,5]         print(solution(n,lost,reserve)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_04/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level2 큰 수 만들기(그리디)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level2 그리디 큰 수 만들기 파이썬(Python) 풀이      풀이로 이동!   문제풀이     총 두가지의 방법으로 문제를 풀었는데 모두 테스트케이스 10에서 시간 초과로 인해 풀지 못하였다…  그래서 정답 코드를 가지고 와서 공부를 하는 것으로 대신하겠다.  파이썬에는 스택 자료구조가 따로 없고 리스트로 스택을 흉내내서 사용할 수 있다. 정답 코드는 스택의 성질을 사용하여서 문제를 해결했다.    맞는 풀이 solution3      stack을 흉내내는 리스트(stack이라 부르겠다.)에 number의 첫번째 값을 넣어준다(push).   number의 두번째 값부터 반복문을 돈다.   while문을 도는데, 조건은 세가지다.            stack에 값이 있어야한다.       stack의 마지막 값(stack.top)이 num보다 작아야한다.       k가 0보다 커야한다.           위에 해당하지 않으면 stack에 값을 추가해준다(push).   조건이 해당하면, 반복문을 돌면서 stack.pop()과 k를 1씩 줄여준다.   반복문이 끝나고도 k가 0이 아니면 stack을 뒤에서 k만큼 slicing해준다.   '’으로 join하여 문자열로 return한다.   틀린 풀이 solution1      numbur의 i와 i+1을 비교한다.   i가 i+1보다 작으면 i를 pop해준다.   다시 첫번째 index로 돌아가 1-2번을 반복한다.   남아있는 값이 len(number)-k의 길이가 아니면, 뒤에서 k만큼 slicing 해준다.   '’으로 join하여 문자열로 return한다.   틀린 풀이 solution2      number의 i와 j를 비교한다.   i가 j보다 작으면 i의 인덱스를 새로운 배열에 저장한다.   모두 저장된 배열에 포함된 인덱스를 number에서 제거해준다.   남아있는 값이 len(number)-k의 길이가 아니면, 뒤에서 k만큼 slicing 해준다.   '’으로 join하여 문자열로 return한다.   코드       def solution1(number, k):         number = list(number)         i = 0;         while k &gt; 0:             for j in range(i,i+k+1):                 if number[i] == '9': break                 if number[i] &lt; number[j]:                     number.pop(i)                     k = k -1                     if i&gt;0:                         i = i -1                         break                     i = -1                     break             i += 1         answer = ''.join(number)         return answer          def solution2(number, k):         number = list(number)         length = len(number)-k         remove_list = []         i = 0         while k &gt; 0:             if i+1+k &gt; len(number):                 break             for j in range(i+1,i+1+k):                 if number[i] &lt; number[j]:                     remove_list.append(i)                     k -= 1                     break             i += 1         number = [number[i] for i in range(len(number)) if i not in remove_list]         number = number[:length]         answer = ''.join(number)         return answer                    def solution3(number,k):         stack = [number[0]]         for num in number[1:]:             while len(stack) &gt; 0 and stack[-1] &lt; num and k &gt; 0:                 k -= 1                 stack.pop()             stack.append(num)         if k != 0:             stack = stack[:-k]         return ''.join(stack)               if __name__ == \"__main__\":         number = '4177252841'         k = 4         print(solution3(number, k)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_05/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 모험가 길드",
        "excerpt":"이것이 코딩 테스트다 with 파이썬   그리디 모험가 길드(Python)   문제   모험가 N명에겐 공포도 X가 각각 존재한다.  공포도가 X인 모험가는 반드시 X명 이상으로 구성된 그룹에 참여하고 여행을 떠나야 한다.  여행을 떠날 수 있는 그룹 수의 최댓값을 구하라.      예시    입력 : [2,3,1,2,2]  결과 : 5   풀이     공포도가 가장 큰 모험가를 우선으로 그룹을 지정해주어야 한다. 그렇기 때문에 내림차순으로 정렬을 하고 접근한다.       array를 내림차순으로 정렬   array의 첫번째 인덱스의 값만큼 slicing해서 array에 저장, count를 1 올려줌   array가 빈 리스트가 되면 while문 탈출   return count   코드       def solution(array):         count = 0         array.sort(reverse=True)프로그래머스 파이썬 알고리즘          while array:             array = array[array[0]:]             count += 1              return count          if __name__ == \"__main__\":         array = [2,3,1,2,2]         print(solution(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_01/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 곱하기 혹은 더하기",
        "excerpt":"이것이 코딩 테스트다 with python   그리디 곱하기 혹은 더하기(Python)   문제   숫자로만 이루어진 문자열 S가 있다.  숫자 사이에 ‘x’, ‘+’ 연산자를 넣어 가장 큰 수를 만들어라.       예시   입력 : ‘02984’  결과 : 576   풀이     0과 1일 때는 +를 해주고 그렇지 않으면 x를 해주는 것이 이 문제의 포인트로 보인다.       sum 변수에 str(문자열 S)의 첫번째 인덱스의 값을 넣어준다.   str의 두번째 인덱스의 값부터 반복문을 돌린다.   sum과 ch(반복문을 도는 str의 값)이 2보다 작다면 +, 그렇지 않으면 x를 해준다.            sum도 체크 하는 이유는 sum이 0이나 1이면 +를 해줘야 하기 때문           return sum   코드       def solution(str):         sum = int(str[0])              for ch in str[1:]:             ch = int(ch)             if sum &lt; 2 or ch &lt; 2:                 sum += ch             else:                 sum *= ch              return sum               if __name__ == \"__main__\":         str = \"567\"         print(solution(str)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_02/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 문자열 뒤집기",
        "excerpt":"이것이 코딩 테스트다 with python   그리디 문자열 뒤집기(Python)   문제   0과 1로만 이루어진 문자열 S가 있다.  연속된 숫자를 잡고 뒤집을 수 있다.(0을 1로, 1로 0으로)  모두 같은 수를 만들 수 있는 뒤집기의 최소 횟수를 구하라.      예시   입력 : ‘00001110000’  결과 : 1   풀이     0과1이 인접한 부분이 몇개 있는지를 체크하면 된다. 예를들어 인접한 부분의 패턴을 ‘01’을 조사한다. 하지만, 1010 문자열을 조사하게 되면 마지막 인접한 부분을 조사하지 못해 최소 횟수가 1이 되므로 마지막 문자열에 1을 붙여주고 조사한다. 이렇게만 진행했을 경우 ‘010’을 조사하게 되면 최소 횟수가 2회가 된다. 그렇기 때문에 같은 방법으로 ‘01’과 ‘10’을 둘다 조사하여 두가지의 최소 횟수중 최소값을 구한다.       문자열 S(str)의 마지막 부분을 조사해서 0 또는 1을 붙여준다.   반복문을 돌며 ‘01’패턴과 ‘10’패턴을 조사한다 각각의 횟수를 count_0, count_1에 저장한다.   count_0과 count_1중 최소값을 return한다.   코드       def solution(str):         if str[-1] == '1':             str += '0'         else:             str += '1'         count_0 = 0         count_1 = 0              for i in range(len(str)-1):             if str[i]+str[i+1] == '01':                 count_0 += 1             if str[i]+str[i+1] == '10':                 count_1 +=1              return min(count_0,count_1)                    if __name__ == \"__main__\":         str = \"010\"         print(solution(str)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_03/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 만들 수 없는 금액",
        "excerpt":"이코테   그리디 만들 수 없는 금액(Python)   문제   N개의 동전을 갖고 있다.  N개의 동전을 이용하여 만들 수 없는 정수 금액 중 최솟값을 구하라.       예시   입력 : [3,2,1,1,9]  결과 : 8   풀이     고민을 좀 많이 했던 문제이다. 만들 수 있는 금액을 모두 구한 뒤 해당 금액에서 없는 금액중 최소값을 구하는 방식으로 접근했었다. 이렇게 문제를 풀면 n^2의 시간이 걸린다. 하지만, 해답에서는 n으로 풀고 있어 정답 코드를 배울 필요성이 있어 보인다. 정답 코드는 누적합을 사용한다.    solution1     동전이 모두 저장되어 있는 array를 정렬한다.   동전들의 모든 가능한 합이 저장될 set 타입의 변수를 선언한다. (set은 중복이 없다.)   1,1,2,3,9라면, 1, 1+1, 1+1+2, 1+1+2+3, 1+1+2+3+9 \\ 1, 1+2, 1+2+3, 1+2+3+9 \\ 2, 2+3, … 식으로  2중 포문을 돌리며 값을 저장한다.   이후 set의 max값 만큼 반복문을 돌며 만들 수 없는 최솟값을 구한다.   4번에서 구한 최소값을 return한다.   solution2     동전이 모두 저장되어 있는 array를 정렬한다.   target=1을 선언한다.(0인 동전은 없기 때문에)   array를 반복문을 돌며 동전을 하나씩 꺼낸다.   target이 동전보다 작다면 break 한다.(더이상 만들 수 없는 동전을 만났기 때문)   target이 동전보다 작지 않다면 target에 동전을 더해준다.   반복문을 빠져나오면 target을 return한다.      모든 것을 다 구해야만 가능하다고 생각해서 이중 포문을 돌았지만,  누적된 합은 다시 구해도 되지 않은 수이기 때문에 부등호를 사용하여 비교한 점이 인상 깊었다.    코드       def solution1(array):         array.sort()         money_set = set()         for i in range(len(array)):             sum = 0             for j in range(i,len(array)):                 sum += j                 money_set.add(sum)              for i in range(max(money_set)):             if i not in money_set:                 return i         return max(money_set)+1          def solution2(array):         array.sort()         target = 1         for x in array:             if target &lt; x:                 break             target += x              answer = target          if __name__ == \"__main__\":         array = [3,2,1,1,9]         print(solution2(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_04/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 볼링공 고르기",
        "excerpt":"이코테   그리디 볼링공 고르기(Python)   문제   두 사람이 서로 다른 무게의 볼링공을 고르려고 한다.  같은 무게의 공이 여러개 있다면 서로 다른 공으로 간주된다.  이 때 두 사람이 고를 수 있는 볼링공 번호의 조합의 경우의 수를 구하라.      예시   입력 : [1,3,2,3,2]  결과 : 8   풀이     정렬을 한 뒤에 자신과 다른 무게를 가지고 있는 볼링공을 차례로 비교하여 count하면 쉽게 풀 수 있는 문제다. 하지만, 나는 n^2으로 풀었고 답지는 n으로 풀었다. 남아있는 볼링공의 개수와 현재 해당하는 볼링공의 무게의 개수를 곱하면 더 빠른 시간복잡도로 문제를 해결할 수 있다. 조합을 위와 같은 방법으로 접근 할 수 있다는 것을 새롭게 배웠다.    solution1(n^2)     볼링공의 무게가 담겨져 있는 배열(array)를 정렬한다.   A 사람이 i번째 볼링 공을 골랐을 때 B가 고를 경우의 수를 이중포문을 돌려서 체크한다.(A와 무게가 다르다면 count +1을 해준다.)   이중포문을 돌릴 때 i번째 이후 공만 체크하면 되기 때문에 index와 value 두가지로 포문을 돌린다.   return count   solution2(n)     weight_list에 무게의 종류만큼 0으로 초기화한다.   볼링공의 무게가 담겨져 있는 배열을 반복문을 돌면서 볼링공의 무게에 해당하는 index에 값을 1씩 증가해준다.   볼링공의 최대 무게까지 반복문을 돈다.   현재 인덱스 무개의 볼링공의 개수를 전체 개수에서 제외해준다.   result에 현재 인덱스 무게의 볼링공 * 전체 개수를 계산하여 더해준다.   return result      조합 문제를 어떻게 접근하냐에 따라서 시간복잡도를 줄일 수 있다.  앞으로도 문제를 풀 때 최대한 시간복잡도를 생각하면서 풀 수 있도록 노력해야겠다.    코드       def solution1(array):         array.sort()         money_set = set()         for i in range(len(array)):             sum = 0             for j in range(i,len(array)):                 sum += j                 money_set.add(sum)              for i in range(max(money_set)):             if i not in money_set:                 return i         return max(money_set)+1          def solution2(array):         array.sort()         target = 1         for x in array:             if target &lt; x:                 break             target += x              answer = target          if __name__ == \"__main__\":         array = [3,2,1,1,9]         print(solution2(array)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_05/",
        "teaser": null
      },{
        "title": "[이코테/Python] 그리디 - 무지의 먹방 라이브(2019 카카오)",
        "excerpt":"이코테   그리디 무지의 먹방 라이브 - 2019 카카오 문제(Python)   문제   문제로 이동!   풀이     k만큼 반복문을 돌며 0을 만나면 패스하고 0이 아닌 값을 만나면 인자와 k값을 -1씩 하는 방식으로 처음 문제를 접근했다. index 접근은 array의 길이만큼 나눈 나머지로 접근함으로써 반복문 하나로 접근하였지만, 시간초과로 문제를 풀지 못하였다.     답지에서는 우선순위큐로 접근하였다. 다 먹는데 가장 적게 걸리는 음식들을 순서로 접근하였고, 이 때 하나의 음식을 다 먹는 시간이 k보다 커지면 반복문을 탈출하고 남은 값들 중에서 정답을 도출하였다.    solution2(fail)     k&gt;0 인 조건에서 while문을 돈다.   index를 1씩 증가하고 index를 array의 length로 나눈 나머지로 배열에 접근한다.   0이면 continue, 1이면 k와 인자를 -1씩 해준다.   탈출 시 index로 배열에 접근하여 해당 값이 0이 아니라면 index+1(음식은 1부터 시작)로 return 한다.   0일 경우 한바퀴를 돌면서 해당 index부터 순서로 0보다 큰 값을 찾는다.   한바퀴가 돌아도 찾아지지 않는다면 -1로 return, 찾아졌다면 해당 index로 return   solution3(solved)     array의 총합이 k보다 적으면 -1로 우선 return 하여준다.   (array의 값, array의 인덱스)로 값을 기준으로 정렬하여 우선순위큐에 넣어준다.   (현재 먹은 음식과 이전에 먹은 음식의 차이)와 (현재 배열의 길이) 를 곱하고 (이전 반복문까지 더해졌던 sum_value)와 더해서 k보다 커지면 반복문을 탈출한다.            위의 값이 k보다 크다면, 더이상 음식을 다 먹을 수 있는 경우가 아니기 때문에 반복문을 탈출하고 남은 횟수만큼 인덱스를 더해 결과를 도출한다.           반복문을 탈출했다면, 다시 인덱스 기준으로 정렬하고 결과값을 찾는다.      처음 문제를 풀었을 때 문제에서 순차적으로 접근하는 것 처럼 설명이 되어 있어 순차적으로 접근하면서 푸는 방법이 맞는 방법이라고 생각했다. 하지만, 문제에 대해 조금 더 생각했더라면, 우선순위큐를 생각할 수 있었을 것 같다. 다양한 유형을 풀어본다면, 어떤 유형으로 풀 수 있는 지에 대한 생각의 폭이 넓어질 것 같다.    새로 알게된 문법     solution1을 풀 때 리스트 컴프리헨션의 조건문에 대한 새로운 문법을 알게 되었다.       조건문이 뒤에 있을 때 : 조건문에 해당 하는 값 i만 추가   [i for i in array if i%2 == 0]     조건문이 앞에 있을 때 : if에 해당하는 값은 i, 아니면 else 뒤에 있는 값으로 추가   [i if i%2 == 0 else None for i in array]  코드       def solution(food_times, k):         length = len(food_times)         quotient = k // length         remainder = k % length         food_times = [v-quotient-1 if i&lt;remainder else v-quotient for i,v in enumerate(food_times)]         time_sum = sum([i for i in food_times if i&lt;0])         index = (remainder + time_sum) % length         if food_times[index] &lt;= 0:             for i,v in enumerate(food_times[index:]):                 if v &gt; 0:                     return i+index+1             return -1         return index               def solution2(food_times, k):         length = len(food_times)         index = -1         while k &gt; 0:             index += 1             if food_times[index % length] == 0:                 continue             else:                 food_times[index % length] -= 1                 k -= 1              index = (index + 1) % length              if food_times[index] &lt;= 0:             for i in range(length+1):                 if food_times[(index+i) % length] &gt; 0:                     return (index+i) % length + 1             return -1              return index+1               def solution3(food_times, k):         import heapq              if sum(food_times) &lt;= k:             return -1              q = []         for i in range(len(food_times)):             heapq.heappush(q, (food_times[i], i+1))              sum_value = 0         previous = 0              length = len(food_times)         while sum_value + ((q[0][0] - previous) * length) &lt;= k:             now = heapq.heappop(q)[0]             sum_value += (now - previous) * length             length -= 1             previous = now              result = sorted(q, key =lambda x: x[1])         return result[(k - sum_value) % length][1]               if __name__ == \"__main__\":         food_times = [3,1,1,1,2,4,3]         k = 12         print(solution3(food_times,k)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_06/",
        "teaser": null
      },{
        "title": "[프로그래머스/Python] Level1 완주하지 못한 선수(해시)",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 해시 완주하지 못한 선수 파이썬(Python) 풀이   풀이로 이동!   문제풀이     딕셔너리에 선수의 이름을 key값으로, 중복된 선수의 이름을 체크하는 count를 value값으로 만들어준 뒤,  완주한 선수의 목록을 반복문을 돌며 count를 1씩 줄이며 마지막으로 남아있는 선수를 출력하면 된다. 파이썬에서 딕셔너리는 해시테이블이라고 볼 수 있다.    solution2(solved)     딕셔너리 변수를 하나 지정해준다.   참가자들의 반복문을 돌며 딕셔너리에 key값이 존재하지 않다면 value 0을, 존재한다면 value +1로 설정해준다.   완주자들의 반복문을 돌며 딕셔너리에서 key값을 조회하며 value를 -1씩 해준다.   반복문을 돌며 0보다 큰 값을 출력해준다.   solution3(solved)     hash값을 아주 잘 이용한 case여서 배워두면 유용하게 사용할 수 있을 것 같다.       딕셔너리 변수를 하나 지정해준다.   참가자들의 반복문을 돌며 딕셔너리 key값으로 참가자의 이름에 해당하는 hash값, value에는 참가자의 이름을 저장해준다.   추가적으로 해당 hash값을 모두 더하여 저장하는 temp 변수를 만든다.   완주자의 반복문을 돌며 완주자의 이름에 해당하는 hash값을 temp에서 계속 빼간다.   이후 temp의 남아있는 값으로 딕셔너리의 key값을 조회한다.   새로 알게된 문법     solution1은 시간초과로 문제를 해결하지 못하였는데 그 이유는 딕셔너리 컴프리헨션에서 사용한 count가 O(n) 시간을 가지고 있기 때문이다.    리스트 컴프리헨션만 존재하는 줄 알았지만, 컴프리헨션은 딕셔너리에서도 적용 가능했다.       a = {p:participant.count(p) for p in participant}  key:value 형식으로 저장한다.   코드       def solution(array, commands):         answer = []         for command in commands:             answer.append(sorted(array[command[0]-1:command[1]])[command[2]-1])         return answer          if __name__ == \"__main__\":         array = [1, 5, 2, 6, 3, 7, 4]         commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]]         print(solution(array, commands)) ","categories": ["programmers"],
        "tags": ["Algorithm","Python","프로그래머스 코테"],
        "url": "/programmers/python_06/",
        "teaser": null
      },{
        "title": "전역변수 vs 매개변수",
        "excerpt":"DFS 문제를 풀며   DFS 문제를 공부하며, 예제 코드를 봤는데, graph 변수를 전역변수로 선언하고 사용하고 있었다. 컴퓨터구조를 공부하면서, 전역변수는 메모리에 할당되고 함수의 일부 매개변수는 레지스터에 저장되어 훨씬 빠른 속도로 액세스된다고 이해했었다. 그렇다면 graph 변수를 dfs 함수의 인자로 넘겨줄 때, ‘전역변수를 사용하지 않고 매개변수로 넘겨주면 성능이 더 좋은 코드가 되지 않을까?’ 라는 궁금증에 휩싸여 풀던 문제를 내려놓고 열심히 구글링을 하기 시작하였다.   기존에 알고 있던 것  우선 두가지 생각을 했다. 첫번째, 전역변수는 메모리에 올라가기 때문에 액세스가 느리다. 두번째, 매개변수는 지역변수이지만, 재귀함수처럼 호출이 잦다면 해당 매개변수를 할당하고 해제하는 작업을 반복하면서 느려질 것이다. 첫번째 의견에 대해서는 지역변수의 액세스보다 전역변수의 액세스가 느리다는 것은 대충 ‘그렇게 들었다~’ 수준으로 알고 있었다. 두번째 의견은 컴퓨터 구조를 공부하며 어셈블리 코드에 대해서도 아주 살짝 공부를 했었는데, 함수를 호출하는 부분에서 매개변수의 할당과 해제에 대한 어셈블리 코드가 없다는 것은 알고 있었다. 그렇기 때문에 ‘함수의 호출이 잦아도 매개변수의 할당과 해제로 실행속도가 느려지거나 하진 않을 것이다.’  라는 결론을 내렸지만, 이 의견이 맞는지 조금 불안했다.   전역변수와 지역변수의 저장 위치  구글링의 결과, 전역변수와 함수로 인해서 호출된 지역변수는 모두 메모리에 위치한다. 하지만, 전역변수는 메모리에서 상대적으로 낮은 위치인 데이터 영역에 저장되고, 지역변수는 상대적으로 높은 위치인 스택 영역에 저장된다. 데이터 영역은 프로그램 끝나기 전까지 해제되지 않고, 스택 영역은 해당 함수가 리턴되면 해제된다. 또한 데이터 영역보다 스택 영역의 액세스가 빠르다.   캐시 적중  해당 데이터가 캐시 위에 올라와 있을 확률은 최근에 사용된 적이 있는 지역 변수쪽이 전역 변수쪽보다는 높다. 전역 변수는 비슷한 위치의 주소공간에 존재한다는 보장이 없다.  반대로 지역변수의 경우는 스택에 쌓이기 때문에, 모두 비슷한 위치에 존재한다. 결국 지역변수들은 한 캐시 블록 안에 올라가 있을 확률이 매우 높다.   컴파일러 최적화  C언어 기준으로, 전역 변수는 최적화에 불리하다. 전역 변수는 언제 그 값이 변경되는지 알 수 없기 때문에, 컴파일러가 최적화를 진행할 때 전역 변수를 제거하지 않는다. 즉, 컴파일러가 사용자의 의도를 모르기 때문에, 최적화를 하지 못하고 그대로 코드를 남겨둔다.   결론 : 매개변수가 전역변수보다 빠르다.  물론 모든 상황에서 매개변수로 전달하는 것이 전역변수보다 빠르지 않을 수 있다. 특정 블로그에서 실험했을 때 매개변수로 전달된 변수들을 전역변수로 변경하니 실행 시간이 2배 정도 향상되었다고 한다. 하지만, 최적화를 위해서 전역변수를 사용하는 것은 잘못된 방법이며, 더 적절한 알고리즘과 자료구조를 사용하는 것이 옳다. 물론 간단한 코드에서 전역변수로 전달을 하냐 매개변수로 전달을 하냐에 대해 아주 미미한 속도 차이 혹은 차이가 없을 수도 있겠지만, 항상 이러한 생각을 가지며 혹시 모를 병목 현상을 예방하는 것이 더 나은 프로그래머가 될 수 있는 길이라고 생각한다.  ","categories": ["CS"],
        "tags": ["CS"],
        "url": "/cs/csetc_01/",
        "teaser": null
      },{
        "title": "[이코테/Python] DFS/BFS - 음료수 얼려 먹기",
        "excerpt":"이코테   DFS/BFS 음료수 얼려 먹기(Python)   문제   N x M 크기의 얼음 틀이 있다.  구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.  구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있을 경우 서로 연결되어 있는 것으로 간주한다.  이때 생성할 수 있는 총 얼음의 개수를 구하라.      예시    입력 :           [0,0,1,1,0]          [0,0,0,1,1]          [1,1,1,1,1]          [0,0,0,0,0]  결과 : 3   풀이     이 문제는 0이 연결되어 있는 부분들을 모두 찾아야된다. 그렇기 때문에 하나에서 연결된 부분의 끝까지 탐색하는 DFS(깊이우선탐색) 방법으로 접근하면 쉽게 풀 수 있다.       문제의 입력으로 주어진 그래프를 2중 반복문을 사용하여 모든 인자값을 탐색한다.   dfs 함수를 호출하여 해당 인자값으로부터 시작해서 얼음틀이 어디까지 연결되어 있는지를 체크한 후 1로 변경한뒤 전체 결과값에서 +1을 해준다.   dfs 함수는 재귀함수 형식으로 호출되며, 탐색을 시작한 값에서 상,하,좌,우 를 탐색하는 방식으로 dfs 함수를 재귀로 호출하여 체크해준다.   새로 알게된 문법     새로 알게된 ‘문법’ 까지는 아니지만, DFS/BFS를 배울 때 해당 예시로 그려진 그래프와 같은 그래프에만 적용되는 줄 알았다. 하지만 해당 문제 처럼 상하좌우를 강제적으로(ex.[x-1,y],[x,y+1]) 형식으로 조회하여 찾을 수 있다는 것을 알게 되었다. 하지만 이렇게 풀 경우 반복문을 세번이나 돌게 되면서 n^3인데 시간초과가 나지 않는 것이 조금 신기하다… 해당 부분은 조금 더 공부가 필요해보인다.    코드       def solution(graph):         result = 0         for i in range(len(graph)):             for j in range(len(graph[0])):                 # 현재 위치에서 DFS 수행                 if dfs(i, j, graph) == True:                     result += 1              print(result)               def dfs(x, y, graph):              # 주어진 범위를 벗어나는 경우에는 즉시 종료         if x &lt;= -1 or x &gt;= len(graph) or y &lt;= -1 or y &gt;= len(graph[0]):             return False              # 현재 노드를 아직 방문하지 않았다면         if graph[x][y] == 0:             graph[x][y] = 1             dfs(x-1, y, graph)             dfs(x, y-1, graph)             dfs(x+1, y, graph)             dfs(x, y+1, graph)             return True              return False               if __name__ == \"__main__\":         graph = [             [0,0,1,1,0],             [0,0,0,1,1],             [1,1,1,1,1],             [0,0,0,0,0]         ]              solution(graph) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_07/",
        "teaser": null
      },{
        "title": "[이코테/Python] DFS/BFS - 미로 탈출",
        "excerpt":"이코테   DFS/BFS 미로 탈출(Python)   문제   N x M 크기의 미로가 있다.  몬스터가 있는 곳은 0, 몬스터가 없는 곳은 1로 표시된다.  몬스터를 피해서 (0,0) 좌표에서 (N,M) 좌표까지 탈출해야한다.  이때 탈출까지의 최단 거리를 구하여라.      예시    입력 :       [1,0,1,0,1,0]      [1,0,1,1,1,1]      [1,0,1,1,1,0]      [1,0,1,0,1,0]      [1,1,1,0,1,1]  결과 : 14   풀이     이 문제는 1이 연결된 길을 찾으면 되는 문제이다. 최단 거리를 구하기 위해서 현재 위치에서 근접한 1의 위치를 찾으면 된다. 그렇기 때문에 BFS로 접근하였다. 하지만, 관건은 근접한 1의 위치를 찾고 최단거리를 계산하는 방법이다. 1을 만나게 되면, 이전 노드의 정보를 더해주는 방식으로 (1,1) 좌표에서 특정 노드까지의 최단거리를 모두 저장해주면 된다. 이후 (N,M)에 저장되어 있는 정보를 출력하면 된다.    solution1     탐색하기 위해 노드를 저장하는 deque 변수를 선언한다.            deque는 (x좌표,y좌표,해당노드까지의 최단 거리) 가 tuple 형식으로 저장된다.           deque가 비게 되면 탈출하게 되는 while문을 선언한다.   반복문을 돌며 첫번째로 deque를 pop하여 각각 x,y,v에 저장한다.   x와 y가 0보다 작거나 graph의 크기를 벗어나면 continue 해준다.   graph의 x, y좌표가 1이라면, 해당 노드에 v 값을 더해준다.   이후 deque에 해당 좌표 기준 상,하,좌,우 값을 추가하여 탐색할 수 있게 설정한다.   반복문이 끝나면 graph의 N,M 좌표에 해당하는 value를 return한다.   solution2     solution1과 로직은 같지만, solution2는 상하좌우를 배열에 저장하였고, 큐에는 x와 y좌표만 저장해두었다.    코드       from collections import deque          def solution1(graph):         queue = deque([(0,0,0)])         n = len(graph)         m = len(graph[0])              while queue:             x,y,v = queue.popleft()             if x&gt;=n or y&gt;=m or x&lt;0 or y&lt;0:                 continue             if graph[x][y] == 1:                 graph[x][y] += v                 queue.append((x+1, y, graph[x][y]))                 queue.append((x, y+1, graph[x][y]))                 queue.append((x-1, y, graph[x][y]))                 queue.append((x, y-1, graph[x][y]))              return graph[n-1][m-1]               def solution2(graph):         # 이동할 네 방향 정의(상, 하, 좌, 우)         dx = [-1, 1, 0, 0]         dy = [0, 0, -1, 1]              # graph 크기 정의         n = len(graph)         m = len(graph[0])              # BFS 소스코드 구현         def bfs(x, y):                  # 큐(Queue) 구현을 위해 deque 라이브러리 사용             queue = deque()             queue.append((x, y))                  # 큐가 빌 때까지 반복             while queue:                 x, y = queue.popleft()                 # 현재 위치에서 네 방향으로의 위치 확인                 for i in range(4):                     nx = x + dx[i]                     ny = y + dy[i]                     # 미로 찾기 공간을 벗어난 경우 무시                     if nx &lt; 0 or ny &lt; 0 or nx &gt;= n or ny &gt;= m:                         continue                     # 벽인 경우 무시                     if graph[nx][ny] == 0:                         continue                     # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록                     if graph[nx][ny] == 1:                         graph[nx][ny] = graph[x][y] + 1                         queue.append((nx, ny))                  # 가장 오른쪽 아래까지의 최단 거리 반환             return graph[n - 1][m - 1]                  return bfs(0,0)          if __name__ == \"__main__\":         graph = [             [1,0,1,0,1,0],             [1,0,1,1,1,1],             [1,0,1,1,1,0],             [1,0,1,0,1,0],             [1,1,1,0,1,1]         ]         print(solution1(graph)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_08/",
        "teaser": null
      },{
        "title": "[이코테/Python] 이진 탐색 - 부품 찾기",
        "excerpt":"이코테   이진탐색 부품 찾기(Python)   문제   전자 매장에는 부품이 N개 있다.   어느날 손님이 M개 종류의 부품을 구매하려고 한다.   이 때 매장에서 손님이 사려고 하는 부품이 있는지 yes와 no 형태로 구하라.      예시   입력 :           array = [9, 3, 7, 9, 2]           target = [5, 7, 9]   결과 : no yes yes   풀이     탐색시간을 줄이기 위해서는 array를 정렬하고 이진 탐색으로 target에 저장된 배열의 인자를 하나씩 탐색해나가면 쉽게 풀 수 있다.       array를 내림차순으로 정렬   target 배열의 인자를 하나씩 꺼내서 target으로 설정   array의 end가 start보다 크거나 같을 동안 while문 반복   이진탐색 알고리즘을 사용하여 탐색이 완료되면 Yes, 탐색이 되지 않으면 while 문 밖에서 No(No 저장 때 array[mid]가 t가 아닐 때의 조건을 걸어 둔 이유는 무차별적으로 No가 저장되는 것을 방지하기 위함)   다른 풀이     이진탐색 뿐만 아니라, count sorting, set 자료형을 사용하여 풀 수 있다. set 자료형은 {} &lt;- 로 array를 묶어 target in {} 문법을 사용하여 쉽게 풀 수 있다.    코드       def solution(array, target, start, end):         array.sort()         result = []         for t in target:             while start &lt;= end:                 mid = (start + end) // 2                 if array[mid] == t:                    result.append(\"Yes\")                    break                 elif array[mid] &gt; t:                     end = mid - 1                 else:                     start = mid + 1             if array[mid] != t:                 result.append(\"No\")             start = 0             end = len(array)-1              return result               def solution2(array, target):         def binary_search(array, target, start, end):             while start &lt;= end:                 mid = (start + end) //2                 if array[mid] == target:                     return mid                 elif array[mid] &gt; target:                     end = mid - 1                 else:                     start = mid + 1                  return None              store = []              for i in target:             result = binary_search(array, i, 0, len(array)-1)             if result != None:                 store.append(\"Yes\")             else:                 store.append(\"No\")              return store               if __name__ == \"__main__\":         array = [9, 3, 7, 9, 2]         target = [5, 7, 9]         print(solution(array, target, 0, len(array)-1)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_09/",
        "teaser": null
      },{
        "title": "[이코테/Python] 이진 탐색 - 나무 자르기",
        "excerpt":"이코테   이진탐색 나무 자르기(Python)   문제   문제로 이동!   풀이     나무를 자를 수 있는 길이는 0부터 가장 긴 나무의 길이다. 0~가장 긴 나무 길이를 이진 탐색을 하며 잘려진 나무의 합이 목표 길이보다 크다면 자른 길이를 저장한다. 최대값을 구하기 위해서 탐색이 종료될 때까지 조건에 맞는 길이를 찾아간다.       나무 길이의 최대 값을 찾는다.   start는 0, end는 나무 길이의 최대 값으로 설정한다.   중간 값을 찾고, 나무 길이 - 중간 값을 리스트 컴프리헨션으로 음수가 되는 값은 0으로 변경하여 전체 합을 구한다.   전체합과 target을 비교하여 전체합 보다 target이 작거나 같으면 결과에 중간값을 저장한다.   탐색이 끝날 때 까지 반복하며 최대 값을 구한다.   추가 설명     해당 문제는 전형적인 이진 탐색 문제이자, 파라메트릭 서치parametric search 유형의 문제라고 한다. “원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제”에 주로 사용한다. 예를 들어 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진 탐색으로 결정 문제를 해결하며 범위를 좁혀갈 수 있다.    코드            def solution(array, target):         end = max(array)         return binary_search(array, target, 0, end)               def binary_search(array, target, start, end):         result = 0         while start &lt;= end:             mid = (start + end) // 2             total = sum([0 if i-mid &lt; 0 else i-mid for i in array])             if total &lt; target:                 end = mid - 1             else:                 result = mid                 start = mid + 1              return result          if __name__ == \"__main__\":         target = 6         array = [19, 15, 10, 17]         print(solution(array, target)) ","categories": ["이코테"],
        "tags": ["Algorithm","Python","이코테"],
        "url": "/%EC%9D%B4%EC%BD%94%ED%85%8C/this_10/",
        "teaser": null
      },{
        "title": "[DataEngineering] 첫 번째 데이터엔지니어 인턴 회고",
        "excerpt":"첫 회사 생활  4학년 1학기에 졸업작품을 마치고 현업을 경험하고 싶어 인턴을 지원했다. 그 때 당시에는 아직 세세한 직무를 정하지 않아서, 평소에 관심 있던 백엔드와 데이터엔지니어 두 분야에 지원했다. 둘 중 더 좋은 조건의 인턴을 붙게 된다면 해당 직무를 경험해보자는 생각이였다. 지원은 많이 했지만, 코테 준비가 미흡해서 면접까지 간 회사는 거의 없었다. 코테를 보지 않는 회사 중 두 곳을 면접을 보게 되었는데, 첫 번째 회사의 면접 경험은 정말 최악이었다. 두 번째 회사의 면접은 정말 마음에 들었다. 내가 했던 프로젝트에 대해서 상세하게 질문이 들어왔고, 꼬리에 꼬리를 무는 질문이 많았다. 면접을 하면서도 내가 부족한 부분이 무엇인지 더 공부해야할 부분들을 알게 되는 신기한 경험을 하게 되었다. 면접을 진행하면서 모르겠다고 답변했던 것들 투성이여서 그 때 당시 내 현주소도 알게 되면서 조금 부끄러웠던 것 같다. (졸업작품을 막 끝내고 더닝크루거의 우매한 봉우리에 위치 해  있었던 것 같다…)   1주일 뒤에 합격 통지를 받았고, 데이터엔지니어 챕터의 인턴으로 합류하게 되었다. 굉장히 설레면서도 무서웠다. 할 수 있는 것은 야매로 프로젝트를 했던 경험이 전부인데,  현업에 뛰어들어 내가 1인분 역할을 할 수 있을지 정말 미지수였다. 하지만, 평소에 궁금했던, 현업에서는 코딩을 어떻게 하는지, 어떤 프로젝트들을 맡아 진행하는지,  팀원들간의 의사소통은 어떻게 하는지 등등… 을 해결할 수 있어서 신나기도 했다.   좌절의 연속  인턴 생활을 하면서 내 자신이 프로그래머로서 너무나도 부족한 사람이구나를 여러번 깨달았다.   첫번째, 업무를 진행하기 위해서 환경세팅을 하는 모든 것이 어려웠다. 나는 R로 작성되어 있는 ETL 레거시 파일들을 python 으로 migration 하는 업무를 맡았다.  Docker를 사용해서 python 개발 환경을 구축해야 했고, git-secret 등록, git-secret을 등록하기 위해서 GPG Key 생성, SSH Key 생성, AWS MFA 설정 등등… 사용 방법이 작성되어 있는 문서를 봐도 쉽게 따라할 수 없는 것들이였다.   두번째, 챕터내의 전반적인 개발 프로세스를 따라하는 것이 어려웠다. 개발자들은 소통을 위한 tool을 굉장히 많이 사용하고 있었다. Slack 부터 사용해서 Notion, Jira, Ally, Github 등등… Slack을 통한 간단한 메세지와 Notion을 통한 문서화는 어렵지 않았지만, 새로운 task를 부여 받았을 때 Jira로 관리하는 것이 뭔가 어색하기도 해서  어렵게 느껴졌다. Jira를 사용할 때 문서를 작성하는 것도 어색했던 것 같다. 그리고 이러한 소통을 하면서 사용하는 단어들(예를들어 에픽, man month, OKR 등등…) 또한 처음 들어본 단어들이 많아서 의사소통을 하면서 처음에 적응하기 쉽지 않았다.   세번째, 사내에 다양한 세미나에 참여했는데, 반 이상은 이해하지 못했다. 가장 크게 좌절했던 부분이다. 다른 팀원들은 세미나 주제에 대해서 일정 시간동안 문서를 읽고  다양한 의견들을 서로 주고 받는데, 나는 문서를 읽으면서도 이해하지 못하는 것들이 태반이였고, 당연하지만 여러 의견들도 나누지 못했다. 여기서 나는 이론적으로도 실무적으로도 너무나도 부족한 개발자라는 것을 뼈저리게 느꼈다. 예를들어 우리 DE 챕터에서는 PostgreSQL을 사용했는데, 세미나 주제가 PostgreSQL의 인덱싱 알고리즘이였다. PostgreSQL 에서 인덱싱에 사용되는 여러 알고리즘들을 소개하고, 해당 방법들이 어떤 데이터에서 유용한지에 대한 공식 도큐멘테이션을 읽고 서로 의견을 나누는 세미나다. 하지만 나는  ‘인덱싱’ 이라는 개념 조차도 정확히 알고있지 못하는 상태였다.   마지막은 코딩이다. ETL을 작성하면서 python pandas를 가장 많이 사용하였는데, 코드 리뷰를 받으면서 내가 알지 못하는 문법들이 굉장히 많았고, 프로그램의 속도에 관해서  처음으로 고민을 시작하게 됐던 것 같다. Unittest를 작성하면서도 모르는 개념들 투성이였다. R로 작성되어 있는 코드를 실행하면서 실행결과를 비교해가면서 migration 했는데, 코딩 속도도 굉장히 만족스럽지 못했고, Terminal 안에서 파일들을 열고 수정하는 부분들도 부족함을 많이 느꼈다. &lt;- 이 부분에 대해서 얘기하고 싶은 것이 하나 있는데, 같은 팀원이 했던 얘기가 굉장히 인상 깊었다. “GUI 툴로는 사용자가 원하는 만큼 접근할 수 없다. 프로그램에 컨트롤 당하면 안되고 프로그램 위에서 컨트롤 할 줄 알아야 한다.”  GUI 툴에서 지원하는 기능에 너무 기대지 않고 직접 해당 기능들을 만질 수 있어야 된다는 의미 같다.   어깨 너머로 배운 것들  좌절도 많이 했지만, 독학으로는 배우지 못했던 것들을 어깨 너머로 많이 배운 것 같다. 내가 맡았던 업무에 대한 프로세스를 간단히 얘기해보자면,  레포 세팅을 하면서 webhook과 git-secret, AWS, GPG 를 secret action에 등록해준다. Docker로 해당 task의 환경을 세팅해주고, Dockerfile을 빌드하기 전에 AWS ECR 레포와 DB 환경 변수를 추가해주고 빌드를 진행한다. ETL과 Unittest를 모두 작성하면 해당 파일에 lint를 적용해 일정 점수 이상을 받게 되면 black 과 isort로 한번 더 파일을 정리해준다. 이후에 work branch 에서 test branch로 merge하게 되면, Git Action에서 CI/CD가 자동으로 돌고 AWS ECR에 생성했둔 레포에 해당 ETL 파일의 이미지가 저장된다. 해당 이미지를 가지고 Airflow에 Dag를 작성해 배포해준다.   ETL 프로세스에 대해 전반적으로 배울 수 있었던 것 같다. 추가적으로 공부하고 싶은 부분이 있다면, ETL과 unittest 작성 부분을 제외하고 나머지 모두 다이다. 나 혼자서 CI/CD를 자동으로 구축해보고 싶고, Airflow를 구축해서 자동으로 배포도 해보고 싶다. 또한 Dockerfile을 만들어 python 개발 환경을 구축해보고 싶다.     위의 것들은 개인 프로젝트로 진행해볼 예정이다! 위의 것들을 적용시키기 위한 좋은 아이디어를 생각중이다…    또한 팀내 다양한 문서와 세미나를 통해 데이터엔지니어가 알고 있어야할 개념들을 많이 알게 되었다. 입사하기 전에는 데이터웨어하우스의 개념조차도 몰랐었던걸 비교하면  굉장히 다양한 개념(딱 개념 수준정도만…)을 알게 된 것 같다.   앞으로의 방향성  어쩌다보니 다음 목적지도 데이터엔지니어로 정하게 됐다. 인턴을 하면서 부족했던 CS 지식들은 독학으로 채워가고 있다. 어느정도 CS 공부가 마무리 되면(공부에 마무리는 없지만…) 개인 프로젝트를 진행하면서 인턴 생활을 하면서 직간접적으로 배웠던 것들을 직접 적용해볼 생각이다. 또한 데이터엔지니어 과정의 국비교육도 수강할 계획에 있다. 앞으로 신입 데이터엔지니어가 되기 위해 필요한 지식들을 하나씩 쌓아가면서 든든한 데이터엔지니어가 되어보겠다.   ","categories": ["DataEngineering"],
        "tags": ["DataEngineering"],
        "url": "/dataengineering/de_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 07 링커",
        "excerpt":"Chapter 07. 링커     링킹은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파이로 만드는 작업이다.            링킹은 컴파일 시에 수행할 수 있다.       로더에 의해 로드 타임에, 응용프로그램에 의해 실행 시에도 수행될 수 있다.           링커는 소프트웨어 개발 시에 중요한 역할: 독립적인 컴파일을 가능하게 하기 때문이다.   링커를 배우는 이유            큰 프로그램을 작성하는 데 도움이 된다.       위험한 프로그래밍 에러를 피할 수 있다.       어떻게 언어의 변수 영역 규칙이 구현되었는지 이해하는 데 도움이 된다.       다른 중요한 시스템 개념을 이해할 수 있게 된다.       공유 라이브러리에 대해 이해할 수 있다.           7.1 컴파일러 드라이버     대부분의 컴파일 시스템은 사용자를 대신해서 언어 전처리기, 컴파일러, 어셈블러, 링커를 필요에 따라 호출하는 컴파일러 드라이버를 제공한다.   컴파일 순서            C 전처리기(cpp)로 main.c -&gt; ASCII 중간 파일인 main.i로 번역       C 컴파일러(cc1)로 main.i -&gt; ASCII 어셈블리 언어 파일인 main.s로 번역       어셈블러(as)로 main.s -&gt; 재배치 가능한 바이너리 목적파일인 main.o로 번역       링커(ld)로 main.o &amp; sum.o 두개를 연결 -&gt; 실행 가능 목적파일 prog 생성       로더라고 부르는 운영체제 내의 함수를 호출 -&gt; 로더는 실행파일 prog의 코드와 데이터를 메모리로 복사하고, 제어를 프로그램의 시작 부분으로 전환한다.              7.2 정적연결     정적 링커는 재배치 가능한 목적파일들과 명령줄 인자들을 받아들여 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 생성한다.   실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행한다.            심볼 해석 symbol resolutions: 각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결하는 것이다.       재배치 Relocation: 링커는 섹션들을 각 심볼 정의와 연결시켜 재배치한다.           7.3 목적파일     세가지 목적파일이 있다.            재배치 가능 목적파일 Relocatable object file: 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함       실행 가능 목적파일 Executable object file: 메모리에 직접 복사될 수 있고 실행될 수 있음       공유 목적파일 Shared object file: 로드타임 또는 런타임 시에 동적으로 링크되고 로드될 수 있는 목적파일           컴파일러와 어셈블러는 재배치 가능 목적파일을 생성, 링커는 실행 가능한 목적파일을 생성   7.4 재배치 가능 목적파일        위의 그림은 전형적인 ELF(Executable and Linkable Format) 재배치 가능 목적파일의 포맷이다.            .text: 컴파일된 프로그램의 머신 코드       .rodata: printf 문장의 포맷 스트링       .data: 초기화된 전역변수 및 정적변수       .bss: 초기화되지 않은 또는 0으로 초기화된 전역변수 및 정적변수       .symtab: 프로그램에서 정의되고 참조되는 전역변수들과 함수에 대한 정보를 가지고 있는 심볼 테이블       .rel.text: 다른 목적 파일들과 연결할 때 링커가 수정해야하는 .text 섹션 내 위치들의 리스트       .rel.data: 전역변수들에 대한 재배치 정보       .debug: 프로그램 내에서 정의된 지역변수들과 typedef       .line: 최초 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑       .strtab: 섹션 이름들을 위한 스트링 테이블           7.5 심볼과 심볼 테이블     재배치 가능 목적 모듈 m은 m에 의해서 정의되고 참조되는 심볼들에 대한 정보를 포함하는 심볼 테이블을 가지고 있다.            m에 의해 정의되고 다른 모든 모듈들에 의해서 참조될 수 있는 전역 심볼                    전역                       m에 의해 참조되지만 다른 모듈에 의해 정의된 전역 심볼                    external                       m에 의해서 배타적으로 참조되고 정의된 지역 심볼                    static                              지역 변수는 런타임에 스택에 의해서 관리되며 링커에는 관심거리가 아니다.            .symtab 섹션의 ELF 심볼 테이블은 엔트리들의 배열을 포함하고 있다.             테이블 엔트리가 없는 의사 섹션pseudo section 이 존재한다.             ABS: 재배치해서는 안 되는 심볼       UNDEF: 정의되지 않은 심볼, 해당 모듈에서는 참조만 되고 다른 곳에서 정의된 심볼들을 위함       COMMON: 아직 할당되거나 초기화되지 않은 데이터 객체를 위함              COMMON: 초기화하지 않은 전역변수들, .bss: 초기화하지 않은 정적변수들과 0으로 초기화된 전역변수나 정적변수들    7.6 심볼 해석     링커는 자신의 입력 재배치 가능 목적파일들의 심볼 테이블로부터 정확히 한 개의 심볼 정의에 각 참조를 연결시켜서 심볼 참조를 해석한다.   컴파일러가 현재 모듈에서 정의되지 않은 심볼을 만나면, 다른 모듈에서 정의되어 있다고 가정하고 링커 심볼 테이블 엔트리를 생성하며, 링커가 이것을 처리하도록 남겨둔다.   7.6.1 링커가 중복으로 정의된 전역 심볼을 해결하는 방법     링커의 입력은 여러 개의 재배치 가능한 오브젝트 모듈들이다.            일부는 지역적이다(정의된 모듈 내에서만 볼 수 있는).       일부는 전역적이다(다른 모듈에서도 볼 수 있는).           컴파일러는 각 전역 심볼을 어셈블러로 강하게 또는 약하게 보내 심볼 테이블에 묵시적으로 인코딩하게 한다.            함수들과 초기화된 전역변수들은 강한 심볼       비초기화된 전역변수들은 약한 심볼이다.           링커는 중복된 심볼 이름을 처리하기 위해서 다음과 같은 규칙을 사용한다.            동일한 이름을 갖는 복수의 강한 심불은 허용 X       동일한 이름의 강한 심볼과 다수의 약한 심볼들이 있으면 강한 심볼 선택       동일한 이름의 여러 개의 약한 심볼이 있으면 어떤 약한 심볼을 선택해도 관계 X           7.6.2 정적 라이브러리와 링크하기     모든 컴파일 시스템은 관련된 객체 모듈들을 정적 라이브러리라고 부르는 한 개의 파일로 패키징하는 매커니즘을 제공한다.            이 라이브러리는 다음에 링커의 입력으로 제공될 수 있다.              컴파일러 개발자들이 라이브러리의 다양한 함수들을 정적 라이브러리의 혜택 없이 사용자들에게 재공하려면 컴파일러가 직접 함수의 코드를 생성하거나 한 개의 재배치 가능 목적 모듈에 저장하거나 해야한다. 하지만 이런 방법들은 상당한 복잡성을 더하거나 디스크 공간을 극도로 낭비한다. 위와 같은 접근 방법의 단점들을 해겨하기 위해 정적 라이브러리 개념이 개발되었다.         위 그림은 정적 라이브러리 연결 시 링커의 동작을 요약한 것이다.   7.6.3 링커가 참조를 해석하기 위해 정적 라이브러리를 사용하는 방법     링커는 실행파일을 구성하기 위해 합쳐질 재배치 가능 목적파일들의 집합 E, 미해석 집합 U, 이전 입력파일에서 정의된 심볼 집합 D를 유지한다.            입력파일 f에 대해서 링커는 f가 목적파일 또는 아카이브인지 결정한다.       f가 목적파일이면 f를 E에 추가하고 U와 D를 갱신한다.       f가 아카이브라면, 링커는 U 안의 미해석 심볼들을 아카이브의 멤버들에 의해 정의된 심볼들과 매칭하려고 시도한다.       심볼을 정의한다면 m은 E에 추가되고 U와 D를 갱신한다.       위 과정을 U와 D가 더 이상 바뀌지 않는 일정 지점까지 반복 실행한다.       스캔을 끝마칠 때 U가 비어있지 않다면 에러 출력, 그렇지 않다면 E에 있는 목적파일들을 합치고 재배치해서 출력 실행파일을 만든다.              위의 알고리즘은 명령줄의 라이브러리와 목적파일의 순서가 중요한 이유가 된다.    7.7 재배치     링커가 심볼 해석 단계를 완료하면, 코드 내 각 심볼 참조는 정확히 한 개의 심볼 정의에 연결된다.(입력 모듈 중 하나의 심볼 테이블 엔트리로 연결됨)   이후 재배치를 하게 된다. 재배치는 두 단계로 구성된다.            섹션과 심볼 정의를 재배치한다.       섹션 내 심볼 참조를 재배치한다.           7.7.1 재배치 엔트리     어셈블러가 목적 모듈을 생성할 때, 어셈블러는 코드와 데이터가 궁극적으로 메모리 어디에 저장될지 알지 못한다.            어셈블러가 위치를 알지 못하는 객체로의 참조를 만나면, 링커에게 이 참조를 어떻게 수정하는지 알려주는 재배치 엔트리를 생성한다.                 재배치 타입            R_X86_64_PC32: 32비트 PC-상대주소를 사용하는 참조를 재배치한다.       R_X86_64_32: 32비트 절대주소를 사용하는 참조를 재배치한다.           7.7.2 심볼 참조의 재배치        위의 그림은 링커의 재배치 알고리즘을 위한 의사코드이다.   7.8 실행 가능한 목적파일         실행 가능 목적파일의 포맷은 재배치 가능한 목적파일의 포맷과 유사하다.            .text, .rodata, .data 섹션들이 각자의 최종 런타임 메모리 주소로 재배치되었다.       _init는 프로그램의 초기화 코드에서 호출한다.       실행파일이 완전히 링크(재배치) 되었기 때문에, .rel 섹션을 필요로 하지 않는다.           ELF 실행파일들은 연속적인 메모리 세그멘트에 매핑된 연속적인 실행 가능 파일들의 덩어리로 메모리에 로드하기 쉽도록 설계되었다.            이 매핑은 프로그램 헤더 테이블에 설명되어 있다.           모든 세그먼트 s에 대해, 링커는 다음과 같이 시작주소를 선택해야 한다.            vaddr mod align = off mod align       align은 프로그램 헤더에 명시된 정렬(2^21 = 0x2000000)이다.       이러한 정렬 요구사항은 프로그램이 실행될 때 목적파일의 세그먼트들이 메모리로 효과적으로 전송될 수 있도록 하는 최적화의 결과다.                    가상메모리가 크기가 큰 연속된 2의 제곱 크기의 바이트 묶음으로 구성되어 있는 방식이기 때문이다.                           7.9 실행 가능 목적파일의 로딩     실행 가능 목적파일 prog를 실행한다.   쉘은 로더loader 라고 알려진 메모리 상주 운영체제 코드를 호출해서 prog를 실행한다.   로더는 디스크로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사한다.   해당 프로그램의 첫 번째 인스트럭션, 즉 엔트리 포인트로 점프해서 프로그램을 실행한다.        모든 실행 중인 리눅스 프로그램은 위의 그림과 유사한 런타임 메모리 이미지를 가진다.   7.10 공유 라이브러리로 동적 링크하기     정적 라이브러리들은 다른 모든 소프트웨어처럼 관리해야 하고 주기적으로 갱신해야한다.   공유 라이브러리들은 정적 라이브러리의 단점들을 극복한다.            공유 라이브러리는 런타임이나 로드타임에 임의의 메모리 주소에서 로드되고, 메모리에서 프로그램으로 연결될 수 있는 목적 모듈이다.       해당 과정을 동적 링킹이라고 한다.       리눅스 시스템에서 .so 확장자, 윈도우 시스템에서 DLL(dynamic link libraries)이라고 부른다.           공유 라이브러리들은 두 가지 다른 방법으로 “공유”된다.            어떤 주어진 파일 시스템에서, 특정 라이브러리에 대해 정확히 한 개의 .so 파일만이 존재한다.                    .so 파일 내의 코드와 데이터는 이 라이브러리를 참조하는 모든 실행 가능한 목적파일들에 의해 공유된다.                       메모리에 있는 공유 라이브러리의 .text 섹션은 서로 다른 실행중의 프로세스들에 의해 공유될 수 있다.                위의 그림은 공유 라이브러리로 동적 링크 과정을 요약한 것이다.   기본 아이디어는 링킹의 일부는 실행 가능 파일이 생성될 때 정적으로 수행하고, 프로그램이 로드될 때 링킹 작업을 동적으로 완료하는 것이다.   7.11 Applications 으로부터 공유 라이브러리를 로드하고 링크하기     응용프로그램이 돌고 있는 동안에 동적 링커에게 응용프로그램을 컴파일 시에 라이브러리와 링크할 필요 없이 임의의 공유 라이브러리를 로드하고 링크할 것을 요청할 수도 있다.   기본 아이디어는 공유 라이브러리에서 동적 콘텐츠를 생성하는 각 함수들을 패키지 하는 것이다.            서버는 동적으로 적당한 함수를 로드하고 링크한 뒤에 직접 호출한다.       함수는 서버의 주소공간에 캐시된 상태로 남으며, 후속 요청들은 간단한 함수 호출하는 비용만으로 처리될 수 있다.           7.12 위치-독립성 코드(PIC)     공유 라이브러리를 사용하는 주목적은 다수의 실행되고 있는 프로세스들이 메모리 내에서 동일한 라이브러리 코드를 공유하도록 하는 것이며, 귀중한 메모리 자원을 절약하는 것이다.            한 가지 접근 방법은 공유 라이브러리를 사전에 정해진 주소공간 블록에 할당 하는 것이다.                    단점 : 사용하지 않을 때도 할당, 메모리 블록들이 중첩되지 않도록 보장해줘야 함                           위의 문제점을 피하기 위해 공유 모듈들의 코드 일부분을 컴파일해서 링커에 의해 수정되지 않고도 이들이 메모리 어디든지 로드될 수 있도록 한다.            어떠한 재배치 작업 없이 로드될 수 있는 코드는 위치-독립성코드라고 한다.(PIC)              PIC와 GOT, PLT는 아직 이해를 하지 못해 좀 더 찾아보고 공부해야 한다.    7.13 라이브러리 삽입     컴파일 삽입   링크 삽입   런타임 삽입   7.14 요약     링킹은 컴파일 시에 정적 링커에 의해 수행될 수 있으며, 로드타임과 런타임에는 동적 링커에 의해 수행된다.   목적 파일들은 세 가지 형태로 나타난다.            재배치 가능: 정적 링커에 의해 실행 가능 목적파일로 연결       실행 가능: 메모리에 로드되고 실행       공유: 공유 라이브러리           링커의 두 가지 주요 임무            전역 심볼들이 유일한 정의에 연결되는 경우 심볼 해석       재배치 작업           로더는 실행파일의 내용을 메모리로 매핑하고 프로그램을 실행한다.   ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_23/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 08 예외적인 제어흐름",
        "excerpt":"Chapter 08. 예외적인 제어흐름     프로세서에서 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터는 연속된 값들을 가정한다.            인스트럭션 I에 대응되는 주소가 ak -&gt; ak+1 로의 전환은 제어이동이라고 부른다.       이러한 제어이동의 배열은 제어흐름 또는 프로세서의 제어흐름이라고 부른다.           프로그램의 실행과는 반드시 관련되어 있지 않은 시스템 상태의 변화에도 반응할 수 있어야 한다.            현대의 시스템들은 갑작스런 변화를 만드는 방법으로 이러한 상황에 반응한다.       일반적으로 이와 같은 급격한 변화를 예외적인 제어흐름exceptional control flow(ECF)라고 한다.           ECF의 중요성            ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.       ECF를 이해하면 어떻게 application들이 운영체제와 상호작용하는지를 이해할 수 있다.       ECF는 컴퓨터 시스템에서 동시성을 구현하는 기본 메커니즘이다.       ECF를 이해하면소프트웨어적인 예외상황이 어떻게 동작하는지 이해할 수 있다.              7장까지는 시스템에 대한 application이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다. 98장은 application이 운영체제와 어떻게 상호작용하는지 배우게 되는 측면에서 전환점이라고 볼 수 있다.       컴퓨터 수준에 존재하는 ECF의 다양한 형태            하드웨어와 운영체제의 교차점에 놓인 예외       application에게 운영체제 내부로 엔트리 포인트를 제공하는 예외인 시스템콜       application과 운영체제의 교차점에 위치한 프로세스와 시그널       비지역성 점프 - ECF의 응용수준           8.1 예외상황     예외상황은 부분적으로는 하드웨어와 운영체제에 의해서 구현된 예외적인 제어흐름의 한가지 형태다.        위의 그림은 예외상황의 기본 아이디어다.   프로세서가 이벤트(상태 변화)가 발생했다는 것을 감지하면, 예외 테이블이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 간접 프로시저 콜을 하게 된다.   예외처리 핸들러가 처리를 끝마치면, 다음 세 가지 중의 한 가지 일을 발생한다.            핸들러는 제어를 현재 인스트럭션으로 돌려준다.       핸들러는 제어를 다음 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션으로 돌려준다.       핸들러는 중단된 프로그램을 종료한다.           8.1.1 예외처리     한 시스템 내에서 가능한 예외상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다.   시스템 부팅 시, 운영체제는 예외 테이블이라고 하는 점프 테이블을 할당하고 초기화해서 엔트리 k가 예외상황 k에 대한 핸들러의 주소를 갖는다.   런타임에 프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다.   k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다.   예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작 주소는 ‘예외 테이블 베이스 레지스터’라는 특별한 CPU 레지스터에 저장되어 있다.             위의 그림은 예외테이블이다.            예외상황과 프로시저 콜의 차이점             프로시저 콜: 스택에 리턴주소 푸시, 예외상황: 현재 또는 다음 인스트럭션       핸들러가 리턴할 때 중단된 프로그램을 다시 시작하기 위해 스택 상에 추가적인 프로세서 상태를 푸시한다.       모든 아이템들은 사용자 스택 위가 아니라 커널 스택 상에 푸시된다.       예외 핸들러는 ‘커널 모드’에서 돌아간다.           8.1.2 예외의 종류     예외상황은 네 가지 종류를 구분할 수 있다.            인터럽트       트랩       오류fault       중단abort           인터럽트     프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 비동기적으로 발생한다.(특정 인스트럭션을 싫애해서 발생한 것이 아니라는 의미)   핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.      인터럽트를 제외한 나머지 예외의 종류들은 동기적으로 일어난다.    트랩과 시스템 콜     의도적인 예외상황으로, 어떤 인스트럭션을 실행한 결과로 발생한다.   트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다.   트랩의 가장 중요한 사용은 시스템콜이라고 알려진 사용자 프로그램과 커널 사이의 프로시저와 유사한 인터페이스를 제공하는 것이다.   시스템 콜은 ‘커널 모드’에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.   오류(fault는 error와 다르다.)     오류는 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생한다.   핸들러가 에러 조건을 정정한다면, 제어를 오류를 발생시킨 인스트럭션으로 돌려주어 거기서부터 재실행한다.   정정하지 못한다면, 커널 내부의 abort 루틴으로 리턴해서 프로그램을 종료한다.   중단 abort     중단 핸들러는 절대로 응용프로그램으로 제어를 리턴하지 않는다.   8.1.3 리눅스/x86-64 시스템에서의 예외상황   오류와 중단     나누기 에러: 0으로 나누려할 때   일반 보호 오류: 프로그램이 가상메모리의 정의되지 않은 영역을 참조하거나 read-only를 쓰려고 하기 때문에 발생   페이지 오류: 가상메모리 페이지 오류   머신 체크: 오류 인스트럭션을 실행하는 동안에 검출된 치명적인 하드웨 에러의 결과로 발생   시스템 콜     리눅스는 파일을 읽거나 쓸 때, 또는 새로운 프로세스를 만들 때 응용프로그램이 사용할 수 있는 수백 개의 시스템 콜을 제공한다.   x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해서 제공된다.        위의 그림은 리눅스 x86-64 시스템의 주요 시스템 콜   8.2 프로세스     예외상황은 프로세스 개념을 운영체제 커널이 제공할 수 있게 하는 기본 구성 블록이다.   프로세스의 고전적인 정의는 실행 프로그램의 인스턴스이다.   시스템 내의 각 프로그램은 어떤 프로세스의 문맥context에서 돌아간다.   사용자가 실행 목적파일의 이름을 쉘에 입력해서 프로그램을 돌릴 때마다 쉘은 새로운 프로세스를 생성하고, 실행 목적파일을 이 새로운 프로세스의 문맥에서 실행한다.   프로세스가 application에 제공하는 주요 추상화            프로세서를 혼자서 사용한다는 착각을 제공하는 독립적 논리 제어 흐름       혼자서 메모리 시스템을 가진다는 착각을 제공하는 사적 주소공간           8.2.1 논리적인 제어흐름     논리흐름            프로그램과 동적으로 런타임에 링크된 공유 객체 내의 인스트럭션들에게 일련의 프로그램 카운터 PC 값들이 대응된다는 것을 관찰할 수 있다.       이러한 PC 값들의 배열을 논리적 제어흐름 또는 논리흐름이라고 부른다.                위의 그림은 논리적 제어흐름이다.            하나의 프로세서를 사용해서 여러 프로세스들이 교대로 돌아간다.           8.2.2 동시성 흐름     논리흐름은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 갖는다.            예외 핸들러, 프로세스, 시그널 핸들러, 쓰레드, 자바 프로세스는 모두 논리흐름의 예다.           자신의 실행시간이 다른 흐름과 겹치는 논리흐름을 동시성 흐름이라고 부른다.   동시성: 공동으로 실행되는 흐름의 일반적인 현상   멀티태스킹: 프로세스가 다른 프로세스들과 교대로 실행된다는 개념   타임 슬라이스: 프로세스가 자신의 흐름 일부를 실행하는 매 시간 주기      두 개의 흐름이 서로 다른 프로세서 코어나 컴퓨터에서 동시에 돌아간다면, 이것은 병렬 흐름 이라고 한다.    8.2.3 사적 주소공간     프로세스는 각 프로그램에 자신이 시스템의 주소공간을 혼자서 사용한다는 착각을 불러일으킨다.   프로세스는 각 프로그램에 자신만의 사적 주소공간을 제공한다.            이 공간의 특정 주소에 연결된 메모리의 한 개의 바이트가 일반적으로 다른 프로세스에 의해서 읽히거나 쓰일 수 없다는 의미로 이 공간은 사적이다.                위의 그림은 프로세스 주소공간이다.   8.2.4 사용자 및 커널 모드     운영체제가 완벽한 프로세스 추상화를 제공하기 위해서 프로세서는 응용프로그램이 접근할 수 있는 주소공간 뿐만 아니라 응용프로그램이 실행할 수 있는 인스트럭션들을 제한하는 메커니즘을 제공해야한다.   커널 모드에서 돌고 있는 프로세스는 인스트럭션 집합의 어떤 인스트럭션도 실행할 수 있으며, 시스템 내의 어떤 메모리 위치도 접근할 수 있다.   예외가 발생해서 제어가 예외 핸들러로 넘어가면, 프로세서는 사용자 모드에서 커널 모드로 변경한다.            핸들러는 커널 모드에서 돌아간다.           8.2.5 문맥 전환     운영체제 커널은 문맥 전환context switch 이라고 알려진 예외적인 제어흐름의 상위수준 형태를 사용해서 멀티태스킹을 구현하고 있다.   커널은 각 프로세스마다 컨텍스트를 유지한다. 컨텍스트는 커널이 선점된 프로세스를 다시 시작하기 위해서 필요로 하는 상태다.             위의 그림은 프로세스 문맥 전환의 분석이다.       스케줄링            커널은 프로세서가 실행되는 동안의 어떤 시점에 현재 프로세스를 선점하고 이전에 선점된 프로세스를 다시 시작할 것을 결정한다       스케줄러라고 불리는 커널 내부의 코드에 의해 처리된다.       커널이 실행할 새 프로세스를 선택할 때 커널이 그 프로세스를 스케줄 했다고 말한다.           문맥 전환            커널이 실행할 새 프로세스를 스케줄한 후에 현재 프로세스를 선점하는 것을 말한다.           문맥 전환의 수행 절차            현재 프로세스의 컨텍스트를 저장한다.       이전에 선점된(일시적으로 정지된) 프로세스의 저장된 컨텍스트를 복원한다.       제어를 이 새롭게 복원된 프로세스로 전달한다.           8.3 시스템 콜의 에러 처리     Unix의 시스템 수준 함수가 에러를 만날 때 이들은 대개 -1을 리턴하고, 전역 정수 변수인 errno를 세팅해서 무엇이 잘못되었는지를 나타낸다.   8.4 프로세스의 제어     Unix는 C 프로그램으로부터 프로세스를 제어하기 위한 많은 시스템 콜을 제공한다.   8.4.1 프로세스 ID 가져오기          각각의 프로세스는 고유의 양수 프로세스 ID(PID)를 가진다.       getpid 함수는 호출하는 함수의 PID를 리턴한다.   getppid 함수는 자신의 부모의 PID를 리턴한다.   8.4.2 프로세스의 생성과 종료     프로그래머의 관점에서 프로세느는 세 가지 상태가 존재한다.            실행중 running: 프로세스는 CPU에서 실행하고 있거나 실행을 기다리고 있다. 궁극적으로 커널에 의해서 스케줄될 것이다.       정지 stopped: 프로세스의 실행은 정지한 상태이고 스케줄되지 않는다.       종료 terminated: 프로세스는 영구적으로 정지된다.           exit 함수는 종료 상태 status로 프로세스를 종료한다.   fork 함수는 부모 프로세스가 자식 프로세스를 생성한다.            한 번 호출하고 두 번 리턴한다.(한 번은 부모가, 다른 한 번은 자식이)       동시 실행한다.(부모와 자식은 동시에 돌아가는 별도의 프로세스)       중복되었지만 별도의 주소공간이다.       파일을 공유한다.(자식이 부모가 오픈한 모든 파일들을 상속받음)           8.4.3 자식 프로세스의 청소     프로세스가 어떤 이유로 종료할 때, 커널은 시스템에서 즉시 제거하지 않는다.            부모가 청소할 때까지 종료된 상태로 남아 있는다.       부모가 종료된 자식을 청소할 때 커널은 자식의 exit 상태를 부모에게 전달 후 종료된 프로세스를 없앤다. 이 때 프로세스가 사라진다.       종료되었지만 아직 청소되지 않은 프로세스를 좀비라고 한다.           waitpid 함수는 자신의 자식들이 종료되거나 정지되기를 기다린다.   wait 함수는 waitpid의 단순화된 버전이다   8.4.4 프로세스 재우기     sleep 함수는 일정 기간 동안 프로세스를 정지시킨다.   pause 함수는 호출하는 함수를 시그널이 프로세스에 의해 수신될 때까지 잠을 재운다.   8.4.5 프로그램의 로딩과 실행     execve 함수는 현재 프로그램의 컨텍스트 내에서 새로운 프로그램을 로드하고 실행한다.   8.5 시그널     리눅스 시그널이라고 알려진 상위수준의 소프트웨어 형태의 예외적 제어흐름을 배운다.            해당 시그널은 프로세스와 커널이 다른 프로세스를 중단하도록 한다.           시그널            작은 메시지 형태로, 프로세스에게 시스템 내에 어떤 종류의 이벤트가 일어났다는 것을 알려준다.                위의 그림은 리눅스 시스템에서 지원되는 30개의 서로 다른 종류의 시그널을 보여준다.   8.5.1 시그널 용어     시그널을 목적지 프로세스로 전달하는 것은 두 단계로 이루어진다:            시그널 보내기: 커널은 목적지 프로세스의 컨텍스트 내에 있는 일부 상태를 갱신해서 시그널을 목적지 프로세스로 보낸다(배달한다).       시그널 받기: 목적지 프로세스는 배달된 신호에 대해서 커널이 어떤 방식으로 반응해야 할 때 목적지 프로세스는 시그널을 받는다.ㅜ           펜딩pending 시그널: 보내졌지만 아직 받지 않은 시그널   8.5.2 시그널 보내기     Unix 시스템은 시그널을 프로세스로 보내는 여러가지 메커니즘을 제공한다.            모든 메커니즘은 프로세스 그룹 개념을 사용한다.           프로세스 그룹          모든 프로세스는 정확히 한 개의 프로세스 그룹에 속한다.       getpgrp 함수는 현재 프로세스의 프로세스 그룹 ID를 리턴한다.   setpgid 함수는 프로세스 pid의 프로세스 그룹을 pgid로 변경한다.   시그널을 /bin/kill 프로그램을 사용해서 보내기     /bin/kill -9 15213: 시그널 9번(SIGKILL)을 프로세스 15213에 보낸다.   /bin/kill -9 -15213: SIGKILL 시그널이 프로세스 그룹 15213 내의 모든 프로세스에게 보내지도록 한다. (음수 PID는 전체에게 보냄)   키보드에서 시그널 보내기     Ctrl+C를 입력하면 커널은 SIGINT 시그널을 포그라운드 프로세스 그룹에 속한 모든 프로세스에게 보낸다.   Ctrl+Z를 입력하면 마찬가지로 모든 프로세스에 SIGSTP 시그널을 보낸다.   kill 함수로 시그널 보내기     프로세스는 kill 함수를 호출해서 시그널을 다른 프로세스로 보낸다.   alarm 함수로 시그널 보내기     프로세스는 SIGALRM 시그널을 alarm 함수를 호출해서 자기 자신에게 보낼 수 있다.   8.5.3 시그널의 수신     커널이 프로세스 p를 커널 모드에서 사용자모드로 전환할 때, 커널은 프로세스 p에 대한 블록되지 않은 펜딩 시그널의 집합을 체크한다.            만일 이 집합이 비어 있다면, 커널은 제어를 p의 논리 제어흐름 내의 다음 인스트럭션으로 전달한다.       집합이 비어 있지 않다면, 커널은 집합 내 어떤 시그널 k를 선택해서 p가 시그널 k를 수신하도록 한다.           8.5.4 시그널 블록하기와 블록 해제하기     묵시적 블록 방법            기본적으로, 커널은 핸들러에 의해 처리되고 있는 유형의 모든 대기 시그널들의 처리를 막는다.           명시적 블록 방법            응용 프로그램들은 sigprocmak 함수와 이들의 도움함수를 이용해서 시그널들을 명시적으로 블록하거나 해제할 수 있다.           8.6 비지역성 점프     C는 비지역성 점프라고 부르는 사용자 수준의 예외적 제어흐름의 형태를 제공한다.            이것은 보통의 콜-리턴 순서를 통할 필요 없이 하나의 함수에서 현재 실행하고 있는 다른 함수로 제어를 이동한다.       setjmp와 longjmp 함수로 제공된다.           비지역성 점프의 중요한 응용은 심하게 중첩된 함 수콜에서, 어떤 에러 조건을 검출한 결과 즉시 리턴을 허용하는 것이다.            예를 들어, 에러 조건이 중첩된 함수 호출의 깊은 곳에서 발견되면, 콜 스택을 거꾸로 돌아가는 대신 공통의 지역적인 에러 핸들러로 직접 리턴하기 위해 사용한다.           8.7 요약     예외적 제어흐름 ECF는 컴퓨터 시스템의 모든 수준에서 일어나며, 컴퓨터 시스템에 동시성을 제공하는 기본 메커니즘이다.   운영체제 수준에서, 커널은 ECF를 사용해서 프로세스의 근본적인 개념을 제공한다.   프로세스는 응용프로그램에 두 개의 추상화를 제공한다:            각 프로그램에 자신이 프로세서를 혼자서 사용하고 있다는 착각을 느끼게 하는 논리적 제어흐름.       각 프로그램이 메인 메모리를 혼자서 사용하는 착각을 제공하는 사적 주소공간.              8.4 프로세스의 제어, 8.5.5 시그널 핸들러 작성하기 8.6 비지역성 점프 부분은 한번 더 꼭 읽어보자.    ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_24/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 09 가상메모리 (9.1물리 및 가상주소 방식 ~ 9.6주소의 번역)",
        "excerpt":"Chapter 09. 가상메모리     시스템의 프로세스들은 CPU와 메인 메모리를 다른 프로세스들과 공유한다.   메모리를 보다 효율적이고 더 적은 에러를 갖도록 관리하기 위해서 현대의 시스템은 가상메모리 virtual memory VM 이라고 알려진 메인 메모리의 추상화를 제공한다.   가상메모리는 각 프로세스에 하나의 크고 통합된, 사적 주소공간을 제공한다.   가상 메모리의 중요한 세가지 기능            메인 메모리를 디스크에 저장된 주소공간에 대한 캐시로 취급해서 메인 메모리 내 활성화 영역만 유지하고, 데이터를 디스크와 메모리 간에 필요에 따라 전송하는 방법으로 메인 메모리를 효율적을 ㅗ사용       각 프로세스에 주소공간을 제공함으로써 메모리 관리를 단순화한다.       각 프로세스의 주소공간을 다른 프로세스에 의한 손상으로부터 보호한다.              가상 메모리를 이해하면 어떻게 시스템이 일반적으로 동작하는지 더 잘 이해할 수 있으며, 가상메모리의 강력한 성능을 응용프로그램에 적용할 수 있다. 또한 가상메모리는  치명적인 에러를 발생시키는데 이를 방지할 수 있다.    9.1 물리 및 가상주소 방식     컴퓨터 시스템의 메인 메모리는 M개의 연속적인 바이트 크기 셀의 배열로 구성된다.   각 바이트는 고유의 물리 주소(PA physical address)를 가진다.        위의 그림은 물리 주소 방식이다.        위의 그림은 가상주소방식이다.            CPU는 가상주소지정으로 가상주소(VA virtual address)를 생성해서 메인 메모리에 접근하다.       가상주소를 물리 주소로 변환 하는 작업은 주소 번역이다.       CPU 칩 내에 메모리 관리 유닛(MMU)를 사용해서 가상주소로 번역한다.           9.2 주소공간     메인 메모리의 각 바이트는 가상 주소공간으로부터 선택된 가상주소를 가진다.   9.3 캐싱 도구로서의 VM     가상메모리는 디스크에 저장된 N개의 바이트 크기의 셀 배열로 구성된다.   VM system은 가상메모리를 규정된 사이즈 블록 단위로 분할하여 관리한다.            분할된 블록들은 가상페이지라고 부른다.           가상페이지의 집합은 세 개의 중첩되지 않는 부분집합으로 나누어진다.            Unallocated: VM 시스템에 의해 아직까지 할당되지 않은 페이지들       Cached: 현재 물리 메모리에 캐시되어 할당된 페이지들       Uncached: 물리 메모리에 캐시되지 않은 할당된 페이지들                위의 그림은 여덟 개의 가상페이지를 갖는 작은 가상메모리를 보여준다.   9.3.1 DRAM 캐시의 구성     DRAM 캐시의 미스 비용과 첫 번째 바이트를 접근하는 데 드는 비용은 크기 때문에 가상페이지 또한 커지고 있다.   DRAM 캐시는 완전 결합성이기 때문에 모든 가상페이지는 물리페이지에 둘 수 있다.   디스크의 큰 접근 시간 때문에 DRAM은 항상 write-through 대신에 write-back을 사용하고 있다.      완전 결합성은 하나의 집합에 모든 라인이 들어있는 캐시 구조를 말한다.    9.3.2 페이지 테이블     모든 캐시에서처럼 VM 시스템은 가상페이지가 DRAM 어딘가에 캐시되었는지 결정하기 위한 방법을 갖고 있어야 한다.   이러한 기능은 운영체제 소프트웨어와 MMU 내의 주소 번역 하드웨어와 페이지 테이블의 조합으로 제공된다.            페이지 테이블: 가상페이지를 물리페이지로 매핑하는 역할       주소 번역 하드웨어: 가상주소를 물리 주소로 변환할 때마다 페이지 테이블을 읽는다.       운영체제: 페이지 테이블의 콘텐츠 관리와 페이지들을 디스크와 DRAM 사이에서 왔다 갔다 하는 것을 관장한다.                     위의 그림은 페이지 테이블의 기분 구조를 보여준다.            DRAM 캐시가 완전 결합성이므로 물리페이지가 모든 가상페이지를 포함할 수 있다.       9.3.3 페이지 적중     PTE 내의 물리 메모리 주소를 사용해서 해당 워드의 물리 주소를 구성한다.을 관장한다.      9.3.4 페이지 오류     가상메모리 용어에서 DRAM 캐시 미스는 페이지 오류page fault라고 알려져 있다.        VP3 내의 워드에 대한 참조는 미스가 되고 페이지 오류를 발생시킨다.                 페이지 오류 핸들러는 VP4를 희생시키고 디스크로부터 VP3의 사본으로 교체한 뒤 정상적으로 읽는다.       페이지: 가상메모리 용어에서의 블록   스와핑(페이징): 디스크와 메모리 사이에 페이지를 전송하는 동작   요구 페이징 demand paging: 미스가 발생할 때, 하나의 페이지로 스와핑되어 들어오는 마지막 순간까지 기다리는 전략   9.3.5 페이지의 할당     운영체제가 가상메모리의 새로운 페이지를 할당할 때 디스크 상에 공간을 만들고 임의의 PTE를 디스크에 새롭게 만든 페이지를 가리키도록 할당한다.   9.3.6 문제해결을 위한 또 한 번의 지역성의 등장     가상메모리의 개념을 공부하면 비효율적인 것을 느낄 수 있다 하지만 실제로 가상메모리는 잘 동작하는데, 주로 지역성 문제 때문이다.   지역성의 원리는 시간상의 어느 시점에서라도 이들이 동작 집합working set 또는 거주 집합resident set이라고 알려진 보다 작은 활성화된 페이지 집합에서 동작하는  경향을 보일 것이라는 점을 약속해준다.   쓰레싱thrashing: 동작 집합 크기가 물리 메모리보다 더 크면, 페이지들이 연속적으로 스왑을 반복하게 되는 불행한 상황   9.4 메모리 관리를 위한 도구로서의 VM     다수의 가상페이지들이 동일한 공유된 물리페이지에 매핑될 수 있다.   요구 페이징과 분리된 가상 주소공간의 조합은 메모리가 시스템에서 사용되고 관리되는 방식에 중요한 영향을 미친다.   특히 VM은 링킹과정과 로딩, 코드와 데이터의 공유, application으로의 메모리 할당을 단순화 해준다.            링킹을 단순화한다: 별도의 주소공간은 각 프로세스들이 각 메모리 이미지에 대해서 코드와 데이터가 실제로 물리 메모리 내 어디에 위치하는지에 상관 없이 동일한 기본 포맷을 사용하도록 해준다. 이러한 통일성은 링커의 설계와 구현을 매우 단순화해준다.       로딩을 단순화한다: 가상메모리는 실행파일과 공유 목적파일들을 메모리에 로드하기 쉽게 해준다.       공유를 단순화한다: 운영체제는 다수의 프로세스가 서로 다른 프로세스에 들어 있는 가상페이지들을 동일한 물리페이지들로 적절하게 매핑해서 한 개의 사본을 공유하도록 할 수 있다.       메모리 할당을 단순화한다: 운영체제는 적당한 수의 연속적인 가상메모리 페이지를 할당하고 이들을 물리 메모리 내에 위치한 k개의 임의의 물리페이지로 매핑한다.           9.5 메모리 보호를 위한 도구로서의 VM     컴퓨터 시스템은 운영체제가 메모리 시스템에 접근하는 것을 제어할 수 있는 수단을 제공한다.   별도의 가상 주소공간을 제공하면 사적 메모리를 다른 프로세스로부터 분리하는 것이 쉬워진다.        위 그림에서 SUP는 커널 모드(수퍼바이저)로 돌고 있는지를 나타내는 비트다.            만약 사용자모드에서 VP2에 접근하려 한다면 CPU는 일반 보호 오류를 발생해서 SIGSEGV 시그널을 위반한 프로세스로 보내 커널 내의 예외 핸들러로 제어를 이동시킨다.       위와 같은 예외를 “세그먼트 오류segmentation fault”라고 보고한다.           9.6 주소의 번역     용어설명          VA: virtual address     PETA: page table entry address     PTE: page table entry     PA: physical address           페이지 적중이 일어났을 때            프로세서는 가상주소를 생성하고 이것을 MMU로 보낸다.       MMU는 PTE 주소를 생성하고 이것을 캐시/메인 메모리에 요청한다.       캐시/메인 메모리는 PTE를 MMU로 리턴한다.       MMU는 물리 주소를 구성하고 이것을 캐시/메인 메모리로 보낸다.       캐시/메인 메모리는 요청한 데이터 워드를 프로세서로 보낸다.                페이지 오류를 처리할 때            페이지 적중과 동일       페이지 적중과 동일       페이지 적중과 동일       PTE의 유효비트는 0이므로 MMU는 예외를 발생시키고, CPU 내의 제어를 운영체제 커널의 페이지 오류 예외 핸들러로 이동시킨다.       오류 핸들러는 물리 메모리 내의 희생자 페이지를 결정하고, 만일 이 페이지가 수정되었다면 디스크로 페이지를 이동한다.       오류 핸들러는 새 페이지를 페이지 이동해서 들여오고, 메모리 내의 PTE를 갱신하다.       오류 핸들러는 처음의 프로세스로 돌아가고 오류 인스트럭션은 재시작된다.           9.6.1 캐시와 VM의 통합     대부분의 시스템은 SRAM 캐시에 물리 주소지정을 선택한다.   물리 주소를 사용하면 다중 프로세스들이 캐시에서 블록을 갖는 것과 마찬가지로 가상페이지로부터 블록을 공유하는 것이 단순해진다.   물리 주소를 사용하는 캐시가 가상메모리와 통합될 수 있는 이유는 주소 번역이 캐시 참조 이전에 일어나기 때문이다.            TLB를 사용하면 캐시 참조 이전에 주소 번역이 일어남           9.6.2 TLB를 사용한 주소 번역 속도의 개선     주소 번역의 비용을 줄이기 위해 MMU 내에 번역 참조 버퍼translation lookaside buffer(TLB)라고 부르는 작은 캐시를 포함한다.   TLB는 작은 가상주소지정 캐시로, 각 라인은 하나의 PTE로 구성된 하나의 블록을 저장한다.        TLB 적중이 발생할 때            CPU는 가상주소를 생성한다.       MMU는 적당한 PTE를 TLB로부터 선입한다.       MMU는 적당한 PTE를 TLB로부터 선입한다.       MMU는 가상주소를 물리 주소로 번역하고, 그것을 캐시/메인 메모리로 전송한다.       캐시/메인 메모리는 요청한 데이터 워드를 CPU로 리턴한다.                      TLB 미스가 발생하면, MMU는 PTE를 L1캐시에서 선입해야한다.   9.6.3 다중 레벨 페이지 테이블     주소를 번역하기 위해서 한 개의 페이지 테이블을 사용하면 낭비가 매우 심하기 때문에 페이지 테이블의 계층구조를 사용한다.        위의 그림은 2단계 페이지 테이블 계층구조이다.   위와 같은 기법은 메모리 요구량을 두 가지 방법으로 줄여준다.            만일 1단계 PTE가 널이면, 해당 2단계 페이지 테이블이 존재할 필요가 없어진다. -&gt; 절약       1단계 테이블만이 항상 메인 메모리에 있고 2단계 페이지 테이블은 필요로 할 때마다 페이지 인 또는 아웃이 되므로 메인 메모리로의 압박을 줄일 수 있다.                위의 그림은 K단계 페이지 테이블을 사용한 주소 번역이다.  ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_25/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 09 가상메모리 (9.8 메모리 매핑 ~ 9.12 요약)",
        "excerpt":"Chapter 09 가상메모리     물리 및 가상주소 방식   주소공간   캐싱 도구로서의 VM   메모리 관리를 위한 도구로서의 VM   메모리 보호를 위한 도구로서의 VM   주소의 번역   사례 연구: 인텔 코어 i7/리눅스 메모리 시스템   메모리 매핑   동적 메모리 할당   가비지 컬렉션   C 프로그램에서의 공통된 메모리 관련 버그   요약   9.8 메모리 매핑     매핑: 리눅스는 가상메모리 영역의 내용을 디스크의 객체에 연결해서 초기화한다.   영역들은 다음 두 종류의 객체 중의 하나로 매핑될 수 있다.            리눅스 파일 시스템 내의 일반 파일: 한 영역은 실행가능 목적파일과 같은 일반 디스크 파일의 연속적인 섹션으로 매핑될 수 있다.       무기명 파일: 한 영역은 또한 무기명 파일로 매핑될 수 있다.           가상페이지가 초기화된 후에는 커널이 관리하는 특별한 스왑 파일 사이에서 스왑 인되었다가 아웃되었다가 한다.            스왑 파일은 스왑 공간 또는 스왑 영역이라고도 한다.           9.8.1 다시 보는 공유 객체     메모리 매핑에 대한 아이디어는 만일 가상메모리 시스템이 보통의 파일 시스템과 통합될 수 있다면, 단순하고 효과적으로 프로그램과 데이터를 메모리에 로드할 수 있을 것이라는 기발한  생각에서 생겨났다.   프로세스 개념은 각 프로세스에 자신만의 가상 주소공간을 제공하며, 이것은 다른 프로세스들에 의해 잘못된 쓰기와 읽기 작업이 발생하는 것을 막아준다.   객체는 공유 가상메모리 영역으로 공유 객체 또는 사적private 개체로 매핑될 수 있따.            공유 객체에 매핑: 프로세스가 해당 영역에 쓰는 모든 내용은 자신의 공유 메모리 내로 객체를 매핑한 다른 프로세스들도 볼 수 있게 한다. 변경된 내용은 디스크 상의 원래의 객체에도 반영된다.       사적 객체에 매핑: 해당 영역에 가한 수정사항들은 다른 프로세스들은 볼 수 없다.                위의 그림은 공유 객체이다.        위의 그림은 사적 copy-on-write 객체이다.            사적 객체들은 copy-on-write라고 알려진 기법을 사용해서 가상메모리에 매핑된다.       공유된 객체에 다른 프로세스가 쓰기 작업을 하게 되면 새로운 사본을 물리페이지 내에 만들고 해 사본을 가르키게 한다.       copy-on-write는 마지막 가능한 순간까지 사적 객체 내에서 페이지를 복사하는 것을 지연시켜서 부족한 물리 메모리를 가장 효율적으로 사용한다.           9.8.2 다시 보는 fork 함수     현재 프로세스가 fork 함수를 호출하면, 커널은 새로운 프로세스를 위한 여러가지 자료 구조를 생성하고, 여기에 고유한 PID를 부여한다.   새 프로세스를 위한 가상메모리를 생성하기 위해 현재 프로세스의 mm_struct, 영역 구조체, 페이지 테이블과 동일한 사본을 만든다.   두 프로세스의 모든 페이지들을 읽기-허용으로 표시하고, 두 프로세스의 영역 구조체들을 사적 copy-on-write로 표시한다.   9.8.3 다시 보는 execve 함수     가상메모리와 메모리 매핑은 또한 프로그램을 메모리로 로딩하는 과정에서 중요한 역할을 한다.   execve 함수는 현재 프로세스 내에서 현재 프로그램을 효과적으로 교체하면서 실행 목적파일에 포함된 프로그램을 실행하고 로드한다.            기존 사용자 영역을 제거한다.       사적 영역을 매핑한다. copy-on-write형식을 사용한다.       공유 영역을 매핑한다.       프로그램 카운터를 설정한다.           9.8.4 함수를 이용한 사용자수준 메모리 매핑     리눅스 프로세스들은 함수를 이용해서 가상메모리의 새로운 영역들을 만들 수 있으며, 객체들을 이 영역으로 매핑할 수 있다.   mmap 함수: 커널에 새 가상메모리 영역을 생성해 줄 것을 요청             위의 그림은 mmap 인자의 시각적 해석            nunmap 함수: 가상메모리의 영역들을 삭제한다.       9.9 동적 메모리 할당     동적 메모리 할당기을 사용하여 추가적인 가상메모리를 런타임에 획득한다.   동적 메모리 할당기는 힙heap 이라고 하는 프로세스의 가상메모리 영역을 관리한다.            힙은 미초기화된 데이터 영역 직후에 시작해서 위쪽(높은 주소 방향)으로 커지는 무요구 메모리 영역이라고 가정한다.                     위의 그림은 힙heap 이다.            할당기는 힙을 다양한 크기의 블록들의 집합으로 관리한다.             명시적 할당기: application이 명시적으로 할당된 블록을 반환해 줄 것을 요구한다. malloc 패키지.       묵시적 할당기: 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구한다. 가비지 컬렉터garbage collector.           9.9.1 malloc과 free함수     malloc 함수: 힙으로부터 블록들을 할당받는다.   sbrk 함수: brk 포인터에 인자값(incr)을 더해서 힙을 늘리거나 줄인다.   free 함수: 할당된 힙 블록을 반환한다.        위의 그림은 malloc과 free를 사용해서 블록을 할당하고 반환시키는 모습을 보여준다.   9.9.2 왜 동적 메모리 할당인가?     프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 없는 경우들이 있기 때문이다.            예를들어 n만큼의 배열 길이를 초기화 해줘야 하는데, n은 프로그램 실행 후에 입력받는다면, 배열의 길이를 n만큼 동적 할당해줘야한다.           9.9.3 할당기 요구사항과 목표     명시적 할당기들은 다소 엄격한 제한사항 내에서 동작해야 한다.            임의의 요청 순서 처리하기: application은 각각의 가용 블록이 이전의 할당 요청에의해 현재 할당된 블록에 대응되어야 한다는 제한사항을 만족해야한다.       요청에 즉시 응답하기       힙만 사용하기: 비확장성 자료 구조들은 힙 자체에 저장되어야 한다.       블록 정렬하기(정렬 요건) : 어떤 종류의 데이터 객체라도 저장할 수 있도록 정렬해야한다.       할당된 블록을 수정하지 않기: 할당기는 가용 블록을 조작하거나 변경할 수만 있다. 할당된 블록은 수정하거나 이동하지 않는다.           할당기는 두가지 목표를 달성하기 위해 노력한다.            처리량 극대화하기       메모리 이용도를 최대화하기           9.9.4 단편화     단편화: 가용 메모리가 할당 요청을 만족시킬 수 없는 상태 일어난다.            내부 단편화: 할당된 블록이 데이터 자체보다 더 클 때 일어난다. 사용하지 않는 블록이 낭비된다.       외부 단편화: 요청을 처리할 수 있는 단일한 가용블록이 없는 경우 발생한다. (가용 가능한 블록을 모두 모으면 충분한 크기가 존재하지만 단일 블록들이 만족할 수 없어서)                외부 단편화를 위의 그림을 예로 든다면, 8워드 블록의 할당을 요청하면, 가용 블록들을 모두 모으면 가능하지만, 6워드 블록과, 2워드 블록으로 나뉘어져 있기 때문에 외부 단편화가 일어난다.   9.9.5 구현 이슈     가용 블록 구성: 어떻게 가용 블록을 지속적으로 추적하는가?   배치: 새롭게 할당된 블록을 배치하기 위한 가용 블록을 어떻게 선택하는가?   분할: 블록을 새롭게 할당 후 가용 블록의 나머지 부분들로 무엇을 할 것인가?   연결: 방금 반환된 블록으로 무엇을 할 것인가?   9.9.6 묵시적 가용 리스트(implict free list)        위의 그림은 힙 블록의 포맷이다.            한 블록은 1워드 헤더, 데이터, 추가적인 패딩으로 구성된다.       헤더: 블록 크기와 블록이 할당되었는지 가용 상태인지를 인코딩한다. 블록 크기는 정렬 기준의 배수이다.       데이터: 헤더 다음에는 malloc을 불렀을 때 요구한 데이터가 따라온다.       패딩: 패딩의 크기는 가변적이다. 패딩을 해야하는 이유는 1)외부 단편화를 극복하기 위해, 2)정렬 요구사항을 만족하기 위해                위의 그림은 묵시적 가용 리스트를 사용해서 구현한 힙이다.            8byte 더블 워드 정렬을 기준으로 구현했기 때문에 블록의 크기는 항상 8의 배수이다.           이러한 구조를 묵시적 리스트라고 부르는데, 가용 블록이 헤더 내 필드에 의해서 묵시적으로 연결되기 때문이다.   9.9.7 할당한 블록의 배치     application이 메모리 할당을 요청할 때 요청한 블록을 저장하기에 충분히 큰 가용 블록을 리스트에서 검색한다. 할당기가 검색을 수행하는 방법은 배치 정책에 의해서 결정된다.            First fit: 가용 리스트를 처음부터 검색한다.       Next fit: 이전 검색이 종료된 지점에서 검색을 시작한다.       Best fit: 모든 가용 블록을 검사하며 크기가 맞는 가장 작은 블록을 선택한다.           9.9.8 가용 블록의 분할     할당기는 가용 블록을 두 부분으로 나눈다.   예를들어 8워드 크기의 가용 블록중 2워드 크기를 할당하면 나머지 6워드 크기의 내부 단편화가 생긴다. 이를 분할해서 6워드 크기의 가용 블록을 새로 만든다.   9.9.9 추가적인 힙 메모리 획득하기     가용 블록이 부족하다면 할당기는 커널에게 sork 함수를 호출해서 추가적인 힙 메모리를 요청한다.   9.9.10 가용 블록 연결하기        위의 그림은 가용할 수 있는 블록이 16/0 으로 두개로 나뉘어져 있다. 이는 오류 단편화false fragmentation라고 한다.            이를 극복하기 위해서 16/0으로 나뉘어져 있는 가용블록을 32/0으로 연결한다.                     위의 그림처럼 연결 된다.       즉시 연결: 할당기는 블록이 반환될 때마다 인접 블록을 통합한다.   지연 연결: 일정 시간 후에 가용 블록들을 연결하기 요청이 들어오면 블록들을 통합한다.   9.9.11 경계 태그로 연결하기     현재 블록(반환하려고 하는 블록)의 헤더는 다음 블록의 헤더를 가리키고 있으며, 이것은 다음 블록이 가용한지 결정하기 위해 체크될 수 있다. 하지만 이전 블록을 체크 할 수  있는 방법은 없다. 해당 문제점을 해결하기 위해서 경계 태그 기법을 만들었다.   경계태그: 각 블록의 끝 부분에 풋터footer(경계 태그)을 추가하고 이 풋터는 이전 블록의 헤더를 복사한 것이다.   9.9.12 종합설계: 간단한 할당기의 구현     현재 실력으로 구현은 조금 힘든 것 같아서 지식을 조금 더 쌓고 꼭 구현해보도록 하겠다!    9.9.13 명시적 가용 리스트(explicit free list)     묵시적 가용 리스트는 블록 할당 시간이 전체 힙 블록의 수에 비례하기 때문에 범용 할당기에는 적합하지 않다.   명시적 가용 리스트는 가용 블록들을 일종의 명시적 자료구조로 구성하는 것이다.            가용 블록들을 연결리스트로 모두 쭈르륵 연결한거라고 생각하면 된다! 반면에 묵시적 가용 리스트는 모든 블록을 연결한다.                     위의 그림은 이중 연결 가용 리스트를 사용하는 힙 블록의 포맷이다. -가용 블록 내에 pred와 succ 포인터를 포함하는 이중 연결 리스트로 구성된다.       명시적 가용 리스트의 접근법            후입선출(LIFO): 리스트를 새롭게 반환한 블록들을 리스트의 시작 부분에 삽입해서 후입선출 순으로 유지 하는 것이다. LIFO 순서와 first fit 배치 정책을 사용하면, 할당기는 대부분의 최근에 사용된 블록들을 먼저 조사한다.       주소 순으로 정렬: 리스트를 주소 순으로 정렬해 리스트 내 각 블록의 주소가 다음 블록의 주소보다 작도록 한다. 후입선출 방식보다 좀 더 좋은 메모리 이용도를 가진다.           명시적 리스트의 단점은 가용 블록들이 header와 footer 뿐만 아니라 필요한 포인터까지 포함해야한다는 것이다. 그래서 최소 블록 크기가 커지고 내부 단편화 가능성이 증가한다.   9.9.14 분리 가용 리스트     단일 연결 가용 블록 리스트를 사용하는 할당기는 한 개의 블록을 할당하는 데 가용 블록의 수에 비례하는 시간이 필요하다.   할당 시간을 줄이기 위해 분리 저장장치segregated storage는 다수의 가용 리스트를 유지하며, 각 리스트는 거의 동일한 블록들을 저장한다.   모든 가능한 블록 크기를 크기 클래스size class라고 하는 동일 클래스의 집합들로 분리하는 것이다.   9.10 가비지 컬렉션     가비지 컬렉터garbage collector: 더 이상 프로그램에서 사용하지 않는 블록들을 자동으로 반환하는 동적 저장장치 할당기다.   가비지garbage: 사용하지 않는 블록들   가비지 컬렉션: 자동으로 힙 저장장치를 반납하는 과정      많은 가비지 컬렉션이 있지만, 우리는 논의를 가비지 컬렉션을 처음 개발한 McCarthy의 오리지널 Mark&amp;Sweep 알고리즘에 국한할 것이다.    9.10.1 가비지 컬렉터 기초        가비지 컬렉터는 위의 그림과 같이 방향성 도달 그래프로 메모리를 고려한다.            그래프의 노드들은 루트 노드들과 힙 노드들로 나눈다.       각 힙 노드는 힙 내 한 개의 할당된 블록에 대응된다.       방향성 에지egde p -&gt; q는 블록 p 내부의 위치가 블록 q 내부의 위치를 가리킨다는 것을 의미한다.       루트노드들은 가상메모리의 읽기-쓰기 데이터 영역 내 레지스터, 스택변수, 전역변수가 될 수 있따.       어떤 루트 노드에서 p로 방향성 경로가 존재한다면, p는 도달할 수 있다고 말한다.       application은 어떤 시점에서든 도달할 수 없는 노드를 다시는 사용할 수 없는 가비지에 대응시킨다.       가비지 컬렉터의 역할은 이 도달성 그래프의 표시를 관리하는 것과 도달 불가 노드들을 free시키는 것이다.           컬렉터들은 자신의 서비스를 요청에 의해서 제공하거나, application과 병렬로 별도의 쓰레드로서 실행되어 도달성 그래프를 지속적으로 갱신하고 가비지를 회수한다.   9.11 C 프로그램에서의 공통된 메모리 관련 버그     메모리 관련 버그들은 위험하다, 그 이유는 이들이 종종 시간과 공간적으로 버그의 원인으로부터 멀리 떨어진 곳에서 자신을 드러내기 때문인다.   메모리 관련 버그            잘못된 포인터 역참조       초기화되지 않은 메모리를 읽는 경우: bss 메모리 위치들은 0으로 초기화, 하지만 힙 메모리는 그렇지 않다.       스택 버퍼 오버플로우 허용하기: 배열의 범위를 벗어나면 버퍼 오버플로우를 갖는다.       Off-by-One 에러 만들기: 덮어쓰기 버그       포인터가 가리키는 객체 대신에 포인터 참조하기       존재하지 않는 변수 참조하기       가용 힙 블록 내 데이터 참조하기       메모리 누수leak 유발: 블록을 할당하고 반환을 하지 않는다.           9.12 요약     가상 메모리는 메인 메모리를 추상화한 것이다.            가상메모리를 지원하는 프로세서는 가상주소지정이라고 하는 간접화의 형태로 메인 메모리를 참조한다.       프로세서는 가상주소를 생성하고, 이것은 메인 메모리로 보내지기 전에 물리 주소로 번역된다.       페이지 테이블을 사용해서 번역한다.           가상 메모리는 세 가지 중요한 기능을 제공한다.            자동으로 최근에 사용한 디스크상의 가상 주소공간의 내용을 메모리로 캐시한다.                    페이지: 가상 메모리 캐시에서 블록                       가상메모리는 메모리 관리를 단순화해 주고, 링킹, 프로세스들 간의 데이터 공유, 프로세스를 위한 메모리 할당, 프로그램 로딩을 단순화해 준다.       가상메모리는 매 페이지 테이블 엔트리 내 보호 비트를 사용해서 메모리 보호를 단순화해 준다.           TLB를 사용해서 캐시의 동작과 통합   메모리 매핑: 가상메모리 블록을 디스크 상의 파일 묶음에 이들을 연계해서 초기화하는 과정            메모리 매핑은 데이터의 공유, 새로운 프로세스의 생성, 프로그램의 로딩을 위한 효율적인 메커니즘을 제공           메모리 할당기            힙이라고 부르는 가상의 주소공간 영역에 블록 할당       명시적 할당기: malloc (동적 메모리 할당기)       묵시적 할당기: 가비지 컬렉터 (자동으로 미사용 블록들 반환)           ","categories": ["CSAPP"],
        "tags": ["CS:APP","CS"],
        "url": "/csapp/csapp_26/",
        "teaser": null
      },{
        "title": "[Python] `__name__` 전역 변수란 무엇인가?",
        "excerpt":"모듈  __name__ 전역 변수가 정확히 어떤 역할을 하는지 알기 위해선 python 에서의 모듈 개념에 대해서 먼저 알고 있어야 한다.   인터프리터 입력을 에디터를 사용해서 준비한 후에 그 파일을 입력으로 사용해서 실행하는 것을 스크립트를 만든다고 한다. 여러 프로그램(스크립트)에서 썼던  편리한 함수를 각 프로그램에 정의를 복사하지 않고 사용하는 것을 지원하기 위해 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 수 있는 방법을 제공한다. 그런 파일을 모듈이라고 한다. 모듈로부터 정의들이 다른 모듈이나 메인 모듈로 임포트 될 수 있다.   모듈은 파이썬 정의와 문장들을 담고 있는 파일이다. 파일의 이름은 모듈 이름에 확장자 .py를 붙인다.   __name__  모듈의 이름은 전역 변수 __name__ 으로 제공 된다. 즉 현재 py 파일의 이름을 가지고 있는 변수라는 것이다.   예를들어, fibo.py 라면 __name__ 전역 변수가 fibo라는 문자열을 가지고 있게 된다.   그렇다면 if __name__ == __main__ 은 뭘까?  위에 설명했던 것 처럼 __name__ 전역 변수가 자기 자신의 모듈 이름을 가지고 있지만, 자기 자신의 모듈 안에서 __name__를 호출하게 되면 __main__ 문자열을 갖게 된다.   예를들어, test1.py 와 test2.py 가 있을 때, test1에 test2를 import 하게 되면, test1은 __main__ 이 되고 test2는 ‘test2’가 된다.   # test1.py import test2 name = __name__ print(\"test1.py :\", name)  # test2.py name = __name__ print(\"test2.py: \", name)  ------------------------------------------ \"\"\" 출력 값 test2.py:  test2 test1.py : __main__ \"\"\"  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_02/",
        "teaser": null
      },{
        "title": "[Python] 파이썬은 call by value인가? 아니면 call by reference인가?",
        "excerpt":"call by value     값에 의한 호출   인자로 받은 값을 복사하여 처리한다.   call by reference     참조에 의한 호출   인자로 받은 값의 주소를 참조하여 직접 값에 영향을 준다.   call by assignment     파라미터로 전달받는 객체에 따라 객체의 참조방식이 결정된다.            immutable이면 값이 변경 되지 않는다.       mutable이면 값이 변경된다.           mutable, immutable     숫자형(number): immutable   문자열(string): immutable   리스트(list): mutable   튜플(tuple): immutable   딕셔너리(dictionary): mutable  ","categories": ["Pandas"],
        "tags": ["Python","Pandas","DataEngineering"],
        "url": "/pandas/python_03/",
        "teaser": null
      },{
        "title": "[백준/Python] 2891 카약과 강풍(그리디)",
        "excerpt":"BOJ   그리디 2891 카약과 강풍  문제로 이동!   문제   2890번을 보면 알겠지만, 상근이는 카약 대회를 개최했다. 그런데, 갑자기 엄청난 강풍이 경기장에 불었고, 일부 카약이 부서졌다. 경기는 5분 안에 시작해야 하는 상황이다.   다행히 일부 팀은 혹시 모를 사태에 대비해서 카약을 하나 더 경기장에 들고 왔다. 카약은 매우 무겁고 운반하기 어렵다. 따라서, 자신의 바로 다음이나 전에 경기하는 팀에게만 카약을 빌려주려고 한다. 즉, 팀 4는 여분의 카약을 3이나 5에게만 빌려줄 수 있다. 다른 팀에게서 받은 카약은 또 다른 팀에게 빌려줄 수 없다. 또, 카약을 하나 더 가져온 팀의 카약이 손상되었다면, 여분의 카약으로 경기에 출전하게되고, 이 카약은 다른 팀에게 빌려줄 수 없다.   카약이 부서진 팀과 하나 더 가져온 팀이 주어진다. 카약을 적절히 빌렸을 때 출발하지 못하는 팀의 최솟값은 몇 팀인지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 팀의 수 N, 카약이 손상된 팀의 수 S, 카약을 하나 더 가져온 팀의 수 R이 주어진다. (2 ≤ N ≤ 10, 1 ≤ S, R ≤ N)   둘째 줄에는 카약이 손상된 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.   셋째 줄에는 카약을 하나 더 가져온 팀의 번호가 주어진다. 팀 번호는 중복되지 않는다.   예제 입력  입력: [5, 2, 1] [2, 4] [3],  출력: 1  입력: [5, 2, 3] [2, 4] [1, 3, 5], 출력: 0    풀이     해당 문제는 카약이 손상된 팀과 여분의 카약을 가져온 팀의 관계를 잘 생각하면서 풀어야 한다. 여분을 가져온 팀이 손상이 되는 경우가 있는 부분을 잘 생각해야한다. 또한 여분을 나누어 줄 때 index 0 부터 차례대로 나누어줘야 모두에게 적절히 분배할 수 있다. 그렇기 때문에 여분을 가져온 팀의 정렬이 필요하다.(배열이 [5, 2, 4] 이런식으로 들어올 수 있기 때문)    solution     카약을 모두 가져왔다고 가정하고 n 길이의 배열을 1로 초기화한다.   손상된 카약을 가지고 있는 팀을 반복문을 돌면서 -1 해준다.   여분을 가져온 카약팀을 정렬해준다.   여분을 가져온 카약팀을 반복문을 돌면서 양 옆에 카약이 없는 팀을 조회하고 있다면 카약이 없는 팀의 value를 +1, 여분을 가져온 카약팀을 -1 올려준다.            여분을 가져온 카약팀은 카약이 2 이상 있는 팀이기 때문에 조건문을 x&gt;=2 로 설정한다.           코드       def solution(n_list, brk_list, add_list):         kayak = [1] * n_list[0]         for i in brk_list:             kayak[i-1] -= 1         add_list.sort()         for i in add_list:             index = i-1             kayak[index] += 1             if kayak[index] &gt;= 2 and index-1 &gt;= 0:                 if kayak[index-1] == 0:                     kayak[index] -= 1                     kayak[index-1] += 1             if kayak[index] &gt;= 2 and index+1 &lt; n_list[0]:                 if kayak[index+1] == 0:                     kayak[index] -= 1                     kayak[index+1] += 1              result = kayak.count(0)         return result               if __name__ == \"__main__\":         n_list = list(map(int, input().split()))         brk_list = list(map(int, input().split()))         add_list = list(map(int, input().split()))              print(solution(n_list, brk_list, add_list)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_01/",
        "teaser": null
      },{
        "title": "[백준/Python] 1459 걷기(그리디)",
        "excerpt":"BOJ   그리디 1459_걷기  문제로 이동!   문제   세준이는 학교에서 집으로 가려고 한다. 도시의 크기는 무한대이고, 도시의 세로 도로는 모든 정수 x좌표마다 있고, 가로 도로는 모든 정수 y좌표마다 있다. 세준이는 현재 (0, 0)에 있다. 그리고 (X, Y)에 위치한 집으로 가려고 한다. 세준이가 걸을 수 있는 방법은 두가지 인데, 하나는 도로를 따라서 가로나 세로로 한 블록 움직여서 이번 사거리에서 저 사거리로 움직이는 방법이고, 블록을 대각선으로 가로지르는 방법이 있다.   세준이가 집으로 가는데 걸리는 최소시간을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 집의 위치 X Y와 걸어서 한 블록 가는데 걸리는 시간 W와 대각선으로 한 블록을 가로지르는 시간 S가 주어진다. X와 Y는 1,000,000,000보다 작거나 같은 음이 아닌 정수이고, W와 S는 10,000보다 작거나 같은 자연수이다.   예제 입력  입력: 4 2 3 10, 출력: 18  입력: 2 0 12 10, 출력: 20  입력: 135 122 43 28, 출력: 3929    풀이     해당 문제는 다양한 조건을 나누어 해결해야하는 문제이다. W와 S의 관계를 잘 관찰한 뒤 총 세가지 조건으로 나누어 문제를 해결하였다. 첫번째 조건은 S가 W보다 작을 때, 이 때는 가로 및 세로로 가는 것보다 대각선으로 가는게 훨씬 빠르다. 하지만 이 조건에서 한번 더 조건 분기 하는데, 남은 블록 수가 홀수라면 마지막 움직임은 가로 혹은 세로로 움직여야 최소 시간에 도착할 수 있다. 두번째 조건은 S가 2*W보다 작을 때, 세번째 조건은 나머지 조건을 제외한 경우이다.    solution     s 가 w 보다 작을때, s가 w2 보다 클 때 그리고 s가 w2 보다 작을 때로 조건을 나눈다.   s가 w*2 이하라면, x와 y중 최소값 만큼은 s로 움직인다. x와 y 차이값 만큼은 w로 움직인다.   s가 w보다 작다면, x와 y중 최소값 만큼은 s로 움직이고, x와 y의 차이값이 짝수라면 w만큼, 홀수라면 차이값-1 으로 s를 움직이고 마지막 w를 더해준다.   코드       def solution(x,y,w,s):         if s &lt;= w:             min_val = min(x, y)             if abs(x-y) % 2 == 0:                 result = ((min_val) * s) + (abs(x-y) * s)             else:                 result = ((min_val) * s) + ((abs(x-y)-1) * s) + w         elif s &gt; w*2:             result = (x+y) * w         else:             min_val = min(x,y)             result = ((min_val) * s) + (abs(x-y) * w)              return result               if __name__ == \"__main__\":         x, y, w, s = map(int, input().split())         print(solution(x,y,w,s)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_02/",
        "teaser": null
      },{
        "title": "[백준/Python] 1543 문서 검색(그리디)",
        "excerpt":"BOJ   그리디 1543 문서 검색  문제로 이동!   문제   세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다.   세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 문서가 주어진다. 문서의 길이는 최대 2500이다. 둘째 줄에 검색하고 싶은 단어가 주어진다. 이 길이는 최대 50이다. 문서와 단어는 알파벳 소문자와 공백으로 이루어져 있다.   예제 입력  입력: “ababababa” “aba”, 출력: 2  입력: “aaaaaaa” “aa”, 출력: 3    풀이     count 메서드를 사용하면 간단하게 해결할 수 있다.    solution     count 메서드를 사용한다.   코드       import sys          def solution(data, find):         return data.count(find)               if __name__ == \"__main__\":         data = sys.stdin.readline().rstrip()         find = sys.stdin.readline().rstrip()         print(solution(data, find)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_03/",
        "teaser": null
      },{
        "title": "[백준/Python] 2012 등수 매기기(그리디)",
        "excerpt":"BOJ   그리디 2012 등수 매기기  문제로 이동!   문제   2007년 KOI에 N명의 학생들이 참가하였다. 경시일 전날인 예비소집일에, 모든 학생들은 자신이 N명 중에서 몇 등을 할 것인지 예상 등수를 적어서 제출하도록 하였다.   KOI 담당조교로 참가한 김진영 조교는 실수로 모든 학생의 프로그램을 날려 버렸다. 1등부터 N등까지 동석차 없이 등수를 매겨야 하는 김 조교는, 어쩔 수 없이 각 사람이 제출한 예상 등수를 바탕으로 임의로 등수를 매기기로 했다.                  자신의 등수를 A등으로 예상하였는데 실제 등수가 B등이 될 경우, 이 사람의 불만도는 A와 B의 차이 (       A - B       )로 수치화할 수 있다. 당신은 N명의 사람들의 불만도의 총 합을 최소로 하면서, 학생들의 등수를 매기려고 한다.           각 사람의 예상 등수가 주어졌을 때, 김 조교를 도와 이러한 불만도의 합을 최소로 하는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 500,000) 둘째 줄부터 N개의 줄에 걸쳐 각 사람의 예상 등수가 순서대로 주어진다. 예상 등수는 500,000 이하의 자연수이다.   예제 입력  입력: 5 1 5 3 1 2, 출력: 3    풀이     정렬 이후 abs 함수를 이용해서 순차별로 계산하면 해결할 수 있는 간단한 문제이다.    solution     학생들의 예상 점수가 저장되어 있는 리스트를 오름차순으로 정렬한다.   학생들의 점수를 차례대로 1,2,3 ~ 순서로 빼주고 절대값 처리를 해준다.   코드       def solution(n, expectations):         expectations.sort()         result = 0         for i in range(n):             result += abs(expectations[i]-(i+1))         return result               if __name__ == \"__main__\":         n = int(input())         expectations = [int(input()) for _ in range(n)]         print(solution(n, expectations)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_04/",
        "teaser": null
      },{
        "title": "[백준/Python] 2036 수열의 점수(그리디)",
        "excerpt":"BOJ   그리디 2036 수열의 점수  문제로 이동!   문제   n개의 정수로 이루어진 수열이 있다. 이 수열에서 한 정수를 제거하거나, 또는 두 정수를 제거할 수 있다. 한 정수를 제거하는 경우에는 그 정수가 점수가 되고, 두 정수를 제거하는 경우에는 두 정수의 곱이 점수가 된다. 이를 반복하여 수열에 아무 수도 남지 않게 되었을 때, 점수의 총 합의 최대를 구하는 프로그램을 작성하시오.   예를 들어 -1, 5, -3, 5, 1과 같은 수열이 있다고 하자. 먼저 1을 제거하고, 다음으로는 5와 5를 제거하고, 다음에는 -1과 -3을 제거했다고 하자. 이 경우 각각 점수가 1, 25, 3이 되어 총 합이 29가 된다.   입력   첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 절댓값이 1,000,000을 넘지 않는 정수가 n개 주어진다.   예제 입력       \"\"\"     입력     5     -1     5     -3     5     1     출력     29     \"\"\"  풀이     양수 부분과 음수 부분을 나누어서 해결해야한다. 우선 0은 양수 부분에 있으면 최대값을 찾는데 도움을 주지 않는다. 그렇기 때문에 0음 음수 부분으로 나누어 준다. 또한 나뉘어진 부분의 개수가 홀수라면 음수 중에서는 제일 큰 수가 더해져야하고, 양수 중에서는 제일 작은 수가 더해져야한다. 이후 이 모두를 합산하면 결과값이 나온다.    solution     우선 입력받은 numbers 리스트를 정렬해준다.   numbers를 반복문을 돌며 음수 부분과 양수 부분으로 나누어준다.   음수 부분이 짝수 개수라면 모두 두개씩 곱해준다.   음수 부분이 홀수 개수라면 negative_n-1에 위치한 값을 제외하고 모두 곱해준뒤 해당 값은 더해준다.   양수 부분이 짝수 개수라면 모두 두개씩 곱해준다.   양수 부분이 홀수 개수라면 0에 위치한 값을 제외하고 모두 곱해준뒤 해당 값은 더해준다.   코드       def solution(numbers):         numbers.sort()         result = 0         negative_list = []         positive_list = []         negative_n = 0         positive_n = 0              for n in numbers:             if n &lt;= 0:                 negative_list.append(n)                 negative_n += 1             else:                 positive_list.append(n)                 positive_n += 1              if negative_n % 2 == 0:             for i in range(0,negative_n, 2):                 result += negative_list[i] * negative_list[i+1]         else:             for i in range(0, negative_n-1, 2):                 result += negative_list[i] * negative_list[i+1]             result += negative_list[negative_n-1]              if positive_n % 2 == 0:             for i in range(0, positive_n, 2):                 if positive_list[i] &gt; 1 and positive_list[i+1] &gt;1:                     result += positive_list[i] * positive_list[i+1]                 else:                     result += positive_list[i] + positive_list[i+1]         else:             for i in range(1, positive_n, 2):                 if positive_list[i] &gt; 1 and positive_list[i+1] &gt;1:                     result += positive_list[i] * positive_list[i+1]                 else:                     result += positive_list[i] + positive_list[i+1]             result += positive_list[0]                   return result               if __name__ == \"__main__\":         n = int(input())         numbers = []         for _ in range(n):             numbers.append(int(input()))         print(solution(numbers)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_05/",
        "teaser": null
      },{
        "title": "[백준/Python] 2138 전구와 스위치(그리디)",
        "excerpt":"BOJ   그리디 2138 전구와 스위치  문제로 이동!   문제   N개의 스위치와 N개의 전구가 있다. 각각의 전구는 켜져 있는 상태와 꺼져 있는 상태 중 하나의 상태를 가진다. i(1 &lt; i &lt; N)번 스위치를 누르면 i-1, i, i+1의 세 개의 전구의 상태가 바뀐다. 즉, 꺼져 있는 전구는 켜지고, 켜져 있는 전구는 꺼지게 된다. 1번 스위치를 눌렀을 경우에는 1, 2번 전구의 상태가 바뀌고, N번 스위치를 눌렀을 경우에는 N-1, N번 전구의 상태가 바뀐다.   N개의 전구들의 현재 상태와 우리가 만들고자 하는 상태가 주어졌을 때, 그 상태를 만들기 위해 스위치를 최소 몇 번 누르면 되는지 알아내는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 전구들의 현재 상태를 나타내는 숫자 N개가 공백 없이 주어진다. 그 다음 줄에는 우리가 만들고자 하는 전구들의 상태를 나타내는 숫자 N개가 공백 없이 주어진다. 0은 켜져 있는 상태, 1은 꺼져 있는 상태를 의미한다.   예제 입력       \"\"\"     case 1:     입력     3     000     010     출력     3      case 2:     입력     7        1101000     1111111     출력     3      case 3:     입력         8     00000000     11011000     출력     2     \"\"\"  풀이     진짜 어려웠던 문제다… 전구를 키는 방법이 여러가지인데 어떻게 최소값을 찾는지 정말 아이디어가 떠오르지 않았다. 하지만, 이번 문제를 해결하고 또 이전에 이 문제와 비슷한 문제를 겪어 봤을 때 결론은, 최소값을 구할 때 어떻게 해야지 최소값이 나오는지 모를 때는 앞에서부터 차근차근 계산해 나가는 방법으로 접근 해봐야 한다. 하지만 이 문제는  양 끝을 키고 끌 때 다르게 작동된다. 그렇기 때문에 첫번째 전구를 킨 case와 키지 않은 case 두가지 case로 나누어 풀어야한다. 또한 마지막 테케가 계속 틀렸는데, 입렵값이 애초부터 같은 값인 것을 예외처리 해주어야 한다.    solution     change 함수를 정의해 준다. 0이면 1, 1이면 0, 양 끝이 변경 될 때의 조건을 포함한다.   입력값 두개가 서로 같으면 0으로 얼리 리턴 해준다.   전구를 누르는 로직은 현재 조사하는 위치의 왼쪽 전구(즉, 다음 전구를 조사하게 되면 해당 전구는 더이상 키거나 끌 수 없는 전구)가 결과 값과 다르다면 현재 위치의 전구를 누른다.   위의 로직을 첫번째 전구를 눌렀을 경우, 누르지 않았을 경우 두가지로 나누어 처리한다.   계산이 끝나면, 각 경우의 결과값중 최소값을 리턴하면 되지만, 정답을 도출할 수 없는 경우 count가 -1로 저장되기 때문에 해당 부분에 적절한 분기 처리를 해준다.   코드       import sys               def change(first, i, n):         if i != 0:             if first[i - 1] == \"0\":                 first[i - 1] = \"1\"             else:                 first[i - 1] = \"0\"         if first[i] == \"0\":             first[i] = \"1\"         else:             first[i] = \"0\"         if i != n - 1:             if first[i + 1] == \"0\":                 first[i + 1] = \"1\"             else:                 first[i + 1] = \"0\"               def solution(n, first, last):         if first == last:             return 0              first_f = list(first)         first_n = list(first)         last = list(last)         count_f, count_n = -1, -1              # 첫 번째 전구를 누르는 경우         change(first_f, 0, n)         count = 0         for i in range(1,n):             if first_f[i-1] != last[i-1]:                 change(first_f, i, n)                 count += 1         if first_f == last:             count_f = count+1              # 첫 번째 전구를 누르지 않을 경우         count = 0         for i in range(1,n):             if first_n[i-1] != last[i-1]:                 change(first_n, i, n)                 count += 1         if first_n == last:             count_n = count              if count_n == -1 and count_f != -1:             return count_f         elif count_n != -1 and count_f == -1:             return count_n         elif count_n != -1 and count_f != -1:             return min(count_f, count_n)         else:             return -1               if __name__ == \"__main__\":         n = int(input())         first = sys.stdin.readline().rstrip()         last = sys.stdin.readline().rstrip()         print(solution(n, first, last)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_06/",
        "teaser": null
      },{
        "title": "[백준/Python] 2785 체인(그리디)",
        "excerpt":"BOJ   그리디 2785 체인  문제로 이동!   문제   희원이는 그의 다락방에서 N개의 체인을 찾았다. 각각의 체인은 몇 개의 고리로 연결되어 있는데, 각각의 고리는 최대 두 개의 인접한 고리를 가질 수 있다. 각각의 고리는 열고 닫을 수 있다. 그래서, 체인을 분리하거나 두 체인을 연결하여 하나의 긴 체인으로 만들 수 있다. 희원이는 가능한 한 적은 고리를 열고 닫아서, 모든 체인을 하나의 긴 체인으로 연결하려고 한다.   예를 들어, 희원이가 세 개의 체인을 가지고 있고, 각 체인이 고리 하나로만 이루어져 있다면, 그 중 하나를 열어서 나머지 두 개를 연결하고 닫으면 된다.      체인의 개수와 각각의 체인의 길이가 주어지면, 하나의 긴 체인으로 모든 체인을 묶기 위해 희원이가 열고 닫아야할 최소한의 고리 수를 찾아라.   입력   첫 번째 줄에는 체인의 개수를 나타내는 양의 정수 N (2 ≤ N ≤ 500000)이 주어진다. 두 번째 줄에는 각각의 체인의 길이를 나타내는 N개의 양의 정수 Li(1 ≤ Li ≤ 1000000)가 주어진다.   예제 입력       \"\"\"     case 1:     입력     2     3 3     출력     1          case 2:     입력     5     4 3 5 7 9     출력     3     \"\"\"  풀이     문제 해석을 case1을 예를 들면, 체인 3개가 연결되어 있는 체인이 총 두개 존재하고 있는 것이다. 그렇다면 우선 연결된 체인이 제일 적은 체인을 소모 하는 것이 체인을 최소로 사용하고 모든 체인을 연결할 수 있는 key point가 된다. 이후 적게 연결된 체인부터 확인해가며 전체 체인을 연결하였는지 살펴보면 된다. 예를들어 3,4,5,7,9 가 있다면, 3을 소모해 4,5,7,9를 모두 연결할 수 있다. 또한 2,5,6,7,8 이라면 2를 소모해 6,7,8을 연결하면 5와 (6,7,8) 이렇게 두 체인만 남게된다. 이것의 관계를 전체 n 개수와 체인이 담겨진 리스트를 반복문을 돌며 둘의 관계를 따지며 해결한다.    solution     우선 체인이 담긴 리스트 chains를 오름차순으로 정렬한다.   하나의 체인에 연결된 모든 체인을 소모해도 하나의 전체 체인을 만들지 못했을 때 소모한 체인을 count하기 위한 use_chain 변수를 생성한다.   반복문을 돌며 chains에서 chain을 하나씩 검사한다.   만약 chain을 다 소모해도 체인을 만들지 못하면, 소모한 chain을 use_chain에 저장하고, 전체 개수 n에서 소모된 chain과 연결된 chain을 빼주어서 현재 전체 체인의 개수를 n에 저장한다.   만약 chain이 n-1보다 크면 해당 체인으로 자기 자신과 다른 모든 체인을 연결해야하기 때문에 use_chain + n - 1로 리턴한다.   만약 chain이 n-1과 같다면 자기 자신을 모두 소모하고 나머지 체인들이 연결되기 때문에 use_chain + chain으로 리턴한다.   solution2     solution2는 정답은 맞았지만, 시간초과가 뜬 풀이법이다. 내장함수를 자주 사용해서 코드를 작성하지 말자!    코드       def solution(n, chains):         count = 0         chains.sort()         use_chain = 0         for chain in chains:             if chain == n - 1:                 return use_chain + chain             elif chain &gt; n - 1:                 return use_chain + n - 1             else:                 n -= (chain + 1)                 use_chain += chain              return count          def solution2(n, length):         count = 0         length.sort()         while len(length) &gt; 1:             if length[0] == 0:                 length = length[1:]             if len(length) == 2:                 count += 1                 break             if len(length) == 1:                 break             length[0] -= 1             length.append(length.pop() + length.pop())             count += 1              return count          if __name__ == \"__main__\":         n = int(input())         chains = list(map(int, input().split()))         print(solution(n, chains)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_07/",
        "teaser": null
      },{
        "title": "[백준/Python] 2885 초콜릿 식사(그리디)",
        "excerpt":"BOJ   그리디 2885 초콜릿 식사  문제로 이동!   문제   학교 근처 편의점에 새 초콜릿이 들어왔다. 이 초콜릿은 막대 모양이고, 각 막대는 정사각형 N개로 이루어져 있다. 초콜릿의 크기(정사각형의 개수)는 항상 2의 제곱 형태이다. 즉, 1, 2, 4, 8, 16, …개의 정사각형으로 이루어져 있다.   상근이는 점심식사로 초콜릿을 먹는다. 이때, 적어도 K개 정사각형을 먹어야 남은 수업을 졸지 않고 버틸 수 있다. 상근이의 친구 선영이도 초콜릿을 좋아한다. 선영이는 초콜릿은 돈을 주고 사기 아깝다고 생각하기 때문에, 상근이가 주는 초콜릿만 먹는다.   상근이는 막대 초콜릿를 하나 산 다음에, 정확하게 K개 정사각형이 되도록 초콜릿을 쪼갠다. K개는 자신이 먹고 남는 것은 선영이에게 준다.   막대 초콜릿은 나누기 조금 어렵게 되어 있어서, 항상 가운데로만 쪼개진다. 즉, 정사각형이 D개 있는 막대는 D/2개 막대 두 조각으로 쪼개진다.   K개 정사각형을 만들기 위해서, 최소 몇 번 초콜릿을 쪼개야 하는지와 사야하는 가장 작은 초콜릿의 크기를 구하는 프로그램을 작성하시오. 상근이는 초콜릿을 하나만 살 수 있다. 꼭 한 조각이 K개일 필요는 없고, 여러 조각에 있는 정사각형을 합쳤을 때 K개이면 된다.   입력   첫째 줄에 K가 주어진다. (1 ≤ K ≤ 1,000,000)   예제 입력       \"\"\"     입력     6     출력     2     \"\"\"  풀이     문제를 이해하기가 조금 어려웠는데, 2의 제곱 형태인 초콜릿을 계속 반씩 나눈 값을 더해서 입력값인 k가 되게 만들면 되는 최소값을 구하면 된다. 우선 이 문제는 더할 수 있는  값이 2의 제곱수들이기 때문에 k값이 어떤 2의 제곱수끼리 더해졌는지를 알아내야 한다. 그렇기 때문에 2의 제곱수중 가장 큰 수부터 나누어서 나머지가 0으로 떨어지면  나눈 값까지만 초콜릿을 반씩 쪼개면 된다. 만약 k가 홀수라면 초콜릿을 1개 까지 나눠야하기 때문에 계산을 적게하기 위해 얼리리턴 해준다.    solution     우선 k값보다 큰 2의 제곱수가 무엇인지 반복문을 통해 찾아낸다.   2의 제곱수로 상근이가 사야할 초콜릿 크기를 구해준다.   가장 큰 2의 제곱수로 k를 나누었을 때 0이면 나누지 않아도 되기 때문에 얼리 리턴 해준다.   가장 큰 2의 제곱수로 k를 나누었을 때 1이면 마지막 까지 나눠야 하기 때문에 2의 제곱수로 리턴 해준다.   가장 큰 2의 제곱수부터 내림차순으로 k값을 나누어준다.   2의 제곱수로 나누어지면 (최대 제곱수 - 해당 2의 제곱수)로 리턴해준다.   코드       def solution(k):         degree = 0         while True:             if 2**degree &gt;= k:                 break             degree += 1              size = 2**degree         if k == size/2:             return 1         if k%2 == 1:              return size, degree         for s in reversed(range(degree+1)):             if k%(2**s) == 0:                 return size, degree - s               if __name__ == \"__main__\":         k = int(input())         m, n = solution(k)         print(m, n) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_08/",
        "teaser": null
      },{
        "title": "[백준/Python] 11501 주식(그리디)",
        "excerpt":"BOJ   그리디 11501 주식  문제로 이동!   문제   홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다.   주식 하나를 산다. 원하는 만큼 가지고 있는 주식을 판다. 아무것도 안한다. 홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.   예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.   입력   입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.   예제 입력       \"\"\"     입력     3     3     10 7 6     3     3 5 9     5     1 1 3 1 2     출력     0     10     5     \"\"\"  풀이     첫쨋날 부터 계산을 하지 않고, 마지막날 부터 계산 하는 것이 해당 문제의 key point다. 주식 가격이 들어 있는 리스트를 스택이라고 가정하고 문제를 푼다. 마지막 날 주식 가격을 pop 해와서 제일 높은 가격이라고 가정하고 max값에 저장한다. 그다음 주식을 pop 해왔을 때 max값보다 작으면 max와의 차이를 benefit 리스트에 더해준다. max보다 크다면 max값을 변경해준다.    solution     이익을 저장할 리스트를 [0] * n 으로 초기화한다.   먼저 주식 가격이 저장된 리스트를 pop 해서 max값에 저장한다.   주식 가격이 저장된 리스트의 원소가 없어질 때 까지 while 문을 돌며 조건별로 처리해준다.   코드       def solution(n, stocks):         benefit = [0] * n         for s in range(n):             max = stocks[s].pop()             while stocks[s]:                 item = stocks[s].pop()                 if item &lt;= max:                     benefit[s] += max - item                 else:                     max = item              return benefit               if __name__ == \"__main__\":         n = int(input())         stocks = []         for _ in range(n):             m = int(input())             stocks.append(list(map(int, input().split())))         result = solution(n, stocks)         for r in result:             print(r) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_09/",
        "teaser": null
      },{
        "title": "[백준/Python] 12018 Yonsei TOTO(그리디)",
        "excerpt":"BOJ   그리디 2012 등수 매기기  문제로 이동!   문제   연세대학교 수강신청이 얼마 전부터 바뀌어, 마일리지 제도로 바뀌었다. 이 제도는 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다. 그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다.   성준이는 연세대학교 재학 중인 학생이다. 성준이는 저번 수강신청에서 실패하여 휴학을 했기 때문에 이번 수강신청만은 필사적으로 성공하려고 한다. 그래서 성준이는 학교 홈페이지를 뚫어버렸다.   그 덕분에 다른 사람들이 신청한 마일리지를 볼 수 있게 되었다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다. (내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다.   입력   첫째 줄에는 과목 수 n (1 ≤ n ≤ 100)과 주어진 마일리지 m (1 ≤ m ≤ 100)이 주어진다. 각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li이 주어지고 그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. (1 ≤ Pi ≤100, 1 ≤ Li ≤ 100)   (단 마일리지가 같다면 성준이에게 우선순위가 주어진다고 하자.)   예제 입력       \"\"\"     입력     5 76     5 4      36 25 1 36 36     4 4     30 24 25 20     6 4     36 36 36 36 36 36     2 4     3 7     5 4     27 15 26 8 14          출력     4     \"\"\"  풀이     여러가지 요소들을 입력받고 어떻게 효율적으로 저장할지 고민을 좀 했던 문제이다. 수강신청 인원과 정원 그리고 학생들이 배팅한 마일리지를 하나의 set으로 묶어서 처리했고,  수강신청 인원과 정원 수를 비교한뒤 조건 분기로 나누었으며, 배팅한 마일리지를 정렬해서 문제를 해결했다.    solution     첫 번째 반복문은 해당 수업을 수강하기 위해서 필요한 마일리지를 mileage 리스트에 모두 저장하는 반복문이다.   수강 정원과 수강 신청 인원을 비교한 뒤 각각에 mileage 리스트에 필요한 마일리지를 append 해준다.   mileage 리스트를 정렬해준다.(마일리지가 적게 들어가는 수업을 우선 수강하기 위해서)   mileage 리스트를 하나씩 꺼내서 더해가며 총 마일리지인 m보다 커지면 반복문을 탈출한다.            성준이의 마일리지가 우선순위가 높은걸 주의하자! ex) [36, 36, 36, 36] 이라면 성준이가 36 마일리지를 쓴다면 수강할 수 있다.           코드       def solution(n, m, course):         mileage = []         for i in range(n):             if course[i][1] - course[i][0] &gt; 0:                 mileage.append(1)             else:                 course[i][2].sort()                 mileage.append(course[i][2][course[i][0] - course[i][1]])              mileage.sort()         sum_v = 0         count = 0         for v in mileage:             if v &gt; 36:                 continue             sum_v += v             if sum_v &gt; m:                 return count             count += 1              return count               if __name__ == \"__main__\":         n, m = map(int, input().split())         course = []         for _ in range(n):             register, possible = map(int, input().split())             course.append((register, possible, list(map(int, input().split()))))         print(solution(n, m, course)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_10/",
        "teaser": null
      },{
        "title": "[백준/Python] 17609 회문(그리디)",
        "excerpt":"BOJ   그리디 17609 회문  문제로 이동!   문제   회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.   여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.   입력   입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.   예제 입력       \"\"\"     입력     7     abba     summuus     xabba     xabbay     comcom     comwwmoc     comwwtmoc     출력     0     1     1     2     2     0     1     \"\"\"  풀이     회문은 양 끝부터 차례대로 확인해야 하기 때문에 투 포인터를 사용한다. 다른 문자를 만나게 되면 start 포인터를 pop 하는 경우와 end 포인터를 pop 하는 경우 두가지를  계산한다. 이 계산에서 한번 더 다른 문자를 만나게 되면 더 이상 계산할 필요가 없기 때문에 break를 걸어 전체 반복문을 탈출해서 답을 도출한다.    solution     start 포인터를 pop 할 때 계산하는 함수와 end 포인터를 pop 할 때 계산하는 함수를 정의한다. (함수를 사용하는 이유는 전체 반복문을 편리하게 탈출하기 위해서이다.)   스타트 포인터가 해당 string의 중간지점에 위치할 때 까지 while문을 돈다.   다른 문자를 만나게 되면 count를 1 올려주고 start_pop 함수와 end_pop 함수를 호출한다.   각각의 함수에서 다른 문자를 만나게 되면 count를 2로 설정해서 리턴한다.   각각 함수를 호출하고 난뒤 리턴 받은 count(count_sp, count_ep)중 최소값을 count에 저장한 뒤 break로 반복문을 빠져나온다.   count를 결과 리스트에 저장해서 return 한다.   코드       import sys               def start_pop(string, start, end):         start += 1         while start &lt; len(string)//2 + 1:             if string[start] != string[end]:                 return 2             start += 1             end -= 1         return 1               def end_pop(string, start, end):         end -= 1         while start &lt; len(string)//2:             if string[start] != string[end]:                 return 2             start += 1             end -= 1         return 1               def solution(strings):         result = []              for string in strings:             count = 0             start = 0             end = len(string)-1             while start &lt; len(string)//2:                 if string[start] != string[end]:                     count_sp = start_pop(string, start, end)                     count_ep = end_pop(string, start, end)                     count = min(count_ep, count_sp)                     break                 start += 1                 end -= 1             result.append(count)         return result                    if __name__ == \"__main__\":         n = int(input())         strings = []         for _ in range(n):             strings.append(sys.stdin.readline().rstrip())         results = solution(strings)         for result in results:             print(result) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_11/",
        "teaser": null
      },{
        "title": "[백준/Python] 10044 Project Teams(그리디)",
        "excerpt":"BOJ   그리디 20044 Project Teams  문제로 이동!   문제   코딩 프로젝트 수업을 가르치는 수찬이는 프로젝트 팀을 가능하면 공정하게 구성하려고 한다. 프로젝트 팀 하나는 두 명의 학생으로 구성되는데, 각 학생들의 코딩 역량은 모두 다르다. 각 학생은 한 팀의 팀원이어야 한다. 공정성을 높이기 위해 수찬이는 팀원 코딩 역량의 합을 최대한 일정하게 유지하려고 한다. 학생들이 코딩 역량이 주어졌을 때 수찬이가 팀을 구성하는데 도움이 되는 프로그램을 작성하라.                  문제를 간단하게 하기 위해, 학생 수는 2n이라 가정하자 (n은 양의 정수). 각 학생 si의 코딩 역량은 양의 정수 w(si)로 나타내면 한 i번째 팀 Gi의 코딩 역량은 w(Gi) = ∑s∈Giw(s)로 나타낼 수 있다. 작성할 프로그램 목적은 Sm = min{w(Gi)       1 ≤ i ≤ n}이 최대화되도록 n개의 팀 G1, G2, …, Gn 을 구성하고 이때 Sm을 출력하는 것이다.           예를 들어, 학생들의 코딩 역량이 {1, 7, 5, 8}로 주어졌다면 (8, 1), (7, 5)로 2개의 조를 짤 수 있으며 프로그램은 9를 출력해야 한다.   입력   입력은 표준입력을 사용한다. 입력의 첫 번째 행에는 팀 수를 나타내는 양의 정수 n(1 ≤ n ≤ 5,000)이 주어진다. 그 다음 행에 학생 si 의 코딩 역량 w(si)를 나타내는 2n개의 양의 정수가 공백으로 분리되어 주어진다 (1 ≤ w(si) ≤ 100,000). 학생들의 코딩 역량은 모두 다르다. 즉, i ≠ j이면 w(si) ≠ w(sj)이다.   예제 입력  입력: 2 [1, 7, 5, 8], 출력: 9  입력: 3 [1, 7, 3, 5, 9, 2], 출력: 8    풀이     정렬 후 양 index마다 양 끝을 더한 뒤 최소값을 출력하면 된다.    solution     정렬 후 양 index마다 양 끝을 더한 뒤 최소값을 출력하면 된다.   코드       def solution(n, students):         students.sort()         result = min([students[i]+students[(n*2)-1-i] for i in range(n)])         return result               if __name__ == \"__main__\":         n = int(input())         students = list(map(int, input().split()))         print(solution(n, students)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_12/",
        "teaser": null
      },{
        "title": "[백준/Python] 2606 바이러스(DFS/BFS)",
        "excerpt":"BOJ   그리디 2606 바이러스  문제로 이동!   문제   신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.   예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.      어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.  예제 입력       \"\"\"     case 1:     입력     3     7     6     1 2     2 3     1 5     5 2     5 6     4 7     출력     4      case 2:     입력     7        10     7     1 2     2 3     3 4      5 6     7 8     8 9     9 1     출력     6     \"\"\"  풀이     1번 정점과 연결된 모든 정점의 개수를 찾는 문제이다. 입력은 각 연결된 정점 두개를 받는다. 이를 인접리스트로 변경한 후 dfs로 접근하여 방문했던 정점의 개수-1 을 출력하면된다.(1번 자기 자신은 포함하지 않기 때문에)    solution     인접리스트를 초기화해준다.   visited 리스트를 초기화해준다.   입력받은 값을 각 값에 맞도록 인접리스트에 추가해준다.   dfs 함수를 정의해서 방문 노드를 조회한다.   코드       def dfs(v):         visited[v] = True         for i in graph[v]:             if not visited[i]:                 dfs(i)               if __name__ == \"__main__\":         n = int(input())         m = int(input())              graph = []         for _ in range(n+1):             graph.append([])              visited = [False] * (n+1)              for _ in range(m):             x, y = map(int, input().split())             graph[x].append(y)             graph[y].append(x)              dfs(1)         print(visited.count(True) - 1) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_13/",
        "teaser": null
      },{
        "title": "[백준/Python] 1206 DFS와 BFS(DFS/BFS)",
        "excerpt":"BOJ   그리디 1260 DFS와 BFS  문제로 이동!   문제   그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.   입력   첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.   예제 입력       \"\"\"     case 1:     입력     4 5 1     1 2     1 3     1 4     2 4     3 4     출력     1 2 4 3     1 2 3 4      case 2:     입력     5 5 3     5 4     5 2     1 2     3 4     3 1       출력     3 1 2 5 4     3 1 4 2 5     \"\"\"  풀이     DFS와 BFS를 사용하면 간단히 풀 수 있는 문제이다. 하지만, 입력값으로부터 인접리스트 그래프를 만들 때 들어가는 인자값을 sorting을 해주어야 정확한 순서로 그래프를 탐색한다.    solution     bfs와 dfs 함수를 정의한다.   인접리스트 graph를 초기화한다.   입력값을 저장하고 해당 리스트를 정렬한다.   bfs와 dfs 함수를 호출해 정답을 도출한다.   새로 배운점     리스트에 *을 붙여서 print하면 c언어 처럼 출력된다.   graph 인접리스트를 만들 때 heapq로 생성하면 리스트 후 정렬 하는 것보다 성능이 아주 조금 더 좋다.   코드       from collections import deque               def dfs(v):         visited_dfs[v] = True         order_dfs.append(v)         for i in graph[v]:             if not visited_dfs[i]:                 dfs(i)               def bfs(v):         visited_bfs[v] = True         order_bfs.append(v)         queue = deque([v])         while queue:             x = queue.popleft()             for i in graph[x]:                 if not visited_bfs[i]:                     visited_bfs[i] = True                     order_bfs.append(i)                     queue.append(i)               if __name__ == \"__main__\":         n, m, start = map(int, input().split())         graph = []         for _ in range(n+1):             graph.append([])              for _ in range(m):             x, y = map(int, input().split())             graph[x].append(y)             graph[x].sort()             graph[y].append(x)             graph[y].sort()                   visited_dfs = [False] * (n+1)         order_dfs = []         visited_bfs = [False] * (n+1)         order_bfs = []              dfs(start)         print(*order_dfs)         bfs(start)         print(*order_bfs) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_14/",
        "teaser": null
      },{
        "title": "[백준/Python] 1697 숨바꼭질(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 1697 숨바꼭질  문제로 이동!   문제   수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.   수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.   입력   첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.   예제 입력       \"\"\"     case 1:     입력     5 17     출력     4     힌트     5 -&gt; 19 -&gt; 9 -&gt; 18 -&gt; 17     \"\"\"  풀이        위의 그림에서 볼 수 있듯이 현재 값을 계속 큐에 집어 넣고 pop 해온 뒤 -1, +1, *2 계산한 값을 다시 큐에 집어넣고를 반복하면 모든 가능한 경우의 수를 구할 수 있다. 하지만, 한번 계산했던 값은 이미 계산을 해서 진행중이기 때문에 계산했던 값은 계산하지 않도록 분기 처리해준다.(visited 배열로 처리한다.) 또한 x의 범위가 0에서 100,000 이기 때문에 해당 조건을 만족해야하며 visited 배열은 모두 1로 초기화한 뒤 하나씩 더해가는 방식으로 진행한다. 탐색중에 k값을 만나게 되면 visited에 거리를 저장하고 바로 bfs 함수를 종료한다.(계산적 이점을 얻기 위해)    solution     visited 배열을 max값인 100001로 초기화한다.   bfs함수를 정의한다.   큐에 현재 n값을 넣는다.   while문을 queue에 원소가 없을 때 까지 돈다.   분기를 *2, +1, -1 세가지로 처리한다.   각각 dx(x*2, x+1, x-1) 이 범위에 포함되는지 체크한다.   visited[dx]가 1이라면(방문하지 않음) dx를 큐에 집어넣고, visited[dx]에 자신을 호출한 값을 더해준다.(visited[x])   만약 dx가 k라면, visited 리스트를 업데이트 해주고 바로 break문으로 반복문을 빠져 나온다.   모든 자기 자신에 2씩 더해졌으므로 visited[k] - 2 로 print 해준다.   코드       from collections import deque               def bfs(n, visited):         queue = deque([n])         visited[n] += 1         while queue:             x = queue.popleft()             if 0 &lt;= x*2 &lt;= 100000:                 if visited[x*2] == 1:                     visited[x*2] += visited[x]                     if x*2 == k:                         break                     queue.append(x*2)             if 0 &lt;= x+1 &lt;= 100000:                 if visited[x+1] == 1:                     visited[x+1] += visited[x]                     if x+1 == k:                         break                     queue.append(x+1)             if 0 &lt;= x-1 &lt;= 100000:                 if visited[x-1] == 1:                     visited[x-1] += visited[x]                     if x-1 == k:                         break                     queue.append(x-1)               if __name__ == \"__main__\":         n, k = map(int, input().split())         visited = [1] * 100001         bfs(n,visited)         print(visited[k] - 2) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_15/",
        "teaser": null
      },{
        "title": "[백준/Python] 2178 미로 탐색(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 2178 미로 탐색  문제로 이동!   문제   N×M크기의 배열로 표현되는 미로가 있다.      미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.   위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.   입력   첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.   예제 입력       \"\"\"     case 1:     입력     4 6     101111     101010     101011     111011     출력     15      case 2:     입력     2 25     1011101110111011101110111     1110111011101110111011101     출력     38     \"\"\"  풀이     bfs로 접근을한다. (0,0) 시작 위치에서 상,하,좌,우를 탐색해서 1이라면 시작 위치의 값을 더해준다. 이를 반복하면 시작위치에서 5 떨어져 잇는 곳은 5가 저장되어있다. 모든 그래프를 이 방식으로 새로 그려주면 마지막 도착위치인 (n-1,m-1)위치에 시작 위치로 부터의 거리가 저장되어 있다.    solution     해당 문제에서는 visited 리스트를 사용하지 않는다.   bfs 함수 인자로 시작 위치 x, y 좌표를 보내준다.   현재 위치에서 상,하,좌,우를 탐색할 수 있는 dx, dy 리스트를 정의해준다.(for문으로 현재 x와 y에 계산해줄 것임)   queue에 현재 위치 set 형식으로 삽입하고 while문을 돈다.   queue에서 현재 위치 x, y를 꺼내주고 상,하,좌,우를 탐색한다.   탐색시 범위를 벗어나면 continue 해준다.   상,하,좌,우 에서 1을 만나면 현재 위치의 값을 더해주고 해당 값을 큐에 삽입해준다.   코드       from collections import deque               def bfs(x, y, graph):              dx = [0, 0, 1, -1]         dy = [1, -1, 0, 0]              queue = deque()         queue.append((x,y))         while queue:             x, y = queue.popleft()             for i in range(4):                 nx = x + dx[i]                 ny = y + dy[i]                 if nx&lt;0 or nx&gt;=n or ny&lt;0 or ny&gt;=m:                     continue                 elif graph[nx][ny] == 1:                     graph[nx][ny] += graph[x][y]                     queue.append((nx,ny))               if __name__ == \"__main__\":         n, m = map(int, input().split())         graph = []         for _ in range(n):             graph.append(list(map(int,input())))              bfs(0,0, graph)         print(graph[n-1][m-1]) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_16/",
        "teaser": null
      },{
        "title": "[백준/Python] 2468 안전 영역(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 2468 안전 영역  문제로 이동!   문제   재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.   어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다.      이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다.      물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다).   또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다.      이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.   어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.   입력   첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다.   예제 입력       \"\"\"     case 1:     입력     5     6 8 2 6 2     3 2 3 4 6     6 7 3 3 2     7 2 5 3 6     8 9 5 2 7     출력     5      case 2:     입력     7     9 9 9 9 9 9 9     9 2 1 2 1 2 9     9 1 8 7 8 1 9     9 2 7 9 7 2 9     9 1 8 7 8 1 9     9 2 1 2 1 2 9     9 9 9 9 9 9 9     출력     6     \"\"\"  풀이     우리는 물에 잠기는 영역을 1부터 최대값 까지 조사하면서, 각각의 안전 영역들을 저장한 뒤 최대값을 구해주는 방식으로 접근할 것이다. 우선 graph 리스트의 최대값을 구해준다. 이후 1부터 최대값까지 물에 잠기면서 안전 영역을 구한다. 안전 영역을 구하는 방법은 graph의 (0,0) 부터 (n-1, n-1) 까지 탐색하며 잠기는 영역보다 초과한 값들을 탐색하고 해당 지역에서 상,하,좌,우를 탐색한 뒤 True로 리턴한다. True로 리턴하면 count값을 상승시켜준다. 해당 반복문이 돌면, k층까지 잠길 때의 안전영역이 구해진다. 현재 안전 영역 수와 이전의 안전 영역수를 비교해서 더 큰수를 max값에 저장한다.    solution     graph의 max값을 이중 반복문을 돌며 찾아준다.   안전 영역의 초기 max_g 값을 0으로 정의한다.   graph를 copy한다.(할당 연산자를 사용하면 얕은 복사가 이루어지며, 복사된 graph의 값을 변경하면 원본 graph도 변경된다.)            graph를 복사하는 이유는, dfs 함수에서 방문처리를 하기 위해 방문한 원소들을 0으로 변경해줄 것이기 때문이다.           max값 만큼 반복문을 돈다 : k   이중 반복문을 돌며 graph의 모든 원소값들을 확인해준다.   dfs 함수에서는 x,y가 리스트의 범위를 벗어나거나 물에 잠긴 영역이라면 False로 리턴해준다.   그렇지 않다면, 상,하,좌,우를 탐색하는 dfs 함수를 재귀적으로 호출하고 True로 리턴해준다.   graph의 모든 원소값들을 확인하며 return 받은 True의 개수를 세어 안전 영역 max 값과 비교해서 더 큰 수를 max_g에 집어 넣는다.   max_g를 print 한다.   새로 배운 것     list.copy() &lt;- 사용하면 깊은 복사가 가능하다.   2차원 리스트를 깊은 복사 하면, 내부의 리스트는 깊은 복사가 되지 않아, 반복문을 돌면서 내부의 리스트 하나하나 깊은 복사를 해주어야 한다.   코드       import sys     sys.setrecursionlimit(10**6)          def dfs(x, y, k, graph_copy):         if x &lt; 0 or x &gt;= n or y &lt; 0 or y &gt;= n:             return False         if graph_copy[x][y] &lt;= k:             return False         graph_copy[x][y] = 0         dfs(x-1, y, k, graph_copy)         dfs(x+1, y, k, graph_copy)         dfs(x, y-1, k, graph_copy)         dfs(x, y+1, k, graph_copy)         return True          if __name__ == \"__main__\":         n = int(input())         graph = []         for _ in range(n):             graph.append(list(map(int, input().split())))              max_v = max(graph[0])         for g in graph:             if max_v &lt; max(g):                 max_v = max(g)              max_g = 0         for k in range(max_v):             graph_copy = [g.copy() for g in graph]             count = 0             for i in range(n):                 for j in range(n):                     if dfs(i, j, k, graph_copy):                         count += 1             if max_g &lt; count:                 max_g = count              print(max_g) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_17/",
        "teaser": null
      },{
        "title": "[백준/Python] 2644 촌수계산(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 2644 촌수계산  문제로 이동!   문제   우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.   여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.   입력   사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.   각 사람의 부모는 최대 한 명만 주어진다.   예제 입력       \"\"\"     case 1:     입력     9     7 3     7     1 2     1 3     2 7     2 8     2 9     4 5     4 6     출력     3      case 2:     입력     9     8 6     7     1 2     1 3     2 7     2 8     2 9     4 5     4 6     출력     -1     \"\"\"  풀이     bfs로 찾고자 하는 두 개의 노드 사이를 계산 할 것이다. 찾고자 하는 두 개의 노드 중에서 기준 노드를 하나 잡는다. visited 리스트를 1로 초기화(1일 땐 방문하지 않은 것이다.)하고, 방문하게 되는 노드에 visited 리스트를 이전 노드에 저장된 값만큼 더해줄 것이다. 그렇다면 2 -&gt; 3 -&gt; 4 -&gt; … 순서로 기준 노드부터 기준 노드와 인접한 노드는 값이 저장될 것이다. 기준 노드와 찾고자 하는 노드의 인덱스를 뽑아서 -2를 해주면 정답을 도출할 수 있다.    solution     visited 리스트를 1로 초기화해준다.   찾고자하는 노드중 하나를 기준 값, 하나를 찾는 값으로 설정하고, bfs의 인자에 기준 값을 전해준다.   bfs를 돌면서 방문하게 되는 노드의 visited 값에 해당 노드를 호출한 노드의 visited 값을 더해준다.   bfs 함수가 return 되면, 찾고자 하는 노드의 visited값 - 2를 출력해준다.   코드   from collections import deque       def bfs(v, graph, visited):         queue = deque([v])         visited[v] += 1         while queue:             v = queue.popleft()             for i in graph[v]:                 if visited[i] == 1:                     visited[i] = visited[i] + visited[v]                     queue.append(i)               if __name__ == \"__main__\":         n = int(input())         x, y = map(int, input().split())         m = int(input())              visited = [1] * (n+1)         graph = []         for _ in range(n+1):             graph.append([])              for _ in range(m):             v1, v2 = map(int, input().split())             graph[v1].append(v2)             graph[v2].append(v1)              bfs(x, graph, visited)         print(visited[y] - 2) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_18/",
        "teaser": null
      },{
        "title": "[백준/Python] 2667 단지번호붙이기(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 2667 단지번호붙이기  문제로 이동!   문제   &lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.      입력   첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.   예제 입력       \"\"\"     case 1:     입력     7     0110100     0110101     1110101     0000111     0100000     0111110     0111000     출력     3     7     8     9     \"\"\"  풀이     전체 graph의 인자를 하나씩 훑으면서 1을 만나게 되면 dfs로 접근하여 1과 인접한 1들을 모두 찾은 뒤 count를 세어준다(단지 하나의 크기를 세기 위해). 또한, 1을 찾게 되면 무조건 True로 리턴해서 전체 단지의 개수를 세준다. dfs 함수 내에서는 현재 위치의 상,하,좌,우를 탐색하여 인접한 1들을 찾아낸다.    solution     graph 리스트의 인자값을 이중 반복문을 사용하여 전체 인자값을 탐색할 수 있도록 설정한다.   단지내 집의 수를 세기 위해 전역변수 x_count를 정의한다.(재귀함수 내에서 count 해야하기 때문에 전역변수로 지정했다.)   단지수를 세기 위해 지역변수 total_count를 정의한다.(재귀함수 내에서 1을 발견하면 True로 return 한 뒤 재귀함수 호출의 return 값이 True라면 total_count++을 해준다.)   재귀 함수 내에서 현재 위치가 리스트 범위를 벗어나면 False로 return 한다.   재귀 함수 내에서 현재 위치가 0이라면 False로 return 한다.   재귀 함수 내에서 현재 위치가 1이라면 0으로 변경해준 뒤 x_count를 1 올려준다. 이후 현재 위치에서 상,하,좌,우로 dfs함수를 호출하여 재귀적으로 탐색한다. 이후 return 값은 True이다.   호출한 dfs 리턴값이 True라면, total_count를 1 올려주고, count_list에 x_count를 저장해준다.   graph의 이중반복문을 통해서 모든 위치에서 탐색이 완료되면, count_list는 정렬하고 print한다.   코드       def dfs(x, y, graph):         global x_count         if x &lt; 0 or x &gt;= n or y &lt; 0 or y &gt;= n:             return False         if graph[x][y] == 0:             return False         else:             graph[x][y] = 0             x_count += 1             dfs(x+1, y, graph)             dfs(x-1, y, graph)             dfs(x, y+1, graph)             dfs(x, y-1, graph)             return True               if __name__ == \"__main__\":         n = int(input())         graph = []         for _ in range(n):             graph.append(list(map(int,input())))              total_count = 0         count_list = []         global x_count              for i in range(n):             for j in range(n):                 x_count = 0                 if dfs(i, j, graph):                     total_count += 1                     count_list.append(x_count)         count_list.sort()         print(total_count)         for c in count_list:             print(c) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_19/",
        "teaser": null
      },{
        "title": "[백준/Python] 7596 토마토(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 7596 토마토  문제로 이동!   문제   철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.      창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.   토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.   입력   첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.   토마토가 하나 이상 있는 경우만 입력으로 주어진다.   예제 입력       \"\"\"     case 1:     입력     5 3 1     0 -1 0 0 0     -1 -1 0 1 1     0 0 0 1 1     출력     -1          case 2:     입력     5 3 2     0 0 0 0 0     0 0 0 0 0     0 0 0 0 0     0 0 0 0 0     0 0 1 0 0     0 0 0 0 0     출력     4     \"\"\"  풀이     bfs로 접근한다. 토마토를 입력받을 때 1인 위치를 미리 큐에 모두 집어 넣는다.(이렇게 하는 이유는 이 문제에서 bfs로 탐색하는 순서가 중요하기 때문이다.) 3차원 리스트이기 때문에 bfs의 탐색을 앞,뒤,좌,우,상,하 6개의 dx로 나누어 탐색한다. 범위를 벗어나거나 -1을 만나면 countinue 해준다.          1번 경우는 1을 미리 큐에 집어 넣지 않고, (단지번호붙이기 문제) 처럼 반복문을 통해 1을 찾고 해당 1에서 접근 가능한 노드를 탐색할 때의 순서이다. 2번 경우는 1을 미리 큐에 집어 넣고, 해당 큐로부터 bfs를 접근하는 순서이다. (0,0) 위치가 익은 토마토가 되기 까지에 2일이 걸리지만, 1번 경우에는 3일이 걸리게 되어 틀린 답이 도출된다. 또한 1번 경우에서 dfs 함수 내에 조건을 걸어 min()으로 예외 처리를 해준다면 시간초과로 인해 틀린 답이 도출된다.    solution     box 리스트를 초기화 해주며 값이 1인 위치를 큐에 집어 넣는다.   bfs 함수를 호출한다.   앞, 뒤, 상, 하, 좌, 우 위치를 탐색할 수 있는 dx, dy, dz를 정의한다. (6번의 반복문을 통해 접근할 것이다.)   큐에서 x, y, z를 꺼낸 뒤 dx, dy, dz와 더해준다.   nx, ny, nz가 범위를 벗어나거나 -1을 만나면 continue 해준다.   0이라면 x, y, z 의 값에 1을 더해준 값을 대입하고 큐에 추가해준다.   bfs함수가 종료되면, 반복문을 돌며 0인 값을 찾고 만약 있다면 -1을 print 해주고 종료해준다.   최대값을 갱신해주며 마지막 최대값을 출력해준다.   코드       from collections import deque               def bfs(queue,box):         dx = [1, -1, 0, 0, 0, 0]         dy = [0, 0, 1, -1, 0, 0]         dz = [0, 0, 0, 0, 1, -1]         while queue:             x, y, z = queue.popleft()             for i in range(6):                 nx = x + dx[i]                 ny = y + dy[i]                 nz = z + dz[i]                 if nx &lt; 0 or nx &gt;= h or ny &lt; 0 or ny &gt;= n or nz &lt; 0 or nz &gt;= m:                     continue                 if box[nx][ny][nz] == -1:                     continue                 if box[nx][ny][nz] == 0:                     queue.append((nx,ny,nz))                     box[nx][ny][nz] = box[x][y][z] + 1               if __name__ == \"__main__\":         m, n, h = map(int, input().split())         box = []         queue = deque()         for i in range(h):             floor = []             for j in range(n):                 floor.append(list(map(int, input().split())))                 for k in range(m):                     if floor[j][k] == 1:                         queue.append((i,j,k))             box.append(floor)              bfs(queue, box)              max_count = 0         for b in box:             for f in b:                 if f.count(0) &gt;= 1:                     print(-1)                     exit()                 if max_count &lt; max(f):                     max_count = max(f)              print(max_count - 1) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_20/",
        "teaser": null
      },{
        "title": "[백준/Python] 9205 맥주 마시면서 걸어가기(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 9205 맥주 마시면서 걸어가기  문제로 이동!   문제   송도에 사는 상근이와 친구들은 송도에서 열리는 펜타포트 락 페스티벌에 가려고 한다. 올해는 맥주를 마시면서 걸어가기로 했다. 출발은 상근이네 집에서 하고, 맥주 한 박스를 들고 출발한다. 맥주 한 박스에는 맥주가 20개 들어있다. 목이 마르면 안되기 때문에 50미터에 한 병씩 마시려고 한다. 즉, 50미터를 가려면 그 직전에 맥주 한 병을 마셔야 한다.   상근이의 집에서 페스티벌이 열리는 곳은 매우 먼 거리이다. 따라서, 맥주를 더 구매해야 할 수도 있다. 미리 인터넷으로 조사를 해보니 다행히도 맥주를 파는 편의점이 있다. 편의점에 들렸을 때, 빈 병은 버리고 새 맥주 병을 살 수 있다. 하지만, 박스에 들어있는 맥주는 20병을 넘을 수 없다. 편의점을 나선 직후에도 50미터를 가기 전에 맥주 한 병을 마셔야 한다.   편의점, 상근이네 집, 펜타포트 락 페스티벌의 좌표가 주어진다. 상근이와 친구들이 행복하게 페스티벌에 도착할 수 있는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 t가 주어진다. (t ≤ 50)   각 테스트 케이스의 첫째 줄에는 맥주를 파는 편의점의 개수 n이 주어진다. (0 ≤ n ≤ 100).   다음 n+2개 줄에는 상근이네 집, 편의점, 펜타포트 락 페스티벌 좌표가 주어진다. 각 좌표는 두 정수 x와 y로 이루어져 있다. (두 값 모두 미터, -32768 ≤ x, y ≤ 32767)   송도는 직사각형 모양으로 생긴 도시이다. 두 좌표 사이의 거리는 x 좌표의 차이 + y 좌표의 차이 이다. (맨해튼 거리)   예제 입력       \"\"\"     case 1:     입력2     2     0 0     1000 0     1000 1000     2000 1000     2     0 0     1000 0     2000 1000     2000 2000     출력     happy     sad     \"\"\"  풀이     처음은 그리디 정렬로 접근 하였다. 하지만, 정렬로 접근하면 음수값에서 큰 오류가 발생한다. 그렇기 때문에 원점(상근이의 집)과 각 편의점끼리 갈 수 있는 거리인지 조사를 해야한다. 원점과 각 편의점이 노드이고 갈 수 있는 거리(1000m)가 조건이다. 원점부터 1000m 거리에 있는 편의점들을 큐에 넣고, 해당 편의점에서 또 갈 수 있는 편의점들을 큐에 넣다보면, 어느새 페스티벌에 갈 수 있는지 갈 수 없는지를 판단할 수 있다. visited 배열을 통해서 한번 갔던 편의점들은 방문처리를 해서 재방문을 하지 않도록 한다.          그리디 정렬에서 해결할 수 없는 예제   1 2 0 500 -1000 1000 1000 500 1000 1500  solution     각각의 테스트를 반복문을 통해 하나씩 bfs 함수를 호출하고 print 해준다.   bfs에서 상근이의 집(start) 좌표를 큐에 넣는다.   큐가 빌 때까지 while문을 돈다.   큐에서 x, y 좌표를 꺼낸다.   test(편의점과 페스티벌 도착 위치가 담겨져 있는 리스트)를 반복문을 돌면서 하나씩 꺼내서 x, y 좌표와 비교한다.   1000 이하라면, 해당 test의 좌표를 큐에 넣고 방문처리한다.   만약 페스티벌이 방문처리되면 즉시 리턴한다.   코드       from collections import deque            def bfs(start, test, length):         queue = deque()         queue.append((start))         while queue:             x, y = queue.popleft()             for i in range(length):                 if not visited[i]:                     if abs(x-test[i][0]) + abs(y-test[i][1]) &lt;= 1000:                         queue.append(test[i])                         visited[i] = True                         if visited[length-1]:                             return True               if __name__ == \"__main__\":         n = int(input())         tests = []         starts = []         ends = []         for _ in range(n):             x = []             m = int(input())             starts.append(list(map(int, input().split())))             for _ in range(m+1):                 x.append(list(map(int, input().split())))             tests.append(x)              for start, test in zip(starts, tests):             length = len(test)             visited = [False] * (length+1)             if bfs(start, test, length):                 print(\"happy\")             else:                 print(\"sad\") ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_21/",
        "teaser": null
      },{
        "title": "[OSTEP] 운영체제 개요",
        "excerpt":"운영체제 개요  프로그램이 실행될 때 어떤일이 일어날까?     명령어가 실행된다.   프로세서는 명령어를 초당 수백만번 fetch, decode, execute 한다.   시스템을 사용하기 쉽게하기 위해(easy to use) 프로그램 실행 시 다양한 일들이 발생한다.     프로그램 간의 메모리 공유를 가능하게 한다.   프로그램이 장치와 상호작용을 가능하게한다.   시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 소프트웨어를 운영체제(operating stystem, OS)라고 부른다.   운영체제에는 세가지 기법을 사용한다.     가상화(virtualization)   병행성(concurrency)   영속성(persistence)   가상화  운영체제는 프로세서, 메모리, 또는 디스크와 같은 물리적(physical)인 자원을 이용하여 일반적이고 강력하고 사용이 편리한 가상(virtual) 형태의 자원을 생성한다. 때문에 운영체제를 때로는 가상 머신(virtual machine)이라고 부른다.   두가지 가상화가 존재한다.     CPU 가상화   메모리 가상화   CPU 가상화  여러개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것을 CPU 가상화(virtualizing the CPU)라 한다.       #include &lt;stdio.h&gt;     #include &lt;stdlib.h&gt;     #include &lt;sys/time.h&gt;     #include &lt;assert.h&gt;     int     main(int argc, char *argv[]){         if (argc != 2){             fprintf(strderr, \"usage: cpu &lt;string&gt;\\n);             exit(1);         }         char *str = argv[1]         while (1){             Spin(1);             printf(\"%s\\n\", str);         }         return 0;          /*     입력:     prompt&gt; ./cpu A &amp; ; ./cpu B &amp; ./cpu C &amp; ; ./cpu D &amp;     출력:     (아래 그림)     */     }     메모리 가상화  물리 메모리 모델은 매우 단순한 바이트의 배열이다. 메모리는 프로그램이 실행되는 동안 항상 접근한다.       #include &lt;unistd.h&gt;     #include &lt;stdio.h&gt;     #include &lt;stdlib.h&gt;     int     main(int argc, char *argv[]){         int *p = malloc(sizeof(int));         printf(\"(%d) memory address of p: %u\\n\", getpid(), (unsigned)p);         *p = 0;         int cnt = 0;         while (cnt &lt;= 20) {             *p = *p + 1;             printf(\"(%d) p: %d\\n\", getpid(), *p);             cnt++;         }         return 0;     }     /*     입력:     prompt&gt; ./mem &amp; ; ./mem &amp;     출력:     (24113) memory address of p: 0x20000     (24114) memory address of p: 0x20000     (24113) p:1     (24114) p:1     (24113) p:2     (24114) p:2     .     .       .     */     책에서는 위의 출력처럼 나온다고 했는데 나는 직접 해보니 아래의 그림처럼 다른 메모리값을 가지게 나왔다.         위의 출력 예제와 같이 각각이 독립적으로 메모리 주소 번지의 값을 갱신한다. 물리 메모리를 다른 프로그램과 공유하는 것이 아니라 각자 자신의 메모리를 가지고 있는 것 처럼 보인다. 운영체제가 메모리 가상화(virtualiziang memory)을 하기 때문에 이런 현상이 생긴다.   각 프로세스는 자신만의 가상 주소 공간(virtual address space)을 갖는다.   병행성  프로그램이 한 번에 많은 일을 하려할 때 (즉, 동시에) 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 병행성 용어를 사용한다.      병행성과 병렬성의 차이         병행성: 동시에 처리 되는 것 ‘처럼’ 보임     병렬성: 진짜 동시에 처리 됨           영속성  DRAM과 같은 장치는 데이터를 휘발성(volatile) 방식으로 저장하기 때문에 메모리의 데이터는 쉽게 손시로딜 수 있따. 데이터를 영속적(persistence)으로 저장할 수 있는 하드웨어와 소프트웨어가 필요하다.   ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_01/",
        "teaser": null
      },{
        "title": "[OSTEP] CPU 가상화 - 프로세스 개념과 문맥전환",
        "excerpt":"1. 프로세스의 개념   1.1 프로세스의 개념     운영체제는 실행 중인 프로그램의 개념을 제공하는데, 이를 프로세스(process)라고 한다.   프로세스의 구성 요소를 이해하기 위해서 하드웨어 상태를 이해해야 한다.            메모리: 프로그램의 명령어와 데이터는 메모리에 저장된다.       레지스터: 프로그램의 많은 명령어들이 레지스터를 직접 읽거나 갱신한다.           1.2 프로세스 API     운영체제가 제공하는 API 중 중요한 다섯가지            생성(Create): 운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야 한다.       제거(Destroy): 운영체제는 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다.       대기(Wait): 프로세스의 실행 중지를 기다릴 필요가 있다.       각종 제어(Miscellaneous Control): 일시정지나 재개등       상태(Status): 프로세스 상태 정보를 얻어내는 인터페이스를 제공한다.           1.3 프로세스 생성: 좀 더 자세하게     프로그램 실행을 위하여 운영체제가 하는 첫 번째 작업은 프로그램 코드와 정적 데이터(static data)를 메모리, 프로세스의 주소공간에 탑재(load)하는 것이다.   코드와 정적 데이터가 메모로 탑재된 후 운영체제는 다음과 같은 일을 한다.            운영체제는 특정 크기의 메모리 공간이 프로그램에 스택(run-time stack) 용도로 할당되어야 한다.       운영체제는 프로그램의 힙(heap)을 위한 메모리 영역을 할당한다.       운영체제는 입출력과 관계된 초기화 작업을 수행한다.       위의 세가지 일을 끝마치면 main() 루틴으로 분기함으로써 프로그램 실행이 시작된다.           1.4 프로세스 상태     프로세스 상태            실행(Running): 프로세스는 프로세서에서 실행 중이다. 즉, 명령어를 실행하고 있다.       준비(Ready): 프로세스는 실행할 준비가 되어 있지만, 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다.       대기(Blocked): 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산이다. 예: 입출력을 요청하고 블락됨           프로세스는 운영체제의 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 전이한다.        위의 그림은 “프로세스: 상태 전이” 이다.   1.5 자료 구조     운영체제도 일종의 프로그램으로서 다양한 정보를 유지하기 위한 자료 구조를 가지고 있따.            ex1: 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 프로세스 리스트(process list)를 유지한다.       ex2: 실행 중 프로세스를 명시하기 위한 부가적인 자료 구조도 유지한다.       ex3: 대기 상태인 프로세스들에 대한 정보도 관리한다.           1.6 요약     프로세스는 간단히 말하면 실행 중인 프로그램이다.   프로세스의 핵심 사항            프로세스 구현에 필요한 기법       구현한 프로세스를 스케줄링하는 정책           2. 제한적 직접 실행 원리(Limited Direct Execution)     CPU를 가상화하기 위해서 운영체제는 여러 작업들이 동시에 실행되는 것처럼 보이도록 물리적인 CPU를 공유한다.            CPU 시간을 나누어 씀으로써 가상화를 구현할 수 있다.           위와 같은 가상화 기법을 구현하기 위해서는 몇 가지 문제를 해결해야 한다.            성능 저하 : 시스템에 과중한 오버헤드를 주어선 안됨       제어 문제 : CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시켜야함           2.1 기본 원리: 제한적 직접 실행(LDE)     운영체제 개발자들은 프로그램을 빠르게 실행하기 위하여 제한적 직접 실행(Limited Direct Excution, LDE)라는 기법을 개발하였다.            “직접 실행”: 프로그램을 CPU 상에서 그냥 직접 실행           제한적 직접 실행 접근법은 CPU를 가상화함에 있어 몇가지 문제를 일으킨다.            프로그램을 직접 실행시킨다면 프로그램이, 운영체제가 원치않는 일을 하지 않는다는 것을 어떻게 보장할 수 있는가?       프로세스 실행시, 운영체제는 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환시킬 수 있는가                    즉, CPU를 가상화하는 데 필요한 시분할(time sharing)기법을 어떻게 구현하는가                           2.2 문제점 1: 제한된 연산     직접 실행의 장점은 빠르게 실행된다는 것이다.   하지만 프로세스가 디스크에 대하여 입출력을 제한하지 않으면 운영체제의 접근 권한 기능이 의미가 없다.            이 때문에 사용자 모드(user mode)가 도입되었다.           사용자 모드(user mode): 사용자 모드에서 실행되는 코드는 할 수 있는 일이 제한된다.        커널 모드(kernel mode): 사용자 모드와 대비되는 모드로서 운영체제의 중요한 코드들이 실행된다.       사용자 모드에서 운영체제의 도움이 필요할 때 시스템 콜을 사용한다.   커널은 시스템 콜을 통하여 자신의 주요 기능을 사용자 모드 프로그램에게 제공한다.   시스템 콜을 실행하기 위해 프로그램은 trap 특수 명령어를 실행해야 한다.   호출한 프로세스의 필요한 레지스터들을 저장해야 한다.            운영체제가 return-from-trap 명령어 실행 시 사용자 프로세스로 제대로 리턴할 수 있어야 하기 위함이다.       PC, 플래그, 레지스터를 각 프로세스의 커널 스택에 저장한다.           커널은 부팅 시에 트랩 테이블을 만들고 이를 이용하여 시스템을 통제한다.        운영체제는 특정 명령어를 사용하여 하드웨어에게 트랩 핸들러(trap handler)의 위치를 알려준다.            모든 시스템 콜은 자신의 고유 번호를 갖고 있따.       LDE 방식은 두 단계로 진행된다.            전반부에서(부팅 시) 커널은 트랩 테이블을 초기화하고 CPU는 나중에 사용하기 위하여 테이블의 위치를 기억한다.       후반부에서(프로세스를 실행할 때) return-from-trap을 이용하여 사용자 프로세스를 시작할 때 몇 가지 작업을 수행한다.                    프로세스 리스트 삽입, 메모리 할당 등                           2.3 문제점 2: 프로세스 간 전환     직접 실행의 두 번째 문제점은 프로세스 전환이 가능해야한다는 점이다.   협조 방식: 시스템 콜 호출시 까지 대기     협조 방식은 각 사용자 프로세스가 비정상적인 행동은 하지 않을것으로 가정한다.            프로세스들이 CPU를 사용 완료하면 CPU를 반납할 것이라 믿는다.           이 방식의 문제점은 프로세스가 무한 루프에 빠져 시스템 콜을 호출할 수 없다면 문제가 발생할 수 있다.   비협조 방식: 운영체제가 제어권 확보     타이머 인터럽트를 이용한다.            타이머는 수 밀리 초마다 인터럽트라 불리는 하드웨어 신호를 발생시킨다.           인터럽트가 발생하면 운영체제는 현재 수행 중인 프로세스를 중단시키고 해당 인터러븥에 대한 인터럽트 핸들러(interrupt handler)를 실행한다.   운영체제는 타이머 인터럽트가 발생 시 실행해야 할 코드의 주소를 기록해두어야 한다.   문맥의 저장과 복원     시스템 콜을 통하여 협조적으로 하던, 타이머 인터럽트를 통하여 약간은 강제적으로 하던, 운영체제가 제어권을 다시 획득하면 중요한 결정을 내려야 한다.            현재 실행 중인 프로세스를 계속 실행할 것인지 아니면 다른 프로세스로 전환될 것인지를 결정해야 한다.       이결 정은 운영체제의 스케줄러(scheduler)라는 부분에 의해 내려진다.           현재 프로세스를 중단하고 다른 프로세스를 실행하기로 결정을 하면 운영체제는 문맥 교환(context switch)이라 불리는 코드를 실행한다.            현재 실행 중인 프로세스의 레지스터 값들을 커널 스택에 저장하고, 새로 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이다.                위의 그림은 제한적 직접 실행 방식(타이머 인터럽트)의 예시이다.  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_02/",
        "teaser": null
      },{
        "title": "[OSTEP] CPU 가상화 - 프로세스 API 구현",
        "excerpt":"gcc 컴파일 방법     옵션            -o: 오브젝트의 파일명 설정       -c: 소스파일과 같은 이름의 오브젝트 파일 생성       -I(대문자 i): 헤더파일을 검색할 디렉토리 명       -L: 라이브러리를 검색할 디렉토리명       -l(소문자 L): 링크할 라이브러리 파일명           c 컴파일            gcc -o         ex) gcc -o main main.c           실행            ./       ex) ./main           fork() 시스템 콜     프로세스 생성에 fork() 시스템 콜이 사용된다.   fork() 는 자신과 비슷한 자식 프로세스를 생성한다.            자식 프로세스는 자신의 주소 공간, 자신의 레지스터, 자신의 PC 값을 가진다.               #include &lt;stdio.h&gt;     #include &lt;stdlib.h&gt;     #include &lt;unistd.h&gt;      int main(int argc, char *argv[]){         printf(\"hello world (pid:%d)\\n\", (int)getpid());         int rc = fork();         if (rc &lt; 0){             fprintf(stderr, \"fork failed\\n\");             exit(1);         } else if (rc == 0){             printf(\"hello, I am child (pid:%d)\\n\", (int)getpid());         } else {             printf(\"hello, I am parent of %d (pid:%d)\\n\", rc, (int)getpid());         }         return 0;     }     fork()와 wait() 호출     wait() 시스템 콜을 호출하여 자식 프로세스 종료 시점까지 자신의 실행을 잠시 중지시킨다.       #include &lt;stdio.h&gt;     #include &lt;unistd.h&gt;     #include &lt;stdlib.h&gt;          int main(int argc, const char * argv[]) {         // insert code here...         printf(\"hello world (pid:%d)'\\n\", (int)getpid());         int rc = fork();         if (rc &lt; 0) {             fprintf(stderr, \"fork failen\");             exit(1);         } else if (rc == 0){             printf(\"hello, I am child (pid:%d)\\n\", (int)getpid());         } else{             int rc_wait = wait(NULL);             printf(\"hello, I am parent of %d (rc_wait:%d) (pid:%d)\\n\", rc, rc_wait, (int)getpid());         }         return 0;     }        결과를 보면 알 수 있듯이 fork() 함수만 사용했을 때는 부모 프로세스의 정보가 먼저 출력되었지만, wait()을 사용해서 자식 프로세스의 정보가 먼저 출력 되었다.   exec() 시스템 콜     자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용한다.   fork() 시스템 콜은 자신의 복사본을 생성하여 실행한다.   exec() 시스템 콜은 자신의 복사본이 아닌 새로운 프로세스를 생성하여 실행한다.       #include &lt;stdio.h&gt;     #include &lt;unistd.h&gt;     #include &lt;stdlib.h&gt;     #include &lt;string.h&gt;     #include &lt;sys/wait.h&gt;          int main(int argc, const char * argv[]) {         printf(\"hello world (pid:%d)'\\n\", (int)getpid());         int rc = fork();         if (rc &lt; 0) {             fprintf(stderr, \"fork failen\");             exit(1);         } else if (rc == 0){             printf(\"hello, I am child (pid:%d)\\n\", (int)getpid());             char *myargs[3];             myargs[0] = strdup(\"wc\");             myargs[1] = strdup(\"main.c\");             myargs[2] = NULL;             execvp(myargs[0], myargs);             printf(\"this shouldn't print out\");         } else{             int rc_wait = wait(NULL);             printf(\"hello, I am parent of %d (rc_wait:%d) (pid:%d)\\n\", rc, rc_wait, (int)getpid());         }         return 0;     }        결과를 보면 exec() 함수 호출 이후 “printf(“this shouldn’t print out”);” 이 출력되지 않음을 확인할 수 있다.   왜, 이런 API를?     Unix 쉘을 구현하기 위해서는 fork()와 exec()을 분리해야한다.   그래야만 쉘이 fork()를 호출하고 exec()를 호출해서 프로세스를 만들어낸다.  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_process_API/",
        "teaser": null
      },{
        "title": "[백준/Python] 2573 빙산(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 2468 안전 영역  문제로 이동!   문제   지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.      빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.   그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.      한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.   입력   첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. N과 M은 3 이상 300 이하이다. 그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0 이상 10 이하이다. 배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. 배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.   예제 입력       \"\"\"     case 1:     입력     5 7     0 0 0 0 0 0 0     0 2 4 5 3 0 0     0 3 0 2 5 2 0     0 7 6 2 4 0 0     0 0 0 0 0 0 0     출력     2     \"\"\"  풀이     전체 빙산의 정보를 저장하는 리스트(info)와 빙산의 방문처리(visited)를 위한 2차원 리스트를 생성한다. bfs를 돌기 전에 info의 길이를 구한다.  무한 루프에서 bfs를 돌면서 방문 횟수를 count 한다. bfs 함수가 종료되면 count와 info의 길이를 비교한다. 같다면 빙산이 모두 이어져 있는 것이고, count가 더 작다면 2등분 된것으로 간주하고 반복문을 종료한다.    코드       from collections import deque      def bfs(x, y):         global count         info = []              queue = deque()         queue.append((x,y))         visited[x][y] = True                   dx = [0, 0, 1, -1]         dy = [1, -1 ,0, 0]              while queue:             x, y = queue.popleft()             count += 1             water_count = 0             for i in range(4):                 nx = x + dx[i]                 ny = y + dy[i]                 if nx &lt; 0 or nx &gt;= n or ny &lt; 0 or ny &gt;= m:                     continue                 if visited[nx][ny]:                     continue                 if graph[nx][ny] &gt; 0:                     queue.append((nx,ny))                     visited[nx][ny] = True                 if graph[nx][ny] == 0:                     water_count += 1             graph[x][y] -= water_count             if graph[x][y] &lt; 0:                 graph[x][y] = 0             if graph[x][y] &gt; 0:                 info.append((x,y))              return info               if __name__ == \"__main__\":         n, m = map(int, input().split())         graph = []         info = []         for i in range(n):             graph.append(list(map(int, input().split())))             for j in range(m):                 if graph[i][j] &gt; 0:                     info.append((i,j))              total_count = 0         flag = 0         while True:             visited = [[False] * m for _ in range(n)]             x, y = info[0]             length = len(info)             count = 0             info = bfs(x, y)             if length &gt; count:                 break             if len(info) &lt; 1:                 flag = 1                 break             total_count += 1         if flag == 1:             print(0)         else:             print(total_count) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_22/",
        "teaser": null
      },{
        "title": "[백준/Python] 5014 스타트링크(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 5014 스타트링크  문제로 이동!   문제   강호는 코딩 교육을 하는 스타트업 스타트링크에 지원했다. 오늘은 강호의 면접날이다. 하지만, 늦잠을 잔 강호는 스타트링크가 있는 건물에 늦게 도착하고 말았다.   스타트링크는 총 F층으로 이루어진 고층 건물에 사무실이 있고, 스타트링크가 있는 곳의 위치는 G층이다. 강호가 지금 있는 곳은 S층이고, 이제 엘리베이터를 타고 G층으로 이동하려고 한다.   보통 엘리베이터에는 어떤 층으로 이동할 수 있는 버튼이 있지만, 강호가 탄 엘리베이터는 버튼이 2개밖에 없다. U버튼은 위로 U층을 가는 버튼, D버튼은 아래로 D층을 가는 버튼이다. (만약, U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다)   강호가 G층에 도착하려면, 버튼을 적어도 몇 번 눌러야 하는지 구하는 프로그램을 작성하시오. 만약, 엘리베이터를 이용해서 G층에 갈 수 없다면, “use the stairs”를 출력한다.   입력   첫째 줄에 F, S, G, U, D가 주어진다. (1 ≤ S, G ≤ F ≤ 1000000, 0 ≤ U, D ≤ 1000000) 건물은 1층부터 시작하고, 가장 높은 층은 F층이다.   예제 입력       \"\"\"     case 1:     입력     10 1 10 2 1     출력     6      case 2:     입력     100 2 1 1 0     출력     use the stairs     \"\"\"  풀이     BFS를 통해 접근한다. 현재 위치에서 시작해서 방문 처리를 하며 u와 d에 접근한다. 만약 현재 위치가 도착지 위치라면 반복문을 끝내고 visited에서 목표 위치의 방문 count를 출력해주면된다. 방문 count는 자신을 부른 방문 위치의 count를 더해주며 증가시킨다.    코드       from collections import deque               def bfs(s, visited):         queue = deque([s])         visited[s] = 1         while queue:             x = queue.popleft()             if x+u &lt;= f:                 if visited[x+u] == 0:                     queue.append(x+u)                     visited[x+u] = visited[x] + 1                     if x+u == g:                         break             if x-d &gt; 0:                 if visited[x-d] == 0:                     queue.append(x-d)                     visited[x-d] = visited[x] +1                     if x-d == g:                         break               if __name__ == \"__main__\":         f, s, g, u, d = map(int, input().split())         visited = [0] * (f+1)         bfs(s, visited)         if visited[g] == 0:             print(\"use the stairs\")         else:             print(visited[g]-1) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_23/",
        "teaser": null
      },{
        "title": "[백준/Python] 14503 로봇 청소기(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 14503 로봇 청소기  문제로 이동!   문제   로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.   로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 북쪽에서부터 r번째, 서쪽에서부터 c번째로 위치한 칸은 (r, c)로 나타낼 수 있다.   로봇 청소기는 다음과 같이 작동한다.      현재 위치를 청소한다.   현재 위치에서 다음을 반복하면서 인접한 칸을 탐색한다.  a. 현재 위치의 바로 왼쪽에 아직 청소하지 않은 빈 공간이 존재한다면, 왼쪽 방향으로 회전한 다음 한 칸을 전진하고 1번으로 돌아간다. 그렇지 않을 경우, 왼쪽 방향으로 회전한다. 이때, 왼쪽은 현재 바라보는 방향을 기준으로 한다.  b. 1번으로 돌아가거나 후진하지 않고 2a번 단계가 연속으로 네 번 실행되었을 경우, 바로 뒤쪽이 벽이라면 작동을 멈춘다. 그렇지 않다면 한 칸 후진한다.   입력   첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)   둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.   셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.   로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.   예제 입력       \"\"\"     case 1:     입력     3 3     1 1 0     1 1 1     1 0 1     1 1 1     출력     1      case 2:     입력     11 10     7 4 0     1 1 1 1 1 1 1 1 1 1     1 0 0 0 0 0 0 0 0 1     1 0 0 0 1 1 1 1 0 1     1 0 0 1 1 0 0 0 0 1     1 0 1 1 0 0 0 0 0 1     1 0 0 0 0 0 0 0 0 1     1 0 0 0 0 0 0 1 0 1     1 0 0 0 0 0 1 1 0 1     1 0 0 0 0 0 1 1 0 1     1 0 0 0 0 0 0 0 0 1     1 1 1 1 1 1 1 1 1 1     출력     57       \"\"\"  풀이     구현으로 해결하였다. 문제에서는 0이 북쪽, 1이 동쪽, 2가 남쪽, 3이 서쪽이지만, 풀이 편의상 동쪽과 서쪽의 번호를 바꾸었다. 이렇게 할 경우, 0~3의 방향 순서가 로봇 청소기가 탐색을 위해 회전하는 방향의 순서와 같아지므로 반복문으로 코드를 줄일 수 있다. 로봇청소기가 상,하,좌,우를 탐색하고 0이 있다면 진행후 방향을 진행 방향으로 업데이트, 모두 탐색해도 0이 없다면 현재 방향의 뒤를 탐색하고 벽이 아니라면 방향을 현재 방향으로 업데이트하고 뒤로 이동한다.(후진) 이후 벽을 만나게 되면 현재 count로 리턴한다.     DFS로도 문제를 해결할 수 있다고 한다.    코드       from collections import deque               def solution(r, c, d, graph):         graph[r][c] = -1         count = 1         dx = [0, 1, 0, -1]         dy = [-1, 0, 1, 0]         queue = deque()         queue.append((r, c))         while queue:             flag = 0             x, y = queue.popleft()             for i in range(4):                 nx = x + dx[(d + i) % 4]                 ny = y + dy[(d + i) % 4]                 if nx &lt; 0 or nx &gt;= n or ny &lt; 0 or ny &gt;= m:                     continue                 if graph[nx][ny] == 0:                     queue.append((nx, ny))                     graph[nx][ny] = -count                     count += 1                     flag = 1                     d = (d+i+1) % 4                     break             if flag == 0:                 nx = x + dx[(d+1) % 4]                 ny = y + dy[(d+1) % 4]                 if graph[nx][ny] == 1:                     return count                 else:                     graph[nx][ny] = -1                     queue.append((nx, ny))              return count               if __name__ == \"__main__\":         n, m = map(int, input().split())         r, c, d = map(int, input().split())         if d == 1:             d = 3         elif d == 3:             d = 1              graph = []         for _ in range(n):             graph.append(list(map(int, input().split())))         print(solution(r, c, d, graph)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_24/",
        "teaser": null
      },{
        "title": "[백준/Python] 18352 특정 거리의 도시 찾기(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 18352 특정 거리의 도시 찾기  문제로 이동!   문제   어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.   이 때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 X에서 출발 도시 X로 가는 최단 거리는 항상 0이라고 가정한다.   예를 들어 N=4, K=2, X=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.      이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다.  2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.   입력   첫째 줄에 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X가 주어진다. (2 ≤ N ≤ 300,000, 1 ≤ M ≤ 1,000,000, 1 ≤ K ≤ 300,000, 1 ≤ X ≤ N) 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, B가 공백을 기준으로 구분되어 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ A, B ≤ N) 단, A와 B는 서로 다른 자연수이다.   예제 입력       \"\"\"     case 1:     입력     4 4 2 1     1 2     1 3     2 3     2 4     출력     4      case 2:     입력     4 3 2 1     1 2     1 3     1 4     출력     -1      case 3:     입력     4 4 1 1     1 2     1 3     2 3     2 4     출력     2     3        \"\"\"  풀이     BFS로 해결하였다. 이 문제는 단방향이기 때문에 graph 리스트에 원소를 삽입할 때 주의해서 삽입해야한다. (양방향이었다면, i j를 입력 받았을때 graph[i] = j, graph[j] = i 둘 모두 입력 해줫어야 하지만, 단방향이기 때문에 i -&gt; j 인, graph[i] = j 만 입력해준다.) 이후 BFS 함수를 사용해서 방문처리와 거리 계산을 동시에 해주면 된다.    코드       from collections import deque               def bfs(s, graph, visited, k):         queue = deque([s])         visited[s] = 0         answer = []         while queue:             x = queue.popleft()             for v in graph[x]:                 if visited[v] == -1:                     visited[v] = visited[x] + 1                     queue.append(v)              return answer               if __name__ == \"__main__\":         n, m, k, x = map(int, input().split())         graph = [[] for _ in range(n+1)]         visited = [-1] * (n+1)         for _ in range(m):             i, j = map(int, input().split())             graph[i].append(j)              bfs(x, graph, visited, k)              flag = False         for i in range(1, n + 1):             if visited[i] == k:                 print(i)                 flag = True              if not flag:             print(-1) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_25/",
        "teaser": null
      },{
        "title": "[백준/Python] 1920 수 찾기(이진 탐색)",
        "excerpt":"BOJ   이진 탐색 1920 수 찾기  문제로 이동!   문제   N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.   예제 입력       \"\"\"     case 1:     입력     5     4 1 5 2 3     5     1 3 7 9 5     출력     1     1     0     0     1      case 2:     입력     4                           2147483647 10 -2147483640 0     6     0 -2147483640 10000000 0 2147483647 9      출력     1     1     0     1     1     0     \"\"\"  풀이     이진 탐색을 통해서 풀었다. 하지만 target의 값이 num_list의 범위 밖으로 벗어난다면, 예외처리를 해준다.    코드       def binary_search(num_list, target, start, end):         while start &lt;= end:             mid = (start + end) // 2             if num_list[mid] == target:                 return 1             elif num_list[mid] &lt; target:                 start = mid + 1             else:                 end = mid - 1         return 0               def solution(n, num_list, find_list):         num_list.sort()         result = []         max_v = max(num_list)         min_v = min(num_list)         for f in find_list:             if min_v &lt;= f &lt;= max_v:                 result.append(binary_search(num_list, f, 0, n))             else:                 result.append(0)         return result               if __name__ == \"__main__\":         n = int(input())         num_list = list(map(int, input().split()))         m = int(input())         find_list = list(map(int, input().split()))         answer = solution(n, num_list, find_list)         for v in answer:             print(v) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_26/",
        "teaser": null
      },{
        "title": "[백준/Python] 10816 숫자 카드(이진 탐색)",
        "excerpt":"BOJ   이진 탐색 10816 숫자 카드 2  문제로 이동!   문제   숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.   셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.   예제 입력       \"\"\"     case 1:     입력     10     6 3 2 10 10 10 -10 -10 7 3     8     10 9 -5 2 3 4 5 -10     출력     3 0 0 1 2 0 0 2     \"\"\"  풀이      이진탐색을 사용해서 풀었다. target이 되는 값의 가장 처음의 위치를 찾는 lower bound와 target이 되는 값보다 큰 값이 가장 처음의 위치를 찾는 upper bound를 사용해서 풀었다. 하지만, 이진탐색을 이용해서 문제를 푸는 것보다 딕셔너리에 하나씩 저장해서 해결하는 것이 시간 효율은 더 좋아보인다.    코드       def lower_bound(array, target, start, end):         while start &lt;= end:             mid = (start + end) // 2             if array[mid] == target:                 if end == mid:                     break                 end = mid             elif array[mid] &gt; target:                 end = mid -1             else:                 start = mid + 1         if array[mid] == target:             return mid         else:             return -1               def upper_bound(array, target, start, end):         while start &lt; end:             mid = (start + end) // 2             if array[mid] &lt;= target:                 start = mid + 1             elif array[mid] &gt; target:                 end = mid         mid = (start + end) // 2         if array[mid] &gt; target:             return mid         else:             return -1               def solution(n, num_list, find_list):         answer = []         num_list.sort()         for f in find_list:             start = lower_bound(num_list, f, 0, n-1)             if start == -1:                 answer.append(0)                 continue             end = upper_bound(num_list, f, 0, n-1)             if end == -1:                 end = n             count = end - start             answer.append(count)              return answer               if __name__ == \"__main__\":         n = int(input())         num_list = list(map(int, input().split()))         m = int(input())         find_list = list(map(int, input().split()))         print(*solution(n, num_list, find_list)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_27/",
        "teaser": null
      },{
        "title": "[OSTEP] CPU 가상화 - 프로세스 스케줄링",
        "excerpt":"1. 스케줄링: 개요  이전 포스트에서는 프로세스를 실행시키기 위한 문맥 교환 등의 저수준 기법에 대해서 설명하였다. 이번 포스트에서는 운영체제 스케줄러의 고수준 정책에 관한 이야기다.   1.1 워크로드에 대한 가정     프로세스가 동작하는 일련의 행위를 워크로드(workload)라 한다.            적절한 워크로드의 선정은 스케줄링 정책 개발에 매우 중요한 부분이다.           스케줄러의 종류를 임의로 세가지로 구분한다.            기본 스케줄러                    선입선출(FIFO)           최단 작업 우선(SJF, Shortest Job First)           최소 잔여시간 우선(STCF, Shortest Time-to-Completion First)           라운드 로빈(RR, Round-Robin)                       멀티 레벨 피드백 큐(MLFQ)       비례 볘분 or 공정 배분                    추첨 스케줄링(lottery scheduling)           보폭 스케줄링(stride scheduling)           리눅스 CFS(Completely Fair Scheduler)                           2. 기본 스케줄러   2.1 선입선출(FIFO)     먼저 도착한 프로세스를 우선적으로 스케줄링 한다.        위의 그림은 FIFO의 간단한 예이다.        위의 그림은 FIFO의 단점을 보여주는 예이다.            긴 실행 시간을 가진 A가 먼저 도착했기 때문에 전체 평균 반환 시간이 110초로 늘어났다.       만약 B, C를 먼저 해결한다면 전체 평균 반환 시간은 대폭 줄어들 것이다.       해당 현상을 convoy effect 라고 부르며 CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상을 말한다.              반환시간은 작업이 완료된 시각에서 작업이 도착한 시각을 뺀 시각이다.    2.2 최단 작업 우선(SJF)     앞서 소개한 convoy effect는 최단 작업 우선 스케줄링으로 간단하게 해결할 수 있다.   가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.        위의 그림은 SJF의 간단한 예이다.        위의 그림은 SJ의 단점을 보여주는 예이다.            긴 실행 시간을 가진 A가 실행중에 B,C가 도착했기 때문에 convoy 문제가 다시 발생한다.           2.3 최소 잔여시간 우선(STCF)     SJF에 선점 기능을 추가한 스케줄러다.            현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.                위의 그림은 STCF의 간단한 예이다.   2.4 라운드 로빈(RR)     FIFO, SJF, STCF는 모두 평가 기준을 반환 시간인 스케줄러이다. RR은 스케줄러의 응답 시간 평가 기준을 추가한 기법이다.       RR은 프로세스의 작업이 끝날 때 까지 기다리지 않는다. 대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.            이때 작업이 실행되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling quantum)이라 부른다.       RR은 때때로 타임 슬라이싱이라고 불린다.                위의 그림은 SJF 스케줄링이다. 응답 시간이 좋지 않다.        위의 그림은 RR 스케줄링이다. 응답 시간이 좋다.      SJF, STCF, RR 모두 프로세스의 미래 동작을 예측해야 가능한 스케줄링이다. 하지만, 실제로 프로세서가 미래동작을 예측하는데 있어 많은 어려움이 있다.  이를 해결하기 위해 과거의 프로세스 동작 이력을 반영하는 방식으로 해결한다. 해당 스케줄러는 멀티 레벨 피드백 큐이다.    3. 멀티 레벨 피드백 큐(MLFQ)     MLFQ가 해결하려고 하는 기본적인 문제는 두 가지이다.            짧은 작업을 먼저 실행시켜 반환 시간을 최적화하고자 한다.       MLFQ는 대화형 사용자를 위해 응답 시간을 최적화한다.           3.1 MLFQ: 기본 규칙     MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위(priority level)가 배정된다.            실행할 프로세스를 결정하기 위하여 우선순위를 사용한다.           큐에 둘 이상의 작입어 존재하면 RR 스케줄링 알고리즘이 사용된다.        고정된 우선순위를 부여하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다.       규칙            Priority(A) &gt; Priority(B) 이면, A가 실행된다.       Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행한다.       작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다.       주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다.       타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다.                위의 그림은 규칙 4번을 보여준다.        위의 그림은 규칙 3번을 보여준다.            A가 제일 낮은 우선순위에서 실행 되는 동안, B가 새로 들어옴으로써 가장 높은 우선순위에 할당된다. 이후 타임 슬라이스를 소모해가며 우선순위가 낮아진다.           3.2 위의 규칙으로 인한 MLFQ의 문제     두가지 문제가 있다.            규칙 5번에 의해 기아 상태가 발생할 수 있다.       타임 슬라이스의 99퍼를 사용하고 강제로 입출력을 주어서 프로세서를 악의적으로 독점할 수 있다.                     위의 그림은 기아 상태의 예이다. A(검정색)이 반복되는 입출력 작업으로 인해 실행되지 않는 모습을 보여준다.            첫번째 문제는 상향 조정(boost)를 사용하는 것이다.             일정 시간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.                     위의 그림은 boost의 예이다.            두번째 문제는 CPU 총 사용 시간을 측정 하여 일정 CPU 시간을 소진하면 다음 우선순위 큐로 강등시킨다.            위의 그림은 CPU 사용 시간 측정의 예이다.   4. 비례 볘분(Proportional Share) or 공정 배분(fair share)     비례 배분 혹은 공정 배분이라고도 하는 유형의 개념은 반환 시간이나 응답 시간을 최적화하는 대신 스케줄러가 각 작업에게 CPU의 일정 비율을 보장하는 것이 목적이다.   비례 배분 스케줄링의 좋은 예는 추첨 스케줄링(lottery scheduling)이다.   4.1 추첨 스케줄링     추첨권(티켓) 이라는 기본적인 개념이 추첨 스케줄링의 근간을 이룬다.   A 와 B 두 프로세스가 있을 때, A는 75장, B는 25장을 추첨권을 준다. -&gt; A에게 75% CPU, B에게 25% CPU를 주기 위함   추첨 스케줄링은 이러한 목적을(타임 슬라이스가 끝날 때마다) 확률기반으로 달성한다.            A : 0~74, B: 75~99, 스케줄러는 추첨권을 뽑고 뽑힌 추첨권 값에 따라 다음에 실행될 프로세스가 결정된다.           추첨 기법     추첨권 화폐(ticket currency)            A가 받은 추첨권 75장을 자신의 작업들에 나누어 줄 수 있다.           추첨권 양도(ticket transfer)            양도를 통하여 프로세스는 일시적으로 추첨권을 다른 프로세스에게 넘겨줄 수 있다.           추첨권 팽창(ticket inflation)            프로세스는 일시적으로 자신이 소유한 추첨권의 수를 늘이거나 줄일 수 있다.           4.2 보폭 스케줄링(stride scheduling)          무작위성(추첨 스케줄링)을 이용하면 스케줄러를 단순하게 만들 수 있지만, 정확한 비율을 보장할 수 없다. 이 때문에 결정론적 공정 배분 스케줄러인  보폭 스케줄링을 고안하였다.            보폭 스케줄링             시스템의 각 작업은 보폭을 가지고 있으며 프로세스가 실행될 때마 pass라는 값을 보폭만큼 증가시켜 CPU를 얼마나 사용하였는지 추적한다.       가장 작은 pass 값을 다음 프로세스로 결정한다.                위의 그림은 보폭 스케줄링의 예이다.   4.3 리눅스 CFS(Completely Fair Scheduler)     이 스케줄러의 장점은 효율성과 확장성이다.   기본 연산     기존 스케줄러들은 고정된 길이의 타임 슬라이스를 사용한다. 반면에 CFS는 모든 프로세서들에게 CPU를 공평하게 배분하기 위해 virtual runtimne(vruntime) 이라는 간단한 counting 기반 테크닉을 사용한다.   프로세스가 실행되면 스케줄러는 해당 프로세서의 vruntime 값을 누적시킨다.   스케줄링시 CFS는 가장 낮은 vruntime을 가진 프로세스를 다음에 실행할 프로세스로 선택한다.   CFS가 자주 실행되면, 공정성이 좋아지지만 성능이 악화된다. CFS가 드물게 실행되면, 공정성은 악화되지만 성능은 향상된다.            sched_latency 변수를 사용하여 하나의 프로세스가 CPU를 사용한 후, 다음 번에 CPU를 사용할 수 있을 때까지의 최대 시간 간격을 나타낸다.(약 48ms)       min_granularity 변수를 사용하여 각 프로세스에게 할당된 시간 조각 이하가 되지 않도록 하여 스케줄링한다. (약 6ms)           가중치     CFS는 사용자나 관리자가 프로세스의 우선 순위를 조정하여 다른 프로세스들 보다 더 많은 CPU 시간을 할당받게 할 수 있다.   nice를 부여받는데 이를 부여 받으면 vruntime에 영향을 준다.            예) nice가 -10이면(음수일수록 우선순위가 높음) vruntime은 10분의1 만큼 증가한다.(더 많은 시간동안 실행될 수 있음)           Red-Black 트리의 활용     실행할 프로세스를 선택하는데 Red-Black 트리를 활용한다.   ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_03/",
        "teaser": null
      },{
        "title": "[백준/Python] 1654 랜선 자르기(이진 탐색)",
        "excerpt":"BOJ   이진 탐색 1654 랜선 자르기  문제로 이동!   문제   집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.   이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는 버려야 한다. (이미 자른 랜선은 붙일 수 없다.)   편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.   입력   첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.   예제 입력       \"\"\"     case 1:     입력     4 11     802     743     457     539     출력     200     \"\"\"  풀이      upper bound를 사용해서 해결하였다. 만들 수 있는 랜선의 최대 길이를 1 ~ 가지고 있는 랜선의 최대 값으로 생각하고 이를 이진탐색을 통해 upper bound를 사용 하는 것이다. 우선 mid 값을 가지고 가지고 있는 랜선의 수를 나눈다. 그리고 나뉘어진 몫의 합과 필요한 랜선의 수 N과 비교하여 start와 end 값을 재설정 해준다.    코드       def upper_bound(start, end, target):         while start &lt; end:             mid = (start + end) // 2             sum_v = sum([a//mid for a in array])             if sum_v &gt;= target:                 start = mid + 1             elif sum_v &lt; target:                 end = mid         mid = (start + end) // 2         sum_v = sum([a//mid for a in array])         if sum_v &gt;= target:             return mid         if sum_v &lt; target:             return mid-1         else:             return -1               if __name__ == \"__main__\":         n, k = map(int, input().split())         array = [int(input()) for _ in range(n)]         max_v = max(array)         print(upper_bound(1, max_v, k)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_28/",
        "teaser": null
      },{
        "title": "[백준/Python] 2512 예산(이진 탐색)",
        "excerpt":"BOJ   이진 탐색 2512 예산  문제로 이동!   문제   국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다.      모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.   모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다.   예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. 이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다.   여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오.   입력   첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다. 다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다. 그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다.   예제 입력       \"\"\"     case 1:     입력     4     120 110 140 150     485     출력     127      case 2:     입력     5     70 80 30 40 100     450     출력     100     \"\"\"  풀이      upper bound를 사용하여 풀었다. 1~m 까지의 범위에서 mid 값을 찾으며, 찾은 mid 값을 각 지방의 예산과 비교하여 할당된 예산의 총합을 계산한다.  예산의 총합과 가능한 예산을 비교하여 적거나 같으면 start=mid+1, 크면 end=mid를 하며 가능한 예산보다 한단계 더 큰 값을 찾아간다. 이후 값이 찾아지면 -1을 하여 return한다.    코드       def upper_bound(start, end, target):         while start &lt; end:             mid = (start + end) // 2             sum_v = sum(map(lambda i: min(i, mid), array))             if sum_v &lt;= target:                 start = mid + 1             else:                 end = mid         mid = (start + end) // 2         return mid - 1               if __name__ == \"__main__\":         n = int(input())         array = list(map(int, input().split()))         m = int(input())         total = sum(array)         if total &lt;= m:             print(max(array))         else:             print(upper_bound(1, m, m)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_29/",
        "teaser": null
      },{
        "title": "[백준/Python] 16401 과자 나눠주기(이진 탐색)",
        "excerpt":"BOJ   이진 탐색 16401 과자 나눠주기  문제로 이동!   문제   명절이 되면, 홍익이 집에는 조카들이 놀러 온다. 떼를 쓰는 조카들을 달래기 위해 홍익이는 막대 과자를 하나씩 나눠준다.   조카들이 과자를 먹는 동안은 떼를 쓰지 않기 때문에, 홍익이는 조카들에게 최대한 긴 과자를 나눠주려고 한다.   그런데 나눠준 과자의 길이가 하나라도 다르면 조카끼리 싸움이 일어난다. 따라서 반드시 모든 조카에게 같은 길이의 막대 과자를 나눠주어야 한다.   M명의 조카가 있고 N개의 과자가 있을 때, 조카 1명에게 줄 수 있는 막대 과자의 최대 길이를 구하라.   단, 막대 과자는 길이와 상관없이 여러 조각으로 나눠질 수 있지만, 과자를 하나로 합칠 수는 없다. 단, 막대 과자의 길이는 양의 정수여야 한다.   입력   첫째 줄에 조카의 수 M (1 ≤ M ≤ 1,000,000), 과자의 수 N (1 ≤ N ≤ 1,000,000)이 주어진다.   둘째 줄에 과자 N개의 길이 L1, L2, …, LN이 공백으로 구분되어 주어진다. 과자의 길이는 (1 ≤ L1, L2, …, LN ≤ 1,000,000,000) 를 만족한다.   예제 입력       \"\"\"     case 1:     입력     3 10     1 2 3 4 5 6 7 8 9 10     출력     8      case 2:     입력     4 3     10 10 15     출력     7     \"\"\"  풀이      파라메트릭 서치(parametric search)를 사용해서 풀었다. mid 값을 조사하고 답이 되지 않는다면 그 이하 또는 이상은 답이 되지 않는다고 판단하는 방법이다. mid 값에서 과자를 나눠줄 수 있는 경우의 수를 구한 뒤 target과 비교하고 mid 값을 조절해준다. mid값과 target이 같아 진다면 answer에 저장해둔 뒤 mid값을 또 조사해 최적의 answer를 탐색한다.    코드       def upper_bound(start, end, target):         result = 0         while start &lt;= end:             mid = (start + end) // 2             sum_v = sum(map(lambda x: x//mid, array))             if sum_v &gt;= target:                 start = mid + 1                 result = mid             else:                 end = mid - 1         return result               if __name__ == \"__main__\":         n, m = map(int, input().split())         array = list(map(int, input().split()))         if sum(array) &lt; n:             print(0)         else:             print(upper_bound(1,max(array),n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_30/",
        "teaser": null
      },{
        "title": "[백준/Python] 1790 수 이어 쓰기2(수학)",
        "excerpt":"BOJ   수학 1790 수 이어 쓰기2  문제로 이동!   문제   1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.   1234567891011121314151617181920212223…   이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N(1 ≤ N ≤ 100,000,000)과,  k(1 ≤ k ≤ 1,000,000,000)가 주어진다. N과 k 사이에는 공백이 하나 이상 있다.   예제 입력       \"\"\"     case 1:     입력     20 23     출력     6     \"\"\"  풀이     자연수를 이어 쓴다면, 1~9, 10~99, 100~999, … 으로 구분할 수 있다. “자릿수”에 따라 이어지는 숫자의 위치가 달라진다. 그럼 N번째의 숫자가 무엇인지 알기 위해서는 1~9 자리인 9개의 숫자, 10~99 자리인 180개의 숫자(자릿수가 2개이기 때문에 90*2를 해준다.), 100~999 자리인 2700개의 숫자… 로 표현할 수 있다.  그렇기 때문에 반복문을 돌면서 N에 9를 빼주고, 180을 빼주고, 2700을 빼주고를 반복한다. 이후 더이상 뺄 수 없는 숫자라면, 예를들어 9를 뺄 수 있다면 N은 10부터 시작이다. 또한 9와 180 사이의 N에서 9를 빼면 10~99 에서 숫자가 나온다. 자릿수가 2이기 때문에 2씩 나눈다면, 해당 N번째 숫자가 무엇인지 확인 할 수 있다. 이후 한번더 자릿수로 나누어 정확한 N번째 숫자가 무엇인지 구할 수 있다.    코드       def solution(k):         store = 0         digit = 1         nine = 9              while k &gt; digit * nine:             k -= (digit * nine)             store += nine             digit += 1             nine *= 10              answer = (store + 1) + ((k - 1) // digit)         if answer &gt; n:             return -1         else:             return int(str(answer)[(k - 1) % digit])               if __name__ == \"__main__\":         n, k = map(int, input().split())         print(solution(k)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_31/",
        "teaser": null
      },{
        "title": "[백준/Python] 2110 공유기 설치(이진탐색)",
        "excerpt":"BOJ   이진 탐색 2110 공유기 설치  문제로 이동!   문제   도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.   도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.   C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.   입력   첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.   예제 입력       \"\"\"     case 1:     입력     5 3     1     2     8     4     9     출력     3     \"\"\"  풀이     공유기 설치의 거리를 이진탐색으로 좁혀가거나 넓혀가거나로 탐색해나가며 문제를 풀어간다. 공유기 거리의 최소값을 1, 최대값을 index0에서 마지막값을 뺀 값으로 설정한다. mid값이 설정되면 해당 거리를 집마다 설치할 수 있는 개수가 C보다 작다면 거리를 좁혀야하고, C보다 크다면 거리를 넓혀야 한다. prametric search로 정답을 저장해가며 탐색한다.    코드       def binary_search(array, start, end):         result = 0         while start &lt;= end:             mid = (start + end) // 2             value = array[0]             count = 1             for i in range(1,n):                 if array[i] &gt;= value +mid:                     value = array[i]                     count +=1             if count &gt;= c:                 start = mid + 1                 result = mid             else:                 end = mid - 1              return result               if __name__ == \"__main__\":         n, c = map(int, input().split())         array = []         for _ in range(n):             array.append(int(input()))         array.sort()         end = array[-1] - array[0]         print(binary_search(array, 1, end)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_32/",
        "teaser": null
      },{
        "title": "[백준/Python] 2295 세 수의 합(수학)",
        "excerpt":"BOJ   이진 탐색 2110 공유기 설치  문제로 이동!   문제   N(5 ≤ N ≤ 1,000)개의 자연수들로 이루어진 집합 U가 있다. 이 중에서 적당히 세 수를 골랐을 때, 그 세 수의 합 d도 U안에 포함되는 경우가 있을 수 있다. 이러한 경우들 중에서, 가장 큰 d를 찾으라.   예를 들어 {2, 3, 5, 10, 18}와 같은 집합이 있다고 하자. 2+3+5 = 10이 되고, 이 수는 집합에 포함된다. 하지만 3+5+10 = 18이 되고, 이 경우가 세 수의 합이 가장 커지는 경우이다.   입력   첫째 줄에 자연수 N이 주어진다. 다음 N개의 줄에 차례로 U의 원소가 하나씩 주어진다. 주어진 U는 집합이 되므로 입력되는 두 수가 같아서는 안 된다. U의 원소는 200,000,000보다 작거나 같은 자연수이다. 답이 항상 존재하는 경우만 입력으로 주어진다.   예제 입력       \"\"\"     case 1:     입력     5     2     3     5     10     18     출력     18     \"\"\"  풀이     x+y+z=k를 반복문을 돌며 탐색한다면 N^3의 시간이 소요된다. 하지만 x+y=k-z 로 식을 치환해서 반복문을 돈다면 N^2의 시간이 소요되므로 더 빠른 속도로 문제를 해결할 수 있다. 또한 x+y를 set 자료구조에 추가하여 중복을 자동으로 제거한다.    코드       def solution(array, n):         array.sort()         sum_set = set()         for i in range(n):             for j in range(n):                 sum_set.add(array[i] + array[j])              answer = []         for i in range(n-1, -1, -1):             for j in range(i+1):                 if array[i] - array[j] in sum_set:                     answer.append(array[i])                     break         answer.sort()         return answer[-1]          if __name__ == \"__main__\":         n = int(input())         array = []         for _ in range(n):             array.append(int(input()))              print(solution(array, n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_33/",
        "teaser": null
      },{
        "title": "[백준/Python] 2467 용액(이진탐색)",
        "excerpt":"BOJ   이진 탐색 2467 용액  문제로 이동!   문제   KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.   같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.   예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.   산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.   입력   첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.   예제 입력       \"\"\"     case 1:     입력     5     -99 -2 -1 4 98     출력     -99 98     \"\"\"  풀이     two pointer를 사용하여 문제를 해결했다. start와 end를 배열의 양 끝으로 설정한다. 그렇다면 start는 가장 작 음수값을 가지며, end는 가장 큰 양수값을 가진다. 이 폭을 좁혀가며 탐색할 것이다. start와 end에 해당하는 인자의 합의 절대값과 기존의 min의 절대값을 비교하여 현재 인자들의 합이 더 작다면 정답 리스트에 저장해둔다. 또한 현재 인자의 합이 0보다 크다면 end를 1씩 줄이고, 0보다 작다면 start를 1씩 줄인다.    코드       def binary_search(array, start, end):         value = array[0] + array[1]         answer = [array[0], array[1]]         while start &lt; end:             x = array[start] + array[end]             if abs(x) &lt; abs(value):                 value = x                 answer = [array[start], array[end]]             if x &lt; 0:                 start += 1             elif x &gt; 0:                 end -= 1             else:                 break              return answer               if __name__ == \"__main__\":         n = int(input())         array = list(map(int, input().split()))         start = 0         end = n-1         print(*binary_search(array, start, end)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_34/",
        "teaser": null
      },{
        "title": "[백준/Python] 2473 세 용액(이진탐색)",
        "excerpt":"BOJ   이진 탐색 2473 세 용액  문제로 이동!   문제   KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.   같은 양의 세 가지 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 세 가지 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.   예를 들어, 주어진 용액들의 특성값이 [-2, 6, -97, -6, 98]인 경우에는 특성값이 -97와 -2인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 세 종류의 알칼리성 용액만으로나 혹은 세 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.   산성 용액과 알칼리성 용액이 주어졌을 때, 이 중 같은 양의 세 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 세 용액을 찾는 프로그램을 작성하시오.   입력   첫째 줄에는 전체 용액의 수 N이 입력된다. N은 3 이상 5,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.   예제 입력       \"\"\"     case 1:     입력     5     -2 6 -97 -6 98     출력     -97 -2 98     \"\"\"  풀이     2467번의 용액과 비슷한 문제이다. 하지만 이는 세가지 수의 합이므로 기준 값을 하나 설정하고 나머지 값들을 two pointer를 활용해 해결한다. 우선 반복문을 돌며 가장 작은 값부터 기준 값으로 설정한다. 기준 값 + 1과 가장 큰 값인 N-1 을 start와 end 인자로 설정한다. 이후 start와 end의 폭을 좁혀가며 (기준 값 + start + end)의 절대값과 기존의 정답이 되는 최소 값의 절대값과 비교하여 작다면 정답 리스트에 저장해둔다. 이후 현재 값의 합이 0보다 작다면 start를 +1, 0보다 크다면 end를 -1 해준다. start와 end가 만나 while문을 탈출하게 되면 기준값을 하나 옮겨주고 반복한다.    코드       def two_pointer(array, basis, start, end):         global value         global answer         while start &lt; end:             x = array[basis] + array[start] + array[end]             if abs(value) &gt; abs(x):                 value = x                 answer = [array[basis],array[start],array[end]]             if x &lt; 0:                 start += 1             elif x &gt; 0:                 end -= 1             else:                 answer = [array[basis],array[start],array[end]]                 return True         return False               if __name__ == \"__main__\":         n = int(input())         array = list(map(int, input().split()))         array.sort()         value = array[0] + array[1] + array[2]         answer = [array[0],array[1],array[2]]         for i in range(n):             if two_pointer(array, i, i+1, n-1):                 break         print(*answer) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_35/",
        "teaser": null
      },{
        "title": "[OSTEP] 메모리 가상화 - 주소 변환과 세그멘테이션",
        "excerpt":"1. 주소 공간의 개념   1.1 초기 시스템     메모리 관점에서 초기 컴퓨터는 많은 개념을 사용자에게 제공하지 않았다. 하지만, 시분할 시스템이 대중화 되면서 운영체제에게 새로운 요구 사항이 부과되었다. 여러 프로그램이 메모리에 동시에 존재하려면 보호(protection)가 중요한 문제가 된다.   한 프로세스가 다른 프로세스의 메모리를 읽거나 혹은 더 안좋게는 쓸 수 있는 상황이 있어선 안된다.   1.2 주소 공간     위 문제의 위험에 대비하기 위해 운영체제는 사용하기 쉬운(easy to use)메모리 개념을 만들어야 한다.            이 개념이 주소 공간(address space)이다.           주소 공간은 실행 프로그램의 모든 메모리 상태를 갖고 있다.            프로그램의 코드(code, 명령어): 메모리에 존재해야 하고 따라서 주소 공간에 존재한다.       스택: 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 데 사용된다.       힙: 동적으로 할당되는 메모리를 위해 사용된다.                위의 그림은 주소 공간의 예이다.            위의 그림처럼 실제로 프로그램이 물리 주소 0에서 16KB 사이에 존재하는 것은 아니다.실제로는 임의의 물리 주소에 탑재된다. 운영체제가 해당 일을 할 때 메모리를 가상화(virtualizing memory)한다고 말한다.       즉, 메모리 가상화는 프로그램은 가상화된 주소를 사용하고 운영체제는 이 가상 주소를 실제 물리 메모리 주소로 변환하는 방식의 메커니즘을 가진다.           1.3 가상 메모리 시스템(VM)의 목표     투명성(transparency): 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 한다.   효율성(efficiency): 운영체제는 가상화가 시간과 공간 측면에서 효율적이도록 해야 한다.   보호(protection): 운영체제는 프로세스를 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호해야 한다.            보호 성질을 이용하여 프로세스들을 서로 격리(isolate)시킬 수 있다.           메모리를 가상화하기 위해 필요한 기본적인 기법과 정책이 있다.   2. 주소 변환의 원리     메모리 가상화에서도 CPU 가상화 부분에서 제한적 직접 실행 기법과 비슷하게 약간의 하드웨어 지원을 받아 효율적인 가상화 제공 전략을 추구한다.   메모리 가상화를 제공하는 동시에 효율성과 제어 모두를 추구한다.            효율성을 높이려면 하드웨어 지원을 활용할 수밖에 없다.       제어는 응용 프로그램이 자기자신의 메모리 이외에는 다른 메모리에 접근하지 못한다는 것을 운영체제가 보장하는 것을 의미한다.       마지막으로, 유연성(flexibility) 측면에서 VM 시스템에서 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들어야 한다.           주소 변환(address translation): 하드웨어 기반 주소 변환(hardware-based address translation)이라고도 하는 기법은 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위하여 하드웨어가 주소를 변환한다.            정확한 변환이 일어날 수 있도록 하드웨어를 셋업하기 위해 운영체제가 관여해야 한다. 운영체제는 메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리한다.                위의 그림은 프로세스와 그 주소 공간이다.   2.1 동적(하드웨어 기반) 재배치: base-bound     베이스와 바운드(base and bound): 이 기술은 동적 재배치(dynamic relocation)라고도 한다.   이 기술은 각 CPU마다 2개의 하드웨어 레지스터가 필요하다. 하나는 베이스(base)레지스터, 다른 하나는 바운드(bound) 레지스터 혹은 한계(limit) 레지스터라고 불린다.      베이스 레지스터 동작 방법            운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정한다.       physical address = virtual address + base &lt;- 방법으로 프로세서에 의해 변환된다.                    프로세스가 생성하는 메모리 참조는 가상 주소이다. 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 물리 주소를 생성한다.                              가상 주소에서 물리 주소로의 변환이 주소 변환이라고 부르는 바로 그 기술이다.   이 주소의 재배치는 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에, 동적 재배치(dynamic relocation)라고도 불린다.      바운드 레지스터는 보호를 지원하기 위해 존재한다. 프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인한다.   바운드 레지스터의 정의 방법            주소 공간의 크기를 저장하는 방식       주소 공간의 마지막 물리 주소를 저장하는 방식              주소 변환에 도움을 주는 프로세서의 일부를 메모리 관리 장치(memory management unit,MMU)라고 부르기도 한다.   2.2 하드웨어 지원   하드웨어 요구사항     특권 모드            사용자 모드 프로세스가 특권 연산을 실행하는 것을 방지하기 위해 필요           베이스/바운드 레지스터            주소 변환과 범위 검사를 지원하기 위하여 CPU 당 한 쌍의 레지스터가 필요           가상 주소를 변환하고 범위 안에 있는지 검사하는 능력            주소 변환과 범위 검사를 위한 회로. 매우 간단함           베이스/바운드를 갱신하기 위한 특권 명령어            프로그램 시작 전에 운영체제가 베이스와 바운드 레지스터 값을 지정할 수 있어야 함           예외 핸들러 등록을 위한 특권 명령어            운영체제가 예외 처리 코드를 하드웨어에게 알려줄 수 있어야 함           예외 발생 기능            프로세스가 특권 명령어 실행을 시도하거나 범위를 벗어난 메모리의 접근을 시도할 때 예외를 발생시킬 수 있어야 함           2.3 운영체제 이슈     베이스와 바운드 방식의 가상 메모리 구현을 위해서 운영체제가 반드시 개입되어야 하는 중요한 세 개의 시점이 존재한다.            프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아 조치를 취해야 한다.                    새로운 프로세스가 생성되면 운영체제는 새로운 주소 공간 할당에 필요한 영역을 찾기 위해 빈 공간 리스트(free list) 자료 구조를 검색해야 한다.                       프로세스가 종료할 때, 즉 정상적으로 종료될 때 또는 잘못된 행동을 하여 강제적으로 죽게될 때 프로세스가 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용할 수 있게 해야 한다.       운영체제는 문맥 교환이 일어날 때에도 몇가지 추가 조치를 취해야 한다.                    운영체제는 프로세스 전환 시 베이스와 바운드 쌍을 저장하고 복원해야 한다.           운영체제가 실행중인 프로세스를 중단시키기로 결정하면 운영체제는 메모리에 존재하는 프로세스 별 자료 구조 안에 베이스와 바운드 레지스터의 값을 저장해야 한다.           이 자료 구조는 프로세스 구조체(process structure) 또는 프로세스 제어 블럭(process control block, PCB)라고 불린다.                       운영체제는 예외 핸들러 또는 호출된 함수를 제공해야 한다.           2.4 주소변환(바운드 베이스) 요약     주소 변환이라고 알려진 가상 메모리 기법을 통해 제한적 직접 실행의 개념을 확장하였다.   주소 변환을 사용하면 운영체제는 프로세스의 모든 메모리 접근을 제어할 수 있고 ,접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장할 수 있다.   베이스 바운드, 즉 동적 재배치는 비효율적이다. 재배치된 프로세스는 스택과 힙 사이의 공간이 단순히 낭비되고 있다. 즉 내부 단편화(internal fragmentation)이 발생한다.            이를 해결하기 위해 베이스 바운드를 일반화한 기법 세그멘테이션(segmentation)을 사용한다.           3. 세그멘테이션     베이스와 바운드 방식은 메모리 낭비가 심하기 때문에 유연성이 없다.   3.1 세그멘테이션: 베이스/바운드(base/bound) 의 일반화     MMU에 하나의 베이스와 바운드값이 존재하는 것이 아니라 세그멘트(segment)마다 베이스와 바운드 값이 존재한다.            세그멘트는 특정 길이를 가지는 연속적인 주소 공간이다: 코드, 스택, 힙의 세 종류의 세그멘트가 있다.                위의 그림은 물리 메모리에 세그멘트 배치를 한 그림이다.        세그멘트의 사이즈는 바운드 레지스터와 일치한다.(위의 그림)   3.2 세그멘트 종류의 파악     하드웨어는 변환을 위해 세그멘트 레지스터를 사용한다.        일반적인 접근법으로는 가상 주소의 최상위 비트 몇 개를 세그멘트 종류를 나타내는데 사용하는 것이다.(위의 그림)            최상위 2비트가 00이면, 하드웨어는 가상 주소가 코드 세그멘트를 가리킨다.       최상위 2비트가 01이면, 하드웨어는 주소가 힙 세그멘트라는 것을 인지한다.                위의 그림처럼 하드웨어는 세그멘트 레지스터를 파악하는 데 처음 2비트를 이용하고 세그멘트 오프셋으로 다음 12비트를 취한다.            오프셋에 베이스 레지스터 값을 더하여 하드웨어는 최종 물리 주소를 계산한다.              특정 주소의 세그멘트를 하드웨어적으로 파악하는 다른 방법이 있다.            묵시적(implicit) 접근 방식에서는 주소가 어떻게 형성되었나를 관찰하여 세그멘트를 결정한다.                    ex) 주소가 프로그램 카운터로부터 생성되었다면 코드 세그멘트, 주소가 스택 또는 베이스 포인터에 기반을 둔다면 스택 세그멘트                           3.3 스택     스택 세그멘트는 다른 세그멘트들과는 반대 방향으로 확장된다.(낮은 주소 방향으로 확장)   위의 이유로 인해 간단한 하드웨어가 추가로 필요하다.            베이스와 바운드 값뿐 아니라 하드웨어는 세그멘트가 어느 방향으로 확장하는지도 알아야 한다.              3.4 공유 지원     세그멘테이션 기법이 발전함에 따라 시스템 설계자들은 간단한 하드웨어 지원으로 새로운 종류의 효율성을 성취할 수 있다는 것을 깨달았다.            메모리를 절야갛기 위해 때로는 주소 공간들 간에 특정 메모리 세그멘트를 공유하는 것이 유용하다.       특히, 코드 공유가 일반적이며, 현재 시스템에서도 광범위하게 사용 중이다.           공유를 지원하기 위해, 하드웨어에 protection bit의 추가가 필요하다.            protection bit를 세그멘트마다 추가하여 세그멘트를 읽거나 쓸 수 있는지 혹은 세그멘트의 코드를 실행시킬 수 있는지를 나타낸다.                위의 그림은 세그멘트 레지스터 값(보호 정보 포함)이다.   3.5 운영체제의 지원     시스템이 각 주소 공간(세그멘트) 단위로 가상 주소 공간을 물리 메모리에 재배치하기 때문에, 전체 주소 공간이 하나의 베이스-바운드 값을 갖는 방식에 비해 물리 메모리를 절약할 수 있다.            스택과 힙 사이의 사용하지 않는 공간에 대해서 할당할 필요가 없기 때문           세그멘테이션의 도입을 위해서는 운영체제가 몇가지 문제를 해결해야 한다.            문맥교환                    세그멘트 레지스터의 저장과 복원                       세그멘트 크기의 변경       미사용 중인 물리 메모리 공간의 관리                    세그멘트들이 많아지면 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다. 이 작은 빈 공간들은 새로이 생겨나는 세그멘트에 할당하기도 힘들거니와 기존 세그멘트를 확장하는 데에도 도움이 되지 않는다. 이를 외부 단편화(external fregmentation)라고 부른다.                                     위의 그림은 압축 전과 압축 후의 메모리 상태이다.       이를 해결하는 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘을 사용하는 것이다.   빈 공간 관리 알고리즘은 할당 가능한 메모리 영역들을 리스트 형태로 유지한다.            최적 적합(best-fit), 최악 적합(worst-fit), 최초 적합(first-fit), 버디 알고리즘(buddy algorithm) 등의 방식이 존재한다.          ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_04/",
        "teaser": null
      },{
        "title": "[백준/Python] 14502 연구소(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 14502 연구소  문제로 이동!   문제   인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.   연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.   일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.   예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.      이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.   2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.      바이러스가 퍼진 뒤의 모습은 아래와 같아진다.      벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.   연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)   둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.   빈 칸의 개수는 3개 이상이다.   예제 입력       \"\"\"     case 1:     입력     7 7     2 0 0 0 1 1 0     0 0 1 0 1 2 0     0 1 1 0 1 0 0     0 1 0 0 0 0 0     0 0 0 0 0 1 1     0 1 0 0 0 0 0     0 1 0 0 0 0 0     출력     27      case 2:     입력     4 6     0 0 0 0 0 0     1 0 0 0 0 2     1 1 1 0 0 2     0 0 0 0 0 2     출력     9      case 3:     입력     8 8     2 0 0 0 0 0 0 2     2 0 0 0 0 0 0 2     2 0 0 0 0 0 0 2     2 0 0 0 0 0 0 2     2 0 0 0 0 0 0 2     0 0 0 0 0 0 0 0     0 0 0 0 0 0 0 0     0 0 0 0 0 0 0 0     출력     3     \"\"\"  풀이   첫번째, 벽을 만든다.  두번째, 바이러스를 상하좌우로 확산시킨다.   세번째, 바이러스가 확산되지 않은 빈 공간을 조사한다.   이렇게 세단계로 풀이를 나뉠 수 있다. 두번째와 세번째는 bfs를 사용해서 간단하게 해결할 수 있다. 하지만 첫번째 단계인 벽을 만드는 방법은 조금 까다롭다. 벽과 벽 사이를 조사해야할 수도 있고, 벽이 없는 모서리를 조사해야할 수도 있으며 벽이 대각선으로 이루어져있는 부분을 조사해야할 수도 있다. 이런 이유 때문에 벽을 만드는 방법은 brute force를 사용해서 해결한다. graph의 빈 부분들을 미리 리스트에 저장한 뒤, 3중 반복문을 돌며 빈 부분들에 벽을 차례대로 하나씩 세운다. 이후 bfs를 돌아 바이러스를 확산시킨후 빈 공간을 조사하고, 빈 공간의 수 중에서 가장 큰 수를 정답으로 도출한다.   코드       from collections import deque               def bfs(replica):         queue = deque()         for virus in virus_list:             queue.append(virus)              dx = [0, 0, 1, -1]         dy = [1, -1, 0, 0]              while queue:             x, y = queue.popleft()             for i in range(4):                 nx = x + dx[i]                 ny = y + dy[i]                 if nx &lt;0 or nx &gt;= n or ny &lt;0 or ny &gt;= m:                     continue                 if replica[nx][ny] == 0:                     queue.append((nx,ny))                     replica[nx][ny] = 2              count = 0         for r in replica:             count += r.count(0)         return count               def make_wall(graph, virus_list, blank_list, n, m):         count_list = []         blank_length = len(blank_list)         for i in range(blank_length):             for j in range(i + 1, blank_length):                 for k in range(j + 1, blank_length):                     replica = []                     for g in graph:                         replica.append(g.copy())                     replica[blank_list[i][0]][blank_list[i][1]] = 1                     replica[blank_list[j][0]][blank_list[j][1]] = 1                     replica[blank_list[k][0]][blank_list[k][1]] = 1                     count_list.append(bfs(replica))              return count_list           if __name__ == \"__main__\":         n, m = map(int, input().split())         graph = []         virus_list = []         blank_list = []              for i in range(n):             graph_row = list(map(int, input().split()))             graph.append(graph_row)             for j in range(m):                 if graph[i][j] == 0:                     blank_list.append((i,j))                 elif graph[i][j] == 2:                     virus_list.append((i,j))              answer = make_wall(graph, virus_list, blank_list, n, m)         print(max(answer)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_36/",
        "teaser": null
      },{
        "title": "[백준/Python] 1759 암호 만들기(백트래킹)",
        "excerpt":"BOJ   수학 1759 암호 만들기  문제로 이동!   문제   바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.   암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.   새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.   입력   첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.   예제 입력       \"\"\"     case 1:     입력     4 6     a t c i s w     출력     acis     acit     aciw     acst     acsw     actw     aist     aisw     aitw     astw     cist     cisw     citw     istw     \"\"\"  풀이   백트래킹을 이용해서 문제를 해결했다. 우선 알파벳이 담겨있는 리스트를 오름차순으로 정렬한다.  visited 배열을 L 길이 만큼 초기화한다. 이후 dfs 함수를 돌면서 visited 첫번째 자리(depth)부터 탐색을 시작한다.  visited 에 값이 들어있지 않다면, visited 첫번째 자리(depth)에 값을 추가해주고, depth +1, visited에 추가한 값의 index +1을 인자값으로 넘기면서 재귀적으로 dfs 함수를 호출한다. 정렬되어 있기 때문에, index+1을 함께 넘겨주어 해당 값 이후(즉, 증가하는 순서)만을 탐색하기 때문에 자동적으로 visited에 추가되는 값은 알파벳의 오름차순이다. 이후 depth가 l과 같아진다면, 모음과 자음의 개수를 확인하고 answer 리스트에 추가해준다.   코드       def dfs(string, depth, index, visited):         global answer         if depth == l:             count = 0             for v in visited:                 if v in collection:                     count += 1             if 1 &lt;= count &lt;= l-2:                 answer.append(visited.copy())         else:             for i in range(index, c):                 if string[i] in visited:                     continue                 visited[depth] = string[i]                 dfs(string, depth+1, i+1, visited)                 visited[depth] = ''               def solution(string):         string.sort()         visited = [''] * l         dfs(string, 0, 0, visited)               if __name__ == \"__main__\":         l, c = map(int, input().split())         string = list(map(str, input().split()))         answer = []         collection = {'a', 'e', 'i', 'o', 'u'}         solution(string)         for a in answer:             print(''.join(a)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_37/",
        "teaser": null
      },{
        "title": "[백준/Python] 10974 모든 순열(백트래킹)",
        "excerpt":"BOJ   수학 10974 모든 순열  문제로 이동!   문제   N이 주어졌을 때, 1부터 N까지의 수로 이루어진 순열을 사전순으로 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.   예제 입력       \"\"\"     case 1:     입력     3     출력     1 2 3     1 3 2     2 1 3     2 3 1     3 1 2     3 2 1     \"\"\"  풀이     백트래킹을 사용해서 수열이 불가능한 지점에서 이전 지점으로 돌아가 탐색을 다시 진행하는 방법으로 해결한다. dfs 함수를 이용하여 문제를 해결하면된다. visited에 현재 탐색되는 수열을 저장하고, 탐색할 숫자가 있는지 체크한다. 모든 숫자를 체크하면 이전 자릿수로 돌아가 해당 숫자 이후로 탐색을 또 진행한다.    코드       def dfs(depth, visited, n):         global answer              if depth == n:             answer.append(visited.copy())         else:             for i in range(1, n+1):                 if i in visited:                     continue                 visited[depth] = i                 dfs(depth + 1, visited, n)                 visited[depth] = 0               if __name__ == \"__main__\":         n = int(input())         visited = [0] * n         answer = []         dfs(0, visited, n)         for a in answer:             print(*a) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_38/",
        "teaser": null
      },{
        "title": "[OSTEP] 메모리 가상화 - 빈 공간 관리",
        "excerpt":"1. 빈 공간 관리     빈 공간 관리가 더 어렵고 흥미로운 경우는 관리하는 공간이 가변-크기 빈 공간들의 집합으로 구성되어 있는 경우이다.            malloc(), free(), 세그멘테이션으로 물리 메모리를 관리하는 운영체제에서 발생한다.           어느 경우에도 외부 단편화가 존재한다.            빈 공간은 다양한 크기의 작은 조각으로 분할되어 결국 단편화된다.              1.1 가정     힙의 빈 공간&lt;/strong&gt;을 관리하는 데는 일반적인 링크드리스트가 사용된다.            이 자료 구조는 영역 내의 모든 빈 청크에 대한 주소를 갖고 있다.           1.2 저수준 기법들     대부분의 할당기에서 사용되는 일반적인 기법            분할(splitting)과 병합(coalescing)       할당된 영역의 크기를 빠르고 상대적으로 쉽게 파악할 수 있는 방법       빈 공간과 사용 중인 공간을 추적하기 위해 빈 공간 내에 간단한 리스트를 구현하는 방법           분할과 병합   분할          위의 예제를 메모리를 1바이트만 요청했다고 가정하자. 이 경우 할당기는 분할(splitting)로 알려진 작업을 수행한다. 요청을 만족시킬 수 있는 빈 청크를 찾아 이를 둘로 분할한다.   병합          위의 예제를 병합하는 예이다.            메모리 청크를 반환할 때 해제되는 청크의 주소와 바로 인접한 빈 청크의 주소를 검사한다. 새로 해제된 빈 공간이 기존에 존재하는 빈 청크와 바로 인접해 있다면 더 큰 빈 공간으로 병합한다.           할당된 공간의 크기 파악     malloc 라이브러리는 해제되는 메모리 영역의 크기를 신속히 파악하여 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 가정한다.            이 작업을 위해 대부분의 할당기는 추가 정보를 헤더(header) 블럭에 저장한다.       헤더 블럭은 메모리에 유지되며 보통 해제된 청크 바로 직전에 위치한다.                위의 그림은 할당된 영역과 헤더이다.             위의 그림은 특정 값이 저장된 헤더이다.            헤더는 적어도 할당된 공간의 크기는 저장해야한다. 또한, 해제 속도를 향상시키기 위한 추가의 포인터, 부가적인 무결성 검사를 제공하기 위한 매직 넘버, 및 기타 정보를 저장할 수 있다.       빈공간 리스트 내장        위의 그림은 3개의 할당 청크를 가진 빈 공간            100바이트씩 할당되는 것을 확인할 수 있다.                위의 그림은 병합되지 않은 빈 공간 리스트            100바이트씩 할당된 청크가 반납되어 해제된 상태를 보여준다.       빈 공간 리스트를 순회하며 해제된 청크를 병합하면 힙은 전체 하나의 큰 청크가 된다.           힙의 확장     힙 공간이 부족한 경우에 어떻게 할 것인가?            가장 쉬운 방법은 단순히 실패를 반환하는 것이다.           대부분의 전통적인 할당기는 적은 크기의 힙으로 시작하여 모두 소진하면 운영체제로부터 더 많은 메모리를 요청한다.            sbrk 시스템콜을 호출한다.       sbrk 요청을 수행하기 위해 운영체제는 빈 물리 페이지를 찾아 요청 프로세스의 주소 공간에 매핑한 후, 새로운 힙의 마지막 주소를 반환한다.           1.3 빈 공간 할당의 기본 전략     이상적인 할당기는 속도가 빠르고 단편화를 치ㅗ소로 해야 한다.            최적 적합(Best Fit)       최악 적합(Worst Fit)       최초 적합(First Fit)       다음 적합(Next Fit)           최적 적합     후보자 그룹 중에서 가장 작은 크기의 청크를 반환한다.   빈 공간 리스트를 한번만 순회하면 반환할 정확한 블럭을 찾을 수 있다.   빈 블럭을 찾기 위해 항상 전체를 검색해야 하기 때문에 엄청난 성능 저하를 초래한다.   최악 적합     가장 큰 빈 청크를 찾아 요청된 크기 만큼 반환하고 남는 부분은 빈 공간 리스트에 계속 유지한다.   최악 적합의 목적은 최적 적합 방식에서 발생될 수 있는 작은 청크들을 방지하는 것이다.   최초 적합     요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환한다.   최초 적합은 속도가 빠르다는 것이 장점이다.   할당기가 빈 공간 리스트의 순서를 관리하는 방법이 쟁점이다.            한가지 방법은 주소-기반 정렬을 사용한다.           다음 적합     마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지한다.   전체 탐색을 하지 않기 때문에 최초 적합의 성능과 비슷하고 빈 공간 탐색을 리스트 전체에 더 균등하게 분산시킬 수 있다.   ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_05/",
        "teaser": null
      },{
        "title": "[OSTEP] 메모리 가상화 - 페이징",
        "excerpt":"1. 페이징: 개요     세그멘테이션은 공간을 다양한 크기의 청크로 분할할 때 공간 자체가 단편화(fragmented)될 수 있고, 할당은 점점 더 어려워진다.   다른 방법은 공간을 동일 크기의 조각으로 분할하는 페이징(paging)&lt;/strong&gt; 기법이다.            프로세스의 주소 공간을 몇개의 가변 크기의 논리 세그멘트(코드, 힙, 스택)로 나누는 것이 아니라 고정 크기의 단위로 나눈다. 이 각각의 단위를 페이지(page)라고 부른다. 상응하여 물리 메모리도 페이지 프레임(page frame)이라고 불리는 고정 크기의 슬롯의 배열이라고 생각한다.           1.1 간단한 예제 및 개요        위의 그림은 128바이트 물리 메모리에 탑재된 64바이트 주소 공간이다.      페이징의 가장 큰 장점은 유연성이다.            힙과 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도 된다.           페이징의 또 다른 장점은 단순함이다.            물리 메모리에 주소 공간을 배치하기 위해서는 운영체제는 비어 있는 네 개의 페이지만 찾으면된다. 운영체제는 모든 비어 있는 페이지의 빈 공간 리스트를 유지하고 리스트의 첫 네 개 페이지를 선택한다.              주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위하여 운영체제는 프로세스 마다 페이지 테이블(page table)이라는 자료 구조를 유지한다.            페이지 테이블의 주요 역할은 주소 공간의 가상 페이지 주소 변환(address translation)정보를 저장하는 것이다.       페이지 테이블은 프로세스마다 존재한다.              프로세스가 생성한 가상 주소의 변환을 위해 먼저 가상 주소를 가상 페이지 번호(virtual page number, VPN)와 페이지 내의 오프셋 2개의 구성 요소로 분할한다.        위의 그림은 movl 21, %eax를 이진 형식으로 변환한 뒤 가상페이지 번호와 오프셋으로 나눈 예이다.        위의 그림은 주소 변환 과정이다.            페이지 테이블에서 VPN을 PFN으로 교체하여 가상 주소를 변환한다. offset은 그대로 사용한다.           1.2 페이지 테이블은 어디에 저장되는가     물리주소로의 변환 정보와 다른 필요한 정보를 저장하기 위하여 각 프로세스의 페이지 테이블을 메모리에 저장한다.   1.3 페이지 테이블에는 실제 무엇이 있는가     페이지 테이블은 가상 주소를 물리 주소로 매핑(mapping)하는 데 사용되는 자료 구조이다.        가장 간단한 형태는 선형 페이지 테이블(linear page table)이다.       페이지 테이블 엔트리(page table entry, PTE)에는 여러가지 비트들이 존재한다.            Valid bit: 특정 변환의 유효 여부를 나타내기 위하여 포함된다. Valid bit은 할당되지 않은 주소 공간을 표현하기 이ㅜ해 반드시 필요하다.       Protection bit: 페이지가 읽을 수 있는지, 쓸 수 있는지, 또는 실행될 수 있는지를 표시한다.       Present bit: 페이지가 물리 메모리에 있는지 혹은 디스크에 있는지(즉, 스왑 아웃되었는지) 가리킨다.                    스와핑은 운영체제가 드물게 사용되는 페이지를 디스크로 이동시켜 물리 메모리를 비울 수 있게 한다.                       dirty bit: 메모리에 반입된 후 페이지가 변경되었는지 여부를 나타낸다.       reference bit: 페이지가 접근되었는지를 추적하기 위해 사용된다.          ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_06/",
        "teaser": null
      },{
        "title": "[백준/Python] 1937 욕심쟁이 판다(DFS/BFS)",
        "excerpt":"BOJ   DFS/BFS 1937 욕심쟁이 판다  문제로 이동!   문제   n × n의 크기의 대나무 숲이 있다. 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다. 그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다. 그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다. 이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다.   이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데, 어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 판다가 최대한 많은 칸을 방문할 수 있는지 고민에 빠져 있다. 우리의 임무는 이 사육사를 도와주는 것이다. n × n 크기의 대나무 숲이 주어져 있을 때, 이 판다가 최대한 많은 칸을 이동하려면 어떤 경로를 통하여 움직여야 하는지 구하여라.   입력   첫째 줄에 대나무 숲의 크기 n(1 ≤ n ≤ 500)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 대나무 숲의 정보가 주어진다. 대나무 숲의 정보는 공백을 사이로 두고 각 지역의 대나무의 양이 정수 값으로 주어진다. 대나무의 양은 1,000,000보다 작거나 같은 자연수이다.   예제 입력       \"\"\"     case 1:     입력     4     14 9 12 10     1 11 5 4     7 15 2 13     6 3 16 8     출력     4      case 2:     입력     2     1 4     2 3     출력     4     \"\"\"  풀이   처음엔 graph의 모든 값을 순회하며 bfs로 최장거리의 max 값을 구했다. 하지만 bfs는 N^4 시간 복잡도를 가지기 때문에 시간초과가 난다. 시간초과를 해결하기 위해 dfs와 dp를 결합해서 문제를 해결해야한다. bfs를 사용하지 않고 dfs를 사용하는 이유는 bfs는 이동할 수 있는 다음 칸의 위치를 큐에 넣고 나중에 탐색하며 반면에 dfs는 해당 위치에서 이동할 수 있는 모든 경로를 탐색하고 최장 경로의 길이를 반환하도록 만들 수 있으므로 비교적 dfs가 간단한다.   dfs를 사용해서 순차적으로 거리를 계산하면, 예를들어 (0,0) -&gt; (0,1) -&gt; (0,2) 순서로 탐색하게 된다면 visited에는 [1,2,3]이 저장 될 것이다. 하지만 우리가 원하는 것은 현재 위치에서의 최장 거리를 저장하는 것이기 때문에, dfs 함수를 호출한 뒤 거리를 계산하는 코드를 넣어준다. 그렇다면, 함수를 반환하면서 1씩 커지기 때문에 visited에는 [3,2,1] 이 저장 될 것이다. 또한, dfs 함수에 0을 만나게되면 return하게 되는 얼리리턴을 사용해서 탐색횟수를 줄여준다.   코드       import sys     sys.setrecursionlimit(10**6)               def dfs(x, y):         if visited[x][y] != 0:             return         visited[x][y] = 1         dx = [0, 0, 1, -1]         dy = [1, -1, 0, 0]         for i in range(4):             nx = x + dx[i]             ny = y + dy[i]             if nx &lt; 0 or nx &gt;= n or ny &lt; 0 or ny &gt;= n:                 continue             if graph[nx][ny] &gt; graph[x][y]:                 dfs(nx, ny)                 if visited[x][y] &lt; visited[nx][ny] + 1:                     visited[x][y] = visited[nx][ny] + 1               if __name__ == \"__main__\":         n = int(input())         graph = [list(map(int, input().split())) for _ in range(n)]         visited = [[0]*n for _ in range(n)]         for i in range(n):             for j in range(n):                 dfs(i, j)         answer = max(map(max, visited))         print(answer) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_39/",
        "teaser": null
      },{
        "title": "[백준/Python] 1699 제곱수의 합(DP)",
        "excerpt":"BOJ   DP 1699 제곱수의 합   문제로 이동!   문제   어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=32+12+12(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=22+22+12+12+12(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.   주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)   예제 입력       \"\"\"     case 1:     입력     7     출력     4      case 2:     입력     12     출력     3      case 3:     입력     41     출력     2     \"\"\"  풀이   DP를 사용해서 풀었다. dp 테이블을 n+1만큼 0으로 초기화를 해준다. 1 부터 n 까지 순회하며 dp 테이블을 i로 업데이트 해준다. 이후 i까지 while 문을 한번 더 순회한다. while 문을 순회하는 이유는 제곱수를 조회하기 위해서이다. 현재 i에서 뺄 수 있는 제곱수를 탐색해서 i에 빼준 dp를 탐색한다. 이후 더 작은 값을 dp[i]에 추가해준다.   코드       def solution(n):         dp = [0] * (n+1)         for i in range(1,n+1):             dp[i] = i             j = 1             while j**2 &lt;= i:                 if dp[i-j**2] + 1 &lt; dp[i]:                     dp[i] = dp[i-j**2] + 1                 j += 1              return dp[n]               if __name__ == \"__main__\":         n = int(input())         print(solution(n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_40/",
        "teaser": null
      },{
        "title": "[백준/Python] 1912 연속합(DP)",
        "excerpt":"BOJ   DP 1912 연속합   문제로 이동!   문제   n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.   예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.   입력   첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.   예제 입력       \"\"\"     case 1:     입력     10     2 1 -4 3 4 -4 6 5 -5 1     출력     14      case 2:     입력     5     -1 -2 -3 -4 -5     출력     -1     \"\"\"  풀이   메모이제이션을 사용하여 문제를 해결한다. max_v(최대 값을 저장할 변수), dp0 둘 모두 array[0]으로 초기화한다. 이후 1부터 n까지 반복문을 순회하며 dp테이블을 업데이트 하는데, 이전 dp 테이블 값과 현재 array의 값을 더한 값과 현재 array의 값을 비교해서 더 큰 값으로 dp값을 업데이트해준다.   array[i] 와 array[i]+dp[i-1] 을 비교하는 이유는, 음수를 만나도 그 다음 값이 훨씬 큰 양수면 음수를 이어서 더하는 것이 더 큰 값을 가지기 때문이다. 예를 들면, 10 -1 2000 이라면 이 세개의 숫자를 모두 이어서 더해야한다. 하지만, 음수를 더하지 않을 경우는 음수를 더한 뒤에 만나는 array의 현재 값보다 더한 값이 작아지면 음수를 더할 필요가 없기 때문에 현재 해당 array값 부터 다시 이어서 더하기 시작한다.   코드       def solution(array, n):         dp = [0] * (n)         dp[0] = array[0]         max_v = array[0]         for i in range(1, n):             dp[i] = max(array[i], array[i] + dp[i-1])             if max_v &lt; dp[i]:                 max_v = dp[i]              return max_v               if __name__ == \"__main__\":         n = int(input())         array = list(map(int, input().split()))         print(solution(array, n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_41/",
        "teaser": null
      },{
        "title": "[백준/Python] 2193 이친수(DP)",
        "excerpt":"BOJ   DP 2193 이친수   문제로 이동!   문제   0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.      이친수는 0으로 시작하지 않는다.   이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.   예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.   N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N이 주어진다.   예제 입력       \"\"\"     case 1:     입력     3     출력     2      case 2:     입력     6     출력     8     \"\"\"  풀이   DP 문제로 해당 문제의 규칙을 찾고 점화식을 세운 뒤 해당 점화식으로 코드를 작성하면 된다. 우선 규칙을 찾기 위해 약간의 노가다를 해보면 다음과 같은 규칙을 찾게 된다.   규칙 :   1 -&gt; 1개  2 -&gt; 1개  3 -&gt; 2개  4 -&gt; 3개(1 + 2)  5 -&gt; 5개(2 + 3)    점화식 : f(n) = f(n-1) + f(n-2)   결국 피보나치수열과 같은 규칙이다.   코드       def solution(n):         dp = [0,1,1]         for i in range(3, n+1):             dp.append(dp[i-1] + dp[i-2])         return dp[n]               if __name__ == \"__main__\":         n = int(input())         print(solution(n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_42/",
        "teaser": null
      },{
        "title": "[백준/Python] 2579 계단 오르기(DP)",
        "excerpt":"BOJ   DP 2579 계단 오르기   문제로 이동!   문제   계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.      예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.      계단 오르는 데는 다음과 같은 규칙이 있다.   계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.      연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.   마지막 도착 계단은 반드시 밟아야 한다.   따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.   각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.   입력   입력의 첫째 줄에 계단의 개수가 주어진다.   둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.   예제 입력       \"\"\"     case 1:     입력     6     10     20     15     25     10     20     출력     75      \"\"\"  풀이   DP를 사용해서 문제를 해결한다. 보텀업 방식을 사용할 것이고, 점화식 또는 규칙을 찾아야한다.   계단을 오르는 규칙은 문제에 나와있듯이      두 계단씩 연속으로 오를 수 있다.   마지막 계단은 밟아야한다.   2번 규칙을 통해 마지막 계단을 꼭 밟아야 하기 때문에, 경우의 수는 두가지가 생긴다. 마지막 계단을 n이라 하자.      n을 밟고, n-1을 밟고(연속으로 밟았다.) n-2는 건너 뛰고 n-3을 밟은 경우   n을 밟고, n-1을 건너 뛰고 n-2를 밟은 경우   첫번째 경우는 n-1은 연속으로 밟기 때문에 array에서 값을 가져오고 n-3은 이전부터 max 값이 저장된 값인 dp값을 가져온다.     dp[n] = array[n] + array[n-1] + dp[n-3]   두번째 경우는 n-2를 이전부터 max 값이 저장된 값인 dp 값을 가져온다.     dp[n] = array[n] + dp[n-2]   이 두 경우중 max인 값을 찾아 dp[n]에 저장하면된다.   코드       def solution(array, n):         dp = [0] * (n+1)         if n &gt;= 1:             dp[0] = array[0]         if n &gt;= 2:             dp[1] = array[1] + array[0]         if n &gt;= 3:             dp[2] = max(array[0]+array[2], array[1]+array[2])             for i in range(3,n):                 left = array[i]+array[i-1]+dp[i-3]                 right = array[i]+dp[i-2]                 dp[i] = max(left, right)         return dp               if __name__ == \"__main__\":         n = int(input())         array = [int(input()) for _ in range(n)]         dp = solution(array, n)         print(dp)         print(dp[n-1]) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_43/",
        "teaser": null
      },{
        "title": "[백준/Python] 9095 1,2,3 더하기(DP)",
        "excerpt":"BOJ   DP 9095 1,2,3 더하기  문제로 이동!   문제   정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.      1+1+1+1   1+1+2   1+2+1   2+1+1   2+2   1+3   3+1   정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.   예제 입력       \"\"\"     case 1:     입력     3     4     7     10       출력     7     44     274      \"\"\"  풀이   백트래킹을 사용해서 하나씩 경우의 수를 구해가며 문제를 풀었는데, DP는 점화식을 세워서 해결하는 문제다. 규칙을 찾아보면 n = f(n-1) + f(n-2) + f(n-3) 이기 때문에 solution2 코드로 간단하게도 해결할 수 있다.   규칙 : n = f(n-1) + f(n-2) + f(n-3)   1 -&gt; 1개  2 -&gt; 2개  3 -&gt; 4개  4 -&gt; 7개(4+2+1)  5 -&gt; 13개(7+4+2)    코드       # solution1: 백트래킹      import sys     sys.setrecursionlimit(10**6)               def dfs(x, case, numbers):         global count         global answer              sum_v = sum(case)         if sum_v == x:             if not case in answer:                 count += 1                 answer.append(case.copy())             case.pop()             return         elif sum_v &gt; x:             case.pop()             return         else:             for number in numbers:                 case.append(number)                 dfs(x, case, numbers)              if len(case) &gt; 0:             case.pop()              return          if __name__ == \"__main__\":         n = int(input())         array = [int(input()) for _ in range(n)]         numbers = [1,2,3]         case = []         count = 0         flag = False         answer = []         for x in array:             dfs(x, case, numbers)             print(count)             count = 0       # solution2: DP      def solution(v):         if v == 1:             return 1         elif v == 2:             return 2         elif v == 3:             return 4         else:             return solution(v-1) + solution(v-2) + solution(v-3)               if __name__ == \"__main__\":         n = int(input())         array = [int(input()) for _ in range(n)]              for v in array:             print(solution(v)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_44/",
        "teaser": null
      },{
        "title": "[백준/Python] 11053 가장 긴 증가하는 부분 수열(DP)",
        "excerpt":"BOJ   DP 11053 가장 긴 증가하는 부분 수열   문제로 이동!   문제   수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.   예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.   입력   첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.   둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)   예제 입력       \"\"\"     case 1:     입력     6     10 20 10 30 20 50     출력     4      case 2:     입력     50 10 20 10 20 30     출력     3     \"\"\"  풀이   DP로 문제를 해결했다. dp 테이블에는 해당 인자까지의 최대 길이를 저장한다. 이중 반복문을 돌며 dp 테이블을 업데이트한다.   첫번째 반복문은 업데이트할 dp 테이블의 인덱스이며, 해당 인덱스를 인덱스-1 ~ 0 까지 돌면서 자신 보다 array 값이 작은 인자를 찾는다.   작은 인자를 찾게 되면 해당 dp값과 현재 자신의 dp값중 큰 값을 자신의 dp 값으로 업데이트해준다.   코드       def solution(array, n):         dp = [1] * n         for i in range(1,n):             for j in range(i-1, -1, -1):                 if array[i] &gt; array[j]:                     dp[i] = max(dp[j] + 1, dp[i])              return max(dp)               if __name__ == \"__main__\":         n = int(input())         array = list(map(int, input().split()))         print(solution(array, n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_45/",
        "teaser": null
      },{
        "title": "[백준/Python] 11727 1xN 타일링 2(DP)",
        "excerpt":"BOJ   DP 11727 2xN 타일링 2  문제로 이동!   문제   2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.   아래 그림은 2×17 직사각형을 채운 한가지 예이다.      입력   첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)   출력   첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.   예제 입력       \"\"\"     case 1:     입력     2      출력     3      case 2:     입력     8      출력     171     \"\"\"  풀이   DP 문제로 해당 문제의 규칙을 찾고 점화식을 세운 뒤 해당 점화식으로 코드를 작성하면 된다. 우선 규칙을 찾기 위해 약간의 노가다를 해보면 다음과 같은 규칙을 찾게 된다.   규칙 :   1 -&gt; 1개  2 -&gt; 3개  3 -&gt; 5개  4 -&gt; 11개(3*2 + 5)  5 -&gt; 21개(5+2 + 11)    점화식 : f(n) = f(n-1) + f(n-2) * 2      DP 문제는 보텀업이나 메모이제이션을 사용하여 문제를 해결하는 방법과 규칙을 찾아 점화식을 세우는 방법 두가지로 나뉘는 것 같다!    코드       def solution(n):         dp = [0] * (n+1)         if n &gt;= 1:             dp[1] = 1         if n &gt;= 2:             dp[2] = 3         if n &gt;= 3:             dp[3] = 5         if n &gt; 3:             for i in range(4,n+1):                 dp[i] = (dp[i-1] + (dp[i-2] * 2)) % 10007         return dp[n]          if __name__ == \"__main__\":         n = int(input())         print(solution(n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_46/",
        "teaser": null
      },{
        "title": "[백준/Python] 14501 퇴사(DP)",
        "excerpt":"BOJ   DP 14501 퇴사  문제로 이동!   문제   상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.   오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.   백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.   각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.   N = 7인 경우에 다음과 같은 상담 일정표를 보자.      1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.   상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.   또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.   퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.   상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.   둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)   예제 입력       \"\"\"     case 1:     입력     7     3 10     5 20     1 10     1 20     2 15     4 40     2 200     출력     45      case 2:     입력     10     5 50     4 40     3 30     2 20     1 10     1 10     2 20     3 30     4 40     5 50     출력     90     \"\"\"  풀이   백트래킹을 이용해서 가능 경우의 수 중 최대값을 구해서 문제를 해결하였다. 하지만 DP를 사용하서 해결하면 더 간단하게 해결할 수 있다.   DP는 보텀업 방식으로 문제를 해결한다. DP 테이블을 n+1개를 0으로 초기화한다. array를 n-1 부터 0까지 순회하면서 DP 테이블을 업데이트할 것이다.   우선 상담일수가 array의 크기보다 벗어나면, 해당 상담을 진행할 수 없기 때문에 dp[i] 를 dp[i+1] 로 정의해준다. 상담이 가능하다면, 이전 상담일까지의 수익과 현재 상담일의 수익 + 현재 상담일을 끝내고 난 뒤의 상담일의 수익을 비교해서 max값을 저장해준다. 현재 상담일을 끝내고 걸리는 시간 뒤의 상담일의 수익이 미리 계산되어 있어야 하기 때문에 반복문 순회를 n에서 0 순서로 진행한다.   코드       # solution1: 백트래킹      import sys     sys.setrecursionlimit(10**6)               def dfs(depth):         global sum_max              if depth == n:             sum_max = max(sum(answer),sum_max)             answer.pop()             return         elif depth &gt; n:             answer.pop()             sum_max = max(sum(answer),sum_max)             return         else:             for i in range(depth, n):                 answer.append(array[i][1])                 dfs(i+array[i][0])              if len(answer) &gt; 0:             answer.pop()         return               if __name__ == \"__main__\":         n = int(input())         array = [tuple(map(int,input().split())) for _ in range(n)]         sum_max = 0         for i in range(n):             answer = []             dfs(i)         print(sum_max)       # solution2: DP      def solution(array, n):         dp = [0] * (n+1)         for i in range(n-1, -1, -1):             if i+array[i][0] &gt; n:                 dp[i] = dp[i+1]             else:                 left = dp[i+1]                 right = dp[i+array[i][0]]+array[i][1]                 dp[i] = max(left, right)         return dp[0]               if __name__ == \"__main__\":         n = int(input())         array = [tuple(map(int, input().split())) for _ in range(n)]         print(solution(array, n)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_47/",
        "teaser": null
      },{
        "title": "[백준/Python] 1316 그룹 단어 체커(문자열)",
        "excerpt":"BOJ   문자열 1316 그룹 단어 체커  문제로 이동!   문제   그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다.   단어 N개를 입력으로 받아 그룹 단어의 개수를 출력하는 프로그램을 작성하시오.   입력   첫째 줄에 단어의 개수 N이 들어온다. N은 100보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 단어가 들어온다. 단어는 알파벳 소문자로만 되어있고 중복되지 않으며, 길이는 최대 100이다.   예제 입력       \"\"\"     case 1:     입력     3     happy     new     year     출력     3      case 2:     입력     4     aba     abab     abcabc     a     출력     1     \"\"\"  풀이   이중 반복문을 사용해서 탐색하는 값부터 n까지 다시 순회 하면서 자기 자신과 다른 값을 찾게 되면 flag를 True로 바꿔주고, flag가 True이고 자기 자신과 같은 값인 조건을 만족하면 False로 리턴한다. 그렇지 않다면 True를 리턴해서 True로 리턴된 개수를 출력한다.   코드       import sys               def solution(string):         length = len(string)         for i in range(length):             flag = False             for j in range(i+1, length):                 if string[i] != string[j]:                     flag = True                 if string[i] == string[j] and flag:                     return False         return True               if __name__ == \"__main__\":         n = int(input())         strings = [sys.stdin.readline().rstrip() for _ in range(n)]         count = 0         for string in strings:             if solution(string):                 count += 1         print(count) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_48/",
        "teaser": null
      },{
        "title": "[백준/Python] 16916 부분 문자열(문자열)",
        "excerpt":"BOJ   수학 16916 부분 문자열  문제로 이동!   문제   문자열 S의 부분 문자열이란, 문자열의 연속된 일부를 의미한다.   예를 들어, “aek”, “joo”, “ekj”는 “baekjoon”의 부분 문자열이고, “bak”, “p”, “oone”는 부분 문자열이 아니다.   문자열 S와 P가 주어졌을 때, P가 S의 부분 문자열인지 아닌지 알아보자.   입력   첫째 줄에 문자열 S, 둘째 줄에 문자열 P가 주어진다. 두 문자열은 빈 문자열이 아니며, 길이는 100만을 넘지 않는다. 또, 알파벳 소문자로만 이루어져 있다.   예제 입력       \"\"\"     case 1:     입력         baekjoon     aek     출력     1      case 2:     입력     baekjoon     oone     출력     0     \"\"\"  풀이   완전탐색을 사용해서 문제를 풀게되면 시간초과로 인해 정답을 도출해내지 못한다. 이럴 경우에 문자열의 부분 문자열을 탐색할 수 있는 KMP 알고리즘을 사용하면 된다. KMP 알고리즘은 패턴에 해당되는 문자열의 접두사와 접미사를 조사한 pi 배열을 이용해서 중복되는 부분을 중복 없이 탐색할 수 있도록 도와주는 알고리즘이다.   자세한 KMP 설명으로!     위 블로그 글이 굉장히 도움이 많이 되었다.   코드            import sys               def KMPSearch(pat, txt):         M = len(pat)         N = len(txt)              lps = [0]*M              computeLPS(pat, lps)              i = 0         j = 0         while i &lt; N:             if pat[j] == txt[i]:                 i += 1                 j += 1             elif pat[j] != txt[i]:                 if j != 0:                     j = lps[j-1]                 else:                     i += 1                  if j == M:                 return 1         return 0               def computeLPS(pat, lps):         leng = 0              i = 1         while i &lt; len(pat):             if pat[i] == pat[leng]:                 leng += 1                 lps[i] = leng                 i += 1             else:                 if leng != 0:                     leng = lps[leng-1]                 else:                     lps[i] = 0                     i += 1               if __name__ == \"__main__\":         txt = sys.stdin.readline().rstrip()         pat = sys.stdin.readline().rstrip()         print(KMPSearch(pat, txt)) ","categories": ["백준"],
        "tags": ["Algorithm","Python","백준"],
        "url": "/%EB%B0%B1%EC%A4%80/python_49/",
        "teaser": null
      },{
        "title": "[OSTEP] 메모리 가상화 - 페이징 개선(TLB, 더 작은 테이블)",
        "excerpt":"1. 페이징: 더 빠른 변환(TLB)     페이징은 주소 공간을 작은 크기(페이지)로 나누고 각 페이지의 실제 위치(매핑 정보)를 메모리에 저장한다. 매핑 정보를 저장하는 자료 구조를 페이지 테이블이라 한다.   페이징은 성능 저하를 유발할 수 있다.            가상 주소에서 물리 주소로의 주소 변환을 위해 메모리에 존재하는 매핑 정보를 읽어야 한다는 사실은 페이지 테이블 접근을 위한 메모리 읽기 작업이며 이는 엄청난 성능 저하를 유발한다.                 주소 변환을 빠르게 하기 위해서 우리는 변환-색인 버퍼(translation-lookaside buffer) 또는 TLB를 도입한다.            TLB는 칩의 메모리 관리부(memory-management unit, MMU)의 일부이다.       자주 참조되는 VirtualMemory-PhysicalMemory 변환 정보를 저장하는 하드웨어 캐시이다.       가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인한다. 만약 있다면 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 실질적으로 TLB는 페이징 성능을 엄청나게 향상시킨다.           1.1 TLB의 기본 알고리즘     주소 변환부는 단순한 선형 페이지 테이블(배열로 이루어진 페이지 테이블) 과 하드웨어로 관리되는 TLB로 구성되어 있다.   하드웨어 부분의 알고리즘은 다음과 같이 동작한다. (TLB Hit 과 Miss로 나뉨)   TLB Hit            가상주소에서 가상 페이지 번호(virtual page nubmer, VPN)을 추출한 후, 해당 VPN을 TLB 존재 여부를 검사한다.       만약 존재한다면 TLB 히트이고 TLB가 변환 값을 갖고 있다는 것을 뜻한다.       해당 TLB 항목에서 페이지 프레임 번호(page fame number, PFN)을 추출한다.       해당 페이지에 대한 접근 권한 검사가 성공하면       그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소를 구성하고 메모리에 접근한다.           TLB Miss            위의 2번에서 TLB Miss되면       하드웨어가 변환 정보를 찾기 위해서 페이지 테이블에 접근한다.       프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면       해당 변환정보를 TLB로 읽어들인다.(시간이 많이 소요되는 작업, 테이블 접근을 위한 메모리 참조 때문)       TLB가 갱신되면 하드웨어는 명령어를 재실행한다.           TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 때문에, 주소 변환 작업은 그다지 부담스러운 작업이아니다.   TLB 미스가 많이 발생할수록 메모리 접근 횟수가 많아진다.            TLB 미스가 발생하는 경우를 최대한 피해야 한다.           1.2 예제: 배열 접근        위의 그림과 같이 배열의 데이터가 저장되어 있다고 가정하자.            index 0부터 9까지 배열을 읽으면 index0을 읽을 때 TLB는 초기화 되어있기 때문에 TLB미스가 발생하고 VPN 06번 페이지를 TLB를 가져온다.       이후 1번과 2번 index를 읽을 때는 TLB히트가 발생하여 바로 가져올 수 있다.       다시 3번 index를 읽을 때는 TLB미스가 발생하여 VPN 07번 페이지를 TLB로 가져온다.           위의 예제를 통해 배열이 처음으로 접근되었지만, TLB는 공간 지역성으로 인해서 성능을 개선할 수 있다.   만약 TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면 히트, 히트, 히트, 히트, … 히트 를 얻는다.            이 경우에는 시간 지역성으로 인해 TLB의 히트율이 높아진다.           프로그램이 공간 혹은 시간 지역성을 보이는 경우, TLB 사용 효과가 더욱 두드러지게 나타날 것이다.   1.3 TLB 미스는 누가 처리할까     TLB 미스의 처리는 두 가지 방법이 있다.            하드웨어와 소프트웨어이다.           CISC(complex-instruction set computers): TLB 미스를 하드웨어가 처리하도록 설계     이를 위해서 하드웨어가 페이지 테이블에 대한 명확한 정보를 가지고 있어야 한다.            메모리 상 위치(page-table base register를 통해서)와 정확한 형식을 파악하고 있어야 한다.           미스 발생시 다음과 같은 일을 한다.            페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾고       필요한 변환 정보를 추출하여       TLB를 갱신한 후       TLB 미스가 발생한 명령어를 재실행한다.           x86 CPU가 하드웨어로 관리 되는 TLB의 대표적인 예다.            멀티 레벨 페이지 테이블을 사용한다.           RISC(reduced instruction set computing): 소프트웨어 관리 TLB 사용     RISC 기반 컴퓨터에서 TLB 미스를 처리하는 과정은 다음과 같다.            TLB에서 주소 찾는 것이 실패하면, 하드웨어는 예외 시그널을 발생시킨다.       예외 시그널을 받은 운영체제는 명령어 실행을 잠정 중지하고, 실행 모드를 커널 모드로 변경하여, 커널 코드 실행을 준비한다.                    실행 모드를 커널 모드로 변경하는 작업의 핵심은 커널 주소 공간을 접근할 수 있또록 특권 레벨(privilege level)로 상향 조정하는 것이다.                       커널 모드로 변경이 되면 트랩 핸들러(trap handler)를 실행한다.                    이 때 실행되는 트랩 핸들러는 TLB 미스의 처리를 담당하는 운영체제 코드이다.                       이 트랩 핸들러는 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 “특권” 명령어를 사용하여 TLB를 갱신한 후에 리턴한다.       트랩 핸들러에서 리턴되면 하드웨어가 명령어를 재실행한다.           TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와의 차이가 있다.            TLB 미스 처리의 경우 다음 명령어의 PC값을 트랩을 발생시킨 명령을 다시 실행해야한다.                TLB 미스 핸들러를 실행할 때, TLB 미스가 무한 반복되지 않도록 주의해야 한다.       TLB를 소프트웨어로 관리하는 방식의 주된 장점은 유연성과 단순함이다.   1.4 TLB의 구성: 무엇이 있나?     TLB는 32, 64, 또는 128개의 엔트리를 가지며, 완전 연관(fully associative) 방식으로 설계된다.            완전 연관 방식에서 변환 정보는 TLB 내에 어디든 위치할 수 있으며, 원하는 변환 정보를 찾는 검색은 TLB 전체에서 병렬적으로 수행된다.           TLB의 구성: VPN \\ PFN \\ offset(다른 비트들)            하드웨어 측면에서 보자면, TLB는 완전 연관 캐시이다.           TLB는 일반적으로 valid bit을 갖고 있다.            특정 항목이 유효한 변환 정보를 갖고 있는지 여부를 나타낸다.           보호(protection)비트라는 것도 있다.            보호 비트들은 페이지가 어떻게 접근될 수 있는지를 나타낸다.           더티 비트(dirty bit)라는 것도 있다.            페이지가 변경되었는지에 대한 정보를 가지고 있다.           1.5 TLB의 문제: 문맥 교환     TLB에 있는 가상 주소와 실제 주소 간의 변환 정보는 그것을 탑재시킨 프로세스에서만 유효하다.            새로운 프로세스에서는 이전에 실행하던 프로세스의 변환 정보를 사용하지 않도록 주의해야 한다.                위의 그림은 TLB의 예이다.(문제가 있음)            하지만 위의 TLB에서는 VPN이 10이 두개가 있으며(process 1과 2의 가상 주소 10) 어떤 프로세스의 가상주소인지 확인할 수 없다.                TLB가 정확하고 효율적으로 멀티 프로세스 간의 가상화를 지원하기 위해서는 추가적 기능이 필요하다.       한 방법은 문맥 교환을 수행할 때 다음 프로세스가 실행되기 전에 기존 TLB 내용을 비우는 것이다.            하지만 TLB 내용이 비어지면 문맥 교체가 빈번히 발생되면 TLB 미스가 많아진다.           다른 방법은 TLB 내에 주소 공간 식별자(address space identifier, ASID) 필드를 추가하는 것이다.            ASID는 프로세스 식별자(process identifier, PID)와 대략적으로 유사하다.                위의 그림은 ASID가 추가된 TLB의 모습이다.            ASID로 프로세스를 구분할 수 있게 됐다.                ASID를 사용하면 코드 페이지를 위의 그림처럼 공유하여 프로세스가 사용하는 물리 페이지의 수를 줄일 수 있다.   1.6 이슈: 교체 정책          모든 캐시가 그러하듯이 TLB에서도 캐시 교체(cache replacement) 정책이 매우 중요하다.       한 가지 흔한 방법은 가장 오래 전부터 사용되었던 최저 사용 빈도(least-recently-used, LRU) 항목을 교체하는 것이다.            LRU는 메모리 참조 패턴에서의 지역성을 최대한 활용하는 것이 목적이다.           다른 방법은 랜덤(random) 정책이다.            랜덤 정책에서는 교체 대상을 무작위로 정한다.       랜덤 교체 정책은 구현이 간단하고 예상치 못한 예외 상황의 발생을 피할 수 있다는 장점이 있다.           1.7 요약     지금까지 주소 변환을 더 빠르게 처리하기 위한 하드웨어 기법에 대해 살펴보았따.   TLB를 주소 변환 캐시로 사용하여 대부분의 메모리 참조들은 메인 메모리 상의 페이지 테이블을 읽지 않고도 처리가 가능하게 되었따.   프로그램이 짧은 시간 동안 접근하는 페이지들의 수가 TLB에 들어갈 수 잇는 수보다 많다면 TLB 미스를 발생할 것이고 느리게 동작하게 될 것이다.   2. 페이징: 더 작은 테이블     페이징의 두 번째 문제점은 페이지 테이블의 크기이다. 페이지 테이블이 크면 많은 메모리 공간을 차지한다.            단순한 배열 기반의 페이지 테이블은(흔히 선형 페이지 테이블이라고 불림) 크기가 크며 일반적인 시스템에서 메모리를 과도하게 차지한다.           2.1 간단한 해법: 더 큰 페이지     페이지 테이블의 크기를 간단하게 줄일 수 있는 방법이 한 가지 있다.            페이지 크기를 증가시키면 된다.           하지만 페이지 크기의 증가는 부작용을 수반한다.            가장 큰 문제는 페이지 내부의 낭비 공간이 증가하는 것이다.       이를 내부 단편화라 한다(할당된 페이지 내부에서 낭비가 발생하기 때문이다).           2.2 하이브리드 접근 방법: 페이징과 세그멘트     페이징과 세그멘테이션을 결합하여 페이지 테이블 크기를 줄이는 아이디어가 있다.   결합 방식을 생각해 보자. 프로세스의 전체 주소 공간을 위해 하나의 페이지 테이블을 두는 대신, 논리 세그멘트마다 따로 페이지 테이블을 두면 어떨까?            코드, 힙 그리고 스택 세그멘트에 대해 페이지 테이블을 각각 두는 것이다.       세그멘트와 비슷하게 베이스 레지스터와 바운드 또는 리미트 레지스터를 사용하여 페이지 테이블의 시작과 끝을 나타낸다.                위의 그림은 페이징과 세그먼트를 이용한 주소 공간이다.            상위 2비트를 소속 세그멘트를 나타내기 위해 사용한다.           하지만, 하이브리드 접근 방법 또한 문제가 있다.            여전히 세그멘테이션을 사용한다 ; 빈 공간이 많은 힙의 경우에는 테이블의 낭비를 면치 못할 수가 있다.       하이브리드 기법은 외부 단편화를 유발한다.           2.3 멀티 레벨 페이지 테이블     멀티 레벨 페이지 테이블에서는 선형 페이지 테이블을 트리 구조로 표현한다.   멀티 레벨 페이지 테이블의 기본 개념은 간단하다.            먼저, 페이지 테이블을 페이지 크기의 단위로 나눈다.       그다음, 페이지 테이블의 페이지가 유효하지 않은 항목만 있으면, 행당 페이지를 할당하지 않는다.           페이지 디렉터리(page directory)라는 자료 구조를 사용하여 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다.            페이지 디렉터리는 페이지 테이블을 구성하는 각 페이지의 존재 여부와 위치 정보를 가지고 있다.                위의 그림은 선형 테이블과 멀티 레벨 페이지 테이블이다.   간단한 2단계 테이블에서, 페이지 디렉터리의 각 항목은 페이지 테이블의 한 페이지를 나타낸다.            페이지 디렉터리는 페이지 디렉터리 항목(page directory entries, PDE)들로 구성된다.       유효(valid) 비트와 페이지 프레임 번호(page frame number, PFN)을 갖고 있다.           멀티 레벨 페이지 테이블의 장점            사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당된다.                    보다 작은 크기의 페이지 테이블로 주소 공간을 표현할 수 있다.                       페이지 테이블을 페이지 크기로 분할함으로써 메모리 관리가 매우 용이하다.                    페이지 테이블을 할당하거나 확장할 때, 운영체제는 free페이지 풀에 잇는 빈 페이지를 가져다 쓰면 된다.                       페이지 테이블의 각 페이지들이 물리 메모리에 산재해 있더라도 페이지 디렉터리를 이용하여 그 위치를 파악할 수 있으므로 ,페이지 테이블을 위한 공간 할당이 매우 유연하다.           멀티 레벨 페이지 테이블의 유의 사항            TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드가 발생하여 추가 비용이 발생한다.       복잡도           2.4 역 페이지 테이블     획기적인 공간 절약 방법으로 역 페이지 테이블(inverted page table)이 있다.   시스템에 단 하나의 페이지 테이블만 둔다.   페이지 테이블은 물리 페이지를 가상 주소 상의 페이지로 변환한다.   2.5 페이지 테이블을 디스크로 스와핑하기     어떤 시스템들은 페이지 테이블들을 커널 가상 메모리에 위치시키고, 메모리가 부족할 경우 페이지 테이블들을 디스크로 스왑(swap)한다.   2.6 요약     테이블을 위한 자료 구조에는 시간과 공간이라는 모순적 선택 사항이 존재한다.   공간을 많이 소모하는 테이블 구조를 사용할 수록 TLB미스의 처리속도가 빨라진다.   공간을 작게 차지한는 테이블 구조를 사용하면 상황은 반대가 된다.  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_07/",
        "teaser": null
      },{
        "title": "[OSTEP] 메모리 가상화 - 물리 메모리 크기의 극복(메커니즘과 정책)",
        "excerpt":"1. 물리 메모리 크기의 극복: 메커니즘     큰 주소 공간을 지원하기 위해서 운영체제는 주소 공간 중에 현재는 크게 필요하지 않은 일부를 보관해 둘 공간이 필요하다.            현대 시스템에서는 보통 하드 디스크 드라이브가 이 역할을 담당한다.           왜 프로세스에게 굳이 “큰” 주소 공간을 제공해야하는가이다.            이에 대한 답은 다시 한번 편리함과 사용 용이성이다.       주소 공간이 충분히 크면, 프로그램의 자료 구조들을 위한 충분한 메모리 공간이 있는지 걱정핮 ㅣ않아도 된다.       필요 시 메모리 할당을 운영체제에게 요청하기만 하면 된다.           스왑 공간이 추가되면 운영체제는 실행되는 각 프로세스들에게 큰 가상 메모리가 있는 것 같은 환상을 줄 수 있다.   멀티프로그래밍 시스템이 발명되면서 많은 프로세스들의 페이지를 물리 메모리에 전부 저장하는 것이 불가능하게 되었다.            그래서 일부 페이지들을 스왑 아웃하는 기능이 필요하게 되었다.           1.1 스왑 공간     디스크에 페이지들을 저장할 수 있는 일정 공간을 확보하는 것이다.            이 용도의 공간을 스왑 공간(swap space)라고 한다.           운영체제는 스왑 공간에 있는 모든 페이지들의 디스크 주소를 기억해야 한다.   스왑 공간의 크기는 매우 중요하다.            시스템이 사용할 수 있는 메모리 페이지의 최대수를 결정하기 때문이다.                위의 긞은 물리 메모리와 스왑 공간이다.            Proc3은 사용되고 있지 않다.           1.2 Present Bit     메모리가 참조되는 과정            프로세스가 가상 메모리 참조를 생성한다(명령어 탑재나 데이터 접근등).       하드웨어는 메모리에서 원하는 데이터를 가져오기 전에, 우선 가상 주소를 물리 주소로 변환한다.       TLB Hit 하면 TLB에서 물리 주소를 얻은 후에 메모리로 가져온다.       TLB Miss 하면 하드웨어는 페이지 테이블의 메모리 주소를 파악하고(페이지 테이블 베이스 레지스터를 사용), VPN을 인덱스로 하여 원하는 페이지 테이블 항목(PTE)을 추출한다.       해당 페이지 테이블 항목이 유효하고 관련 페이지가 물리 메모리에 존재한다면 하드웨어는 PTE에서 PFN 정보를 추출하고 그 정보를 TLB에 탑재한다.       TLB 탑재 후 명령어를 재실행한다.           페이지가 디스크로 스왑되는 것을 가능케 하려면, 많은 기법이 추가되어야 한다.            하드웨어가 PTE에서 해당 페이지가 물리 메모리에 존재하지 않는다는 것을 표현 해야 한다.       present bit을 사용하여 각 페이지 테이블 항목에 어떤 페이지가 존재하는지를 표현한다.       present bit이 1로 설정 되어 있다면, 물리 메모리에 해당 페이지가 존재한다.       present bit이 0으로 설저오디어 있다면, 물리 메모리에 존재하지 않고 디스크에 존재한다는 것을 나타낸다.           물리 메모리에 존재하지 않는 페이지를 접근하는 행위를 일반적으로 페이지 폴트(page fault)라 한다.            페이지 폴트가 발생하면, 페이지 폴트를 처리하기 위해 운영체제로 제어권이 넘어가 페이지 폴트 핸들러(page-fault handler)가 실행된다.           1.3 페이지 폴트     페이지 폴트가 발생하면 운영체제가 그 처리를 담당한다.            운영체제의 페이지 폴트 핸들러가 그 처리 메커니즘을 규정한다.           만약 요청된 페이지가 메모리에 없고, 디스크로 스왑되었다면, 운영체제는 해당 페이지를 메모리로 스왑해 온다.            많은 시스템들에서 해당 정보를 페이지 테이블에 저장한다.       페이지 폴트 발생 시, 운영체제는 페이지 테이블 항목에서 해당 페이지의 디스크 상 위치를 파악하여, 메모리로 탑재한다.           1.4 메모리에 빈 공간이 없으면?     메모리에 여유 공간이 없다면 탑재하고자 하는 새로운 페이지들을 위한 공간을 확보하기 위해 하나 또는 그 이상의 페이지들을 먼저 페이지 아웃(page out)하려고 할 수도 있다.   교체(replace) 페이지를 선택하는 것을 페이지 교체 정책(page-replacement policy)이라고 한다.   1.5 페이지 폴트의 처리         위의 코드를 보면 TLB 미스 발생시, 세 가지의 중요한 경우가 있다는 것을 알 수 있다.            페이지가 존재하며 유효한 경우다.                    TLB 미스 핸들러가 PTE에서 PFN을 가져와서 명령어를 재시도 한다.                       페이지가 유효하지만 존재하지 않는 경우다.                    페이지 폴트 핸들러가 반드시 실행되어야 한다.(물리 메모리에 존재하지 않고 디스크 상에 존재하는 경우다.)                       페이지가 유효하지 않는 경우다.                    하드웨어는 이 무효한 접근이 운영체제의 트랩 핸들러에 의해서 처리되도록 한다.                           1.6 교체는 실제 언제 일어나는가     메모리에 항상 어느 정도의 여유 공간을 비워두기 위해서, 대부분의 운영체제들은 여유 공간에 관련된 최댓값(high watermark, HW)과 최솟값(low watermark, LW)을 설정하여 교체 알고리즘 작동에 활용한다.   동작 방법은 다음과 같다.            운영체제가 공간의 크기가 최솟값보다 작아지면 여유 공간 확보를 담당하는 백그라운드 쓰레드가 실행된다.       이 쓰레드는 여유 공간의 크기가 최댓값에 이를 때까지 페이지를 제거한다.       이 백그라운드 쓰레드는 일반적으로 스왑 데몬(swap daemon) 또는 페이지 데몬(page daemon)이라고 불린다.           일시에 여러 개를 교체하면 성능 개선이 가능하다.            많은 시스템들은 다수의 페이지들을 클러스터(cluster)나 그룹(group)으로 묶어서 한번에 스왑 파티션에 저장함으로써 디스크의 효율을 높인다.           1.7 요약     시스템에 실제 존재하는 물리 메모리의 크기보다 더 많은 메모리를 사용하기 위한 개념을 소개하였다.   메모리에 특정 페이지가 존재하는지를 알리기 위한 present bit와 좀 더 복잡한 페이지 테이블 구조가 필요하다.   운영체제는 페이지 폴트(page fault)를 처리하기 위해서 페이지 폴트 핸들러(page-fault handler)를 실행시킨다.            핸들러는 원하는 페이지를 디스크에서 메모리로 전송하기 위해 메모리의 일부 페이지들을 먼저 교체하여 새롭게 스왑되서 들어올 페이지를 위한 공간을 만드는 조치를 취한다.           2. 물리 메모리 크기의 극복: 정책     빈 메모리 공간이 거의 없으면 일이 더 복잡해진다.   그런 경우 운영체제는 메모리 압박(memory pressure)을 해소하기 위해 다른 페이지들을 강제적으로 페이징 아웃(paging out)하여 활발히 사용 중인 페이지들을 위한 공간을 확보한다.   내보낼(evict) 페이지(또는 페이지들) 선택은 운영체제의 교체 정책(replacement policy)안에 집약되어 있다.   2.1 캐시 관리     시스템의 전체 페이지들 중 일부분만이 메인 메모리에 유지된다는 것을 가정하면, 메인 메모리는 시스템의 가상 메모리 페이지를 가져다 놓기 위한 캐시로 생각될 수 있다.   이 캐시를 위한 교체 정책의 목표는 캐시 미스의 횟수를 최소화하는 것이다.   평균 메모리 접근 시간(average memory access time, AMAT)     앞으로 나올 페이지 교체 정책을 평균 메모리 접근 시간을 통해서 비교할 것이다.   캐시 히트와 미스의 횟수를 안다면 프로그램의 평균 메모리 접근 시간을 계산할 수 있다.   AMAT 는 다음과 같은 식으로 계싼할 수가 있다.            AMAT = Tm + (Pmiss * Td)       Tm: 메모리 접근 비용       Td: 디스크 접근 비용       Pmiss: 캐시미스 확률(0.0~1.0)           2.2 최적 교체 정책     교체 정책의 동작 방식을 잘 이해하기 위해서 최적 교체 정책(The Optimal Replacement Policy)과 비교하는 것이 좋다.            최적 교체 정책은 미스를 최소화한다.       가장 나중에 접근될 페이지를 교체하는 것이 최적이며, 가장 적은 횟수의 미스를 발생시킨다는 것이 증명되었다.                위의 그림은 최적의 교체 정책의 흐름이다.            캐시는 처음에 비어 있는 상태로 시작하기 때문에 첫 세 번의 접근은 미스이다.       이러한 종류의 미스는 최초 시작 미스(cold-start miss) 또는 강제 미스(compulsory miss)라고 한다.           2.3 간단한 정책: FIFO     FIFO(먼저 들어온 것이 먼저 나간다, 선입선출) 교체 방식을 사용하였다.   FIFO는 매우 구현하기 쉽다는 장점을 가진다.   최적의 경우와 비교하면 FIFO는 눈에 띄게 성능이 안좋다.   FIFO는 블럭들의 중요도를 판단할 수가 없다.        위의 그림은 FIFO 정책의 흐름   2.4 또 다른 간단한 정책: 무작위 선택     또 다른 유사한 교체 정책은 무작위 방식이다.   메모리 압박이 있을 때 페이지를 무작위로 선택하여 교체한다.   때로는 매우 좋은 성능을 보이며 때로는 최악의 성능을 보여준다.        위의 그림은 무작위 선택 정책의 흐름   2.5 과거 정보의 사용: LRU     불행하게도 FIFO 또는 무작위 선택 방식처럼 단순한 정책들은 중요한 페이지들을 혹은 바로 다시 참조하게 될 것들을 내보낼 수 있다는 비슷한 문제를 겪는다.   스케줄링 정책에서와 같이 미래에 대한 예측을 위해서 과거 사용 이력을 활용한 기법이다.            페이지 교체 정책이 활용할 수 있는 과거 정보 중 하나는 빈도수(frequency)이다.       좀 더 자주 사용되는 페이지의 특징은 접근의 최근성(recency)이다.           이러한 류의 정책은 지역성의 원칙(principle of locality)라고 부르는 특성에 기반을 둔다.   그리하여 과거 이력에 기반한 교체 알고리즘 부류가 탄생하게 되었다.            Least-Frequently-Used(LFU) 정책은 가장 적은 빈도로 사용된 페이지를 교체한다.       Least-Recently-Used(LRU) 정책은 가장 오래 전에 사용된 페이지를 교체한다.                위의 그림은 LRU 정책의 흐름이다.   2.6 워크로드에 따른 성능 비교        위의 그림은 지역성이 없는 워크로드             위의 그림은 지역성(80대20) 워크로드            지역성의 여부에 따라 워크로드의 효율성이 차이가 난다.             특히 LRU나 FIFO는 “순차 반복” 워크로드에서 거의 최악의 효율을 보여준다.       순차반복: 0,1,2 ~ 50 -&gt; 0,1,2 ~ 50…                위의 그림은 순환 형 워크로드이다.   2.7 과거 이력 기반 알고리즘의 구현     위의 효율이 나빠지는 문제들을 해결하기 위한 방법은 약간의 하드웨어 지원을 받는 것이다.   예를들어 페이지 접근이 있을 때마다 하드웨어가 메모리의 시간 필드를 갱신하도록 할 수 있다.   2.8 LRU 정책 근사하기     LRU는 가장 오래 전에 사용된 페이지를 탐색하는데 많은 비용을 사용한다.   그렇기 때문에 LRU를 “근사” 하는 식으로 만들면 구현이 훨씬 쉬워진다.   이 개념에는 use bit(때로는 reference bit 라고도 불린다)라고 하는 약간의 하드웨어 지원이 필요하다.   페이지가 참조될 때마다(즉, 읽히거나 기록되면) 하드웨어에 의해서 use bit가 1로 설정된다.            하드웨어는 이 비트를 절대로 지우지 않는다.       0으로 바꾸는 것은 운영체제의 몫이다.                 운영체제가 LRU에 가깝게 구현하기 위해서 use bit를 활용하는 방법은 시계 알고리즘(clock algorithm)이다.            운영체제는 현재 바늘이 가리키고 있는 페이지 P의 use bit가 1인지 0인지 검사한다.       만약 1이라면 페이지 P는 최근에 사요되었으며 바람직한 교체 대상이 아니라는 것을 뜻한다.       P의 use bit은 0으로 설정되고 시계 바늘은 다음 페이지 P+1로 이동한다.       알고리즘은 use bit가 0으로 설정되어 있는, 즉 최근에 사용된 적이 없는, 페이지를 찾을 때까지 반복된다.           2.9 갱신된 페이지(Dirty Page)의 고려     운영체제가 교체 대상을 선택할 때 메모리에 탑재된 이후에 변경되었는지를 추가적으로 고려하는 것이다.   어떤 페이지가 변경(modified)되어 더티(dirty) 상태가 되었다면, 그 페이지를 내보내기 위해서는 디스크에 변경 내용을 기록해야 하기 때문에 비싼 비용을 지불해야한다.            VM 시스템들은 더티 페이지 대신 깨끗한 페이지를 내보내는 것을 선호한다.           이와 같은 동작을 지원하기 위해서 하드웨어는 modified bit(더티 비트)를 포함해야 한다.   예를들어, 시계 알고리즘은 교체 대상을 선택할 때 사용되지 않은 상태이고 깨끗한, 두 조건을 모두 만족하는 페이지를 먼저 찾도록 수정된다.   2.10 다른 VM 정책들     페이지 선택            운영체제는 언제 페이지를 메모리로 불러들일지 결정해야한다.       이러한 정책을 페이지 선택(page selection) 정책이라고 불린다.           요구 페이징(demanding paging)            운영체제는 대부분의 페이지를 읽어 들일 때 요구 페이징 정책을 사용한다.       이 정책은 말 그대로 “요청된 후 즉시”, 즉 페이지가 실제로 접근될 때 운영체제가 해당 페이지를 메모리로 읽어 들인다.           운영체제가 변경된 페이지를 디스크에 반영하는 데 관련된 방식의 정책            많은 시스템은 기록해야 할 페이지들을 메모리에 모은 후, 한번에 (더 효율적으로) 디스크에 기록한다.       위와 같은 동작을 클러스터링(clustering) 또는 단순하게 쓰기 모으기(grouping of writes)라고 부른다.           2.11 쓰래싱(Thrashing)     시스템이 끊임없이 페이징을 할 수 밖에 없는 상황을 쓰래싱(thrashing)이라고 부른다.   쓰래싱 해결 기법            다수의 프로세스가 존재할 때, 일부 프로세스의 실행을 중지시킨다.       메모리 요구가 초과되면 메모리 부족 킬러(out-of-memory killer)를 실행시켜 많은 메모리를 요구하는 프로세스를 골라 죽인다.           ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_08/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 개요",
        "excerpt":"1. 병행성: 개요     멀티 쓰레드 프로그램은 하나 이상의 실행 지점(독립적으로 불러 들여지고 실행될 수 있는 여러 개의 PC 값)을 가지고 있다.   멀티 쓰레드를 이해하는 다른 방법은 각 쓰레드가 프로세스와 매우 유사하지만, 차이가 있다면 쓰레드들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다는 것이다.   쓰레드는 어디서 명령어들을 불러 들일지 추적하는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다.   두 개 이상의 쓰레드가 하나의 프로세서에서 실행 중이라면 문맥 교환이 이루어져야 한다.            문맥 전환을 할 때 프로세스는 자신의 상태를 프로세스 제어 블럭(process control block, PCB)에 저장하듯이 쓰레드는 쓰레드 제어 블럭(thread control block, TCB)에 저장한다.       가장 큰 차이 중 하나는 프로세스의 경우와 달리 쓰레드 간의 문맥 교환에서는 주소 공간을 그대로 사용한다.       쓰레드와 프로세스의 또 다른 차이는 쓰레드는 자신만의 스택이 존재한다.           1.1 왜 쓰레드를 사용하는가?     쓰레드를 사용해야하는 2가지 주요 이유가 있다.            병렬 처리(parallelism)       느린 I/O로 인해 프로그램 실행이 멈추지 않도록하기 위해 쓰레드를 사용한다.              쓰레드는 병렬처리가 가능한데 문맥전환을 한다…?! 이 말의 뜻은 만약 프로세서가 1개일 때는 쓰레드가 문맥전환을 이룬다 &lt;- 이것도 멀티 프로세스보다 성능이 좋은데 그 이유는 문맥전환의 비용이 쓰레드가 더 적기 때문이다.     2번의 추가 예로는 예를들어 한 프로세스에서 파일 입출력 시그널이 발생했다. 원래 같으면 해당 프로세스는 블록되고 다른 프로세스로 제어가 넘어가야한다. 하지만 멀티 쓰레드라면 파일 입출력이 진행 되는 동안 같은 프로세스에서 다른 쓰레드가 다른 작업을 이어 나갈 수 있다.    1.2 예제: 쓰레드 생성       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          void *mythread(void *arg) {         printf(\"%s\\n\", (char *) arg);         return NULL;     }          int main (int argc, char *argv[]) {         pthread_t p1, p2;         int rc;         printf(\"main: begin\\n\");         pthread_create(&amp;p1, NULL, mythread, \"A\");         pthread_create(&amp;p2, NULL, mythread, \"B\");         // 종료할 수 있도록 대기 중인 쓰레드 병합하기         pthread_join(p1,NULL);         pthread_join(p2,NULL);         printf(\"main: end\\n\");         return 0;     }     위의 코드를 실행하면, A B 또는 B A가 출력된다.            생성된 쓰레드는 호출자와는 별개로 실행된다는 것을 확인할 수 있다.       다음에 실행될 쓰레드는 OS 스케줄러(scheduler)에 의해 결정된다.           1.3 훨씬 더 어려운 이유: 데이터의 공유       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          static volatile int counter = 0;          // mythread()     // 반복문을 사용하여 단순히 1씩 더하기     // 10,000,000을 변수 counter에 더하는 방법이 아니다.     // 하지만, 문제가 무엇인지 명확하게 해준다.     void *mythread(void *arg) {         printf(\"%s: begin\\n\", (char *) arg);         int i;         for (i=0; i &lt; 1e7; i++){             counter = counter + 1;         }         printf(\"%s: done\\n\", (char *) arg);         return NULL;     }          // main()     // 두 개의 쓰레드를 실행하고 (pthread_create)     // 대기한다 (pthread_join)     int main (int argc, char *argv[]) {         pthread_t p1, p2;         printf(\"main: begin (counter = %d)\\n\", counter);         pthread_create(&amp;p1, NULL, mythread, \"A\");         pthread_create(&amp;p2, NULL, mythread, \"B\");         // 종료할 수 있도록 대기 중인 쓰레드 병합하기         pthread_join(p1,NULL);         pthread_join(p2,NULL);         printf(\"main: done with both (counter = %d)\\n\", counter);         return 0;     }     위의 코드를 실행하면 출력으로 20000000이 나올 줄 알았지만, 결과는 매번 다르다. ex) 187777789, 15796892            왜 이런 결과가 나오는지 궁금하다면 더 읽어보자!           1.4 문제의 핵심: 제어 없는 스케줄링       mov 0x8049alc, %eax     add $0x1, %eax     mov %eax, 0x8049a1c     mythread 함수의 for문을 역 어셈블리 하면 위와 같은 결과를 가진다.            위의 영역을 두 쓰레드가 동시에 접근하기 때문에 결과가 달라지는 것이다.                 명령어의 실행 순서에 따라 결과가 달라지는 상황을 경쟁 조건(race condition) 혹은 데이터 경쟁(data race)라고 한다.   멀티 쓰레드가 같은 코드를 실행할 때 경쟁 조건이 발생하기 때문에 이러한 코드 부분을 임계 영역(critical section)이라고 부른다.            공유 변수(공유 자원)을 접근하고 하나 이상의 쓰레드에서 동시에 실행되면 안 되는 코드를 임계 영역이라 부른다.           이러한 코드에서 필요한 것은 상호 배제(mutual exclusion)이다.            이 속성은 하나의 쓰레드가 임계  영역 내의 코드를 실행 중일 때는 다른 쓰레드가 실행할 수 없도록 보장해준다.           1.5 원자성에 대한 바람     임계 영역 문제에 대한 해결 방법 중 하나로 강력한 명령어 한 개로 의도한 동작을 수행하여, 인터럽트 발생 가능성을 원천적으로 차단하는 것이다.            락과 같은 기능을 사용한다.           우리가 대신 해야 할 일은 하드웨어 동기화 함수(synchronization primitives) 구현에 필요한 몇 가지 유용한 명령어를 요청하는 것이다.  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_09/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 쓰레드 API 구현",
        "excerpt":"1. 쓰레드 API     쓰레드 API의 주요 부분을 간략하게 사용해보고 결과를 확인해볼 것이다.   생성, 종료, 락 세가지에 대해서 사용해 볼 것이다.   1.1 쓰레드 생성   쓰레드 생성       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          typedef struct {         int a;         int b;     } myarg_t;          void *mythread(void *arg) {         myarg_t *args = (myarg_t *) arg;         printf(\"%d %d\\n\", args-&gt;a, args-&gt;b);         return NULL;     }          int main(int argc, char *argv[]) {         pthread_t p;         myarg_t args = {10, 20};                  int rc = pthread_create(&amp;p, NULL, mythread, &amp;args);     }        위의 코드는 쓰레드를 생성하는 코드이다. 하지만, 실행했을 때 args가 출력되지 않는 것을 볼 수 있다.            이 이유는 쓰레드가 생성했지만, 쓰레드 실행 전에 메인 쓰레드인 main() 문이 종료되었기 때문이다.           1.2 쓰레드 종료   쓰레드 종료 기다리기       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          typedef struct {         int a;         int b;     } myarg_t;          void *mythread(void *arg) {         myarg_t *args = (myarg_t *) arg;         printf(\"%d %d\\n\", args-&gt;a, args-&gt;b);         return NULL;     }          int main(int argc, char *argv[]) {         pthread_t p;         myarg_t args = {10, 20};                  int rc = pthread_create(&amp;p, NULL, mythread, &amp;args);         pthread_join(p, (void**)&amp;args);     }        pthread_join 문을 추가하여 부모 쓰레드인 main에게 자식 쓰레드인 p가 종료할 때 까지 기다리라고 지시했다.            결과는 args인 10과 20이 잘 출력되는 모습을 볼 수 있다.           쓰레드에게 간단한 인자 전달하기       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          typedef struct { int x; int y; } myarg_t;     typedef struct { int x; int y; } myret_t;          void *mythread(void *arg) {         long long int value = (long long int) arg;         printf(\"%lld\\n\", value);         return (void *) (value + 1);     }          int main (int argc, char *argv[]) {         pthread_t p;         long long int rvalue;         pthread_create(&amp;p, NULL, mythread, (void *)100);         pthread_join(p, (void **) &amp;rvalue);         printf(\"returned %lld\\n\", rvalue);         return 0;     }        위의 코드는 쓰레드에게 간단한 인자를 전달하는 코드이다.            결과로 100이 출력되고 101이 잘 리턴 된 것을 볼 수 있다.           쓰레드에게 간단한 인자 전달하기(잘못된 방법)       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          typedef struct { int x; int y; } myarg_t;     typedef struct { int x; int y; } myret_t;          void *mythread(void *arg) {         myarg_t *args = (myarg_t *) arg;         printf(\"%d %d\\n\", args-&gt;x, args-&gt;y);         myret_t oops;         oops.x = 1;         oops.y = 2;         return (void *) &amp;oops;     }          int main (int argc, char *argv[]) {         pthread_t p;         long long int rvalue;         pthread_create(&amp;p, NULL, mythread, (void *)100);         pthread_join(p, (void **) &amp;rvalue);         printf(\"returned %lld\\n\", rvalue);         return 0;     }        위의 코드에서는 리턴되는 값을 스택에 할당했기 때문에 에러가 발생하는 것을 볼 수 있다.            스택에 할당되면 해당 값은 쓰레드가 리턴할 때 자동적으로 해제된다.       해제된 변수를 가리키는 포인터를 반환하는 것은 좋지 않은 결과를 가져온다.           1.3 락   락이 없는 코드의 문제점       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;          static volatile int counter = 0;          // mythread()     // 반복문을 사용하여 단순히 1씩 더하기     // 10,000,000을 변수 counter에 더하는 방법이 아니다.     // 하지만, 문제가 무엇인지 명확하게 해준다.     void *mythread(void *arg) {         printf(\"%s: begin\\n\", (char *) arg);         int i;         for (i=0; i &lt; 1e7; i++){             counter = counter + 1;         }         printf(\"%s: done\\n\", (char *) arg);         return NULL;     }          // main()     // 두 개의 쓰레드를 실행하고 (pthread_create)     // 대기한다 (pthread_join)     int main (int argc, char *argv[]) {         pthread_t p1, p2;         printf(\"main: begin (counter = %d)\\n\", counter);         pthread_create(&amp;p1, NULL, mythread, \"A\");         pthread_create(&amp;p2, NULL, mythread, \"B\");         // 종료할 수 있도록 대기 중인 쓰레드 병합하기         pthread_join(p1,NULL);         pthread_join(p2,NULL);         printf(\"main: done with both (counter = %d)\\n\", counter);         return 0;     }        위의 코드는 락이 없을 때 임계 영역에 두 쓰레드가 동시 접근을 하게 되어 예상한 결과값인 20000000이 나오지 않는 모습을 볼 수 있다.            예상한대로 코드를 실행시키기 위해 락을 추가하여 임계 영역을 보호해준다.           락을 사용한 코드       #include &lt;stdio.h&gt;     #include &lt;pthread.h&gt;     #include &lt;assert.h&gt;          static volatile int counter = 0;     pthread_mutex_t mutex_lock;          // mythread()     // 반복문을 사용하여 단순히 1씩 더하기     // 10,000,000을 변수 counter에 더하는 방법이 아니다.     // 하지만, 문제가 무엇인지 명확하게 해준다.     void *mythread(void *arg) {         printf(\"%s: begin\\n\", (char *) arg);         pthread_mutex_lock(&amp;mutex_lock);         int i;         for (i=0; i &lt; 1e7; i++){             counter = counter + 1;         }         pthread_mutex_unlock(&amp;mutex_lock);         printf(\"%s: done\\n\", (char *) arg);         return NULL;     }          // main()     // 두 개의 쓰레드를 실행하고 (pthread_create)     // 대기한다 (pthread_join)     int main (int argc, char *argv[]) {         pthread_t p1, p2;         printf(\"main: begin (counter = %d)\\n\", counter);         int rc = pthread_mutex_init(&amp;mutex_lock,NULL);         assert(rc == 0);         pthread_create(&amp;p1, NULL, mythread, \"A\");         pthread_create(&amp;p2, NULL, mythread, \"B\");         // 종료할 수 있도록 대기 중인 쓰레드 병합하기         pthread_join(p1,NULL);         pthread_join(p2,NULL);         printf(\"main: done with both (counter = %d)\\n\", counter);         return 0;     }        위의 코드는 락을 추가하여 임계 영역을 보호해주었다.            결과로는 우리가 예상한 20000000이 출력되는 것을 확인할 수 있다.           위의 코드에서 시간 비교를 해보자!  두개의 쓰레드를 사용하고 counter에 접근할 때 락을 이용하여 임계 영역을 보호한다. 이 말의 의미는 A 쓰레드와 B 쓰레드가 차례로 번갈아가면서 counter에 접근한다는 의미가 된다. 그렇다면 이런 경우에서는 굳이 멀티 쓰레드를 사용할 필요가 있을까? 궁금한건 못참는다!! 바로 해보자!!   위의 락을 사용한 코드에서 코드의 실행시간을 계산하는 코드를 추가하고, 쓰레드를 두개 사용하는 경우와 하나를 사용하는 경우로 나누어 실험을 진행하였다. 또한 캐시 때문에 실행시간에 차이가 있을 수 있어서 5번씩 실행한 결과로 비교를 하였다. 추가적으로 연산횟수룰 20억으로 늘려서 진행하였다.           위는 멀티쓰레드, 아래는 단일쓰레드다. 결과를 봤을 땐 단일쓰레드가 아주 미세하게 더 빠르다는 것을 확인할 수 있다.   왜 이런 결과가 나왔을까? count에 접근하는 해당 로직은 사실상 사실상 멀티 쓰레드를 이용해도 두개의 쓰레드가 차례로 번갈아가면서 counter에 접근한다. 단일 쓰레드를 사용했을 때와 마찬가지인 것이다. 하지만 락에 의해서 지연이 조금 늘어나게 되고 이를 통해서 단일쓰레드보다 멀티쓰레드가 성능이 더 저하되는 것이다.   ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_thread_API/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 락",
        "excerpt":"1. 락     여러 개의 명령어들을 원자적으로 실행해보고 싶지만 단일 프로세서의 인터럽트로 인해서(또는 멀티 쓰레드를 여러 프로세서에 병행성하려고 해서) 그렇게 할 수가 없었다.   프로그래머들은 소스 코드의 임계 영역을 락(lock)으로 둘러서 그 임계 영역이 마치 하나의 원자 단위 명령어인 것처럼 실행되도록 한다.   1.1 락: 기본 개념     락은 일종의 변수다.   락을 사용하기 위해서는 락 변수를 먼저 선언해야 한다.   이 락 변수는 락의 상태를 나타낸다.   락은 둘중 하나의 상태를 갖는다.            사용 가능(available) 상태 (unlockedf 또는 free)                    즉 어떤 쓰레드도 락을 소유하고 있지 않다.                       사용 중(acquired) 상태                    즉 임계 영역에서 정확히 하나의 쓰레드가 락을 획득한 상태이다.                                 lock() 루틴 호출을 통해 락 획득을 시도한다.            이렇게 락을 획득한 쓰레드를 소유자(owner)라고 부른다.       락을 소유한 쓰레드가 임계 영역에 존재하는 상태에서는 다른 쓰레드들이 임계 영역으로 진입할 수 없다.           락 소유자가 unlock()을 호출한다면 락은 이제 다시 사용 가능한 상태가 된다.         일반적으로 쓰레드는 프로그래머가 생성하고 운영체제가 제어한다.   락으로 코드를 감싸서 프로그래머는 크 코드 내에서는 하나의 쓰레드만 동작하도록 보장할 수 있다.   1.2 Pthread 락     쓰레드 간에 상호 배제(mutual exclusion) 기능을 제공하기 때문에 POSIX 라이브러리는 락을 mutex라고 부른다.   상호 배제는 한 쓰레드가 임계 영역 내에 있다면 이 쓰레드의 동작이 끝날 때까지 다른 쓰레드가 임계 영역에 들어 올 수 없도록 제한한다고해서 얻은 이름이다.   각 데이터와 자료 구조를 보호하는 데 있어서, 여러 락을 사용한다.   1.3 락의 평가     락 설계시, 락의 정상동작 여부 판단을 위한 평가기준을 정해야 한다.            상호 배제를 제대로 지원하는가이다.       공정성(fairness)                    락을 전혀 얻지 못해 굶주리는(starve) 경우가 발생하는지를 판단해야한다.                       성능(performance)이다.              이제부터 1.4절부터 락을 구현하는 여러가지 방법에 대해 알아볼 것이다. 스핀락부터 스핀을 사용하지 않는 락까지 알아본다.    1.4 인터럽트 제어     초창기 단일 프로세스 시스템에서는 상호 배제 지원을 위해 임계 영역 내에서는 인터럽트를 비활성화하는 방법을 사용했다.       void lock(){         DisableInterrupts();     }     void unlock(){         EnableInterrupts();     }     이 방법은 잔점이 많다.   첫 번째 단점은, 요청을 하는 쓰레드가 인터럽트를 활성/비활성화하는 특권(privileged) 연산을 실행할 수 있도록 허가해야 한다.            이를 다른 목적으로 사용하지 않음을 신뢰할 수 있어야 한다.           두 번째 단점은, 멀티프로세서에서는 적용을 할 수가 없다.   세 번째 단점은, 장시간 동안 인터럽트를 중지시키는 것은 중요한 인터럽트의 시점을 놓칠 수 있다.   마지막은, 이 방법은 비효율적이다.   1.5 오직 load/store 명령어만 사용하기(실패한 시도)     load와 store 명령어만으로 락을 구현한다.            간단한 플래그 변수를 사용하여 쓰레드가 락을 획득하였는지를 나타낸다.               void init(lock_t *mutex){         mutex-&gt;flag = 0; // 0 -&gt; 락 사용가능, 1 -&gt; 락 사용중     }     void lock(lock_t *mutex){         while (mutex-&gt;flag == 1) ; // flag 변수 검사 이후 spin-wait         mutex-&gt;flag = 1; // 이제 설정     }     void unlock(lock_t *mutex){         mutex-&gt;flag = 0;     }     실패원인: 적시에 인터럽트가 발생하면 두 쓰레드 모두 플래그를 1로 설정하는 경우가 생길 수 있어서 임계 영역에 두 쓰레드 다 진입할 수 있게 된다.   성능저하: spin-wait라는 방법을 사용하여 플래그의 값을 무한히 검사하는데, 이는 시간을 낭비한다.   1.6 Test-And-Set을 사용하여 작동하는 스핀 락 구현하기     하드웨어 기법 중 가장 기본은 test-and-set 명령어 또는 원자적 교체(atomic exchange)로 알려진 명령어이다.       int TestAndSet(int *old_ptr, int new){         int old = *old_ptr;         *old_ptr = new;         return old;     }          void lock(lock_t *mutex){         while (TestAndSet(flag, 1) == 1) ; // TestAndSet으로 원자적으로 플래그를 검사     }     락의 값을 검사(test)&lt;/storng&gt;하고 새로운 값으로 설정(set)하는 동작을 원자적 연산으로 만듦으로써 오직 하나의 쓰레드만 락을 획득할 수 있도록 만들었다.   지금 설명한 방법이 스핀 락으로 불리는 이유를 이제 이해할 수 있다.   락을 획득할 때까지, CPU 사이클을 소모하면서 회전한다.   이 방식을 제대로 사용하려면 선점형 스케줄러(preemptive scheduler)를 사용해야 한다.            선점형이 아니면, 단일 CPU에서 스핀 락의 사용은 불가능하다. 왜냐하면 while 문을 회전하며 대기하는 쓰레드가 CPU를 영원히 독점하기 때문이다.           스핀 락 평가     정확성            제대로 동작한다.           공정성            단순한 스핀 락은 공정하지 않으며 쓰레드가 굶주리게 만들 수 있다. (while문을 회전하기 때문에)           성능            단일 CPU의 경우 성능 오버헤드는 상당히 클 수 있다. 쓰레드는 할당받은 기간 동안 CPU 사이클을 낭비하면서 락을 획득하기 위해 대기한다.       멀티 CPU의 경우 다른 프로세서에서 락을 획득하기 위해 while문을 회전하면서 대기하는 것은 그렇게 많은 사이클을 낭비하지 않기 때문에 효율적일 수 있다.           1.7 Compare-And-Swap       int CompareAndSwap(int *ptr, int expected, int new){         int original = *ptr;         if (original == expected)             *ptr = new;         return original     }     Compare-And-Swap 기법은 기본 개념은 ptr이 가리키고 있는 주소의 값이 expected 변수와 일치하는지 검사하는 것이다.   CompareAndSwap 명령어는 TestAndSet 명령어보다 더 강력하다.            대기없는 동기화(wait-free synchronization)와 같은 주제를 다룰 때 이 루틴이 갖느 능력을 알게 될 것이다.           1.8 Load-Linked 그리고 Store-Conditional     load-linked와 store-conditional 명령어를 앞뒤로 사용하여 락이나 기타 병행 연산을 위한 자료 구조를 만들 수 있다.   1.9 Fetch-And-Add     Fetch-And-Add 명령어로 원자적으로 특정 주소의 예전 값을 반환하면서 값을 증가시킨다.       int FetchAndAdd(int *ptr){         int old = *ptr;         *ptr = old + 1;         return old;     }      typedef struct __lock_t{         int ticket;         int turn;     } lock_t;          void lock_init(lock_t *lock){         lock-&gt;ticket = 0;         lock-&gt;turn = 0;     }      void lock(lock_t *lock){         int myturn = FetchAndAdd(&amp;lock-&gt;ticket);         while (lock-&gt;turn != myturn) ;     }      void unlock(lock_t *lock){         FetchAndAdd(&amp;lock-&gt;turn)     }     위의 방법은 티켓락            이전까지의 접근 방법과 이번 해법의 중요한 차이 중 하나는 모든 쓰레드들이 각자의 순서에 따라 진행한다는 것이다.           1.10 요약: 과도한 스핀     두개의 쓰레드를 프로세서가 하나인 시스템에서 실행하면 레이턴시가 증가한다.   N개의 쓰레드가 하나의 락을 획득하기 위해 경쟁하게 되면 상황은 더욱 심각해진다.   N-1개의 쓰레드에 할당된 CPU 시간 동안, 비슷한 이유로 낭비하게된다.   1.11 간단한 접근법: 조건 없는 양보!     위의 방법들로 동작이 검증된 락과 락 획득의 공정성(티켓 락을 사용한 경우) 까지도 해결할 수 있었다.   이전 쓰레드가 인터럽트에 걸리기 전에 락을 이미 획득한 상태라서 그 쓰레드가 락을 해제하기를 기다리며 스핀만 무한히 하는 경우에 어떻게 해야 할것인가?            첫 번째 방법은 락이 해제되기를 기다리며 스핀해야하는 경우 자신에게 할당된 CPU를 다른 쓰레드에게 양보하는 것이다.               void init(){         flag = 0;     }      void lock(){         while(TestAndSet(&amp;flag, 1) == 1)             yield();     }      void unlock(){         flag = 0;     }     위의 방법은 Test-And-Set와 양보를 이용한 락이다.            운영체제에 자신이 할당받은 CPU 시간을 포기하고 다른 쓰레드가 실행될 수 있도록 하는 yield90 기법을 사용한다.       단점은 많은 쓰레드가 있을 때 하나를 제외한 나머지의 쓰레드가 실행과 양보를 반복하는 패턴으로 비용이 많이 든다. 또한 어떤 쓰레드는 무한히 양보만 하고 있는 경우가 있을 수 있다.           1.12 뮤의 사용: 스핀 대시 잠자기     이전 방법들의 근본 문제는 너무 많은 부분을 운에 맡긴다는 것이다.   다수의 쓰레드가 락을 대기하고 있을 경우, 다음으로 락을 획득할 쓰레드를 명시적으로 선택할 수 있어야 한다. 이를 위해서는 운영체제의 적절한 지원과 큐를 이요한 대기 쓰레드들의 관리가 필요하다.            park(), unpark() &lt;- 쓰레드를 잠재우고 깨우는 함수이다.           장점            앞서 배운 Test-And-Set 개념을 락 대가지 전용 큐와 함께 사용하여 좀 더 효율적인 락을 만들 수 있다.       큐를 사용하여 다음으로 락을 획득할 대상을 제어하여 기아 현상을 피할 수 있도록 할 수 있다.           1.13 2단계 락     첫 번째 단계에서는 회전하며 대기한다. 락이 빠른 시간 내에 해제될 것을 가정한다.   만약 첫 단계에서 락을 획득하지 못했다면 두 번째 단계로 진입한다.   두 번째 단계에서 호출자는 차단된다.   락 해제시 블럭된 쓰레드중 하나를 잠에서 깨운다.  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_10/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 컨디션 변수",
        "excerpt":"1. 컨디션 변수     “락” 이외에도 병행 프로그램을 제작할 수 있는 다른 기법들이 존재한다.   쓰레드가 실행을 계속하기 전에, 특정 조건의 만족여부를 검사해야 하는 경우가 많이 있다.       volatile int done = 0;        void *child(void *arg){         printf(\"child\\n\");         done = 1;         return NULL;     }      void main(int argc, char *argv[]){         printf(\"parent: begin\\n\");         pthread_t c;         pthread_Create(&amp;c, NULL, child, NULL);         while(done==0); // spin-wait         printf(\"parent: end\\n\");         return 0;     }     위의 코드는 공유 변수를 사용한다.            while 문을 돌며 공유 변수가 변경될 때까지 기다린다.       이 방법은 제대로 동작하지만 부모 쓰레드가 회전을 하면서 CPU 시간을 낭비하기 때문에 비효율적이다.           1.1 컨디션 변수의 개념과 관련 루틴     쓰레드 실행시, 특정 조건이 만족될 때까지의 대기를 위해 컨디션 변수(conditional variable)라고 불리는 개념을 사용할 수 있다.   컨디션 변수는 일종의 큐 자료 구조다.   컨디션 변수는 쓰레드 실행에서 어떤 상태(또는 어떤 조건)가 원하는 것과 다를 때 조건이 만족되기를 대기하는 큐이다.       int done = 0;     pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;     pthread_cond_t c = PTHREAD_COND_INITIALIZER;          void thr_exit() {         pthread_mutex_lock(&amp;m);         done = 1;         pthread_cond_signal(&amp;c);         pthread_mutex_unlock(&amp;m);     }          void *child(void *arg){         printf(\"child\\n\");         thr_exit();         return NULL;     }          void thr_join(){         pthread_mutex_lock(&amp;m);         while (done ==0)             pthread_cond_wait(&amp;c, &amp;m);         pthread_mutex_unlock(&amp;m);     }          int main(int argc, char *argv[]){         printf(\"parent: begin\\n\");         pthread_t p;         pthread_create(&amp;p, NULL, child, NULL);         thr_join();         printf(\"parent: end\\n\");         return 0;     }     wait()는 mutex를 인자로 받으며 wait()가 호출될 때 mutex는 잠겨있다고 가정한다.   wait()는 mutex를 해제하고 호출한 쓰레드를 재운다.   다른 쓰레드가 시그널을 보내어 대기중인 쓰레드가 슬립(sleep) 상태에서 깨어나면, wait()에서 리턴하기 전에 반드시 락을 재획득해야 한다.            “슬립에서 깨어난 프로세스는 리턴하기전에 락을 재획득해야한다.” &lt;- 중요한 문장이다.            pthread_cond_wait(&amp;c, &amp;m) &lt;- 함수의 호출을 통하여, 부모쓰레드는 자신의 상태를 대기로 변경함과 동시에 획득했던 락을 반납한다.   wait()에서 리턴 시, 부모 쓰레드는 락을 보유한 상태가 된다.   잠자고, 깨우고, 락을 설정하는 것이 done 이라는 상태 변수를 중심으로 구현되어 있다.   1.2 생산자/소비자(유한 버퍼) 문제     Dijkstra가 처음 제시한 생산자/소비자(producer/consumer) 문제를 살펴볼 것이다.            락이나 컨디션 변수를 대신하여 사용할 수 있는 일반화된 세마포어를 발명하게 된 이유가 이 생산자/소비자 문제 때문이다.                    생산자/소비자란, 다수의 생산자 쓰레드와 소비자 쓰레드가 있다고 하자. 생산자는 데이터를 만들어 버퍼에 넣고, 소비자는 버퍼에서 데이터를 꺼내어 사용한다.                            유한 버퍼는 공유 자원이다. 경쟁 조건의 발생을 방지하기 위해 동기화가 필요하다.       int buffer;     int count = 0;        void put(int value) {         assert(count == 0);         count = 1;         buffer = value;     }          void get(){         assert(count == 1);         count = 0;         return buffer;     }  불완전한 해답     put()과 get() 루틴에는 임계 영역이 존재한다.            put()은 버퍼에 내용을 기록하고, get()은 버퍼에 있는 내용을 읽는다.           임계 영역을 락으로 보호하는 것만으로는 제대로 동작하지 않는다. 추가적인 장치가 필요하다. 추가적인 장치가 컨디션 변수이다.   if문을 사용해서 어느정도 문제를 해결할 수 있지만, 여전히 문제가 존재한다.            쓰레드가 대기 상태에서 깨어나는 시점과 이 쓰레드가 실제로 실행되는 시점사이에 시차가 존재한다.                    이 기간동안 버퍼 상태가 변경될 수 있다.                           위의 문제를 해결하기 위해 깨어난 쓰레드가 실제 실행되는 시점에는 시그널을 받았떤 시점의 상태가 그대로 유지되어있는지를 다시 체크해야 한다.            이런 식의 시그널을 정의하는 것을 Mesa semantic이라 한다.           개선된, 하지만 아직도 불완전한: if 문 대신 while 문     간단하게 해결하기 위해서는 if 문을 while 문으로 바꾸면 된다.            if문은 처음만 조건을 계산한 이후 if문을 탈출하지만, while 문은 조건을 계속 계산해서 조건에 부합하지 않을 때 while문을 탈출한다.           while문을 사용해서 어느정도 문제를 해결할 수 있지만, 여전히 문제가 존재한다.            여러 쓰레드가 존재할 때 깨워야할 쓰레드가 아닌 다른 쓰레드를 깨우게 되면 모두 대기 상태로 빠질 수도 있다.       시그널을 받는 대상을 명시하는 것이 실질적으로 가능하지 않다. 우리가 원하는 것은 소비자는 생산자만을, 생산자는 소비자만을 깨우는 것이다.           단일 버퍼 생산자/소비자 해법      두 개의 컨디션 변수를 사용하면 된다.   생산자 쓰레드가 empty 조건 변수에서 대기하고 fill에 대해서 시그널을 발생한다.   정반대로 소비자 쓰레드는 fill 에 대해서 대기하고 empty에 대해서 시그널을 발생시킨다.       // 올바른 put()과 get() 루틴     int MAX;     int buffer[10];     int fill = 0;     int use = 0;     int count = 0;          void put(int value) {         buffer[fill] = value;         fill = (fill + 1) % MAX;         count++;     }              int get(){         int tmp = buffer[use];         use = (use + 1) % MAX;         count--;         return tmp;     }          // 올바른 생산자/소비자 동기화     pthread_cond_t empty_c, fill_c;     pthread_mutex_t mutex;     int loops = 10;          void *producer(void *arg){         int i;         for (i=0; i&lt; loops; i++){             pthread_mutex_lock(&amp;mutex);             while(count == MAX)                 pthread_cond_wait(&amp;empty_c, &amp;mutex);             put(i);             pthread_cond_signal(&amp;fill_c);             pthread_mutex_unlock(&amp;mutex);         }         return 0;     }          void *consumer(void *arg){         int i;         for(i=0; i&lt;loops; i++){             pthread_mutex_lock(&amp;mutex);             while(count == 0)                 pthread_cond_wait(&amp;fill_c, &amp;mutex);             int tmp = get();             pthread_cond_signal(&amp;empty_c);             pthread_mutex_unlock(&amp;mutex);             printf(\"%d\\n\", tmp);         }         return 0;     } ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_11/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 세마포어",
        "excerpt":"1. 세마포어(semaphore)     세마포어는 락과 컨디션 변수로 모두 사용할 수 있다.   세마포어를 어떻게 사용하는가?            락과 컨디션 변수 대신에 세마포어를 사용하는 방법은 무엇인가?       세마포어의 정의는 무엇인가?       이진 세마포어는 무엇인가?       락과 컨디션 변수를 사용하여 세마포어를 만드는 것이 가능한가?           1.1 세마포어: 정의     세마포어는 정수 값을 갖는 객체로서 두 개의 루틴으로 조작할 수 있다.            POSIX 표준에서 이 두 개의 루틴은 sem_wait()와 sem_post()이다.       세마포어는 초기값에 의해 동작이 결정되기 때문에, 사용하기 전 “제일 먼저” 값을 초기화해야 한다.               #include &lt;semaphore.h&gt;     sem_t s;     sem_init(&amp;s, 0, 1);     3번째 인자로 1을 전달하여 세마포어의 값을 1로 초기화한다.   2번째 인자는 0인데, 같은 프로세스 내의 쓰레드 간에 세마포어를 공유한다는 것을 의미한다.       int sem_wait(sem_t *s){         decrement the value of semaphore s by one;         wait if value of semaphore s is negative;     }     int sem_post(sem_t *s){         increment the value of semaphore s by one;         if there are one or more threads waiting, wake one;     }     세마포어: sem_wait()과 sem_post()의 정의이다.   sem_wait()            함수는 즉시 리턴하거나(세마포어의 값이 1 이상이면) 아니면 해당 세마포어 값이 1 이상이 될 때 까지 호출자를 대기시킨다.       다수의 쓰레드들이 sem_wait()을 호출할 수 있기 때문에, 대기큐에는 다수의 쓰레드가 존재할 수 있다.(대기하는 법에는 회전과 재우기의 두 가지가 있다.)           sem_post()            함수는 대기하지 않는다.       세마포어 값을 증가시키고 대기 중인 쓰레드 중 하나를 깨운다.           세마포어가 음수라면 그 값은 현재 대기 중인 쓰레드의 개수와 같다.   이 두개의 함수는 원자적으로 실행된다고 가정한다.   1.2 이진 세마포어(락)       sem_t m;     sem_init(&amp;m, 0, 1);     sem_wait(&amp;m);     // 임계 영역 부분은 이곳에 배치     sem_post(&amp;m);     위의 코드는 이진 세마포어이다.        위의 그림은 이진 세마포어를 사용하는 두 개의 쓰레드의 흐름이다.   1.3 순서 보장을 위한 세마포어     자식이 끝나기를 기다리는 부모 쓰레드의 대기를 위해서 세마포어를 어떻게 사용할까       sem_t s;          void *child(void *arg){         printf(\"child\\n\");         sem_post(&amp;s);         return NULL;     }          int main(int argc, char *argv[]){         sem_init(&amp;s, 0, 0);         printf(\"parent: begin\\n\");         pthread_t c;         pthread_create(c, NULL, child, NULL);         sem_wait(&amp;s);         printf(\"parent: end\\n\");         return 0;     }     이경우에는 세마포어의 초기값을 0으로 해야한다. 부모 쓰레드가 자식 쓰레드를 생성하고 자식 쓰레드가 아직 실행하지 않을 경우에도 부모 쓰레드는 대기해야한다.  그렇기 때문에 0으로 초기화하면 부모 쓰레드는 wait을 만나자마자 -1로 인해 대기된다. 이후 자식이 실행되면 세마포어의 값을 0으로 올려주고 부모가 실행할 수 있는 조건이 만족된다.      1.4 생산지/소비자(유판 버퍼) 문제     세마포어로 생산자/소비자를 구현하기 위해선 세가지 기법이 필요하다.            full, empty 조건 추가(두개의 세마포어 값을 사용한다.)       상호 배제 추가하기       교착 상태 방지           full, empty 조건 추가     생산자는 소비자의 세마포어에만 영향을 주어야하고, 반대로 소비자는 생산자의 세마포어에만 영향을 주어야한다.            그렇기 때문에 생산자는 empty를 wait하고 full을 post한다.       소비자는 full을 wait하고 empty를 post한다.       생산자는 empty 락을 획득해야지 값들을 버퍼에 추가할 수 있으며, 버퍼가 다차면 소비자에게 락을 전달해 버퍼에 값을 소비하라고 요청해야한다.       소비자는 full 락을 획득해야지 버퍼에 있는 값들을 소비할 수 있으며, 버퍼가 비게 되면 생산자에게 락을 전달해 버퍼에 값을 넣어달라고 요청해야한다.           상호 배제의 추가     두 개의 생산자 pa, pb가 동시에 put()을 호출하게 되면 pa가 버퍼에 값을 넣고 fill 카운터 변수를 1로 증가시키기 전에 인터럽트가 발생하고 pb가 이어서 같은 버퍼 공간에 값을 덮어 쓰게 된다.   버퍼를 채우고 버퍼에 대한 인덱스를 증가하는 해당 동작은 임계 영역이 된다.   아래의 코드와 같이 락을 put()과 get() 앞 뒤로 추가해준다.       void *producer(void *arg){         int i;         for(i=0; i&lt;loops; i++){             sem_wait(&amp;mutex);             sem_wait(&amp;empty);             put(i);             sem_post(&amp;full);             sem_post(&amp;mutex);         }     }          void *consumer(void *arg){         int i;         for(i=0; i&lt;loops; i++){             sem_wait(&amp;mutex);             sem_wait(&amp;full);             int tmp = get();             sem_post(&amp;empty);             sem_post(&amp;mutex);             printf(\"%d\\n\", tmp);         }     }     하지만 위의 코드는 교착상태로 인해 코드가 동작하지 않는다.   교착 상태의 방지     생산자와 소비자 쓰레드 중 소비자가 먼저 실행되었다. mutex를 획득 후 full 변수에 대하여 sem_wait()을 호출한다. 버퍼가 비어있다. 소비자는 대기모드로 전환된다. CPU를 양보하게 되는데 여기서 중요한 것은 소비자가 아직 mutex 락을 보유하고 있기 때문에 생산자는 실행할 수 없다.   이를 해결하기 위해서 mutex의 순서를 아래와 같이 변경해준다.       void *producer(void *arg){         int i;         for(i=0; i&lt;loops; i++){             sem_wait(&amp;empty);             sem_wait(&amp;mutex);             put(i);             sem_post(&amp;mutex);             sem_post(&amp;full);         }     }          void *consumer(void *arg){         int i;         for(i=0; i&lt;loops; i++){             sem_wait(&amp;full);             sem_wait(&amp;mutex);             int tmp = get();             sem_post(&amp;mutex);             sem_post(&amp;empty);             printf(\"%d\\n\", tmp);         }     }  1.5 Reader-Writer 락     다양한 자료구조를 접근할 때, 각 자료 구조의 특성과 접근 방식을 적절히 고려한 여러 종류의 락 기법이 필요하다.   다수의 쓰레드가 연결 리스트에 노드를 삽입하고 검색을 하는 상황을 가정해보자.            삽입 연산이 없다는 보장만 된다면, 다수의 검색 작업을 동시에 수행할 수 있다.(삽입은 리스트를 변경하기 때문에 임계영역이 된다.)       이와 같은 경우를 위해 만들어진 락이 reader-writer 락이다.           자료구조를 “갱신” 하려면 배타적 접근권한을 갖는 락을 사용한다.   읽기 락은 동시에 여러 쓰레드가 락을 보유할 수 있다.   읽기 락을 획득시 ㅈritelock 세마포어에 대해 sem_wait()을 호출하여 쓰기 락을 함께 획득한다.            획득한 쓰기 락은 읽기 락을 해제할 때 sem_post()로 다시 해제한다.           쓰기 락을 획득하려는 쓰기 쓰레드들은 모든 읽기 쓰레드가 끝날 때 까지 대기하여야 한다.   1.6 식사하는 철학자       철학자 p0~p4 가 양쪽에 있는 포크 f0~f4를 양 손으로 들고 내려두는 행동을 모든 철학자가 할 수 있도록 코드를 작성해야한다.            이 포크를 잡기 위한 경쟁과 그에 따른 동기화 문제가 병행 프로그래밍에서 다루려는 식사하는 철학자 문제이다.           불완전한 해답       void get_forks(int p){         sem_wait(fork-&gt;left(p))         sem_wait(fork-&gt;right(p))     }     void put_forks(int p){         sem_post(fork-&gt;left(p))         sem_post(fork-&gt;right(p))     }     위와 같은 코드로 순서대로 왼쪽 포크와 오른쪽 포크를 한 사람씩 든다고 가정해보자.   간단히 해결될 것 같아도, 1번 철학자가 f1을 든 상황에서 인터럽트가 발생하고, 2번 철학자가 f2를 들게 된다면, 1번 철학자는 f2를 들지 못해 락을 반납하지 못하고 교착 상태에 빠지게 된다.   해답: 의존성 제거     이 문제를 해결하기 위한 가장 간단한 방법은 최소한 하나의 철학자가 다른 순서로 포크를 집도록 하면 된다.       void get_forks(int p){         if(p==4){             sem_wait(fork-&gt;right(p))             sem_wait(fork-&gt;left(p))         }         sem_wait(fork-&gt;left(p))         sem_wait(fork-&gt;right(p))     }     한번 그림을 그려보며 어떻게 동작하는지 확인해보자!   1.7 쓰레드 제어     문제: “과도하게 많은” 쓰레드가 동시에 수행되면 시스템의 효율이 매우 나빠진다.   정답: “과도하게 많은” 에 임계값을 정하고, 세마포어를 사용하여 문제가 되는 코드를 동시에 실행하는 쓰레드 개수를 제한한다.   우리는 이 접근법을 제어(throttling)라고 부르며 수락 제어의 한 형태로 간주한다.   1.8 세마포어 구현     저수준 동기화 기법인 락과 컨디션 변수를 사용하여 우리만의 세마포어를 만들어 본다.       void struct __Zem_t{         int value;         ptrhead_cond_t cond;         pthread_mutex_t lock;     } Zem_t;          // 오직 하나의 쓰레드만 이 문장을 호출할 수 있음     void Zem_init(Zem_t *s, int value){         s-&gt;value = value;         cond_init(&amp;s-&gt;cond);         Mutexinit(&amp;s-&gt;lock);     }        void Zem_wait(Zem_t *s){         Mutex_lock(&amp;s-&gt;lock);         while (s-&gt;value &lt;= 0)             Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);         s-&gt;value--;         Mutex_unlock(&amp;s-&gt;lock);     }          void Zem_post(Zem_t *s){         Mutex_lock(&amp;s-&gt;lock);         s-&gt;value++;         Cond_signal(&amp;s-&gt;cond);         Mutex_unlock(&amp;s-&gt;lock);     }  ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_12/",
        "teaser": null
      },{
        "title": "[OSTEP] 병행성 - 병행성 관련 버그",
        "excerpt":" ","categories": ["OSTEP"],
        "tags": ["OSTEP","CS"],
        "url": "/ostep/ostep_13/",
        "teaser": null
      }]
