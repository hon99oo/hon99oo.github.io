var store = [{
        "title": "블로그를 다시 시작해 보자",
        "excerpt":"4학년 1학기 졸업작품을 3월부터 6월까지 열심히 달렸다. 졸업작품을 끝마치고 나니 현업의 욕심이 생겨 열심히 인턴 지원을 진행하였다. 그렇게 자소서를 쓰고 대학생활을 하며 잰힝했던 포트폴리오를 정리하고 7월 11일에 ‘스페이스워크’라는 회사에 인턴 포지션으로 입사하게 되었다. 인턴 포지션에 입사한 이후로 코딩에 대한 열정이 팍 식은거 같다. 회사일은 내가 졸업작품을 했을 때 처럼 큰 열정을 쏟아 붓지 못한 채 시키는 일만 하는 수동적 인간이 되었다. 그렇게 거의 5개월을 따로 공부도 하지 않고 열정이 없는 채로 살아왔던 것 같다. 당장 내 앞에 펼쳐져 있는 숙제들도 해결하지 않고 뒤로 미뤄두고 기상 - 회사 일 쪼금 - 게임 - 취침의 쳇바퀴의 반복적 인생을 살아왔다.   인턴 포지션 종료일은 1월 11일이다. 이후 나는 졸업요건을 하나 충족하지 않아 초과학기를 해야하며 다음 취업을 준비해야 한다. 인턴 포지션 종료까지는 약 2개월 정도 남았다. 지금은 욕심이지만, 인턴 종료 이후 곧바로 다른 회사의 인턴 포지션으로 들어가거나 현재 있는 회사에 잔류 하는 것이 목표이다. 현재 다니고 있는 회사에서 열심히 하지 못했던 이유는 나에게 목표의식이 조금 사라졌다는 변명을 들 수 있을 것 같다. 다시금 목표가 생긴 현재 이를 정확히 인지하고 행동으로 실천할 때가 온 것 같다.   인턴 생활을 하기 전까지는 모두 뇌피셜로 코딩을 해오고 공부를 해왔다. 그 때는 BE와 FE의 차이점도 몰랐고 DE가 요즘 핫하다는 이야기만 듣고 무슨 일을 하는지도 모른채로 DE포지션으로 인턴을 지원했었다. 하지만, 현업 생활을 약 4개월정도 하고 난 뒤 내 주변에 현업 생활을 하고 있는 지인들의 이야기가 궁금해졌고 많은 사람들의 이야기를 듣고 싶어 일명 DevTalk을 요청하였다. 그리고 이제는 정확하지는 않지만, 개발자라는 직군이 어떻게 돌아가는지 그리고 내가 어떤 일을 할 수 있고 어떤 일을 하고 싶은지 조금은 알 수 있게 되었다.   우선 나의 문제점을 발견했다. 간단하고 명확하게 말하자면, 나는 현재 ‘코싸개’이다. 생각하지 않고 주어진 문제를 해결하기 위해 수단과 방법을 가리지 않고 그저 코드만을 작성했던 굉장히 질 나쁜 개발자였던 것이다. 생각해보면 내가 이 프로그래밍에 관해 진지하게 공부했던 적이 없다. 학문을 가르치는 대학에서 소프트웨어학과를 진학하고 전공 과목은 집중하지 않고 프로젝트를 어떻게든 이쁘게 만들기 위해서 프로젝트를 위한 공부만 했던 것 같다. 현재 사용하고 있는 기술들은 모두 근본이 되는 알고리즘과 컴퓨터구조론에서부터 비롯된 기술임을 몰랐던 것이다. 나에게 가장 부족한 점은 ‘근본 지식’을 모르는 것이다. 많이 늦었다고 말할 수 있지만, 오늘부터 ‘근본 지식’에 관련하여 몇가지를 체계적으로 공부할 생각이다.   첫번째, 알고리즘이다. 알고리즘을 제대로 배워본 적이 없다. 사실 우리학교의 전공 필수 과목이지만, 너무 어렵고 공부하기도 싫어서 대충 했던 기억이 있다. 그리고 모르는 지식이 있으면 그 때 그 때 구글링으로 일시적으로 지식의 빈자리를 매꿀 뿐이었다. 근본이 되는 알고리즘 서적으로 공부할 계획이다. 두번째, 컴퓨터구조론이다. 컴퓨터구조론 또한 우리학교의 전공 필수 과목이지만, 족보를 바탕으로 공부해서 학점은 좋게 받았지만 남아있는 지식은 없다. 알고리즘과 컴퓨터구조론을 우선 공부하여 인턴 포지션 종료 전 까지 어느정도의 지식을 확보하고 싶은 계획이다.   이후 나는 BE나 DE 직군으로 나아갈 예정이다. 현재 내가 사용하는 주 언어는 python이지만, java에도 관심이 조금씩 가고 있다. 알고리즘과 컴퓨터구조론 공부를 마치고 나면 DE의 근본책과 BE의 근본책 두가지를 구매해서 공부할 예정이다. 이 열정이 언제 식을지 모르겠지만, 현재 내 발등에는 불이 그것도 존나게 뜨거운 불이 떨어졌다.   화이팅이다 홍구야  ","categories": ["doodle"],
        "tags": ["doodle"],
        "url": "/doodle/doodle_01/",
        "teaser": null
      },{
        "title": "test post 입니다.",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   Jekyll requires blog post files to be named according to the following format:   YEAR-MONTH-DAY-title.MARKUP   Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": ["test post"],
        "tags": ["test","theme"],
        "url": "/test%20post/test/",
        "teaser": null
      },{
        "title": "2022년 초보 개발자의 취업 계획",
        "excerpt":"   곧 2022년이다. 2021년 한해를 마무리해보자.     2021년 : 마무리   3月-6月 졸업작품    7月-12月 인턴생활    졸업작품 하얗게 불태우고 바로 인턴 생활을 했다. 현업이 되게 궁금했는데 이 부분에 대해서는 굉장히 많은 도움이 된 것 같다. 그리고 Data Engineering 직무도 굉장히 관심 있었는데 직접 경험할 수 있어서 좋았다. 나는 조금 더 다양한 경험을 하고 싶어서  Back End 직무를 공략할 생각이다. 언어는 아무래도 java가 강력하다고 생각해서 java 공부를 시작할 것 같다.    2022년 : 11월 전까지 아래 서류들을 준비해보자      졸업요건 맞추기    토익 또는 오픽    정보처리기사    CS    Algorithm    Java 스킬    ~2022년 포트폴리오 정리    코딩 캠프(네이버부캠,우테코 등등…) 준비      Java Backend Roadmap   ","categories": ["doodle"],
        "tags": ["doodle"],
        "url": "/doodle/doodle_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Google's Neural Machine Translation System : Bridging the Gap between Human and Machine Translation 논문 리뷰",
        "excerpt":"Introduction     Neural Machine Translation            End-to-End 학습 접근 방식의 자동 번역       기존 구문 기반 번역의 약점을 극복           Neural Machine Translation 단점            데이터 양과 매개변수가 많아 훈련과 추론 속도가 느림       Rare Word 처리의 문제점       가끔씩 모든 단어에 대해 번역하지 못함           Google’s Neural Machine Translation            LSTM으로 이루어져 있는 8개의 ENCODER와 8개의 DECODER       병렬 처리 개선을 위해 DECODER의 최하층과 ENCODER의 최상층을 ATTENTION으로 연결       번역속도를 높이기 위해 low-precision arithmetic, Rare Word 처리를 위해 WordPiece 사용            Model Architecture       Model Parallelism            모델 병렬화와 데이터 병렬화 모두 사용함       Downpour SGD를 사용하여 데이터 병렬화                    여러개의 모델로 나누어, 여러개의 머신에서 동시에 학습함, 각각 학습된 gradient를 평균내어 모델에 적용           실험에서는 10개의 머신에서 128개의 문장을 Mini-batch로 사용                       모델 병렬화                    머신당 8개의 GPU 사용 ( 각 층 마다 서로 다른 GPU에 할당 )           i번째 레이어의 작업이 종료전에 i+1번째 작업 진행 가능                            Segmentation Approches     Wordpiece Model            띄어쓰기는 _, 단어는 내부단어 통계에 기반하여 띄어쓰기로 분리       띄어쓰기를 _로 치환한 이유는 차후에 문장 복원을 위해       실험에서는 wordpiece를 8K~32K에서 좋은 결과 얻음       wordpiece로도 얻을 수 없었던 rare word는 copy model을 사용                 Mixed Word/Character Model            OOV 처리를 로 하지 않고 문자 단위로 나누어 처리함       시작 문자 , 중간 문자 , 끝 문자        전체 작업 과정에서 유지한 채로 학습한 후 태그를 삭제함             Training Criteria     Maximum-liklihood 학습 방식은 로그 확률 값을 최대화하는 목적 함수 ( BLUE 평가 지표와 부합되지 않음 )        Reward개념의 목적함수 사용        r은 문장 단위 점수 ( 출력 문서와 실제 문서의 차이 계산 )   GLEU 점수 지표 사용 ( 출력 문장과 정답 문장을 1~4 토큰으로 만든 뒤 recall과 precision을 구한 뒤 더 작은 값을 GLEU로 정함 )   ML방식과 RL 방식 혼합하여 사용 이 때, a는 0.017        Quantizable Model And Quantized Inference     NMT은 연산량이 많아 Inference 시간이 오래 걸리는 것이 큰 단점   해결하기 위하여 Quantized inference 수행!        Decoder     Beam Search를 사용하여 점수 함수를 최대화 하는 시퀀스 Y를 찾음   Length normalization            길이가 더 긴 문장의 확률이 떨어지기 때문에 이를 보정하기 위하여 사용       하이퍼 파라미터 a 사용 ( 실험에서는 0.6 ~ 0.7 사용 )           Coverage Panelty            source word xi로 부터 attention weight의 합을 구함       로그를 취했기 때문에 attention weight이 편중되지 않은 source word의 값이 매우 작음 음수를 가지게 됨       실험에서는 a는 0.6 b는 0.2 사용                Experiments And Results     Data set            WMT En -&gt; Fr 36M       WMT En -&gt; De 5M           Evaluation Metrics            BLUE       implicit human evaluation ( BLUE는 번역 점수 잘 못메김 )           Training Procederue            TensorFlow 사용하여 구현       12개의 머신으로 병렬화       [-0.04, 0.04] 사이로 매개변수를 균일하게 초기화       Adam Optimizer와 SGD 혼합하여 사용 ( 첫 60k는 Adam으로 그 후로는 SGD 사용)           Learning Rate는 0.5 ( 1.2M 이후부터 200k 단위마다 반씩 줄여가며 학습 )          Conclusion     Wordpiece 모델은 번역 품질과 inference 속도를 효과적으로 높힘   모델과 데이터의 병렬화는 sequence-to-sequence NMT 모델을 일주일 안으로 효율적으로 훈련시킬 수 있음   Model quantization은 inference 속도를 가속화할 수 있어 대형 모델에 사용하기 용이함   Length-normalization, coverage penalty 등과 같은 추가 세부 사항이 NMT 시스템을 잘 작동시키게 도와줌  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_01/",
        "teaser": null
      },{
        "title": "Docker는 대충 이런 느낌인가?",
        "excerpt":"Docker   내가 느낀 전체적인 도커의 메커니즘 : 어떠어떠한 것을 빌드해서 이미지를 만들고  -&gt; 이미지를 도커로 띄운 뒤 -&gt; 이미지를 받아서 로컬에서 개발작업을 진행   !!많은 시행착오를 거쳐 도커의 메커니즘에 대해 이해가 조금 되었다.     Dockerfile을 만든다.   해당 디렉토리 위치에서 docker build를 한다.   docker build을 하면 이미지가 생성된다.   이미지가 생성됐으면, 해당 이미지로 docker run을 한다.   docker run을 하면 컨테이너가 만들어지고 해당 이미지를 컨테이너 안으로 넣는다?띄운다?   그럼 환경셋팅이 된다…?   틀린 부분도 있겠지만 아주 조오금 조오오오오금 메커니즘이 이해가 됐다.   앗 참고로 음… 저런 run이니 이미지 파일들이니 어떤 컨테이너가 실행중인지를 GUI로 확인할 수 있는 프로그램이 Docker Desktop 같다 ㅎㅎ..   추가적으로 환경세팅을 완료한 것 같다. 음… 위의 6번까지 진행한 후에          컨테이너를 만들면 어떠한 가상환경이 만들어지는 것 같다.            그럼 그 컨테이너에가 파이썬 환경으로 이루어져있고 추가로 다양한 패키지들이 들어있다.            그럼 그 환경을 내가 사용하고 있는 Pycharm과 연동을 하는 거다.       어떻게 하냐면 파이참 프로젝트의 인터프리터를 해당 컨테이너에 있는 파이썬path로 설정해주는거다. *https://i-am-eden.tistory.com/13        그리고 코딩하면 된다 ㅎㅎ ***            도커엔진 - 도커를 실행하면 Dockered라는 데몬 프로그램이 서버로 실행.   **여기서 잠깐! 데몬 프로그램이 뭘까?   https://blogger.pe.kr/770  (포그라운드, 백그라운드, 데몬 프로세스)    https://haruhiism.tistory.com/9            도커실행 : 도커 이미지를 받아서 컨테이너로 실행   ** -it 라는 명령어는 -i와 -t 옵션이 합쳐진 옵션, -i는 호스트와 컨테이너 상호 입출력을 맞추고, -t는 TTY를 활성화해서 컨테이너에 터미널로 입력이 가능하게 한다.   ** TTY가 뭐지?!   https://cosmosproject2015.tistory.com/143 (TTY, PTS, PTY)            도커 volume : 데이터를 컨테이너에 저장하지 않고 호스트에 저장하는 방식   https://www.daleseo.com/docker-volumes-bind-mounts/       도커빌드 : Dockerfile로 사용자 정의 이미지를 만듬   *공부하기 : 도커 아키텍쳐, 컨테이너-OS 간의 통신 구조   ** Docker의 개념 및 핵심 설명 :  https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90    Docker 예제 실습중 갱장히 이상한 오류가 발생했다.   failed to solve with frontend dockerfile.v0: failed to read dockerfile: open /var/lib/docker/tmp/buildkit-mount174403522/Dockerfile: no such file or directory   구글링을 계속 해봤지만 dockerfile -&gt; Dockerfile 로 이름을 바꾸라는 답변밖에 없었다.   하지만, 오류가 고쳐지지 않았고 터미널을 Open한 디렉토리 경로를 상위 폴더 위치로 open을 해서 났던 오류였다 ㅎㅎ  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/docker_01/",
        "teaser": null
      },{
        "title": "TDD와 each map",
        "excerpt":"TDD   TDD(Test Driven Development)란 본격적인 개발에 들어가기 전에 테스트 계획 및 코드를 작성하는 것을 의미한다. 테스트가 개발을 이끌어 나가는 것이다. 예를들어, 개발 중 에러가 발생했을 때 소규모 개발에서는 큰 문제가 되지는 않지만, 대규모의 개발 상황에서는 수 많은 모듈과 함수간 종속성들이 굉장히 많은 시간을 괴롭히게 된다. 이러한 문제점을 해결하기 위해서 테스트 주도 개발이 등장했다.   나는 pytest를 사용할 것이다. https://binux.tistory.com/47   일단, monkeypatch.setattr 살펴보자.  이것은 어떤것을 하냐면, mocking이다. Mocking은 실제 값이 아닌 가짜 값을 만들어내는 것이다.   음 예를들면 Upload 클래스가 있다.   Class Upload    |_ Def Extract   |_ Def Transform   |_ Def Load   이렇게 되어있을 때 나는 Transform 부분만 테스트하고 싶다. 하지만 함수의 종속성으로 인하여 Transform에서 사용되는 data는 Extract로 부터 참조되며 Extract에서 추출되는 data는  특정 라이브러리의 기능을 참조한다. 나는 Transform 부분만 테스트하고 싶지만 이런 경우에 Extract부터 특정 라이브러리으 기능까지 테스트해야되는 상황에 처한 것이다. 이런 경우에 이제 Mocking이라는 기술을 쓴다. pytest에서도 제공하는 function이 있지만, 단순한 예를 하나 들자면 정답과 인풋값을 csv파일이나 등등으로 미리 만들어서 로컬에서 참조하도록 코드를 작성하면 된다.   하지만 이때, 테스트 코드에서 원코드를 실행할 때 원코드의 Extract가 실행 되기 때문에 monkeypatch.setattr 같은 기능으로 해당 function을 사용하지 않고 넘겨주는 기능을 넣어줘야한다.    each map  each map을 알아야한다.  음 지금 내가 하는 것은 DB -&gt; transform -&gt; DB 적재이다. transform에서 전처리 및 parsing을 해주는데, transform에서 이뤄지는 작업은 모든 Dataframe이 메모리 상으로 올라가게 된다. 작은 task면 문제없이 실행 되겠지만, 큰 규모의 task는 메모리를 많이 차지하게 되어 에러가 날 수 있다. 이럴 때 사용 하는 것이 each map이다. each map은 dataframe에서 row 별로 메모리 상으로 올린다. 이후 해당 row에서 특정 처리를 진행 후에 buffer로 옮긴 뒤 DB로 적재를 한다. 이 때 조심해야 하는 부분은 seperate다. row에서 컬럼으로 구분하는 seperate값을 잘 이용해야지 에러가 나지 않을 것이다.    즉! pytest 부분을 더 공부하고 적절한 testset을 생각해보고, testcode를 작성해보자!  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행",
        "excerpt":"CS:APP  Computer Systems A Programmer’s Perspective, CSAPP로도 잘 알려져있는 컴퓨터 구조론의 바이블이다. 이 책을 통해서 컴퓨터구조론을 다시 공부해볼 생각이다. 군대 전역 직후 2학년 2학기로 복학해서 컴퓨터 구조론 전공 수업을 들었지만 학점을 위한 공부만 해서 남아있는게 없는 것 같다. 인턴 생활을 하면서 다양한 부분에서 어려움을 겪었는데 기초를 몰라서 헤메고 있다는 느낌을 굉장히 많이 받았다.   첫 페이지를 읽었을 때 이 책으로 정하길 정말 잘했다는 생각이 들었다. 전공 수업때 사용했던 컴퓨터구조론 책은 제작자의 관점에서 기술 되었다는 느낌을 강하게 받았었다. 하지만, CSAPP는 프로그래머의 관점에서 기술하였고, 컴퓨터구조론의 시스템들을 어떻게 사용해서 좋은 프로그램을 개발할 수 있는지를 배울 수 있다고 한다.  인턴 생활을 하면서 실제 현업을 겪고 느꼇던 강한 의문들을 해결할 수 있을 것 같은 느낌이다.   책의 목차는 정보의 표현과 처리로 시작하여 프로그램의 기계어 표현, 프로세서 구조, 프로그램 성능 최적화, 메모리 계층구조, 링커, 예외적인 제어흐름, 가상메모리, 시스템 수준 입출력, 네트워크 프로그래밍, 동시성 프로그래밍  순서로 이어져 있다. 많은 사람들은 6장 메모리 계층구조, 7장 링커의 전까지 읽어도 좋다고 하지만, 가능하다면 12장 동시성 프로그래밍까지 읽어볼 생각이다.   Chapter 01. 컴퓨터 시스템으로의 여행     시스템 구현방식은 변하지만 근본적인 개념들은 변하지 않는다.   프로그래머들로 하여금 컴포넌트들이 어떻게 동작하고 프로그램 성능과 정확성에 어떤 영향을 주는지 알 수 있다.   1.1 정보는 비트와 컨텍스트로 이루어진다.     텍스트 문자 -&gt; 아스키(ASCII) 표준 사용하여 표현 -&gt; 각 문자를 바이트 길이의 정수 값으로 표현 -&gt; 연속된 바이트 파일 저장   1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.     hello.c 실행 -&gt; 저급 기계어 인스트럭션들로 번역 -&gt; (실행가능 목적 프로그램)으로 합쳐져 바이너리 디스크 파일로 저장  -&gt; 컴파일러 드라이브는 유닉스 시스템에서 소스파일에서 오브젝트 파일로 변경 -&gt; 4개의 단계를 거쳐서 실행            4개의 단계:                    전처리기           컴파일러           어셈블러           링커                           1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.     프로그램 성능 최적화하기            eg1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?       eg2) while 루프는 for 루프보다 더 효율적일까?       eg3) 포인터 참조가 배열 인덱스보다 더 효율적인가?           링크 에러 이해하기            eg1) 정적변수와 전역변수의 차이는 무엇인가?       eg2) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?           보안 약점 피하기            eg1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?           1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.     인스트럭션이란 : 컴퓨터에게 일을 시키는 단위(기계어)       시스템의 하드웨어 조직            버스 : 시스템 내를 관통하는 전기적 배선군       입출력 장치 : 시스템과 외부세계외의 연결 담당       메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치       프로세서 : 인스트럭션들을 해독(실행)하는 엔진                    인스트럭션의 요청에 의해 CPU(프로세서)가 실행하는 단순한 작업의 예                            적재(load), 저장(store), 작업(operate), 점프(jump)                                                        프로그램의 실행              1.5 캐시가 중요하다.     hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다.   프로그램이 로딩될 때 이들은 메인 메모리로 복사된다.   이 작업이 시간이 너무 오래 걸려서 “단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하는” 캐시 메모리가 설계 되었다.   캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성을 활용하였다.   1.6 저장장치들은 계층구조를 이룬다.          모든 컴퓨터 시스템의 저장장치즈들은 메모리 계층구조로 구성되어 있다.              1.7 운영체제는 하드웨어를 관리한다.     운영체제는 두 가지 주요 목적을 가지고 있다.            제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해       응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해           위 두가지 목표를 위해 근본적인 추상화를 통해 달성하고 있다.   추상화 결과            프로세스 : 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과       가상 메모리 : 메인 메모리와 디스크 입출력 장치의 추상화       파일 : 입출력장치의 추상화           1.8 시스템은 네트워크를 사용하여 다른 시스템과 통신한다.     네트워크는 또 다른 입력장치로 볼 수 있다.   시스템이 메인 메모리로부터 네트워크 어댑터로 일련의 바이트를 복사할 때, 데이터는 로컬디스크 드라이브 대신에 네트워크를 통해서 다른 컴퓨터로 이동된다.   1.9 중요한 주제들     Amdahl의 법칙            우리가 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 구 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계된다.           동시성과 병렬성            동시성 : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념       병렬성 : 동시성을 사용해서 시스템을 보다 더 빠르게 동작하도록 하는 것       쓰레드 수준 동시성                    쓰레드를 이용하면 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수 있음                       인스트럭션 수준 병렬성                    프로세서들은 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있음                           컴퓨터 시스템에서 추상화의 중요성            추상화의 사용은 전산학에서 가장 중요한 개념!           1.10 요약     컴퓨터 내의 정보는 비트들의 그룹으로 표시   컴파일러와 링커에 의해 바이너리 실행파일들로 번역   프로세서는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석   컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간에 데이터를 복사하고 쓰는 데 사용   위와 같은 이유로 시스템의 저장장치들은 계층구조 형성   운영체제 커널은 응용프로그램과 하드웨어 사이에서 중간자 역할 수행   네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법 제공   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.   비트 패턴            이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.       표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.           인코딩            비부호형 : 전통적인 이진수 표시 사용       부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법       부동소수점 : 2진수 버전의 소수 표시방법           이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.        2.1 정보의 저장     기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급   메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음   모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름   2.1.1 16진수 표시     1바이트는 8비트로 이루어짐        이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&gt; 16진수 사용              16진수 &lt;-&gt; 10진수 &lt;-&gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음            2.1.2 데이터의 크기     모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨            w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐       프로그램은 최대 2^w 바이트에 접근 가능                최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임              2.1.3 주소지정과 바이트 순서     여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정            객체의 주소가 무엇이 되어야 하는지       메모리에 바이트들을 어떻게 정렬해야 하는지           비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.            가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]       가장 덜 중요한 바이트 : [x7, x6, . . . , x0]           바이트 저장 방법            리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는       빅 엔디안 : 가장 중요한 바이트가 먼저 오는       대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작           바이트 순서가 이슈가 되는 경우            이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때                    리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜                       정수 데이터를 나타내는 바이트들을 살펴볼 때       프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때           2.1.4 스트링의 표시      그냥 ASCII를 사용한다는 내용,,,    2.1.5 코드의 표현          인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름                   컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것       2.1.6 부울 Boolean 대수     NOT : ~   AND : &amp;   OR : |        EXCLUSIVE-OR : ^              2.1.7 C에서의 비트수준 연산          C에서는 비트들 간의 부울 연산을 지원                   비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.             마스크: 비트 연산에 사용되는 데이터            2.1.9 C에서의 쉬프트 연산     비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공   x « k            x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.           x » k            좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.       논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움       산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움           부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용        2.2 정수의 표시          컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것              2.2.1 정수형 데이터 타입     서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.   64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위            음수의 범위가 양의 범위보다 1 더 넓은 것에 주목                  2.2.2 비부호형의 인코딩     음수 값을 포함하지 않음        B2U는 Binary 에서 Unsigned의 줄임말               2.2.3 2의 보수 two’s complement 인코딩     음수 값을 포함        B2T는 Binary 에서 Two’s complement의 줄임말                  모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며,  부호형 수에 대해서 특정 표시를 가정해서도 안된다.    2.2.4 비부호형과 부호형 간의 변환     C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.   2의 보수에서 비부호형으로의 변환            TMin ≤ x ≤ TMax를 만족하는 x에 대해  x가 0보다 크거나 같으면 x x가 0보다 작으면 x+2^w                  이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.            비부호형에서 2의 보수로의 변환            0 ≤ u ≤ UMax를 만족하는 u에 대해 u가 TMax보다 작거나 같으면 u u가 TMax보다 크면 u-2^w                  이유는 T2U의 이유와 동일하다.  이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)            2.2.5 C에서 부호형과 비부호형의 비교     C에서는 부호형과 비부호형 산술연산을 지원한다.            C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.            2.2.6 수의 비트 표시를 확장하기     비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.            영의 확장 zero extension 이라고 알려짐           2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.            부호 확장 sign extension 이라고 알려짐                  2.2.7 숫자의 절삭     진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.       비트의 개수를 줄이는 경우이다.            eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.           비부호형 수의 절삭            x’ = x mod 2^k 이다.                    삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.           자리값들은 모듈(mod) 계산으로 모두 0이 된다.                           2의 보수 숫자의 절삭            x’ = U2T(x mod 2^k) 이다.                    가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.                           2.2.8 Signed와 Unsigned에 관한 조언     부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.   비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.      2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다. 위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수                2.3 정수의 산술연산     두 개의 양수를 더해서 음수가 나오는 경우, x&lt;y와 x-y&lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,            그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.               2.3.1 비부호형 덧셈  x,y, 0≤x, y≤e^w가 있다고 하자, 두 합의 계산 범위는 0≤x+y≤2^(w+1)-2를 갖는다. 이 합의 크기를 표현 하기 위해서는 w+1개의 비트가 필요하게 된다.     “워드 크기 증가”는 산술연산의 결과를 완벽하게 표시하려면 필요한 워드 크기를 제한할 수 없다는 것을 의미한다.   프로그래밍 언어들은 고정길이 산술연산을 지원하며 따라서 “덧셈”과 “곱셈”같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.        x,y에 대해 x+y 정수합을 w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타낸다.                   정상적인 경우에는 x+y값을 유지하지만, 오버플로우의 경우에는 2^w만큼 줄어드는 효과를 낸다.                 산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때 이 연산은 “오버플로우한다”고 한다.         2.3.2 2의 보수의 덧셈  2의 보수 덧셈의 결과값이 너무 크거나(양수) 또는 너무 작아서(음수) 표시할 수 없을 때 우리는 어떻게 해야 할지 결정해야 한다.          x+y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산이다.                    2의 보수의 합이 2^(w-1)을 넘어간다면 양수 오버플로우가 생기고, -2^(w-1) 미만으로 내려간다면 음수 오버플로우가 생겨 각각에 2^w을 더해주거나 빼준다.         2.3.3 2의 보수에서의 비트반전 Negation          비부호형 비트반전                   2의보수 비트반전                   2.3.4 비부호형 곱셈     비부호형 곱셉은 2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것으로 정의된다.        비부호형 수를 w비트로 절삭하는 것은 해당 값을 2^w로 나눈 나머지를 계싼하는 것과 같다.                  2.3.5 2의 보수 곱셈          2^w로 나눈 나머지를 취하고 비부호형에서 2의 보수형태로 변환하는 것과 같다.                  2.3.6 상수를 사용한 곱셈     정수 곱셉은 매우 느리다. 컴파일러에서 수행되는 중요한 최적화는 상수를 곱하게 되는 경우들을 쉬프트와 덧셈의 조합으로 대체한다.   2의 제곱을 곱하는 경우            k≥0인 모든 k에 대해 x2^k의 w+k 비트수준 표현은 우측에 k개의 0을 추가한 것이다.       eg) 11은 w=4인 경우 [1011]이다. 이것을 왼쪽으로 k=2 쉬프트 하면 [101100]이 되며 이것은 11*4=44를 인코딩한 것이다.           2의 제곱을 곱하면 비부형이건 2의 보수 산술연산이건 오버플로우가 발생할 수 있다.            eg) 위의 예제를 예로 들자면, [101100]을 4비트로 절삭하면 1100을 얻는다.              정수 곱셈이 쉬프트와 덧셈을 사용하는 것보다 훨씬 비용이 많이 드는 연산이기 때문에 C 컴파일러들은 정수가 상수와 곱해지는 경우에 이들을 쉬프트, 덧셈, 뺄셈 등의 조합을 사용해서 제거하려고 노력한다.        2.3.7 2의 제곱으로 나눗셈하기     정수 나눗셈은 정수 곱셉보다 훨씬 느리다. 2의 제곱으로 나누는 것은 오른쪽 쉬프트를 사용한다.   비부호형은 논리 쉬프트, 2의 보수는 산술 쉬프트를 사용한다.   2의 보수 음수에서는 보정값을 더해서 결과값을 0 방향으로 근사하도록 한다.       2.3.8 정수 산술연산에 대한 마지막 고찰  컴퓨터에서 실행되는 “정수” 산술연산은 실제로는 modular 산술연산의 형태로 수행된다. 숫자를 표현하기 위해 유한한 길이의 워드를 사용하기 때문에 가능한 값의 범위가 제한되며 연산의 결과가 오버플로우될 수 있다.  ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_03/",
        "teaser": null
      },{
        "title": "[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성",
        "excerpt":"IntelliJ  학교에서는 java를 배울 때 이클립스(Eclipse)를 사용했다. 하지만 python을 주로 다루면서 파이참(Pycharm)에 익숙해졌다.  java 공부를 하면서 좀 더 친숙한 JetBrains 회사의 개발도구를 사용하려고 한다. 정보를 조금 찾아보니 IntelliJ가 현재 내가 사용하고 있는 환경인 Mac Os에서 이클립스보다 오류가 덜 발생한다고 한다. 통합 개발 환경도 제공한다고 하니 이보다 더 좋을 수가 없다!    해당 포스트는 Mac Os 환경에서 진행되었다.   1. IntelliJ 설치  우선 IntelliJ Mac Os 버전을 설치하려면  IntelliJ 설치 링크 에 접속한다.  각자 Mac 환경에 맞는 파일을 다운로드한다.          java 학습을 위해선 Community Edition으로도 충분하다고 한다. 하지만 본인이 학생 신분이라면 학생 라이센스를 이용한 Ultimate 버전을 추천한다.          아래와 같은 창이 뜨면 설치 성공!      2. Java Project 만들기  위의 창에서 Create New Project를 누르면 아래와 같은 창이 열린다.   왼쪽의 리스트에서는 Java 선택, 오른쪽 리스트에서는 아무것도 선택하지 않고, 오른쪽 아래의 “Next” 버튼을 누른다.          Java 프로젝트를 생성할 때 샘플코드를 생성할지 여부.   본인이 직접 생성할 것이기 때문에 아무것도 선택하지 않고 “Next” 버튼을 누른다.          프로젝트 이름을 정하고 “Next” 버튼을 누른다.      3. Hello World 출력하기  프로젝트 생성이 완료되면, main 메소드가 있는 새로운 Java 클래스를 생성하기 위해 src 폴더를 우클릭한다.  New &gt; Java Class 를 선택한다.          새로 생성할 Java Class 이름을 설정하고 Enter를 친다.          Hello World 출력 코드를 작성한다.  상단의 망치 버튼을 클릭하여 빌드하거나 “control + option + R”키를 눌러 빌드한다.          혹은 out &gt; production &gt; “project_name” &gt; “Class_name” 우클릭 후 Run을 선택해도 된다.          이제 IntelliJ와 함께 Java 공부를 시작해보자,,,!  ","categories": ["Java"],
        "tags": ["Java","IntelliJ"],
        "url": "/java/java_01/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산",
        "excerpt":"Part1 자바 시작하기  Java     객체지향언어   C,C++ 문법을 기본으로 개발            C언어에 객체지향 특성 확장           플랫폼에 독립적임            JVM으로 인해서 어떤 플랫폼에서도 실행 가능함           Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌   JDK : Java Development Kit        JAVA 개발순서     코드 작성   코드 컴파일   컴파일한 소스를 JVM을 이용하여 실행        주석문     // : 행단위 주석   /* */ : 블럭단위 주석   /** ..*.. */ : 문서화 주석       Part2 변수와 계산   변수  변수 값(Data)을 저장할 수 있는 메모리 공간     java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨   java 식별자 명명 규칙            첫 번째 글자는 문자 이거나 $,_ 이어야 함       $,_ 이외의 특수문자는 사용 불가능       키워드는 식별자로 사용할 수 없음           java 변수 명명 관례            첫 번째 문자가 소문자인 명사로 정함       여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)       _를 쓰지 않음               상수  상수란 수식에서 변하지 않는 값을 의미     상수의 선언            final 상수타입 상수명;                    eg) final int J;                           상수 명명 관례            대문자로만 구성된 명사로 정함       여러 단어로 구성된 이릠의 경우 단어 사이에 _을 써서 구분함           상수를 사용해야 하는 경우            값이 변하면 위험한 경우에 상수 사용       값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용               기본형 타입  기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.     논리형            boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음           문자형            char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능           정수형            int 4byte, long 8byte           실수형            float 4byte, double 9byte           리터럴            CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어       리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함           사용 방법            long : 값을 적을 때 뒤에 l이나 L 적어야함       float : 값을 적을 때 뒤에 f나 F를 적어야함               기본형 타입변환     묵시적 형변환            크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌           명시적 형변환            크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함       eg) long x = 20; int y = (int) x;               연산자 우선순위     최우선연산자 ( ., [], () )   단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&gt;부호&gt;증감)            단, 후위연산자(a++)은 우선순위가 낮음       eg) a=5, x = a++ - 5 라면 x는 0, a는6           산술연산자 ( *,/,%,+,-,shift) &lt; 시프트연산자 ( »,«,»&gt; ) &gt;   비교연산자 ( &gt;,&lt;,&gt;=,&lt;=,==,!= )   비트연산자 ( &amp;,|,,~ )   논리연산자 (&amp;&amp; , || , !)   삼항연산자 (조건식) ? :   대입연산자 =,*=,/=,%=,+=,-=  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_02/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 제어문",
        "excerpt":"Part3 제어문   if 조건문  조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.     if 문   if - else 문   if - else if - else 문       논리 연산자  논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.                                     OR :                                       AND : &amp;&amp;   NOT : !   EXCLUSIVE-Or : ^       삼항 연산자     조건식 ? 피연산자1 : 피연산자2            조건식의 결과가 true 라면 결과는 피연산자1       조건식의 결과가 false 라면 결과는 피연산자2               switch문  switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.   switch(변수){         case 값1 :              실행문;              break;         case 값2 :              실행문;              break;           default;         }     break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.   JDK7 이후에는 문자열 타입의 변수도 가능함      당연한걸 수도 있지만, case 에 조건문을 달면 오류가 난다 하하,,,        while문  조건문의 실행 결과가 true일 동안 반복해서 실행한다.   while(조건문){         실행문;      }      do while문  while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.      do{         실행문;     }while(조건문);     실행문을 한번은 실행하고 싶을 경우에 사용됨       for 반복문  for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨       for(초기화식; 조건식; 증감식){         실행문;         실행문;     }  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 배열",
        "excerpt":"Part4 배열   배열 만들기  배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다.   int[] array1 = new int[4]; int[] array2 = new int[]{1,2,3,4}; int[] array3 = {1,2,3,4};      배열 사용하기     배열에 접근할 때에는 인덱스를 통해서 접근한다.   배열의 길이를 알아내는 방법 : array.length        2차원 배열  2차원 배열이란 배열의 배열이다.   int[][] array4 = new int[3][4];  int[][] array5 = new int[3][]; //위와 같이 선언하면 array5는 3개짜리 배열을 참조한다. 3개짜리 배열은 아직 참조하는 배열이 없다는 것을 의미. array5[0] = new int[1]; //정수를 하나 담을 수 있는 배열을 생성해서 array5 의 0 번째 인덱스가 참조한다.   array5[1] = new int[2]; //정수를 두개 담을 수 있는 배열을 생성해서 array5 의 1 번째 인덱스가 참조한다.   array5[2] = new int[3]; //정수를 세개 담을 수 있는 배열을 생성해서 array5 의 2 번째 인덱스가 참조한다.       for each  for문 안에 (value:array), array의 값 하나씩 value로 매칭된다.     python for in 이랑 똑같은거 같아서 너무 반갑다!    int[] iarr = {10,20,30,40,50};  for(int value:iarr){     System.out.println(value); } ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_04/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수           2.3 정수의 산술연산            비부호형 및 2의보수의 덧셈,뺄셈,곱셉,나눗셈                2.4 부동소수점     부동소수점 표현은 V = x*2^y 형태의 소수를 인코딩한다.   거의 모든 컴퓨터가 IEEE 부동소수점이라고 알려지게 된 방식을 지원한다.        2.4.1 비율이진수(Fractional Binary Numbers)     부동소수점에 대해서 이해하기 위한 첫 단계는 비율 이진수에 대해 생각해보는 것이다.            숫자들의 자리값은 십진 소수점 부호(‘.’)에 상대적으로 정의된다.                  위와 같은 방식으로 binary 표기법으로 생각해보자.            부호 ‘.’는 이진 소수점이 되고, 좌측의 브트들은 비음수의 2의 제곱을 자리값으로 가지며, 우측은 2의 음의 제곱을 자리값으로 갖는다.       이진 소수점을 한 자리 우측으로 이동하면 2로 곱한 효과, 좌측으로 이동하면 2로 나눈 효과를 가진다.                  이진수 표기는 x*2^y로 나타낼 수 있는 수만 표시할 수 있다.   이진 표시를 길게 늘려서 정확도를 높이도록 근사해야 한다.        2.4.2 IEEE 부동소수점 표시     IEEE 부동소수점 표준은 수를 V = (-1)^sM2^E 형태로 나타낸다            s는 음수와 양수를 결정한다.       유효숫자 M은 비율 이진수다.       지수 E는 2의 제곱으로 자리값을 제공한다.           부동소수점 수의 비트 표시는 이 값들을 인코딩하기 위해 세 개의 필드로 나누어진다.            한 개의 부호 비트 s는 부호 s를 직접 인코딩한다.       k비트 지수 필드 exp = ek-1…e1e0는 지수 E를 인코딩한다.       n비트 비율 필드 frac = fn-1 … f1f0는 유효숫자 M을 인코딩한다.                 Case 1: 정규화 값 Normalized Values            가장 일반적인 경우       exp의 비트 패턴이 모두 0은 아니며, 모두 1이 아니어야 한다.       E = e - Bias (Bias = 2^(k-1) - 1)       비율 필드 frac은 비율 값 f       유효 숫자 M = 1 + f 로 정의           Case 2: 비정규화 값 Denormalized Values            지수 필드가 모두 0일 때 나타낸 수는 비정규화 형태를 갖는다.       E = 1 - Bias       M = f = 0       비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타냄                    이들은 점증적 언더플로우라고 알려진 특성을 제공 (가능한 숫자 값들이 0.0 근처에서 같은 간격을 갖는다는 의미)                           Case 3: 특수 값 Special Values            지수 필드가 모두 1인 경우                    비율 필드가 모두 0이면, 결과값은 무한대를 나타냄           비율 필드가 0이 아니면 NaN(not a numbuer)                                   2.4.3 숫자 예제      2.4.4 근사법 Rounding     부동소수점 산술연산은 표시방법이 제한된 범위와 정밀도를 갖기 때문에 실제 연산의 근사값을 사용할 수밖에 없다.   “가장 유사한” 값 x를 체계적으로 계산하는 방법을 근사rounding 연산이다.   네가지 근사 모드를 정의함            짝수근사법(round-to-even): 가장 가까운 값, 중간에 위치할 경우 짝수를 향해 근사함       영방향근사 모드(round toward-zero): 양수 값을 아래쪽으로, 음수를 위쪽으로 근사함       하향근사 모드(round-down): 양수와 음수를 모두 아래쪽으로 근사함       상향근사 모드(round-up): 양수와 음수를 모두 위쪽으로 근사함                2.4.5 부동소수점 연산     부동소수점 값 x,y를 실수로 보고, 일부 연산이 실수들에 대해 정의된다면 Round(x,y)가 되는데, 이것은 실수 연산의 정확한 결과 값을 근사한 것이다.   부동소수점 덧셈에서 결합법칙이 성립하지 않는 것은 그룹의 특징 중에서 빠진 가장 중요한 부분이다.   교환법칙은 성립하지만, 결합벅칙은 성립 되지 않는다.        C에서 부동소수점     C는 짝수 근사모드를 사용한다.   int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.   int나 float에서 double로, 정확한 수치 값은 보존될 수 있다.   double에서 float로 범위가 더 작아지기 때문에 값이 오버플로우하여 무한대가 될 수 있따.   float나 double에서 int로, 값은 0 방향으로 근사된다        2.5 요약     정보를 비트로 인코딩하며, 이들은 일반적으로 연속된 바이트들로 구성된다.   대부분의 머신들은 정수를 인코딩하기 위해 2의 보수를 사용하고 부동소수점을 인코딩하기 위해 IEEE 표준 754를 사용한다.   부호형 및 비부호형 정수를 캐스팅할 때 비트 패턴을 유지하려고 하는데, T2U, U2T 함수들에 의해 나타난다.   제한된 길이는 숫자들이 나타낼 수 있는 범위를 넘어설 때 오버플로우를 발생시킨다.   비부호형과 2의 보수 산술연산은 결합법칙, 교환법칙, 분배법칙 등의 정수 산술연산의 많은 특성을 만족한다.   결합법칙, 교환법칙, 분배법칙 특성을 쉬프트와 2의 제곱의 곱셈 간 관계와 함께 사용된다.   부동소수점 산술연산은 매우 조심스럽게 사용해야한다.            제한된 범위와 정밀도를 갖기 때문이며, 결합법칙 같은 일반적인 수학 법칙을 따르지 않기 때문이다.                   부동소수점을 마지막으로 Chapter2 정보의 표현과 처리를 마무리하였다. 데이터 엔지니어링 인턴 포지션에서 ETL 작업을 하며 소수점 데이터에 접근 했을 때  R코드와 Python의 소수 처리 방식이 달라서 해당 오류를 잡는데 많은 시간이 걸린 경험이 있었다. 그 때 당시에는 대충 방식이 다르구나~ 로 끝났지만, 이번 챕터를 공부하게 되면서 아 부동소수점의 표현 방식 때문에(책은 C를 기준으로 하고 있지만,,,) 그런 오류가 잡혔던 거구나 하고 시야가 조금 더 넓어진 것 같다.  2.2절의 캐스팅과 2.4절의 부동소수점을 공부하면서 꽤 많은 애를 먹었지만, 앞으로 코딩을 하면서 캐스팅이나 소수점을 다룰 때 더 주의 깊게 다룰 수 있을 것 같다.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_04/",
        "teaser": null
      },{
        "title": "[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰",
        "excerpt":"Introduction     Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나   Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델   NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음            Machine Translation, Abstract Text Summarization           자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨   Encoder-Attention-Decoder       Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형   Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조       Related Works       Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train   GPT는 Language Modeling을 위해 Decoder를 Pre-train   이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음       MASS:Masked Sequence to Sequence Pre-training       새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자   Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking   마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴   Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공   Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선   Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨        K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터   하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능   BERT Masked LM            K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐           GPT Standard LM            하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨       Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐                m - Input sequence의 전체길이   u - Maskinge된 Fragment의 시작점   v - Masking된 Fragment의 끝점   X^u - u부터 v까지의 fragment   X^\\u:v - u부터 v까지 Making된 Input Sequence       Experiments     Model Configuration            1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer           Datasets            2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M       MASS의 효과 검증을 위한 low-resource language Romanian           Pre-training Details            Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험               Experiment:Unsupervised Machine Translation       Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행   Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델   MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록        Experiment:Low-resource Translation       Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역   Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트   MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가   데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남        Experiment:Abstractive Summarization       Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교   MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가        Experiment:Conversational Response Generation       Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교   MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌        The probability formulation       (a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL   하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과   실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨            문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공           K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증       Couclusion     MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록   Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정   또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%       Related Works     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.       Model     ELMO            ELMO word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM          Task-specific ELMo Embedding         Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.                  Evaluation         6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.        Analysis        기존에 top layer output만 사용 한 것 대비 성능 향상을 검증했다.   대부분의 경우 Regularization parameter λ 가 작을수록 성능이 더 좋아지는 경향이 있다.          일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.          GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.          biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다.          ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.       Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속되 바이트인 기계어 코드를 실행한다.   컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 기계어 코드를 생성한다.   어셈블러 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는 저급 인스트럭션들을 명시해야 한다.   기계어 코드를 배우면 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내제된 비효율성을 분석할 수 있다.   이 장은 X86-64에 기초하고 있다.        3.1 역사적 관점     x86이라고 통칭하는 인텔 프로세서 제품군은 오랜 기간 진화를 통한 개발을 해왔다.            대충 엄청 많은 프로세서들이 나열 되는데, 팬티엄4E(2004, 125M 트랜지스터) 하이퍼쓰레딩 기법의 추가와 AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T가 추가된 해당 모델을 x86-64라고 부른다고 한다.                 3.2 프로그램의 인코딩     C 언어에서 gcc 명령은 소스 코드(test.c)를 실행 코드로 변환하기 위해 일련의 프로그램들을 호출한다.            C 전처리가 #include로 명시된 파일을 코드에 삽입해 주고 #define으로 선언된 매크로를 확장해준다.       컴파일러는 소스파일의 어셈블러 버전(test.s)를 생성한다.       어셈블러는 어셈블리 코드를 바이너리 목적코드인(test.o)로 변환한다.                    목적코드는 기계어 코드의 한 유형이다. - 모든 인스트럭션과 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았다.                       마지막으로 링커가 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.           커맨드 라인 옵션으로 -0g를 주면 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적호 수준을 적용한다.            높은 수준의 최적화를 적용하면 만들어진 코드가 너무 많이 변경되어 본래의 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.                3.2.1 기계수준 코드     컴퓨터 시스템은 보다 간단한 추상화 모델을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.            기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조 즉 “ISA”에 의해 정의된다.                    프로세서의 상태, 인스트럭션의 형식, 프로세서 상태에 대한 각 인스트럭션들의 영향들을 정의한다.                       기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.           컴파일러는 추상화된 실행모델로 표현된 프로그램을 프로세서가 실행하는 매우 기초적인 인스트럭션들로 변환하는 대부분의 일을 수행한다.        3.2.2 코드 예제       기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현에 주목할 필요가 있다.            x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.       인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을 기계어 인스트럭션으로 유일하게 디코딩할 수 있도록 설계한다.       역어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다.                3.3 데이터의 형식     인텔 프로세서들이 근본적으로 16비트 구조를 사용하다가 추후에 32비트로 확장했기 때문에 인텔은 “워드”라는 단어를 16비트 데이터 타입을 말할 때 사용한다.           3.4 정보 접근하기     x86-64 주처리장치 CPU는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.            이들 레지스터는 정수 데이터와 포인터를 저장하는데 사용한다.                   3.4.1 오퍼랜드 식별자 specifier     대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다.   오퍼랜드는 연산을 수행할 소스 값과 그 결과를 저장할 목적지의 위치를 명시한다.   소스 값은 상수로 주어지거나 레지스터나 메모리로부터 읽을 수 있다. 결과 값은 레지스터나 메모리에 저장된다.   세가지 타입으로 나뉘어짐            immediate로, 상수값을 말한다.       register는 레지스터의 내용을 나타내며       Memory, 메모리 참조로 유효주소라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.                   3.4.2 데이터 이동 인스트럭션     가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 복사하는 명령어다.            MOV 클래스 : 소스 위치에서 데이터를 목적지 위치로 어떤 변환도 하지 않고 복사한다.           소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다.   목적 오퍼랜드는 레지스터 또는 메모리 주소의 위치를 지정한다.   x86-64는 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다.              3.4.3 코드 예제           C언어에서 “포인터”라고 부르는 것이 어셈블리어에서는 단순히 주소를 나타낸다.     포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 과정으로 이루어진다.     지역변수들은 메모리에 저장되기보다는 종종 레지스터에 저장된다.           3.4.4 스택 데이터의 저장과 추출 push,pop     push와 pop은 프로그램 스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다.   스택은 프로시저 호출을 처리하는 데 중요한 역할을 한다.   프로그램 스택은 메모리의 특정 영역에 위치한다.   스택의 탑top 원소가 모든 스택 원소 중에서 가장 낮은 주소를 갖는 형태다.   스택은 pop이 되어도 stack의 top을 표현하는 주소가 올라간거지 값은 여전히 pop이 된 위치에 남아있다.   스택이 프로그램 코드와 다른 형태의 프로그램 데이터와 동일한 메모리에 저장되기 때문에 프로그램들은 표준 메모리 주소지정 방법을 사용해서 스택 내 임의의 위치에 접근할 수 있다.      ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_05/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.5 산술연산과 논리연산       위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.   인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.            addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.           연산들은 네 개의 그룹으로 나누어진다.            유효주소 적재, 단항unary, 이항binary, 쉬프트                    이항 연산은 두 개의 오퍼랜드를 가진다.           단항 연산은 한 개의 오퍼랜드를 가진다.                           3.5.1 유효주소 적재 Load Effective Address     유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.   메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.   가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.   이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.   또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다            ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.           목적 오퍼랜드는 반드시 레지스터만 올 수 있다.   3.5.2 단항 및 이항 연산     단항 연산            하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.       오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.       ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자           이항 연산            첫 번째 오퍼랜드는 상수나 레지스터, 메모리 위치가 올 수 있고 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.       C에서 x -= y와 유사하다.       두 개의 오퍼랜드가 모두 메모리 위치가 될 수 없다.       두 번째 오퍼랜드가 메모리 위치일 때 프로세서가 메모리에서 값을 읽고, 연산을 하고, 그 결과를 다시 메모리에 써야 한다는 점에 유의해야 한다.           3.5.3 쉬프트 연산     쉬프트하는 크기를 먼저 주고, 쉬프트할 값을 두 번째로 준다.   산술과 논리형 우측 쉬프트가 모두 가능하다.   쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 명시할 수 있다.   좌측 쉬프트 인스트럭션에는 두 가지 이름이 있다.            SAR: 산술 쉬프트, 부호비트를 복사해서 채운다       SHR: 논리 쉬프트, 0으로 채운다           쉬프트 연산의 목적 오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.   3.5.4 토의     인스트럭션들은 비부호형과 2의 보수 산술연산에 사용될 수 있다.   오직 우측 쉬프트만이 부호형과 비부호형 데이터를 구분하는 인스트럭션을 요구한다.   이것이 부호형 정수 산술연산을 구현하는 방식으로 2의 보수 산술연산을 선호하는 주요 특징이다.   3.5.5 특수 산술연산       두 개의 64비트 부호형 또는 비부호형 정수들 간의 곱셈 결과값을 표시하기 위해 128비트를 필요로한다.   x86064 인스트럭션 집합은 128비트 숫자와 관련된 연산에 대해서는 제한적인 지원을 제공한다.            워드(2바이트), 더블워드(4바이트), 쿼드워드(8바이트), 인텔은 16바이트 워드를 옥트워드oct word라고 명명한다.           IMUL 인스트럭션 클래스의 멤버인 형태            이 형식은 두 개의 64비트 오퍼랜드로부터 64비트 곱을 생성하는 “2 오퍼랜드” 곱셈 인스트럭션을 제공한다.           추가적으로 x86-64는 두 개의 다른 “단일 오퍼랜드” 곱셈 인스트럭션을 제공하며 64비트 값의 완전한 128비트 곱을 계산한다.            하나는 비부호형(mulq), 다른 하나는 2의 보수(imulq) 곱셈이다.       이들 모두 한 개의 인자는 레지스터 %rax에 보관해야 하고 다른 하나는 인스트럭션 소스 오퍼랜드로 주어진다.       곱은 레지스터 %rdx(상위 64비트)와  %rax(하위 64비트)에 저장된다.           곱을 저장하기 위해서는 아래의 그림처럼 두 개의 movq 인스트럭션이 필요하다.        단일 오퍼랜드 곱셈 인스트럭션과 비슷한 단일 오퍼랜드 나눈셈 인스트럭션으로 제공된다.   나눗셈 인스트럭션 idviq은 피제수dividened를 128비트로 레지스터 %rdx(상위 64비트)와 %rax(하위 64비트)에 저장한다.   제수divisor는 인스트럭션의 오퍼랜드로 주어진다.   인스트럭션은 몫은 레지스터 %rax에, 나머지는 레지스터 %rdx에 저장한다.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_06/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰",
        "excerpt":"Introduction     Multi-Task Learning(MTL)은 새로운 Task를 학습하는 데 도움이 되도록 이전 작업에서 학습된 지식을 적용하는 인간 학습 활동에서 영감을 받음   Deep neural networks(DNN)를 이용한 representation learning에 MTL을 적용하는 것에 대한 관심이 높아지고 있음            DNN을 이용한 representation learning은 많은 양의 데이터를 요구함, MTL은 많은 task에서의 supervised labeled data를 제공함       MTL은 특정 Task에 Overfitting 되지 않도록 Regularization 효과를 줌           MTL과 대조적으로, Language Model은 대용량의 unsupervised dataset을 활용하여 모델을 학습함            ELMo, GPT, BERT           MT-DNN은 Language Model Pre-Training을 활용한 BERT에 Multi-task learning을 적용하여 성능을 개선한 모델      Tasks     GLUE의 9개 task를 MTL에 활용   Single Sentence Classification            하나의 문장이 주어졌을 때 문장의 Class를 분류하는 Task       CoLA : 문장이 문법적으로 맞는지 분류 (True/False)       SST-2 : 영화 Review 문장의 감정 분류 (Poistive/Negative)           Text Similarity            문장 쌍이 주어졌을 때, 점수를 예측하는 Regression Task       STB-B : 문장 간의 의미적 유사도를 점수로 예측           Pairwise Text Classification            문장 쌍이 주어졌을 때, 문장의 관계를 분류하는 Task       RTE, MNLI : 문장 간의 의미적 관계를 3가지로 분류 (Entailment, Contradiction, Neutral) – QQP, MRPC : 문장 간 의미가 같음 여부를 분류 (True/False) – Relevance Ranking – QNLI : 질문과 해당 지문 중 한 문장이 쌍으로 주어졌을 때 해당 지문 문장에 질문의 답이 있는지 여부를 분류 (True/False) – MT-DNN에서는 이를 Rank 방식으로 바꾸어 모든 지문 문장에 정답이 있을 가능성을 Scoring 하여 가장 Score가 높은 지문 문장을 True로 분류하는 방식으로 Task 수행              Model Architecture         Lexicon Encoder            Token Embedding                    맨 앞에 [CLS] 토큰을 추가. 추후 Output에서 Classification 등을 위해 사용됨           만약 문장쌍이 들어온다면 각 문장은 Wordpiece로 Toenization 되며 [SEP] Token이 두 문장 사이의 구분자로 사용됨                       Sentence Embedding - 1번째 혹은 2번째 문장임을 표현하는 Vector       Positional Embedding - 각 Token의 위치 정보를 표현하는 Vector                 Transformer Encoder            Lexicon Encoder로 부터 각 Token의 Input Vector를 입력으로 받아 Ouput Vector 추출       BERT 모델과 달리 task별로 fine-tunning하지 않고 MTL로 fine-tunning 함                 Single-Sentence Classification Ouput            [CLS] Token과 Task Specific Parameter의 곱에 Softmax를 취하여 Ouput 추출                  Text Similarity Ouput            [CLS] Token을 활용하여 Task Specific Parameter와 곱한 후 sigmoid function을 사용하여 Score를 예측                  Pairwise Text Classification Ouput            BERT와 다르게 Stochastic Answer Network(SAN)를 이용함                    NLI의 기존 SOTA 모듈, 주어진 문장들에 대한 Multi-step Reasoning을 모델링하는 구조 (한번에 classification 결과를 예측하지 않고 여러번의 예측을 통한 Reasoning으로 결과를 예측)           SAN은 GRU모듈에 주어진 문장쌍의 representation을 Input 및 hidden state로 넣는 과정을 k번 반복함으로써 정제된 representation을 얻고 이를 이용하여 최종 예측                                 각 step을 진행할때마다 linear classifier를 거쳐 각 클래스에 대한 확률 분포 계산         모든 K-step output을 평균하여 클래스에 대한 최종 확률 분포를 계산, averaging 연산 전에 stochastic prediction droput을 적용         Relevance Ranking Ouput            Question과 문장 Pair Input으로 넣어 생성한 [CLS] Token에 Sigmoid를 취하여 문장 별로 점수를 Scoring하고 가장 높은 점수 만 Question에 해당하는 정답이 있다고 예측하는 방식              Training Procedure      Experiments     Datasets            GLUE 벤치마크는 QA, Sentiment Analysis, Text Similarity, Textual Entailment를 포함한 NLU task       SNLI 데이터셋은 570K개의 문장 쌍       SciTail은 Science Question Answering 데이터셋에서 파생된 Textual Entailment 데이터셋임                    주어진 전제가 주어진 가설을 수반하는지 여부를 평가                                  Implementation details            Optimizer : Adamax       learning rate : 5e-5       Batch Size : 32       Maximum number of epoch : 5       Fine-tuning layer dropout : task마다 다르게 설정(MNLI:0.3, CoLA:0.05, Else:0.1)       Tokenizer : WordPiece           Experiments - GLUE Results         MT-DNN이 BERT보다 전체 성능이 약 1.8% 향상됨   각각의 Task 결과가 대부분 SOTA임        Dataset이 적은 Task(MRPC, RTE)의 경우 비교적 높은 성능 향상이 있음              Specific layer로 SAN 사용, pairwise ranking을 한 효과를 보여주는 실험   BERT vs ST-DNN            ST-DNN은 BERT처럼 single-task로 fine-tunning함       MNLI, QQP, MRPC, QNLI에서 BERT보다 성능이 좋음           ST-DNN vs MT-DNN            데이터가 적은 실험에서 더 큰 성능향상이 있음           Experiments - Domain Adaptation Results         SNLI와 SciTail에 MT-DNN을 적용한 실험   MT-DNN은 데이터를 0.1%만 써도 성능이 잘나옴   MT-DNN이 BERT보다 데이터가 적을 때, 압도적인 성능을 보여줌   Conclusion      Multi-task learning model과 pre-training을 결합한 MT-DNN 모델 제안   MT-DNN은 SNLI, SchiTail 및 GLUE에서 10가 NLU task에 높은 성능 향상 결과를 얻음   MT-DNN은 Domain Adaption 실험에서도 탁월한 일반화 기능을 보여줌   MT-DNN 개선을 위해 MTL에서의 모델 구조 공유에 더 깊은 이해, fine-tuning과 pre-training을 위한 더 효과적인 훈련 방법을 더 연구해야함  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 클래스와 객체",
        "excerpt":"Part5 클래스와 객체   클래스 선언     클래스            자바는 객체를 만들기 위해 반드 클래스를 먼저 만들어야 한다. 클래스는 객체를 만들기 위한 일종의 틀이다.                    붕어빵이 객체라면, 붕어빵 틀은 클래스           자동차 클래스 생성           컴파일하여 디스크에 Car라는 클래스를 생성한다.           자동차 클래스가 생성되었다고 해서 자동차가 만들어 진것은 아니다.                                   public class Car{         }        Car객체 생성하기 (자동차 만들기)            new 연산자는 new 연산자 뒤에 나오는 생성자를 이용하여 메모리에 객체를 만들라는 명령.       메모리에 만들어진 객체를 인스턴스(instance)라고도 한다.       이렇게 만들어진 객체를  참조하는 변수가 c1, c2 이다.       아래의 코드가 실행되면 Car라는 객체가 2개가 만들어지고 각각의 객체를 참조하는 c1과 c2변수가 선언된다.                   public class CarExam{              public static void main(String args[]){                 Car c1 = new Car();                 Car c2 = new Car();             }          }  참조타입  참조형 타입은 기본형 타입을 제외한 모든 타입입니다. 앞서 배웠던, 배열도 참조형이고, 클래스도 모두 참조 타입이다.     기본형 타입: boolean, char, byte, short, int, long, float, double   참조형 타입: 기본형 타입을 제외한 모든 타입   참조형 변수            Stirng str = new String(“Hello);                    str 변수 앞에 기본형 타입이 아닌 String 클래스가 적혀있다.           이퀄(=) 뒤에는 new 다음에 생성자라는 것이 있다.           new 라는 키워드는 객체를 메모리에 올려준다. 이렇게 메모리에 올라간 객체를 인스턴스라고 말한다.                       메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 레퍼런스 하는 변수가 str 이다. 레퍼런스 한다라는 것은 변수가 인스턴스를 가지고 있는게 아니라 말 그대로 가리킨다는 의미이다.       str이라는 변수에는 메모리의 위치 값이 저장되는 것이다. 메모리의 위치값이 저장된다고 하더라도,  어떤 메모리에 저장되는지 그 정보를 알 수 있는 방법은 없다. 그렇기 때문에 str변수는 String 인스턴스를 참조한다라고만 알면 된다.           String 클래스  문자열을 표현하는 자바에서 가장 많이 사용하는 클래스    자바 인스턴스 생성 방법     new 연산자를 이용하지 않고 인스턴스를 만드는 경우            “hello”라는 문자열이 메모리 중에서 상수가 저장되는 영역에 저장된다. 상수는 변하지 않는 값을 의미.       String str2 = “hello”; 이 문장이 실행될 때에 hello 라는 문자열 상수는 이미 만들어져 있으므로 str1이 참조하는 인스턴스를 str2도 참조한다.               String str1 = \"hello\";     String str2 = \"hello\";      new 연산자를 이용해서 인스턴스를 만드는 경우            new연산자를 이용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어진다.       String str4 = new String(“hello”); 이 문장이 실행될때도 새롭게 만들게 되므로, str3 과 str4는 서로 다른 인스턴스를 참조한다.       변수끼리 == 로 비교하면 서로 같은 것을 참조하는지 비교한다.       String은 다른 클래스와 다르게 new를 사용하지 않고 사용할 수 있다. 메모리를 아끼려면 String은 new를 사용하지 않고 사용하는 것이 좋다.       String은 불변 클래스이다. 불변이란 String이 인스턴스가 될때 가지고 있던 값을 나중에 수정할 수 없다.       String은 문자열과 관련된 다양한 메소드를 가지고 있다. 메소드를 호출한다 하더라도 String은 내부의 값이 변하지 않는다.       String이 가지고 있는 메소드중 String을 반환하는 메소드는 모두 새로운 String을 생성해서 반환한다.               String str3 = new String(\"hello\");     String str4 = new String(\"hello\");  필드(filed) 선언  자동차는 자동차 이름, 자동차 번호를 가지고 있고, 자동차는 달리고 멈추는 기능이 있따. 여기에서 가지고 있는 것을 속성이라고 한다. 자바에서는 이러한 속성을 필드(Field)라는 용어로 사용한다.     이름과 번호를 필드로 가지고 있는 Car 클래스 선언       public class Car{         String name;             int number;     }     Car 클래스를 인스턴스화 하기       Car c1 = new Car();     Car c2 = new Car();     //Car라는 인스턴스가 메모리에 2개 만들어 진다. 객체별로 name과 number라는 속성을 가진다.     속성 이용하기            참조 변수 다음에 나오는 점(dot)은 참조변수가 참조하는 객체가 가지고 있는 것을 사용할 때 사용               //c1.name은  c1이 참조하는 객체의 name 을 의미.      c1.name = \"소방차\";  //c1이 참조하는 객체의 name을 소방차로 설정      c1.number = 1234;   // c1.number = 1234란 c1이 참조하는 객체의 number를 1234 로 설정       c2.name = \"구급차\"  //c2가 가리키는 객체의name을 구급차로 설정     c2.number = 1004;  //c2가 가리키는 객체의 number를 1004로 설정       System.out.println(c1.name);  //콘솔에 c1이 참조하는 객체의 name 을 출력합니다.      System.out.println(c1.number); //콘솔에 c1이 참조하는 객체의 number 를 출력합니다.       String name = c2.name;   //c2가 참조하는 객체의 name 을 String 타입 변수 name 도 참조하게 합니다.  메소드란?     필드가 물체의 상태라면, 물체의 행동에 해당하는게 메소드다. car에 이름과 번호가 있기도 하지만, car는 앞으로 전진할 수도 있고 후진하는 행동도 할 수 있다.            메소드는 입력값이 있고, 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념이다.       이때 입력값을 매개변수라고 하고, 결과값을 리턴값이라고 한다.                    인자(Argument)는 어떤 함수를 호출시에 전달되는 값을 의미한다.           매개 변수(Parameter)는 그 전달된 인자를 받아들이는 변수를 의미한다.                       메소드란 클래스가 가지고 있는 기능이다. 클래스 안에 선언된다.           메소드(Method) 선언     매개변수도 없고 리턴하는 것도 없는 형태의 메소드            리턴하는 것이 없을 경우 void라고 작성합니다.               public class MyClass{         public void method1(){             System.out.println(\"method1이 실행됩니다.\");         }     }          정수를 받아들인 후, 리턴하지 않는 메소드            받아 들이는 값은 어떤 타입이라도 상관없다.       받아 들이는 값의 수는 여러개 일 수 있다. 여러개일 경우 콤마(,)로 구분한다.               public class MyClass{                public void method2(int x, int y){             System.out.println(x + \" 를 이용하는 method2입니다.\");         }        }          정수를 받아들인 후, 정수를 반환하는 메소드       public int method3(int y){         System.out.println(y + \" 를 이용하는 method5입니다.\");         return 5;     }       String 클래스의 메소드     문자열 길이 구하기            str.length()는 str이 참조하는 문자열의 길이를 구해서 int 타입으로 리턴해주는 메소드이다.           문자열 붙이기(concat)            str.concat(“world”) 메소드는 str이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world를 붙여서 String 타입으로 리턴하는 메소드다.       String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.           문자열 자르기(subString)            str.subString(1,3)은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.       str.subString(2)는 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.           변수의 scope와 static  변수의 scope: 프로그램상에서 사용되는 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의스코프라고 한다.     변수가 선언된 블럭이 그 변수의 사용범위이다.            클래스의 속성으로 선언된 변수 globalScope의 사용 범위는 클래스 전체이다.       매개변수로 선언된 int value는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭 내이다.       메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭 내이다.               public class ValableScopeExam{          int globalScope = 10;   // 인스턴스 변수           public void scopeTest(int value){                int localScope = 10;             System.out.println(globalScope);             System.out.println(localScpe);             System.out.println(value);         }     }          main메소드에서 사용하기            같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.       main은 static한 메소드이다. static한 메소드에서는 static 하지 않은 필드를 사용 할 수 없다.               public class VariableScopeExam {         int globalScope = 10;           public void scopeTest(int value){             int localScope = 20;                         System.out.println(globalScope);             System.out.println(localScope);             System.out.println(value);         }            public static void main(String[] args) {             System.out.println(globalScope);  //오류             System.out.println(localScope);   //오류             System.out.println(value);        //오류           }        }          static            같은 클래스 내에 있음에도 해당 변수들을 사용할 수 없다.       main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메소드를 static 한 메소드라고 한다.       static한 필드(필드 앞에 static 키워드를 붙임)나, static한 메소드는 Class가 인스턴스화 되지 않아도 사용할 수 있다.               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }          static한 변수는 공유된다.            static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.       globalScope같은 변수(필드)는 인스턴스가 생성될 때 생성되기 때문에 인스턴스 변수라고 한다.       staticVal같은 static한 필드를 클래스 변수라고 한다.       클래스 변수는 레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는 것이 더 바람직하다.                    VariableScopeExam.staticVal                               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }       열거형(enum)     자바는 열거타입을 이용하여 변수를 선언할 때 변수타입으로 사용할 수 있다.            열거형은 JDK5에서 추가되었다.       JDK5 이전에는 상수를 열거형 대신 사용                    상수를 이요한는 방법                               public class EnumExam {         public static final String MALE = \"MALE\";         public static final String FEMALE = \"FEMALE\";          public static void main(String[] args) {             String gender1;              gender1 = EnumExam.MALE;             gender1 = EnumExam.FEMALE;                           }     }          상수를 사용했을 때의 문제점            String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에   gender1 = “소년”; 이렇게 수행 되어도 전혀 문제가 되지 않는다.       실행할 때 원했던 값인 MALE,FEMALE이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.           해결 방법            이런 문제를 발생시키지 않게 하기 위해 열거형을 사용한다.       열거형 정의 및 사용 방법               // 정의 방법     enum Gender{         MALE, FEMALE;     }            // 사용 방법     Gender gender2;      gender2 = Gender.MALE;     gender2 = Gender.FEMALE;      //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.            enum에 대해서 좀 더 궁금하다면!! enum의 뿌리   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part6 클래스 다듬기 ",
        "excerpt":"Part6 클래스 다듬기   생성자  모든 클래스는 인스턴스화 될 때 생성자를 사용한다.      생성자의 특징            생성자는 리턴타입이 없다.       생성자를 프로그래머가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어진다.       매개변수가 없는 생성자를 기본생성자라고 한다.       생성자를 하나라도 프로그래머가 만들었따면 기본생성자는 자동으로 만들어지지 않는다.           생성자의 역할            생성자가 하는 일은 객체가 될 때 필드를 초기화 하는 역할을 수행한다.       자동차가 객체가 될 때 반드시 이름을 가지도록 하려면, Car 클래스를 다음과 같이 만들어야 한다.               public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }            // 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법     public class CarExam2{         public static void main(String args[]){                  Car c1 = new Car(\"소방차\");             Car c2 = new Car(\"구급차\");             //Car c3 = new Car(); // 컴파일 오류가 발생합니다.                  System.out.println(c1.name);                  System.out.println(c2.name);         }     }     // Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.       this  this는 현재 객체, 자기 자신을 나타낸다.      this의 사용       public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }                 Car 클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽게 알 수 없다.       n 으로 쓰기 보다는 name 으로 사용하는 것이 좋다.               public Car(String name){         name = name;     }                 “name=name”이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 “name=name”이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.       즉, 필드는 바뀌지 않는다. 이런 경우 필드라는 것을 컴파일러와 JVM에게 알려주기 위해서 this 키워드를 사용해야 한다.               public Car(String name){         this.name = name;     }                 앞의 this.name은 필드 name을 말하고 =(이퀄) 뒤의 name은 매개변수를 의미한다.       즉 매개변수의 값을 필드에 대입하라는 의미가 된다.           클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.   메소드 오버로딩     매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게하는 기술   메소드 오버로딩            이름은 같지만 매개변수가 다른 메소드       메소드 오버로딩은 매개변수 부분이 달라야 한다.       매개변수의 타입과 개수가 동일한 메소드를 또 정의 할 수는 없다.           오버로딩된 메소드 이용하기            메소드의 인자에 어떤 값이 쓰이냐에 따라서 각기 다른 메소드가 호출된다.               public MethodOverloadExam{         public static void main(String args[]){             MyClass2 m = new MyClass2();             System.out.println(m.plus(5,10));             System.out.println(m.plus(5,10,15));             System.out.println(m.plus(\"hello\" + \" world\"));         }     }  생성자 오버로딩과 this     생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.            생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.       매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.               public class Car{         String name;         int number;          public Car(){          }          public Car(String name){             this.name = name;         }          public Car(String name, int number){             this.name = name;             this.number = number;         }     }     오버로딩된 생성자 이용하기   public class CarExam4{     public static void main(String args[]){         Car c1 = new Car();         Car c2 = new Car(\"소방차\");         Car c3 = new Car(\"구급차\", 1234);     } }     자기 생성자 호출하는 this()            기본생성자를 호출하였을 때 name을 “이름없음”, 숫자를 0으로 초기화 하기               public Car(){         this.name = \"이름없음\";         this.number = 0;     }       -     - 위처럼 작성했을 경우 코드의 중복이 일어난다.     - 자신이 가지고 있는 다른 생성자를 이용할 수 있다.       public Car(){         this(\"이름없음\", 0);     }       패키지  패키지(package)란 서로 관련이 있는 클래스 또는 인터페이스들을 묶어 놓은 묶음이다. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록 하고, 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 관리를 편하게 해준다.     패키지 정의방법            package이름은 보통 도메인 이름을 거꾸로 적은 후, 그 뒤에 프로젝트 이름을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.       package이름은 폴더명 점 폴더명 점 폴더명 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.       도메인 이름이 8cruz.com 이고 프로젝트 이름이 javastudy 라면 com.eightcruz.javastudy.Hello 로 패키지를 지정 할 수 있다.                    도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.           도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.                           패키지에 생성된 클래스 사용하기            java.lang 패키지를 제외하고는 다른 패키지에 있는 클래스를 사용하려면 import라는 구문을 적어줘야 한다.                    import com.eightcruz.javastudy.Hello;           import com.eightcruz.javastudy.*;                            해당 패키지에 있는 모든 클래스를 사용한다는 의미                                                   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_06/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 상속",
        "excerpt":"Part7 상속   상속     상속이란? 부모가 가진것을 자식에게 물려주는 것을 의미한다.            노트북은 컴퓨터의 한 종류다.       침대는 가구의 한 종류다. 혹은 침대는 가구다.       소방차는 자동차다.           이렇게 말할 수 있는 관계를 is a 관계 혹은 kind of 관계라고 한다.      Car를 상속받은 Bus를 class로 표현하는 방법            자바는 클래스 이름 뒤에 extends 키워드를 적고 부모 클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.       상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있께 된다.               public class Car{      }      public class Bus extends Car{      }     부모 클래스와 자식 클래스의 메소드            자식 클래스는 부모 클래스에 선언된 메소드를 사용할 수 있다.       자식 클래스는 부모가 가지고 있는 메소드 외에 추가로 메소드를 선언할 수 있다.                    이것을 확장하였다고 표현한다.                           접근제한자  접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.      접근 제한자의 종류            public                    어떤 클래스든 접근할 수 있다는 것을 의미                       protected                    자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속받은 자식 클래스에서는 접근할 수 있다는 것을 의미                       private                    자기 자신만 접근할 수 있다는 것을 의미                       접근제한자를 적지 않으면 default 접근 지정자                    자기자신과 같은 패키지에서만 접근할 수 있다는 것을 의미(상속X)                       public &gt; protectd &gt; default &gt; private           추상클래스  추상 클래스란 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하는데 새, 포유류 같은 것은 구체적이지 않다.     추상 클래스 정의하기            추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.       추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.                    추상 메소드란, 내용이 없는 메소드이다. 즉 구현이 되지 않은 메소드이다.           추상 메소드는 리턴 타입 앞에 abstract라는 키워드를 붙여야 한다.                       추상 클래스는 인스턴스를 생성할 수 없다.               public abstract class Bird{         public abstract void sing();          public void fly(){             System.out.println(\"날다.\");         }     }     추상 클래스를 상속받는 클래스 생성하기            추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 반드시 구현해야 한다.       추상 클래스를 상속받고, 추상 클래스가 갖고 있는 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다.           super와 부모생성자     class가 인스턴스화 될 때 생성자가 실행되면서 객체의 초기화를 한다. 그 때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.            new 연산자로 자식 객체를 생성하면, 자식객체가 메모리에 올라갈 때 부모인 객체도 함께 메모리에 올라간다.       생성자는 객체를 초기화 하는 일을한다.       생성자가 호출될 때 자동으로 부모의 생성자가 호출되면서 부모객체를 초기화 하게된다.           super            자신을 가리키는 키워드가 this 라면, 부모를 가리키는 키워드는 super       super()는 부모의 생성자를 의미한다.       부모의 생성자를 임의로 호출하지 않으면, 부모 class의 기본 생성자가 자동으로 호출된다.           부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법            클래스는 기본 생성자가 없는 경우도 존재한다.               public Bus(){         super(\"소방차\"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.         System.out.println(\"Bus의 기본생성자입니다.\");     }  super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용한다.   오버라이딩  오버라이딩이란 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것이다. 즉 오버라이딩이란 메소드를 재정의 하는 것이다.     메소드 오버라이딩            메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출된다.       오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.                    super 키워드를 이용하면, 부모의 메소드를 호출 할 수 있다.                               //run 메소드를 가지고 있는  Car클래스      public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      //Car 를 상속받는 Bus 클래스      public class Bus extends Car{      }          //오버라이딩     public class Bus extends Car{         public void run(){             System.out.println(\"Bus의 run메소드\");         }     }        //super 키워드     public class Bus extends Car{         public void run(){             **super.run();**  // 부모의  run()메소드를 호출              System.out.println(\"Bus의 run메소드\");         }     }     오버라이딩 vs 오버로딩  오버로딩(Overloading) : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술  오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용    클래스 형변환  부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.     형변환       public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      public class Bus extends Car{         public void ppangppang(){             System.out.println(\"빵빵.\");         }        }  상속 관계란 is a 관계다. “Bus는 Car다.”라는 관계가 성립된다.      부모타입으로 자식객체를 참조할 수 있다.            부모타입으로 자식객체를 참조하게 되면 부모가 있는 메소드만 사용할 수 있다.               public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             car.ppangppang(); // 컴파일 오류 발생         }     }     ppangppang()메소드를 호출하고 싶다면 Bus 타입의 참조변수로 참조 해야한다.       public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             //car.ppangppang(); // 컴파일 오류 발생              Bus bus = (Bus)car;  //부모타입을 자식타입으로 형변환              bus.run();             bus.ppangppang();         }     }     객체들 끼리도 형변환이 가능하다. 단 상속관계에 있었을 때만 가능하다.   부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환이 일어난다.   부모타입의 객체를 자식타입으로 참조하게 할 때는 명시적으로 형변환 해주어야 한다. 단, 이렇게 형변활 할때에는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능하다.      과연 이 형변환을 왜 언제 사용할까! 라는 의문을 가졌다면,,,, 이런 상황들을 생각해보자  첫번째, VIP 회원을 VVIP 회원으로 등급을 올려줄 때  두번째, 모험가 직업을 가진 플레이어가 전사 직업을 가지게 되었을 때…  보통 다형성을 활용하려고 사용한다고 한다… 코드 한줄만 바꿔도 돌아갈수 있도록…?   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.6 제어문)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.6 제어문     일부 구문인 반복문, 스위치문들은 데이터에 적용된 시험결과에 따라 일련의 연산이 실행되는 조건부 실행이 요구된다.   기계어 코드에서는 조건부 동작을 구현하기 위해 두 개의 기본적인 낮은 수준의 방법을 제공한다.            데이터 값들을 시험해서 이 시험 결과에 따라 데이터흐름이나 제어흐름을 변경한다.           기계어 인스트럭션들의 실행 순서는 점프jump 인스트럭션으로 변경할 수 있다.   점프 인스트럭션은 때에 따라서는 어떤 시험의 결과에 따라 프로그램의 다른 일부분으로 제어를 넘겨준다.   3.6.1 조건 코드     정수 레지스터들과 함께 CPU는 가장 최근 산술 또는 논리연산의 특성을 설명하는 단일 비트 조건 코드로 구성된 레지스터들을 운영한다.   이 레지스터들은 조건부 분기를 수행하기 위해서 시험될 수 있다.            CF: 캐리 플래그Carry flag. 가장 중요한 비트로부터 받아 올림이 발생한 것을 표시. 비부호형 연산에서 오버플로우를 검출할 때 사용       ZF: 영 플래그Zero flag. 연산의 결과가 0인 것을 표시       SF: 부호 플래그Sign flag. 연산이 음수를 생성한 것을 표시       OF: 오버플로우 플래그Overflow flag. 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시           leaq 인스트럭션은 주소계산에 사용하기 위한 것이므로 조건 코드를 변경하지 않는다.           반면에, 위의 그림에 나열된 모든 인스트럭션들은 조건 코드 값을 변경한다.            XOR 같은 논리연산에서는 캐리와 오버플로우 플래그가 0으로 세팅된다.       쉬프트 연산에서는 캐리 플래그가 쉬프트되어 없어지는 마지막 비트로 설정되며, 오버플로우 플래그는 0으로 세팅된다.           위의 그림의 인스트럭션들에 의해 조건 코드 값이 변경될 뿐만 아니라, 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 두 개의 인스트럭션 클래스가 있다.(아래의 그림 참조)    CMP 인스트럭션들은 만일 두 오퍼랜드가 같으면 영 플래그르 1로 설정한다. 다른 플래그들은 두 오퍼랜드의 순서관계를 결정하는 데 사용될 수 있다.   TEST 인스트럭션은 목적지 오퍼랜드를 변경하지 않으면서 조건 코드를 설정하는 점만 제외하고는 AND 인스트럭션과 같은 방식으로 동작한다.   3.6.2 조건 코드 사용하기     조건 코드를 이용하는 보편적인 세 가지 방법이 있다.            조건 코드의 조합에 따라 0 또는 1을 한 개의 바이트에 기록       조건에 따라 프로그램의 다른 부분으로 이동하는 방법       조건에 따라 데이터를 전송하는 방법              SET 인스트럭션         첫 번째 경우의 인스트럭션의 클래스를 SET 인스트럭션이라고 부른다.   이 인스트럭션들은 접미어를 이용해서 오퍼랜드의 크기를 나타내는 것이 아니라, 조건 코드의 어떤 조합을 사용할 것인지를 나타낸다.            ex) setl, setb -&gt; long word와 byte를 의미하지 않고 less와 below를 의미한다.           SET 인스트럭션은 목적지로 하위 단일 바이트 레지스터 가운데 한 개나 단일 바이트 메모리 주소를 사용하며, 이 바이트를 0이나 1로 기록한다.            32비트나 64비트 결과를 만드려면, 다른 상위 비트들을 0으로 만들어줘야 한다.           a&lt;b를 계산하는 전형적인 인스트럭션은 아래의 그림과 같이 작성된다.    3.6.3 점프jump 인스트럭션     일반적인 실행의 경우, 인스트럭션들은 나열된 순서에 따라 순차적으로 실행된다.   점프 인스트럭션은 프로그램이 완전히 새로운 위치로 실행을 전환하도록 한다.   점프의 목적지는 일반적으로 어셈블리 코드에서는 레이블label로 표시한다.        인스트럭션 jmp .L1은 프로그램이 movq 인스트럭션을 건너뛰는 대신에 popq로 실행을 다시 시작하게 한다.   어셈블러는 모든 레이블이 붙은 인스트럭션들의 주소를 결정하고, 점프 인스트럭션의 일부분인 “점프 목적지jump target”을 인코딩한다.        위 그림은 여러 가지 점프 인스트럭션을 보여준다.   jmp 인스트럭션은 무조건적으로 점프한다.            점프 목적지가 인스트럭션의 일부로 인코딩 되는 경우에는 직접 점프       점프 대상을 레지스터나 메모리 위치로부터 읽어들여야 하는 경우에는 간접 점프           3.6.4 점프 인스트럭션 인코딩     점프 인스트럭션의 대상이 어떻게 인코딩 되는지 이해하는 것은 7장의 링커를 공부할 때 중요한 역할을 하게 된다.   어셈블리 코드에서, 점프 목적지는 심벌 레이블을 사용해서 작성한다.   점프를 인코딩하는 가장 일반적인 방법은 PC 상대적PC relative 방법이다.            대상 인스트럭션과 점프 인스트럭션 바로 다음에 오는 인스트럭션 주소와의 차이를 인코딩한다.                첫 번째 점프 인스트럭션의 목적지가 0x03으로 인코딩, 다음 인스트럭션의 주소인 0x05에 더하면 점프 목적지 주쇤 0x8을 얻을 수 있다.   PC-상대 주소지정을 수행할 때 프로그램 카운터의 값은 점프 인스트럭션 자신의 주소가 아니라, 점프 다음에 나오는 인스트럭션의 주소가 된다.   PC-상대 방식으로 점프 목적지를 인코딩하면, 인스트럭션들이 간결하게 인코딩(2바이트만 필요)될 수 있고, 목적코드는 수정 없이 메모리 상의 다른 위치로 이동될 수 있다.   3.6.5 조건부 분기를 조건제어로 구현하기     C에서 조건부 수식과 문장을 기계어 코드로 번역하는 가장 일반적인 방법은 조건부 및 무조건 점프를 함께 사용하는 것이다.   어셈블리 코드에서의 무조건 점프와 유사한 C의 goto문을 사용한다.            어셈블리 코드의 제어흐름을 설명하는 C 프로그램을 구성하는 방법으로 사용됨                     위의 그림은 조건문의 컴파일이다.            if-else             컴파일러는 else-문과 then-문에 대해 별도의 코드 블록을 생성한다.       정확한 블록이 실행되도록 조건부와 무조건 분기를 삽입한다.             3.6.6 조건부 이동으로 조건부 분기 구현하기     조건부 동작을 구현하는 전형적인 방법은 조건이 만족되면 프로그램의 한 가지 실행경로를 따르고, 아닌 경우에는 다른 경로를 따라가도록 하는 제어의 조건부 전환을 통해 이루어진다.            이 방법은 간단하고 일반적이지만 최신 프로세서들에서는 매우 비효율적일 수 있다.           또 다른 전략은 데이터의 조건부 전송을 이용하는 것이다.            이 방법은 조건부 동작의 산출물 모두를 계싼하고 조건에 따라 하나만 선택하는 방식이다.       최신 프로세서의 성능특성과 잘 일치하는 간단한 조건부 이동move 인스트럭션으로 구현될 수 있다.                C버전을 공부하면, 이것이 y-x와 x-y 모두를 계산해서 rval, eval로 명명한다는 것을 알 수 있다.            x가 y보다 크거나 같은지 테스트하고, 만일 그렇다면, eval을 Rval로 명명한다는 것을 알 수 있다.           조건부 제어 이동 기반 코드보다 조건부 데이터 이동 코드가 성능이 우수한 이유를 이해하기 위해서는 최신 프로세서들이 어떻게 동작하는지 이해해야 한다.            프로세서들은 각 인스트럭션을 일련의 단계로 처리하며, 이 단계들은 각각 요구된 동작의 작은 부분만을 실행하는 파이프라인을 통해 높은 성능을 얻는다.       이를 위해서는 파이프라인을 실행할 인스트럭션들로 미리 채우기 위해 실행할 인스트럭션들의 순서를 훨씬 일찍 결정할 수 있어야 한다.       결과적으로 분기의 예측오류 손실이 함수의 성능을 결정한다.                    위의 그림은 x86-64로 가능한 조건부 이동 move 인스트럭션을 보여준다.   이들 인스트럭션은 두 개의 오퍼랜드를 갖는다.            소스 레지스터 또는 메모리 위치 S, 그리고 목적지 레지스터 R.           인스트럭션들의 결과는 조건 코드 값에 따라 달라진다.   소스 값은 메모리나 소스 레지스터로부터 읽히지만, 목적지에는 명시된 조건이 만족될 때만 복사된다.      이 이후로 조건부 분기의 “분기의 예측 오류”에 관한 내용이 나온다.   조건부 이동은 조건부 점프와는 달리 결과를 예측하지 않고서도 해당 인스트럭션을 실행할 수 있다.  조건부 이동을 사용한다고 해서 언제나 코드 효율성을 개선할 수 있는 것은 아니다.  컴파일러는 낭비되는 계산량과 분기 예측오류에 의한 잠재적 성능 손실 사이의 상대적 성능을 고려해야 한다.   등의 내용이 담겨져 있는데 이해하기 조금 힘들다….   3.6.6은 뒷부분을 좀 더 읽고 다시 읽으러 돌아오자!!!!!!!    조건부 분기에 따른 실제 어셈블리 코드     조건부 분기를 구하는 방법은 3.6.2에서 세가지 방법이 있다고 했으며, 3.6.5절과 3.6.6절에 조건제어와 조건부이동 두가지로 더욱 자세한 설명으로 풀어냈다. 두 가지의 방법은 예제코드를 활용하여 설명해줬는데 다음의 예제코드와 같다. (C 언어로 작성 되어있다.)    long absdiff(long x, long y){   long result;   if(x&lt;y) result = y - x;   else reuslt = x - y;   return result; }     이 코드를 가지고 if문의 여러가지 어셈블리어로 표현할 수 있다고 표현하는데, 나는 같은 코드인데 기계는 어떻게 알고 다른 어셈블리어들을 생성해내는지가 너무 긍금했다.  다시말해 기계는 언제 조건부 이동을 하여 컴파일을하고, 언제 조건제어를 하여 컴파일을 하는지 너무 궁금했다!!!  궁금증을 참지 못하고 윈도우 환경에서 gcc 컴파일을 진행하였다.          tdm-gcc를 설치했다.     터미널에 gcc -v 명령어를 입력하면 설치 완료를 확인할 수 있다.     위 예제의 코드를 txt 파일로 작성했다.(파일 이름은 p1으로 하였다.)     gcc -S p1.c 명령어를 입력하면 어셈블리 코드를 생성할 수 있다.     gcc -S -Og p1.c 명령어를 입력하면 컴파일 최적화를 진행한다.     -Og, -O1, -O2 …으로 설정하면 단계별로 최적화를 적용한다.        다음의 그림은 default, -Og, -O1, -O2 의 결과다.  가독성을 위해서 main문과 디렉티브문은 삭제하였다.(*디렉티브: 어셈블러와 링커에 지시하기 위한 문장)       //최적화 없음 absdiff:    pushq   %rbp    .seh_pushreg   %rbp    movq   %rsp, %rbp    .seh_setframe   %rbp, 0    subq   $16, %rsp    .seh_stackalloc   16    .seh_endprologue    movl   %ecx, 16(%rbp)    movl   %edx, 24(%rbp)    movl   16(%rbp), %eax    cmpl   24(%rbp), %eax    jge   .L2    movl   24(%rbp), %eax    subl   16(%rbp), %eax    movl   %eax, -4(%rbp)    jmp   .L3 .L2:    movl   16(%rbp), %eax    subl   24(%rbp), %eax    movl   %eax, -4(%rbp) .L3:    movl   -4(%rbp), %eax    addq   $16, %rsp    popq   %rbp    ret  //Og로 최적화함 absdiff:    cmpl   %edx, %ecx    jge   .L2    movl   %edx, %eax    subl   %ecx, %eax .L1:    ret .L2:    movl   %ecx, %eax    subl   %edx, %eax    jmp   .L1   //O1으로 최적화함 absdiff:    movl   %edx, %r8d    subl   %ecx, %r8d    movl   %ecx, %eax    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret   //O2으로 최적화함 absdiff:    movl   %edx, %r8d    movl   %ecx, %eax    subl   %ecx, %r8d    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret     Og가 본문의 조건제어, O1이 조건이동에서 설명한 어셈블리어로 표현되어있다.  유레카를 발견한 것처럼…. 너무 속이 시원했다….  컴파일 명령어에서 최적화의 수준에 따라 어셈블리어 인코딩이 달라진다는 것을 직접 확인할 수 있었다.    3.6.7 반복문     C에서는 여러가지 반복문 구문을 제공한다.            do-while, while, for       기계어에는 반복문에 대응되는 인스트럭션이 없다.       그렇기 때문에 조건부 테스트와 점프를 함께 사용해서 반복문의 효과를 구현한다.                 do-while            body-statement를 반복적으로 실행하고, test-expr를 계산하여 조건에 따라 반복 수행을 계속한다.       body-statement가 적어도 한 번은 실행되는 점이 특이사항이다.               do         body-statement         while (test-expr);        while            while문은 test-expr를 먼저 계산해서, body-statement를 실행하기 전에 종료될 수 있다.       do-while 루프에서 우리가 본 것과 루프 구조가 동일하고, 초기 테스트의 구현방법에서만 다르다.               while (test-expr)         body-statement                     while문은 두가지 번역 방법이 있다.                    중간으로-점프jump-to-middle            조건부 do 번역 사용guarded-do                            for       while (test-expr)         body-statement           init-expr;     while (test-expr){         body-statement         update-expr;     }                 두 반복문이 동일한 동작을 한다.       먼저 초기화 수식인 init-expr를 계산한다.       테스트 조건인 test-expr를 계산하는 곳에서 루프에 들어가며       테스트가 실패하면 루프를 빠져나오고, 반복문 body-statement를 실행한다.       마지막으로 update-expr를 계산한다.       for 루프에 대해 생성된 어셈블리 코드는 최적화 수준에 따라 while 루프의 번역 전략중 하나를 따른다.           3.6.8 Switch문     Switch문은 정수 인덱스 값에 따라 다중분기 기능을 제공한다.   C 코드를 읽기 쉽게 해줄 뿐만 아니라 점프 테이블이라는 자료구조를 사용해서 효율적인 구현을 간응하게 한다.   switch문을 실행하는 데 걸리는 시간이 case의 수에 관계없다는 점이 장점이다.   switch문을 실행하는 데 있어서 핵심 단계는 점프 테이블을 통해서 코드의 위치로 접근하는 것이다.      ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.7 프로시져)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.7 프로시저      프로시저 호출은 소프트웨어에서의 주요 추상화다.   이들은 지정된 인자들과 리턴 값으로 특정 기능을 구현하는 코드를 감싸주는 방법을 제공한다.   프로그램의 여러 지점으로부터 호출될 수 있게 된다. 프로그램 상태에 무슨 효과를 갖는지에 대한 명쾌하고 간결한 인터페이스 정의를 제공한다.   프로시저는 서로 다른 프로그래밍 언어에서 여러가지 다른 모습으로 사용된다.            함수, 메소드, 서브루틴, 핸들러등       이 모두는 일반적인 특징들을 공유한다.           프로시저에 대한 기계어수준 지원을 제공할 떄 처리되어야 하는 여러가지 많은 특성들이 존재한다.   프로시저P가 프로시저Q를 호출하고, 다시 리턴할 경우            제어권 전달: PC는 Q에 대한 코드의 시작주소로 설정되고, 리턴할 때 P에서 Q를 호출하는 인스트럭션 다음의 인스트럭션으로 설정       데이터 전달: P는 하나 이상의 매개변수를 Q에 제공할 수 있어야 하며, Q는 다시 P로 하나의 값을 리턴할 수 있어야 한다.       메모리 할당과 반납: Q는 시작할 때 지역변수들을 위한 공간을 할당, 리턴할 때 이 저장소를 반납할 수 있다.           X86-64에서의 프로시저 구현은 레지스터와 프로그램 메모리 같은 머신의 자원들을 사용하는 방법에 관한 특수 인스트럭션들과 일련의 관습들과 연관되어있다.   프로시저가 요구하는 메커니즘만을 최소한으로 구현하는 최소주의자 전략으로 볼 수 있는 방식들을 따른다.   3.7.1 런타임 스택      프로시저 호출 동작방식의 주요 특징은 스택 자료구조가 제공하는 후입선출 메모리 관리 방식을 활용할 수 있다는 점이다.   프로시저 P가 프로시져 Q를 호출하는 에를 들 때            Q가 실행되고 있는 동안 P까지의 연속된 호출 중의 프로시저 P는 일시적으로 정지되는 것을 볼 수 있다.       Q가 실행되는 동안에는 자신의 지역변수를 위한 새로운 저장공간을 할당할 수 있는 능력이나 다른 프로시저로의 호출을 설정하는 능력만을 필요로 한다.       Q가 리턴할 때는 자신이 할당받은 로컬 저장장소는 반납될 수 있다.       따라서 프로그램은 스택을 사용해서 프로시저들이 요구하는 저장장소를 관리할 수 있으며, 스택과 프로그램 레지스터들은 제어와 데이터를 전송하기 위해, 그리고 메모리를 할당하기 위해 필요한 정보를 제공한다.           x86-64의 스택은 작은 주소 방향으로 성장하며, 스택 포인터 %rsp는 스택의 최상위 원소를 가리킨다.   데이터는 pushq와 popq 인스트럭션을 이용해서 스택에 저장되고 읽어올 수 있다.          아래 그림은 일반적인 스택 프레임 구조. 스택을 프로시저의 인자를 전달하고, 리턴 정보를 저장하며, 레지스터를 저장하고, 지역 저장공간의 목적으로 사용한다. 필요하지 않은 경우 일부분은 생략될 수 있다.           프로시저가 레지스터들에 저장할 수 있는 개수 이상의 저장공간을 필요로 할 때는 공간을 스택에 할당한다.            이 영역을 이 프로시저의 스택 프레임이라고 부른다.           현재 실행 중인 프로시저에 대한 프레임은 항상 스택의 맨 위에 위치한다.   대부분의 프로시저의 스택 프레임들은 프로시저가 시작될 때 할당되는 고정 크기를 갖는다.   시간과 공간 효율성을 위해 x86-64 프로시저는 요청받은 스택 프레임의 부분만을 할당한다.      스택 프레임에 대해서 조금 더 조사할 필요가 있으며, 공간 효율성에 대해서도 조사해보자.    3.7.2 제어의 이동      제어를 함수 P에서 함수 Q로 전달하는 것은 단순히 프로그램 카운터를 Q를 위한 코드의 시작주소로 설정하는 것과 관련된다.   나중에 Q가 리턴해야할 때가 오면 프로세서는 P의 실행을 다시 시작해야하는 코드 위치의 일부 기록을 갖고 있어야한다            인스트럭션 call Q로 프로시저 Q를 호출해서 기록된다.       주소 A를 스택에 푸시하고 PC를 Q의 시작으로 설정한다.       푸시된 주소 A는 리턴주소라고 불리며, call인스트럭션 바로 다음 인스트럭션의 주소로 계산된다.       ret는 주소 A를 스택에서 pop해오고 PC를 A로 세팅한다.        call 인스트럭션은 호출된 프로시저가 싲가하는 인스트럭션의 주소를 목적지로 갖는다.                  아래의 그림은 call과 ret 기능의 에제다. call 인스트럭션은 함수의 시작 부분으로 제어를 이동하는 반면, ret 인스트럭션은 call 다음에 오는 인스터럭션으로 제어를 되돌린다.           아래의 그림은 프로시저 콜과 리턴에 연관된 프로그램의 상세한 실행이다.           리턴 주소를 스택에 푸시하는 간단한 방법을 사용해서 함수가 나중에 프로그램이ㅡ 적절한 위치로 리턴이 가능하게 된다는 것을 알 수 있다.   스택이 제공하는 후입, 선출 메모리 관리 방식과 편리하게 일치한다.   3.7.3 데이터 전송      호출될 때, 그리고 프로시저가 다시 리턴하게 될 때 프로시저로 제어를 전달하는 것 뿐만 아니라, 프로시저 콜은 데이터를 인자로 전달하는 것과 관련되어 있으며, 프로시저에서 리턴하는 것도 어떤 값을 리턴하는 것과 관련되어 있을 수 있따.   대부분의 이들 프로시저로, 프로시저로부터의 데이터 전달은 레지스터를 통해서 일어난다.   x86-64에서는 최대 여섯 개의 정수형(즉, 정수와 포인터) 인자가 레지스터로 전달될 수 있다.   함수가 여섯 개 이상의 정수형 인자를 가질 때, 다른 인자들은 스택으로 전달된다.            인자 1~6은 적절한 레지스터들에 복사하고, 인자 7에서 n까지는 인자 7을 스택 탑에 넣는 방법으로 저장한다.                 3.7.4 스택에서의 지역저장공간      지역 데이터가 메모리에 저장되어야 하는 경우가 있다.            지역 데이터 모두를 저장하기에는 레지스터의 수가 부족하다.       지역변수에 연산자 ‘&amp;’가 사용되었으며, 이 변수의 주소를 생성할 수 있어야 한다.       배열 또는 구조체여서 이들이 배열이나 구조체 참조로 접근되어야 한다.       위 세가지의 경우에 “Local variables”로 명명된 스택 프레임의 일부분이 생겨난다           3.7.5 레지스터를 이용하는 지역저장소      프로그램 레지스터들은 모든 프로시저들이 공유하는 단일 자원의 역할을 한다.   피호출자는 호출자가 나중에 사용할 계획인 일부 레지스터 값은 덮어쓰지 않는다.   레지스터 %rbx, %rbp, %r12-%r15는 피호출자-저장 레지스터로 구분한다.   리턴하기 전에 스택에서 이전 값을 팝해오는 방식으로 레지스터를 보존한다.   레지스터 값들을 푸시하는 것은 “Saved registers”로 이름 붙인 스택 프레임의 일부분을 생성하는 효과를 갖는다.    3.7.6 재귀 프로시저     레지스터와 스택을 사용하는 것에 대해 설명한 관습으로 프로시저들이 이들을 재귀적으로 호출하는 것을 설명할 수 있다.   각 프로시저 콜은 스택상에 자신만의 사적인 공간을 가지며, 따라서 다수의 별도의 호출들의 지역변수들은 서로 간섭하지 않는다.   스택 운영방식은 프로시저가 호출될 때 지역저장소를 할당하고, 리턴하기 전에 이것을 반환하는 적절한 정책을 자연스럽게 제공한다.   스택 기법을 사용해서 함수의 각 호출 시에 상태정보를 위한 자신만의 개별적 저장곤간을 제공한다.   필요한 경우에는 지역변수를 위한 저장공간도 제공할 수 있다.   스택의 할당과 반환 동작은 자연스럽게 함수의 호출-리턴 순서와 일치한다.  ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_08/",
        "teaser": null
      },{
        "title": "[GitBlog] GitBlog 글 포스팅 후 커밋은 했지만, github.io에 적용이 안될 때",
        "excerpt":"사건의 개요    지금은 새벽 한시… csapp 공부가 조금 밀려서 공부를 하던 중에…   3.7절 프로시져에 대한 포스팅을 하려고 미리 csapp 포스트 탭을 만들고 커밋을 해두었다..  하지만, 아무리 새로고침을 해도 새로 포스팅한 글이 github.io에 업데이트가 안된다..    삽질    처음 깃블로그를 만들 때도 github.io에 업데이트가 되지 않는 끔찍함을 겪어서  몇번이고 레포를 새로 만들었던 끔찍한 기억이 떠올랐다.   지금까지 열심히 블로그에 글을 포스팅 했는데 이 글들을 다 날리는건가…?  무슨 캐시 충돌…? 뭐 서버 오류…? 어디선가 꼬였나…?  등등의 오만가지 생각이 들면서 지금까지 포스팅한 글을 지켜야겠다는 생각에 하던 공부를 올스탑했다..    새로운 레포도 파보고,, 글을 하나씩도 올려보고,, config파일을 수정도 해보고,, 캐시도 삭제해보고,,  커밋도 돌려보고,,, 별에 별짓을 다해보았다,,,l   사건 해결    한가지의 특징을 알게 되었다.   포스팅 날짜가 오늘 1월 31일로 되어있는 글만 업데이트가 되지 않는 것이었다.  오늘은 1월 31일 오전 1시였다.  드디어 알게되었다….  현재 날짜는 1월 31일이지만, 아직 새벽이기 때문에? (git 서버 시간의 기준이 다른 나라인가…?)   1월 31일로 작성된 글은 아직 github.io에 업데이트 되지 않는 것이구나!   결론  깃블로그를 처음 만들 때 글이 업데이트 되지 않는 오류 때문에 굉장히 힘들었었다.  하지만, 해당 오류는 서버와의 시간과 포스팅 시간이 맞지 않기 때문이었다!   다음부터 시간이 애매(새벽)하면 어제 날짜로 포스팅 하자!  이제부터 맘편히 깃블로그 포스팅을 하자!!!!      시간 날린게 너무 아깝다ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ  다시는 이런 바보같은 짓은 하지 말자…!   ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 인터페이스와 다른 형식의 클래스",
        "excerpt":"Part8 인터페이스와 다른 형식의 클래스   인터페이스 만들기  인터페이스: 서로 관계까 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템     인터페이스 정의하는 방법            추상 메소드와 상수를 정의 할 수 있다.               public interface TV{         public int MAX_VOLUME = 100;         public int MIN_VOLUME = 0;          public void turnOn();         public void turnOff();         public void changeVolume(int volume);         public void changeChannel(int channel);     }     인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.       public static final int MAX_VOLUME = 100;     public static final int MIN_VOLUME = 0;     인터페이스에서 정의된 메소드는 모두 추상 메소드이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.       public abstract void on();     public abstract void off();     public abstract void volume(int value);     public abstract void channel(int number);  인터페이스 사용하기     인터페이스 사용하는 방법            인터페이스는 사용할 때 해당 인터페이스를 구현하는 클래스에서 implements 키워드를 이용한다.               public class LedTV implements TV{         public void on(){             System.out.println(\"켜다\");         }         public void off(){             System.out.println(\"끄다\");            }         public void volume(int value){             System.out.println(value + \"로 볼륨조정하다.\");           }         public void channel(int number){             System.out.println(number + \"로 채널조정하다.\");                  }     }     인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.(추상클래스는 인스턴스를 만들 수 없음)       public class LedTVExam{         public static void main(String args[]){             TV tv = new LedTV();             tv.on();             tv.volume(50);             tv.channel(6);             tv.off();         }     }     참조변수의 타입으로 인터페이스를 사용할 수 있다. 이 경우 인터페이스가 가지고 있는 메소드만 사용할 수 있다.   만약 TV인터페이스를 구현하는 LcdTV를 만들었따면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것이다. 동일한 인터페이스를 구현 한다는 것은 클래스 사용법이 같다는 것을 의미한다.   클래스는 이러한 인터페이스를 여러개 구현할 수 있다.   인터페이스의 default method  JAVA 8이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.      default 메소드     인터페이스가 default키워드로 선언되면 메소드가 구현될 수 있다. 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.             return i + j;         }     }      //Calculator인터페이스를 구현한 MyCalculator클래스     public class MyCalculator implements Calculator {          @Override         public int plus(int i, int j) {             return i + j;         }          @Override         public int multiple(int i, int j) {             return i * j;         }     }      public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);         }     }     인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.      static 메소드     인터페이스에 static 메소드를 선언함으로써, 인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){             return i + j;         }         public static int exec2(int i, int j){   //static 메소드              return i * j;         }     }      //인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.        public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);              int value2 = Calculator.exec2(5, 10);  //static메소드 호출              System.out.println(value2);         }     }  내부클래스  내부 클래스란 클래스 안에 선언된 클래스    어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.     첫번째는 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언되는 경우. 보통 중첩클래스 혹은 인스턴스 클래스라고 한다.            내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 InnerExam1의 객체를 만든 후에 InnerExam1.Cal cal -= t.new Cal();과 같은 방법으로 Cal 객체를 생성한 후 사용한다.               public class InnerExam1{         class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam1 t = new InnerExam1();             InnerExam1.Cal cal = t.new Cal();             cal.plus();             System.out.println(cal.value);          }     }     두번째는 내부 클래스가 static으로 정의된 경우, 정적 중첩 클래스 또는 static 클래스라고 한다.            필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 InnerExam2 객체를 생성할 필요없이 new InnerExam2.Cal()로 객체를 생성할 수 있다.               public class InnerExam2{         static class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam2.Cal cal = new InnerExam2.Cal();             cal.plus();             System.out.println(cal.value);          }     }     세번째로는 메소드 안에 클래스를 선언한 경우, 지역 중첩 클래스 또는 지역 클래스라고 한다.            메소드 안에서 해당 클래스를 이용할 수 있다.               public class InnerExam3{         public void exec(){             class Cal{                 int value = 0;                 public void plus(){                     value++;                 }             }             Cal cal = new Cal();             cal.plus();             System.out.println(cal.value);         }                public static void main(String args[]){             InnerExam3 t = new InnerExam3();             t.exec();         }     }     네번째로는 익명클래스가 있다.            아래의 절로 이동하여 설명하겠다!           익명클래스  익명 중첩 클래스는 익명 클래스라고 보통 말하며, 내부 클래스이기도 하다.       //추상클래스 Action      public abstract class Action{         public abstract void exec();     }      //추상클래스 Action을 상속받은 클래스 MyAction     public class MyAction extends Action{         public void exec(){             System.out.println(\"exec\");         }     }      //MyAction을 사용하는 클래스 ActionExam      public class ActionExam{         public static void main(String args[]){             Action action = new MyAction();             action.exec();         }     }      //MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.     public class ActionExam{         public static void main(String args[]){             Action action = new Action(){                 public void exec(){                     System.out.println(\"exec\");                 }             };             action.exec();         }     }     생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻한다.   괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다. 이렇게 생성된 이름 없는 객체를 action이라는 참조변수가 참조하도록 하고, exec() 메소드를 호출한다.   익명클래스를 만드는 이유는 Action을 상속받는 클래스를 만들 필요가 없을 경우이다.   Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우이다.   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_08/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part9 예외처리",
        "excerpt":"Part9 예외처리   Exception  프로그램 실행중 예기치 못한 사건을 예외라고 한다. 예외 상황을 미리 예측하고 처리할 수 있는데, 이렇게 하는 것을 예외 처리라고 한다.       public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 5;             int k = i / j;             System.out.println(k);             System.out.println(main 종료!!);         }     }     위 코드에서 j를 0으로 바꾸면 Exception 발생            j를 0으로 바꾸면 Arithmetic Exception이 발생하면서 프로그램이 종료된다.       Java는 정수를 정수로 나눌 때 0으로 나누면 오류가 발생한다.           예외 처리            프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.           예외 처리하는 문법            오류가 발생할 예상 부분을 try라는 블록으로 감싼 후, 발생할 오류와 관련된 Exception을 catch라는 블록에서 처리한다.       오류가 발생했든 안했든 무조건 실행되는 finally라는 블록을 가질 수 있다.       finally 블록은 생략가능하다.               public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = i / j;                 System.out.println(k);             }catch(ArithmeticException e){                 System.out.println(\"0으로 나눌 수 없습니다. : \" + e.toString());             }finally {                 System.out.println(\"오류가 발생하든 안하든 무조건 실행되는 블록입니다.\");             }         }     }     실행결과            0으로 나눌 수 없습니다. :java.lang.ArithmeticException:/by zero  오류가 발생하든 안하든 무조건 실행되는 블록입니다.           Exception 처리하지 않았을 때는 프로그램이 강제 종료되었는데 catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행되는 것을 알 수 있다.   try 블록에서 여러종류의 Exception이 발생한다면 catch라는 블록을 여러개 둘 수 있다.   Exception 클래스들은 모두 Exception 클래스를 상속받으므로, 예외 클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 하나의 catch 블록에서 모든 오류를 처리 할 수 있다.   Throws  throws는 예외가 발생했을 때 예외를 호출한 쪽에서 처리하도록 던져준다.       public class ExceptionExam2 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j){             int k = i / j;             return k;         }     }  정수를 매개변수로 2개를 받아들인 후 나눗셈을 한 후 그 결과를 반환하는 divide 메소드  main 메소드에서는 divide 메소드를 호출   다음과 같이 divide 메소드를 수정       public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }     }  메소드 선언 뒤에 throws ArithmeticException이 적혀있는 것을 알 수 있다. 이렇게 적어놓으면 divide 메소드는 ArithmeticException이 발생하니 divide 메소드를 호출하는 쪽에서 오류를 처리하라는 뜻이다.       package javaStudy;     public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             } catch(ArithmeticException e){                 System.out.println(\"0으로 나눌수 없습니다.\");             }          }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }      }  Exception 발생시키기  강제로 오류를 발생시키는 throw   throw는 오류를 떠넘기는 trhows와 보통 같이 사용된다.       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j){             int k = i / j;             return k;         }        }     divide 메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.      위의 코드를 에러가 발생하지 않게 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);               }          public static int divide(int i, int j){             if(j == 0){                 System.out.println(\"2번째 매개변수는 0이면 안됩니다.\");                 return 0;             }             int k = i / j;             return k;         }     }     j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴   이렇게 할 경우 main 메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.   0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할 수도 있다.      에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     j가 0일 경우에 new연산자를 통하여 IllegalArgumentException 객체가 만들어 진다.   new 앞에 throw는 해당 라인에서 Exception이 발생한다는 의미이다.   즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌 수 없습니다. 라는 오류가 발생한 것이다.   Exception 클래스 이름을 보면 argument가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.      divide 메소드를 호출한 쪽에서의 오류 처리       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             }catch(IllegalArgumentException e){                 System.out.println(\"0으로 나누면 안됩니다.\");             }                    }          public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     divide 메소드 뒤에 throws IllegalArgumentException은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미한다.   사용자 정의 Exception     Exception 클래스를 상속 받아 정의한 checked Exception            반드시 오류를 처리 해야만 하는 Exception       예외 처리하지 않으면 컴파일 오류를 발생 시킨다.           RuntimeException 클래스를 상속 받아 정의한 unChecked Exception            예외 처리하지 않아도 컴파일 시에는 오류를 발생시키지 않는다.              RuntimeException을 상속받은 BizException 객체       public class BizException extends RuntimeException {         public BizException(String msg){             super(msg);         }                public BizException(Exception ex){             super(ex);         }     }     BizSerice 클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.       public class BizService {         public void bizMethod(int i)throws BizException{             System.out.println(\"비지니스 로직이 시작합니다.\");             if(i &lt; 0){                 throw new BizException(\"매개변수 i는 0이상이어야 합니다.\");             }             System.out.println(\"비지니스 로직이 종료됩니다.\");         }     }     앞에서 만든 BizService를 이용하는 BizExam 클래스     매개변수 값을 -1을 넘길 때는 Exception이 발생하기 때문에 try catch 블록으로 처리한다.       public class BizExam {           public static void main(String[] args) {             BizService biz = new BizService();             biz.bizMethod(5);             try{                 biz.bizMethod(-3);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }      프로그래머스 자바 입문을 마무리하며  강의 자체는 굉장히 깔끔했다. 개념 설명 이후 실습을 진행하고, 해당 개념에 대한 의문점도 강의에서는 미리 지적하여 설명해준다. 입문 강의를 들으니 대학 2학년 때 들었던 java 강의가 생각났다. 그 때 이정도 수준의 이해도를 얻었다면 어땠을까… 라는 생각이 스쳐 지나갔다. 이제 입문 강의를 들은 것 뿐이지만, java의 j정도 알게 되었다. 인터페이스나 내부클래스 같은 개념은 실제로 사용해봐야지 더 확실하게 개념이 와닿을 것 같다.   강의를 모두 수강하고도 개념이 조금 헷갈리는 것들을 적어두고 한번 더 복습을 해야할 것 같다.     인스턴스를 만들 때 Parents c = new Child(); &lt;- Parents와 Child가 정확히 어떤 역할을 하는지   인터페이스와 추상클래스의 차이점   내부 클래스들 각각의 쓰임   사용자 정의 Exception   java의 얕은 복사와 깊은 복사   super()   클래스 형변환     해당 강의와 강의 노트는 프로그래머스 자바 입문에서 언제든지 다시 들을 수 있다!  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_09/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 Object 클래스, Part2 java.lang 패키지",
        "excerpt":"Part1 Object 클래스   Object와 오버라이딩     Object 클래스는 모든 클래스의 최상위 클래스   아무것도 상속받지 않으면 자동으로 Object를 상속   Object가 가지고 있는 메소드는 모든 클래스에서 다 사용할 수 있다는 것을 의미   대표적인 예            equals : 객체가 가진 값을 비교할 때 사용       toString : 객체가 가진 값을 문자열로 반환       hashCode : 객체의 해시코드 값 반환           Part2 java.lang 패키지   java.lang 패키지/오토박싱  자바는 기본적으로 다양한 패키지를 지원 그중에서 가장 중요한 패키지     java.lang 패키지의 클래스는 import를 하지 않고도 사용할 수 있다.   java.lang 패키지에는 기본형 타입을 객체로 변환시킬 때 사용하는 Wrapper 클래스가 있다.            Boolean, Byte, Short, Integer, Long, Double 클래스           모든 클래스의 최상위 클래스인 Object도 java.lang 패키지   문자열과 관련된 String StringBuffer, StringBuilder도 모두 java.lang 패키지   화면에 값을 출력할 때 사용했던 System 클래스도 java.lang 패키지   수학과 관련된 Math 클래스도 java.lang 패키지   Thread와 관련된 중요 클래스들이 java.lang 패키지   이외에도 다양한 클래스와 인터페이스가 java.lang 패키지에 속해 있다.   public class WrapperExam {     public static void main(String[] args) {         int i = 5;          Integer i2 = new Integer(5);         Integer i3 = 5;     //오토박싱         int i4 = i2.intValue();         int i5 = i2;       //오토언박싱     } }     오토박싱(Auto Boxing)            Integer i3 = 5; 숫자 5는 원래 기본형이지만 자동으로 Integer 형태로 변환된다.           오토 언박싱(Auto Unboxing)            int i5 = i2; Integer 객체타입의 값을 기본형 int로 자동으로 변환되어 값을 할당한다.           오토박싱, 오토 언박싱은 JAVA 5부터 지원한다. 이 때 내부적으로 Wrapper 클래스들이 사용된다.   스트링버퍼  아무 값도 가지고 있지 않은 StringBuffer 객체를 생성   StringBuffer sb = new StringBuffer(); // 해당 스트링 버퍼에 \"hello\", 공백, \"world\"를 차례대로 추가  sb.append(\"hello\"); sb.append(\" \"); sb.append(\"world\"); // StringBuffer에 추가된 값을 toString()메소드를 이용하여 반환  String str = sb.toString();     출력결과 : hello world   StringBuffer가 가지고 있는 메소드들은 대부분 자기 자신, this를 반환   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     자기 자신의 메소드를 호출하여 자기 자신의 값을 바꿔나가는 것을 메소드체이닝 이라고 한다.   StringBuffer 클래스는 메소드 체인 방식으로 사용할 수 있도록 만들어져 있다.   StringBuffer sb2 = new StringBuffer(); StringBuffer sb3 = sb2.append(\"hello\"); if(sb2 == sb3){     System.out.println(\"sb2 == sb3\"); }     앞에서 5줄로 작성했던 코드를 위와 같이 한 줄로 수정할 수 있다.   StringBuffer는 append 메소드 외에도 길이를 구하거나, 자르거나 등의 다양한 메소드들을 가지고 있다.   스트링 클래스의 문제점  String 클래스는 문자열을 다룰 때 사용하는 클래스   String 클래스는 불변클래스이다.   String str1 = \"hello world\"; String str2 = str1.substring(5); System.out.println(str1); System.out.println(str2);     실행결과            hello world  world           기존의 str1은 전혀 변화 없다.   substring 메소드는 5번째부터 문자열을 잘라서 새로운 문자열을 반환하는 메소드   str1 자체는 전혀 변화가 없다.   String 클래스를 사용할 때 가장 문제가 발생하는 경우는 다음과 같은 코드를 사용할 때이다.   String str3 = str1 + str2; System.out.println(str3);     실행결과            hello world world           문자열과 문자열을 더하게 되면 내부적으로는 다음과 같은 코드가 실행   String str4 = new StringBuffer().append(str1).append(str2).toString(); System.out.println(str4);     java 에서는 new 연산자가 많을 수록 성능이 저하된다. 위와 같은 str3 = str1 + str2; 코드를 반복문에서 사용하게 된다면, new 연산자가 내부에서 계속해서 생성되고 성능이 저하될 수 있다.    Math  Math클래스는 이름 그대로 수학계산을 위한 클래스   코싸인, 싸인, 탄젠트, 절대값, 랜덤값등을 구할 수 있는 클래스     Math 클래스는 생성자가 private으로 되어 있기 때문에 new 연산자를 이용하여 객체를 생성할 수 없다.   객체를 생성할 수는 없지만 모든 메소드와 속성이 static으로 정의되어 있기 때문에 객체를 생성하지 않고도 사용할 수 있다.   public class MathExam {     public static void main(String[] args) {         int value1 = Math.max(5, 20);         int value2 = Math.min(5, -5);         int value3 = Math.abs(-10);         double value4 = Math.random();         double value5 = Math.sqrt(25);       } }  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_10/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 java.util 패키지",
        "excerpt":"Part3 java.util 패키지   java.util 패키지  java.util 패키지는 유용한 클래스들을 많이 가지고 있는 패키지     날짜와 관련된 클래스인 Date, Calendar 클래스   자료구조와 관련된 컬렉션 프레임워크와 관련된 인터페이스와 클래스   deprecated란 더이상 지원하지 않으니 사용하지 않는 것이 좋다란 의미   Date 클래스는 지역화를 지원하지 않는다. 지역화란 국가별로 현재 날짜와 시간은 다룰 수 있는데, 그 부분을 지원하지 못한다.            이런 문제를 해결하기 위하여 나온 클래스가 Calendar 클래스. Calendar 클래스는 자바 1.1에 등장           지역화와 관련된 클래스들은 Locale로 시작되는 일므을 가진 클래스다.   List, Set, Collection, Map은 자료구조 즉 컬렉션 프레임워크와 관련된 인터페이스   컬렉션 프레임워크  java.util 패키지에는 자료를 다룰 수 있는 자료구조 클래스가 다수 존재한다. 자료구조 클래스들을 컬렉션 프레임워크라고 한다.     자료구조란 자료를 저장할 수 있는 구조   책을 보관하기 위해 책장을 이용하는 것 처럼 다양한 자료들을 다양한 방식으로 관리하기 위한 방법이 필요한데, 이러한 방법을 제공하는 것을 자료구조, 컬렉션 프레임워크이다.   컬렉션 프레임워크에서 가장 기본이 되는 interface는 Collection 인터페이스            Collection 인터페이스는 여기에 자료가 있다라는 것을 표현       중복도 허용하고, 자료가 저장된 순서도 기억하지 못하는 것이 Collection 인터페이스       Collection이 가지고 있는 대표적인 메소드는 add(), size(), iterator() 메소드       Collection은 저장된 순서를 기억하지 못하기 때문에, 하나씩 하나씩 꺼낼 수 있는 Iterator라는 인터페이스를 반환한다.                    Iterator는 꺼낼것이 있는지 없는지 살펴보는 hasNext() 메소드와 하나씩 자료를 꺼낼때 사용하는 next() 메소드를 가지고 있다.                           Set 자료구조는 중복을 허용하지 않는 자료구조를 표현하는 인터페이스            Collection 인터페이스를 상속받는다.       Set 인터페이스가 가지고 있는 add 메소드는 같은 자료가 있으면 false, 없으면 true를 반환하는 add 메소드를 가지고 있다.           List 자료구조는 중복은 허용하면서 순서를 기억하는 자료구조를 표현            Set 인터페이스와 마찬가지로 Collection 인터페이스를 상속받고 있다.       List는 순서를 기억하고 있기 때문에 n번째의 자료를 꺼낼 수 있는 get(int) 메소드를 가지고 있다.           Map 자료구조는 Key와 Value를 가지는 자료구조이다.            저장할 때 put() 메소드를 이용하여 key와 value를 함께 저장한다.       원하는 값을 꺼낼 때는 key를 매개변수로 받아들이는 get() 메소드를 이용하여 값을 꺼낸다.       Map에 저장되어 있는 모든 Key들은 중복된 값을 가지면 안된다.       Key의 이런 특징 때문에 Map은 자신이 가지고 있는 모든 Key들에 대한 정보를 읽어들일 수 있는 Set을 반환하는 KeySet() 메소드를 가지고 있다.           Generic  Box 클래스   public class Box {     private Object obj;     public void setObj(Object obj){     this.obj = obj;     }      public Object getObj(){     return obj;     } }  BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box box = new Box();         box.setObj(new Object());         Object obj = box.getObj();          box.setObj(\"hello\");         String str = (String)box.getObj();         System.out.println(str);          box.setObj(1);         int value = (int)box.getObj();         System.out.println(value);     } }     Box는 매개변수 Object를 하나 받아들이고, Object를 반환한다.   Object를 받아들일 수 있다는 것은 Object의 후손이라면 무엇이든 받아들일 수 있다는 것이다.   하지만 반환을 할 경우에는 반환 값에 맞는 형변환을 해주어야한다.            이 귀찮음(?)을 해결하기 위하여 Java5에 Generic이라는 문법이 사용됨           Generic을 이용하여 Box 클래스 수정   public class Box&lt;E&gt; {     private E obj;     public void setObj(E obj){         this.obj = obj;     }      public E getObj(){         return obj;     } }     클래스 이름 뒤에 가 제네릭을 적용한 것이다. Box는 가상의 클래스 E를 사용한다는 의미   Object를 받아들이고, 리턴하던 부분이 E로 변경. E는 실제로 존재하는 클래스는 아니다.   Generic을 이용하여 수정한 Box를 이용하는 BoxExam 클래스   public class BoxExam {     public static void main(String[] args) {         Box&lt;Object&gt; box = new Box&lt;&gt;();         box.setObj(new Object());         Object obj = box.getObj();          Box&lt;String&gt; box2 = new Box&lt;&gt;();         box2.setObj(\"hello\");         String str = box2.getObj();         System.out.println(str);          Box&lt;Integer&gt; box3 = new Box&lt;&gt;();         box3.setObj(1);         int value = (int)box3.getObj();         System.out.println(value);     } }     참조타입에 &lt;Object&gt;, &lt;String&gt;, &lt;Integer&gt;가 있는 것을 볼 수 있다.   첫번째는 Object를 사용하는 Box를 인스턴스로 만들겠다는 의미   두번째는 String을 사용하는 Box 인스턴스를 만들겠다는 의미   세번째는 Integer를 사용하는 Box 인스턴스를 만든다는 의미      Generic을 사용함으로써 선언할 때는 가상의 타입으로 선언하고, 사용시에는 구체적인 타입을 설정함으로써 다양한 타입의 클래스를 이용하는 클래스를 만들 수 있다. Generic을 사용하는 대표적인 클래스는 컬렉션 프레임워크와 관련된 클래스다.    Set  set은 중복이 없고, 순서도 없는 자료구조. HashSet과 TreeSet이 있다.   import java.util.HashSet; import java.util.Iterator; import java.util.Set;  public class SetExam {     public static void main(String[] args) {         Set&lt;String&gt; set1 = new HashSet&lt;&gt;();          boolean flag1 = set1.add(\"kim\");         boolean flag2 = set1.add(\"lee\");         boolean flag3 = set1.add(\"kim\");          System.out.println(set1.size());   //저장된 크기를 출력합니다. 3개를 저장하였지만, 이미 같은 값이 있었기 때문에 2개가 출력         System.out.println(flag1);  //true         System.out.println(flag2);  //true         System.out.println(flag3);  //false          Iterator&lt;String&gt; iter = set1.iterator();          while (iter.hasNext()) {   // 꺼낼 것이 있다면 true 리턴.                       String str = iter.next(); // next()메소드는 하나를 꺼낸다. 하나를 꺼내면 자동으로 다음것을 참조한다.             System.out.println(str);         }     } }  List  list는 데이터의 중복이 있을 수 있고, 순서도 있다.   import java.util.ArrayList; import java.util.List;  public class ListExam {      public static void main(String[] args) {         List&lt;String&gt; list = new ArrayList&lt;&gt;();          // list에 3개의 문자열을 저장합니다.         list.add(\"kim\");         list.add(\"lee\");         list.add(\"kim\");          System.out.println(list.size()); //list에 저장된 자료의 수를 출력 (중복을 허용하므로 3 출력)          for(int i = 0; i &lt; list.size(); i++){             String str = list.get(i);             System.out.println(str);         }     }    }  Map  Map은 key와 value를 쌍으로 저장하는 자료구조. 키는 중복될 수 없고, 값은 중복될 수 있다.   import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Set;    public class MapExam {       public static void main(String[] args) {         // Key, Value가 모두 String 타입인 HashMap인스턴스를 만듭니다.         Map&lt;String, String&gt; map = new HashMap&lt;&gt;();          // key와 value값을 put으로 저장합니다.         map.put(\"001\", \"kim\");         map.put(\"002\", \"lee\");         map.put(\"003\", \"choi\");         // 같은 key가 2개 있을 수 없습니다. 첫번째로 저장했던 001, kim은 001, kang으로 바뀐다.         map.put(\"001\", \"kang\");          // map에 저장된 자료의 수를 추력합니다. 3이 출력됩니다.         System.out.println(map.size());          // 키가 001, 002, 003인 값을 꺼내 출력합니다.         System.out.println(map.get(\"001\"));         System.out.println(map.get(\"002\"));         System.out.println(map.get(\"003\"));          // map에 저장된 모든 key들을 Set자료구조로 꺼냅니다.         Set&lt;String&gt; keys = map.keySet();         // Set자료구조에 있는 모든 key를 꺼내기 위하여 Iterator를 구합니다.         Iterator&lt;String&gt; iter = keys.iterator();         while (iter.hasNext()) {             // key를 꺼냅니다.             String key = iter.next();             // key에 해당하는 value를 꺼냅니다.             String value = map.get(key);             // key와 value를 출력합니다.             System.out.println(key + \" : \" + value);         }     } } ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.8 배열의 할당과 접근)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.8 배열의 할당과 접근   C에서 배열은 스칼라 데이터를 보다 큰 자료형으로 연계시키는 수단이다.   3.8.1 기본 원리      자료형 T와 정수형 상수 N에 대해서 다음과 같은 선언에 대해 생각해보자.            T A[N];            시작하는 위치를 Xa로 표시하자. 이 선언은 두가지 효과를 갖는다.            이것은 L*N 바이트의 연속적인 공간을 메모리에 할당하며, 여기서 L(바이트 단위)은 자료형 T의 크기를 나타낸다.       새로운 식별자 a를 통해서 배열이 시작하는 위치의 포인터로 사용한다.           배열의 각 원소는 0에서 N-1 사이의 정수형 인덱스를 사용해서 접근할 수 있다.   배열의 원소 i는 주소 Xa +L*i에 저장된다.   3.8.2 포인터 연산      C는 포인터 간에 연산을 허용하며, 계산된 값은 포인터가 참조하게 되는 자료형의 크기에 따라 그 값이 확대된다.   어떤 객체를 나타내는 식 Expr에 대해 &amp;Expr는 그 객체의 주소를 주는 포인터이다.   주소를 나타내는 식 A Expr에 대해 *A Expr는 그 주소에 위치한 값을 준다.   3.8.3 다중 배열      배열 할당과 참조에 관한 일반적인 원칙들은 심지어 배열의 배열을 생성할 때도 적용된다.   배열의 원소들은 메모리에 “행 우선row major” 순서로 저장된다.    3.8.4 고정크기의 배열      C 컴파일러는 고정크기의 다차원 배열을 위한 코드에 대해 다양한 최적화를 수행할 수 있다.   아래의 그림은 고정길이 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.    3.8.5 가변크기의배열      가변크기 배열을 원하는 프로그래머는 배열들을 위한 저장공간을 mallock이나 calloc 같은 함수를 사용해서 할당해야한다.   아래의 그림은 가변크기 배열에 대한 행렬 곱셈의 원소 i,k를 계산하는 최초의 코드와 최적화된 코드이다. 컴파일러는 이런 최적화를 자동으로 실행한다.       다중배열의 원소들을 접근할 때 발생하는 패턴을 인식할 수 있다는 것을 살펴보았다.  곱셈을 회피하는 코드를 생성할 수 있다.  이런 최적화들은 프로그램 성능을 상당히 개선하게 된다   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_09/",
        "teaser": null
      },{
        "title": "[Algorithm/Java] 프로그래머스 Level1 K번째수 Java 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 첫 문제였다. 배열 생성도 어색하고 디버깅 하는 것도 너무 어려웠다. 몇가지 문법은 구글링을 해가면서 풀었다. 나는 지금까지 python으로만 알고리즘 문제를 해결했었다. python과 java는 너무나도 다르다… 우선 변수들간의 전송과 출력 모두 python과 달랐다. 여튼 java는 거의 모든 기능을 모듈을 import하여 사용한다는 것이다. 예를들어 Arrays 모듈을 import하여 배열을 한번에 출력하고, ArrayList를 import하여 연결리스트를 만든다.       2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.   commands에 포함된 1차원 배열에서 index 0,1에 위치한 value로 Arrays.copyOfRange(arr,startIndex,endIndex)를 사용하여 array를 slicing 한다.            ex) arr = {10,20,30,40,50} Arrays.copyOfRange(arr, 2, 4) -&gt; returns {20,30,40}           Arrays.sort()를 사용하여 slicing된 배열을 정렬한다.   정렬된 배열에서 commands index 2에 위치한 value에 해당하는 위치를 answer arrayList에 add한다.   return answer   코드       import java.util.ArrayList;     import java.util.Arrays;          public class Main {         public static void main(String[] args){             int[] array = {1,5,2,6,3,7,4};             int[][] commands =  {{2,5,3},{4,4,1},{1,7,3}};                  int[] answer = solution(array,commands);             System.out.println(Arrays.toString(answer));         }              public static int[] solution(int[] array, int[][] commands){             ArrayList&lt;Integer&gt; arrList = new ArrayList&lt;&gt;();                  for(int i=0; i&lt;commands.length; i++){                 int[] k = Arrays.copyOfRange(array,commands[i][0]-1,commands[i][1]);                 Arrays.sort(k);                 arrList.add(k[commands[i][2]-1]);             }                  int size = arrList.size();             int[] answer = new int[size];                  for(int i=0; i&lt;size; i++){                 answer[i] = arrList.get(i);             }                  return answer;         }     } ","categories": ["Algorithm"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/algorithm/java_01/",
        "teaser": null
      },{
        "title": "[키보드/해피해킹] 해피해킹 하이브리드 type-s 리뷰",
        "excerpt":"이게뭐지?!      이건 바로 “해피해킹”이 들어있는 택배다. 무려 일본에서 2주일을 기다려서 받게 된 기다리고 기다리던 나의 첫 내돈내산 키보드이다.(매직키보드는 제외하도록 하겠다.. 왜냐면 매직키보드는… 애플… 이니깐… 꼭 사야하는… 물건중 하나…) 사실 나는 키보드에 그렇게 관심이 있던 사람은 아니였지만 동기들이 자꾸 꼬셨다. 그 중 가장 강렬했던 말은 “민석이형도 몇년동안 계속 키보드 바꾸다가 리얼포스로 정착했는데 너가 해피해킹 사면 한번에 다 뛰어넘고 대장급 되는거다” 이 말에 혹해 그날 저녁먹고  집에 오자마자 바로 “해피해킹 하이브리드 type-s”를 일본에서 직구하였다. 배송 기간 동안 설 연휴가 끼는 바람에 주문을 하고 약 2주뒤에 도착한 것 같다. 그 후로 동기들 집가서 여러 키보드도 타건해보면서 생전 관심도 없던 키보드를 사랑하게 돼버렸다..(사실 아직 뭐가 다른지 크게는 잘 모르겠따…)   택배박스를 열어보자..   회사 퇴근시간에 배송 완료 됐다는 카톡을 받자마자 칼퇴하고 집으로 곧장 달려갔다. 나의 해피해킹을 언능 영접하고 싶어서 호다닥 박스를 열었다.      완충제가 아주 가득 차있어서 일본에서부터 서울까지 다친데 하나 없이 아주 잘 도착한 것 같다 ㅎㅎ 완충제까지도 이쁘다.         완충제를 걷어내면 해피해킹 본체와 같이 주문한 정품 루프가 보인다. 정품 루프가 6만원인건 안비밀이다;;(그냥 아크릴일뿐인데 6만원이나 받아간다 ㅋ…)         이렇게 상자 안에 있는 물건을 다 꺼내면 해피해킹 본체, 전용 루프, 전용 키캡이 들어있다. 모두 다 옵션이고 키캡은 너무 이뻐서 살 수 밖에 없게 만들어놨다.      대망의 해피해킹 하이브리드 type-s   먼저 해피해킹 본체를 살펴보겠다.      “영롱 그 자체” 정말 영롱 그 자체다… 너무 이쁘다… 저 모던하지만 클래식한 디자인.. 투박하지만 미세하게 느껴지는 유려한 곡선.. 이 둘이 함꼐 탱고를 추는듯한 화려함… 가히 키보드의 왕이라 칭하기에 한점 부끄러움 없는 자태를 뽐내고 있다…         키보드를 꺼내고 나면 사용 설명서와 키보드에 들어갈 AA건전지 두개가 함께 들어있다. 건전지가 없을 줄 알고 집오는 길에 편의점에 들려서 AA건전지를 샀는데 여분용으로 남겨놔야할 것 같다. 무려 40만원이 넘는 키보드인데 왜 이런 구식용 건전지를 사용하는지 의문이었는데  구글링을 몇번 하고나니 납득이 되었다. 배터리는 자고로 수명이 있기 때문에 키보드를 오래 쓰기에는 이런 건전지를 사용하는 것이 더 좋다고 한다.         다시 비닐을 벗긴 해피해킹을 보자. 글이 길어지면 진심은 흐려지는 법이라고 하였다. 후훗..      전용루프와 전용키캡      전용루프와 전용키캡은 이렇게 생겼다. 참.. 이쁘다.. 돈값 한다..!!         ㅎㅎ 키캡까지 장착해보았다. 키캡은 무각과 일반 두개가 있다. 정말 이쁘죠? ㅎㅎ         루프도 덮어보았다!       간단 후기   간단 후기를 남겨 보겠다. 우선 나는 키보드는 매직키보드, 맥북키보드 그리고 게이밍용 청축키보드만 사용해본 키린이라는걸 인지해줬으면 좋겠다,,,!   해피해킹 하이브리드 type-s 는 토프레 무접점 키보드라고 한다. 소음은 확실히 적다. 그리고 굉장히 부드럽다. 하지만, 키압이 생각보다 있어 그렇게 가볍지만은 않다. 그리고 해피해킹은 방향키가 없어 커맨드로 사용해야하고, 컨트롤 키도 캡스락에 있어 맥북 한영키와 굉장히 헷갈린다. 백스페이스도 기존 키보드보다 한단계 아래에 위치해 있다. 이러한 부분들이 아직은 익숙하지 않아서 버벅거리는데, 확실히 익숙해진다면 손의 움직임이 기존 키보드보다 적어서 효율적일 것 같다. 키보드를 좀 더 사용해보고 과연 배송비 10만원, 전용루프와 전용키캡 7만원, 본체 35만원 값어치를 하는지 깊은 후기를 남겨보겠다.   ","categories": ["해피해킹"],
        "tags": ["키보드","해피해킹"],
        "url": "/%ED%95%B4%ED%94%BC%ED%95%B4%ED%82%B9/doodle_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 날짜와 시간",
        "excerpt":"Part4 날짜와 시간   Date  날짜와 시간을 구하기 위한 클래스 Date 클래스     Date 클래스는 JDK 1.0때 만들어졌고, Calendar 클래스는 JDK1.1에 만들어졌따.   Date는 지역화에 대한 부분이 고려되지 않았다.            지역화란, 지역에 따라서 시간, 통화(원, 달러, 엔 등) 언어등에 고려하는 프로그래밍을 지역화에 맞춘 프로그래밍이라고 한다.           Date 클래스를 보면 대부분의 생성자와 메소드가  Deprecated 되어 있다.            Deprecated된 것은 앞으로 지원을 안하거나 문제가 있을 수 있으니 사용하지 말란 뜻이다.           기본 생성자를 이용한 Date 클래스 생성            기본 생성자로 Date인스턴스를 만들게 되면 현재 시간과 날짜 정보를 Date인스턴스가 가지게 된다                 Date date = new Date();     toString() 메소드를 이용하여 현재 시간을 문자열로 구한다.            출력 결과 : Wed Jan 06 18:36:56 KST2016                 System.out.println(date.toString());     java.util.SimpleDateFormat 클래스를 이용해서 원하는 형태로 출력하는 방법            yyyy는 년, MM은 월, dd는 일을 표현       hh는 시간, mm은 분, ss는 초를 표현하며 a는 오전/오후를 표현한다.       zzz는 TimeZone을 나타낸다. 한국의 겨우 한국ㅁ표준시 KST가 TimeZone에 해당하는 값이다.               SimpleDateFormat ft = new SimpleDateFormat (\"yyyy.MM.dd 'at' hh:mm:ss a zzz\");     System.out.println(ft.format(date));     현재 시간을 Long값으로 구하는 방법       System.out.println(date.getTime());     // System이 가지고 있는 currentTimeMillis()메소드를 이용해도 됩니다.     long today = System.currentTimeMillis();     System.out.println(today);  Calendar  Date의 단점을 해결하고 등장한 것이 Calendar 클래스     Calendar 클래스 생성 방법            Calendar 클래스는 추상클래스이다.       Calendar 클래스에 대한 인스턴스를 생성하려면 Calendar가 가지고 있는 클래스 메소드 getInstance()를 사용해야 한다.       getInstance() 메소드를 호출하면 내부적으로 java.util.GregorianCalendar 인스턴스를 만들어서 리턴한다.       GregorianCalendar는 Calendar의 자식 클래스다.                 Calendar cal = Calendar.getInstance();     Calendar 클래스를 이용해서 현재 날짜와 시간에 대한 정보를 알아내는 방법            Calendar는 현재 날짜와 시간에 대한 정보를 가진다.       Calendar가 가지고 있는 get메소드에 Calendar의 상수를 어떤 것을 넣어주느냐에 따라서 다른 값이 나온다.                 int yyyy = cal.get(Calendar.YEAR);       int month = cal.get(Calendar.MONTH) + 1; // 월은 0부터 시작       int date - cal.get(Calendar.DATE);       int hour = cal.get(Calendar.HOUR_OF_DAY);       int minuate = cal.get(Calendar.MINUTE);     Calendar 클래스를 이용해서 원하는 날짜나 시간에 대한 정보 얻어오는 방법            Calendar가 가지고 있는 add 메소드를 이용하면 쉽게 다음 날짜나 이전 날짜를 구할 수 있다.       현재 캘린더에 시간을 5시간 더하는 방법.                 cal.add(Calendar.HOUR,5);  java.time 패키지  Java에서 제공하는 ㅇate, Time API는 부족한 기능 지원을 포함한 여러가지 문제점을 가지고 있었다. JDK 코어에서 이런 문제점들을 해결하고 더 좋고 직관적인 API들을 제공하기 위해 새롭게 재 디자인한 date, Time API를 Java SE 8 부터 제공한다.     새로운 API의 핵심 클래스는 오브젝트를 생성하기 위해 다양한 factory 메서드를 사용   오브젝트 자기 자신의 특정 요소를 가지고 오브젝트를 생성할 경우 of 메서드를 호출하면 되고, 다른 타입으로 변경할 경우에는 from 메서드를 호출하면 된다.   LocalDateTime 클래스를 이용해서 현재 시간 time 객체 만드는 방법            now는 현재 시간을 구한다.                 LocalDateTime timePoint = LocalDateTime.now();  // 현재의 날짜와 시간     원하는 시간으로 time 객체 생성하는 방법       // 2012년 12월 12일의 시간에 대한 정보를 가지는 LocalDate객체를 만드는 방법       LocalDate ld1 = LocalDate.of(2012, Month.DECEMBER, 12); // 2012-12-12 from values          // 17시 18분에 대한 LocalTime객체를 구한다.     LocalTime lt1 = LocalTime.of(17, 18); // 17:18 (17시 18분)the train I took home today      // 10시 15분 30초라는 문자열에 대한 LocalTime객체를 구한다.     LocalTime lt2 = LocalTime.parse(\"10:15:30\"); // From a String     현재와 날짜와 시간정보를 getter 메소드를 이용하여 구하는 방법       LocalDate theDate = timePoint.toLocalDate();     Month month = timePoint.getMonth();     int day = timePoint.getDayOfMonth();     int hour = timePoint.getHour();     int minute = timePoint.getMinute();     int second = timePoint.getSecond();     // 달을 숫자로 출력한다 1월도 1부터 시작하는 것을 알 수 있습니다.      System.out.println(month.getValue() + \"/\" + day + \"  \" + hour + \":\" + minute + \":\" + second);  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_12/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 IO, Part6 어노테이션",
        "excerpt":"Part5 IO   자바IO  입출력을 위한 인터페이스와 클래스들     자바 IO는 크게 byte단위 입출력과 문자 단위 이출력 클래스로 나뉜다.            byte단위 입출력클래스는 모두 InputStream과 OutputStream이라는 추상클래스를 상속받아 만들어진다.       문자(char)단위 입출력클래스는 모두 Reader와 Writer라는 추상클래스를 상속받아 만들어진다.           4가지 추상클래스(InputStream, OutputStreamReader,Reader,Writer)를 받아들이는 생성자가 있다면, 다양한 입출력방법을 제공하는 클래스다.   4가지 클래스를 받아들이는 생성자가 없다면, 어디로부터 입력받을 것인지, 어디에 쓸것인지를 나타내는 클래스다.   파일로부터 입력받고 쓰기 위한 클래스 : FileInputStream, FileOutputStream, FileReader, FileWriter   배열로부터 입력받고 쓰기 위한 클래스 : ByteArrayInputStream, ByteArrayOutputStream, CharReader, CharWriter            해당 클래스들은 어디로부터, 어디에라는 대상을 지정할 수 있는 IO클래스다. 이런 클래스를 장식대상 클래스라고 한다.           DataInputStream, DataOutputStream같은 클래스를 보면 다양한 데이터 형을 입력받고 출력한다.   PrintWriter는 다양하게 한줄 입력받는 readLine() 메소드를 가진다.   BufferedReader는 한줄 입력받는 readLine() 메소드를 가진다.            이런 클래스들은 다양한 방식으로 입력하고, 출력하는 기능을 제공한다. 이런 클래스를 장식하는 클래스라고 한다.                    데코레이터 패턴(Decorator Pattern) : 하나의 클래스를 장식 하는 것처럼 생성자에서 감싸서 새로운 기능을 계쏙 추가 할 수 있도록 클래스를 만드는 방식    Byte 단위 입출력  Byte 단위 입출력 클래스는 클래스의 이름이 InputStream 이나 OutputStream으로 끝난다.     파일로부터 1byte씩 읽어들여 파일에 1byte씩 저장하는 프로그램을 작성            파일로부터 읽어오기 위한 객체 - FileInputStream       파일에 쓸 수 있게 해주는 객체 - FileOutputStream           read() 메소드            byte를 리턴한다면 끝을 나타내는 값을 표현할 수가 없기때문에, byte가 아닌 int를 리턴한다.       음수의 경우 맨 좌측 비트가 1이 된다. 읽어들일 것이 있다면 항상 양수를 리턴한다고 볼 수 있다.           FileInputStream과 FileOutputStream을 이용하여, 1바이트씩 읽어들여 1바이트씩 저장            read()메소드가 리턴하는 타입은 정수인데, 정수 4바이트중 마지막 바이트에 읽어들인 1바이트를 저장한다.       read()메소드는 더이상 읽어들일 것이 없을 때 -1을 리턴한다.               public class ByteIOExam1 {         public static void main(String[] args){                  FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readData = -1;                  while((readData = fis.read())!= -1){                     fos.write(readData);                 }                        } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         }     }  Byte 단위 입출력 심화  Byte단위 입출력 클래스는 클래스의 이름이 InputStream이나 OutputStream으로 끝난다.      파일로부터 512byte씩 읽어들여 파일에 512byte씩 저장하는 프로그램을 작성            byte[] buffer = new byte[512];       512byte만큼 읽어 들이기 위해 byte배열을 사용               public class ByteIOExam1 {         public static void main(String[] args){                  //메소드가 시작된 시간을 구하기 위함             long startTime = System.currentTimeMillis();                     FileInputStream fis = null;              FileOutputStream fos = null;                     try {                 fis = new FileInputStream(\"src/javaIO/exam/ByteExam1.java\");                 fos = new FileOutputStream(\"byte.txt\");                  int readCount = -1;                  byte[] buffer = new byte[512];                 while((readCount = fis.read(buffer))!= -1){                     fos.write(buffer,0,readCount);                 }             } catch (Exception e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }finally{                 try {                     fos.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }                 try {                     fis.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }             }         //메소드가 끝났을때 시간을 구하기 위함.          long endTime = System.currentTimeMillis();         //메소드를 수행하는데 걸린 시간을 구할 수 있음.          System.out.println(endTime-startTime);          }     }  다양한 타입의 출력     try-with-resources 블럭 선언            java io 객체는 인스턴스를 만들고, 모두 사용하면 close()메소드를 호출해야 한다.       close() 메소드를 사용자가 호출하지 않더라도, Exxception이 발생하지 않았다면 자동으로 close()가 되게 할 수 있는 방법                   try(                 //io객체 선언         ){                 //io객체 사용         }catch(Exception ex){             ex.printStackTrace();         }     다양한 타입으로 저장할 수 있는 DataOutputStream            writeInt() - 정수값으로 저장       writeBoolean() - boolean값으로 저장       writeDouble() - double값으로 저장               import java.io.DataOutputStream;     import java.io.FileOutputStream;         public class ByteExam3 {             public static void main(String[] args) {             try(                     DataOutputStream out = new DataOutputStream(new FileOutputStream(\"data.txt\"));             ){                 out.writeInt(100);                 out.writeBoolean(true);                 out.writeDouble(50.5);             }catch (Exception e) {                 e.printStackTrace();             }         }        }  다양한 타입의 입력     data.dat로부터 값을 읽어들여 화면에 출력하는 클래스   다양한 타입의 데이터를 읽어낼 수 있는 DataInputStream            readInt() - 정수를 읽어들이는 메소드       readBoolean() - boolean 값을 읽어들이는 메소드       readDouble() - double 값을 읽어들이는 메소드               import java.io.DataInputStream;     import java.io.FileInputStream;      public class ByteIOExam4 {          public static void main(String[] args) {             try(                     DataInputStream out = new DataInputStream(new FileInputStream(\"data.dat\"));             ){                 int i = out.readInt();                           boolean b = out.readBoolean();                           double d = out.readDouble();                  System.out.println(i);                 System.out.println(b);                 System.out.println(d);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }     파일에 저장된 순서대로 읽어 들여야한다.    Char 단위 입출력(Console)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     char 단위 입출력 클래스를 이용해서 키보드로부터 한줄 입력 받아서 콘솔에 출력            System.in - 키보드를 의미(InputStream)       BufferedReader - 한줄씩 입력 받기위한 클래스       BufferedReader 클래스의 생성자는 InputStream을 입력받는 생성자가 없다.       System.in은 InputStream 타입이므로 BufferedReader의 생성자에 바로 들어갈 수 없으므로 InputStreamReader 클래스를 이용해야함               import java.io.BufferedReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.InputStreamReader;     import java.io.PrintWriter;      public class CharIOExam01 {         public static void main(String[] args) {             BufferedReader br = new BufferedReader(new InputStreamReader(System.in));             //키보드로 입력받은 문자열을 저장하기 위해 line변수를 선언                            String line = null;                  try {                 line = br.readLine()             } catch (IOException e) {                 e.printStackTrace();             }             //콘솔에 출력              System.out.println(line);         }     }  Char 단위 입출력(File)  char 단위 입출력 클래스는 클래스 이름이 Reader나 Writer로 끝이 난다.     파일에서 한 줄씩 입력 받아서 파일에 출력            파일에서 읽기 위해서 FileReader 클래스 이용       한 줄 읽어 들이기 위해서 BufferedReader 클래스 이용                    BufferedReader 클래스가 가지고 있는 readLine() 메소드가 한줄씩 읽게 해준다.           readLine() 메소드는 읽ㅇ낼 때 더 이상 읽어 들일 내용이 없ㅇ르 때 mnull을 리턴한다.                       파일에 쓰게하기 위해서 FileWriter 클래스 이용       편리하게 출력하기 위해 PrintWritier 클래스 이용               import java.io.BufferedReader;     import java.io.FileReader;     import java.io.FileWriter;     import java.io.IOException;     import java.io.PrintWriter;      public class CharIOExam02 {         public static void main(String[] args) {             BufferedReader br = null;              PrintWriter pw = null;             try{                         br = new BufferedReader(new FileReader(\"src/javaIO/exam/CharIOExam02.java\"));                 pw = new PrintWriter(new FileWriter(\"test.txt\"));                 String line = null;                 while((line = br.readLine())!= null){                     pw.println(line);                 }             }catch(Exception e){                 e.printStackTrace();             }finally {                 pw.close();                 try {                     br.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }     }  Part6 어노테이션   어노테이션  어노테이션은 Java5에 추가된 기능     어노테이션은 클래스나 메소드 위에 붙는다. @(at)기호로 이름이 시작한다.   어노테이션을 클래스나 메타코드에 붙인 후, 클래스가 컴파일되거나 실행될 때 어노테이션의 유무나 어노테이션에 설정된 값을 통하여 클래스가 좀 더 다르게 실행되게 할 수 있다. 이런 이유로 어노테이션을 일정의 설정파일처럼 설명하는 경우도 있다.   어노테이션은 자바가 기본으로 제공해주는 것도 있고, 사용자가 직접 만들 수도 있다.            사용자가 직접 작성하는 어노테이션을 Custom 어노테이션이라고 한다.           커스텀 어노테이션을 이용하는 방법            어노테이션을 정의한다.       어노테이션을 클래스에서 사용한다. (타겟에 적용)       어노테이션을 이용하여 실행           패키지 익스플로러에서 [new - Annotation]을 이용하여 Count100이라는 어노테이션 생성            Count100어노테이션을 JVM 실행시에 감지할 수 있도록 하려면 @Retention(RetentionPolicy.RUNTIME)를 붙여줘야 한다.               import java.lang.annotation.Retention;     import java.lang.annotation.RetentionPolicy;      @Retention(RetentionPolicy.RUNTIME)     public @interface Count100 {      }     “hello”를 출력하는 hello() 메소드를 가지는 MyHello라는 클래스를 작성            hello 메소드 위에 @Count100어노테이션을 붙힌다               public class MyHello {         @Count100         public void hello(){             System.out.println(\"hello\");         }     }     MyHello 클래스를 이용하는 MyHelloExam클래스를 작성            MyHello의 hello 메소드가 @Count100어노테이션이 설정되어 있을 경우, hello()메소드를 100번 호출하도록 한다.               import java.lang.reflect.Method;      public class MyHelloExam {         public static void main(String[] args) {             MyHello hello = new MyHello();              try{                 Method method = hello.getClass().getDeclaredMethod(\"hello\");             if(method.isAnnotationPresent(Count100.class)){                     for(int i = 0; i &lt; 100; i++){                         hello.hello();                     }                 }else{                     hello.hello();                 }             }catch(Exception ex){                 ex.printStackTrace();             }                }     }  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_13/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.9 이기종 자료구조 ~ 3.10 기계수준 프로그램에서 제어와 데이터의 결합)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.9 이기종 자료구조      C는 서로 다른 유형의 객체를 연결해서 자료형을 만드는 두 가지 방법을 제공한다.            struct 키워드를 사용해서 선언하는 구조체                    다수의 객체를 하나의 단위로 연결한다.                       union으로 선언하는 공용체                    하나의 객체를 여러 개의 다른 자료형으로 참조될 수 있도록 한다.                           3.9.1 구조체      서로 다른 유형의 객체들을 하나의 객체로 묶어주는 자료형을 생성한다.   구조체의 구현은 구조체의 모든 컴포넌트들이 메모리의 연속된 영역에 저장된다.   구조체의 포인터가 첫 번째 바이트의 주소라는 점에서 배열과 유사하다.      3.9.2 공용체      C언어의 자료형 체제를 회피해서 하나의 객체가 다수의 자료형에 따라 참조될 수 있도록 해준다.   공용체를 선언하는 문법은 구조체와 동일하나 그 의미는 매우 다르다.            다른 필드들이 메모리의 다른 블록을 참조하는 것이 아니라 동일한 블록을 참조한다.           3.9.3 데이터의 정렬      많은 컴퓨터 시스템들은 기본 자료형들에 대해 사용 가능한 주소를 제한하고 있어서 어떤 객체의 주소는 어떤 값 K의 배수가 되도록 요구한다.   이러한 정렬제한은 프로세서와 메모리 시스템 간의 인터페이스를 구성하는 하드웨어의 설계를 단순화한다.   이들의 정렬 규칙은 모든 K의 원시 객체들은 K의 배수를 주소로 가져야 한다는 원칙에 기초한다.   정렬은 자료형 내의 모든 객체들이 각각의 정렬 제한사항을 만족하는 방법으로 조직되고 할당되도록 강요된다.   아래의 그림처럼 컴파일러는 c와 j 사이에 3바이트 공간을 삽입한다.            추가로, 컴파일러는 구조체의 마지막에 0을 채워서 구조체 배열에서 각 원소가 각각의 정렬 요건을 만족하도록 해준다.   3.10 기계수준 프로그램에서 제어와 데이터의 결합      데이터와 자료가 상호작용 하는 방식을 살펴본다.   C 프로그래밍 언어에서 가장 심오한 개념인 포인터를 자세히 살펴본다.   기계수준 프로그램의 상세한 동작을 심벌 디버거인 GDB를 사용해서 검토한다.   실제 시스템에서 중요한 보안취약성인 버퍼 오브펄로우를 어떻게 이해할 수 있는지 살펴본다.   함수가 요구하는 스택 저장공간의 양이 실행때마다 달라지는 경우를 기계수준 프로그램이 어떻게 구현하는지 살펴본다.   3.10.1 포인터 이해하기      다른 자료구조 내 원소들에 대한 참조를 생성하는 통일된 방법으로서의 역할을 수행한다.   포인터의 일부 주요 원리            포인터는 연관된 자료형을 갖는다.       모든 포인터는 특정 값을 가진다.       포인터는 &amp;연산자를 사용해서 만든다.       ㅍ포인터는 *연산자를 사용해서 역참조한다.       배열과 포인터는 밀접한 관련이 있다. 배열의 이름은 마치 포인터 변수처럼 참조될 수 있다.       한 종류의 포인터에서 다른 종류로의 자료형 변환은 그 종류만 바뀔 뿐 값은 변화가 없다.       포인터는 함수를 가리킬 수도 있. 이것은 프로그램의 다른 부분에서 호출할 수 있는 코드에 대한 참조를 저장하거나 넘겨줄 수 있는 강력한 기능을 제공한다.           3.10.2 실제 적용하기: GDB 디버거 사용하기      GNU 디버거인 GDB는 기계어 프로그램의 런타임 평가 및 분석에 유용한 기능을 제공한다.            GNU는 운영체제의 하나이자 컴퓨터 소프트웨어의 모음집이다.            GDB를 사용하면, 프로그램의 실행을 정교하게 제어하면서 실행되는 프로그램을 관찰하여 프로그램의 동작을 분석할 수 있다.   일반적인 방법은 브레이크포인트를 프로그램에서 관심이 있는 부분 근처에 설정하는 것이다.   프로그램 실행중에 브레이크포인트를 만나게 되면, 프로그램은 실행을 중단하고, 제어를 사용자에게 넘긴다.   3.10.3 범위를 벗어난 메모리 참조와 버퍼 오버플로우      C에서는 배열참조 시 범위를 체크하지 않으며, 지역변수들이 스택에 보존용 레지스터들과 리턴 주소 같은 상태정보와 함께 스택에 저장된다는 것을 배웠다.   에를들어 배열에 문자열이 저장될 때 stack top인 return address 범위까지 저장이 되면 심각한 오류를 발생시킨다.             버퍼 오버플로우의 보다 치명적인 사용은 일반적으로 프로그램이 하지 않을 기능들을 실행하도록 하는 것이다.   일반적으로 탐색코드exploit code 라고 하는 실행코드를 바이트 인코딩한 탐색코드를 가리키는 포인터 리턴 주소를 덮어쓰는 약간의 추가적인 바이트들을 포함하는 스트링을 입력한다. ret 인스트럭션을 실행하면 탐색코드로 점프하게된다.            인터넷 상의 많은 컴퓨터에 접속을 획득한 FINGER 데몬인 fingerd로의 버퍼 오버플로우 공격이 있다.           3.10.4 버퍼 오버플로우 공격 대응 기법      이들 공격이 실행되기 어렵게 하는 방법과 침입자가 버퍼 오버플로우 공격을 통해서 시스템의 제어권을 획득할 수 있는 방법을 제한하는 방법을 구현하였다.      스택 랜덤화            공격자는 탐색코드를 시스템에 삽입하기 위해서 공격 스트링 내에 코드뿐만 아니라 코드로의 포인터까지 집어넣어야한다. 이 포인터를 만들기 위해서는 스트링이 위치하게 될 스택의 주소를 알아야 한다. 역사적으로 프로그램의 스택 주소는 쉽게 에측할 수 있었다.              스택 랜덤화의 아이디어는 스택의 위치를 프로그램의 매 실행마다 다르게 해주는 것이다.   ASLR을 사용하면 프로그램 코드, 라이브러리 코드, 스택, 전역변수, 힙 데이터를 포함하는 여러 프로그램의 부분들이 프로그램이 매번 실행할 때마다 메모리의 다른 지역에 로딩된다.   하지만, 이런 방법은 공격자가 반복적으로 주소를 바꿔가며 무지막지한 공격을 하면 랜덤화를 극복할 수 있다.      스택 손상 검출            두번째 방법은 스택이 손상되는 것을 감지하는 것이다.       아래의 그림은 스택 보호기가 작동될 때 해당 함수의 스택 구성이다. 특별 “canary” 값이 배열 buf와 저장된 상태 값 사이에 위치한다. 코드는 스택 상태가 손상되었는지 여부를 결정하기 위해 canary 값을 체크한다.                 실행코드 영역 제한하기            마지막 방법은 공격자가 실행코드를 시스템에 추가할 가능성을 제거하는 것이다.       어느 메모리 영역이 실행코드를 저장할지를 제한하는 거시앋. 다른 부분들은 읽기와 쓰기만 허용하도록 제한할 수 있다.           3.10.5 가변크기 스택 프레임 지원하기      공통적으로 할당되어야 하는 스택 프레임의 크기를 컴파일러가 미리 결정할 수 있다는 특징이 있었다. 하지만 일부 함수들은 가변적인 지역저장공간 크기를 필요로 한다.     ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_10/",
        "teaser": null
      },{
        "title": "[Algorithm/Java] 프로그래머스 Level1 완주하지 못한 선수 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 해시 완주하지 못한 선수 자바(Java) 풀이      풀이로 이동!   문제풀이     java 알고리즘 문제 풀이의 두번째 문제이다. 처음 풀어본 문제보다는 자바 문법이 조금 익숙했다. 하지만, 해시를 어떻게 선언하는지 조차 모르고 있어서, 이 부분은 구글링을 하며 풀었다. 이번 문제를 통해서 자바의 해쉬맵을 사용할 수 있게 되었다. 해쉬맵의 여러가지 method들을 숙지하고 있으면 코테에 많은 도움이 될 것 같다.       참가자들이 저장되어 있는 String 배열을 HashMap에 옮겨 담는다.   이 때 참가자들의 이름은 Key값으로 Value는 참가자들의 중복의 유무를 포함하기 위해 default 값을 0으로, 중복된 참가자가 있으면 value를 1씩 증가시킨다.   완주한 참가자들의 이름을 containsKey를 사용하여 해당 Key값의 Value를 1씩 감소시킨다.   해쉬맵의 모든 키를 순회하면서 value값이 0보다 큰 값을 찾는다.   해당 키값을 answer에 저장한다.   return answer   코드       import java.util.*;          public class Main {         public static void main(String[] args){             String[] participant = {\"mislav\", \"stanko\", \"mislav\", \"ana\"};             String[] completion = {\"stanko\", \"ana\", \"mislav\"};                  String answer = solution(participant, completion);             System.out.println(answer);         }              public static String solution(String[] participant, String[] completion){             //정답 문자열 변수 선언             String answer = \"\";             //해쉬맵(딕셔너리) 변수 선언 -&gt; participant 키값으로 넣고 value 값에 Integer 선언해서 completion이랑 비교할거임             Map&lt;String, Integer&gt;ht = new HashMap&lt;String,Integer&gt;();             //해쉬맵에 participant를 키값으로 밸류는 default로 0씩, 키값 중복되면 1씩 추가             for(int i=0; i&lt;participant.length; i++){                 if(ht.containsKey(participant[i])){                     ht.put(participant[i],ht.get(participant[i])+1);                 }                 else{                     ht.put(participant[i],1);                 }             }             //completion을 키값으로 찾아서 밸류값 1씩 감소             for(int i=0; i&lt;completion.length; i++){                 if(ht.containsKey(completion[i])){                     ht.put(completion[i],ht.get(completion[i])-1);                 }             }             //해쉬맵 모든 키를 순회하면서 0보다 큰거 answer에 저장             for(String key:ht.keySet()) {                 if(ht.get(key)&gt;0){                     answer=key;                 }             }                  return answer;         }     }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/algorithm/java_02/",
        "teaser": null
      },{
        "title": "[Algorithm/Java] 프로그래머스 Level1 모의고사 풀이",
        "excerpt":"프로그래머스(Programmers) 코딩테스트 연습   Level1 정렬 K번째수 자바(Java) 풀이      풀이로 이동   문제풀이     완전 탐색 문제다. 완전 탐색은 “컴퓨터의 빠른 계산을 이용하여 가능한 모든 경우의 수를 구하는 알고리즘”이다.  문제를 어떻게 해결할지 방향을 잡고 최대한 빠른 로직으로 코드를 구현하는 것이 관건으로 보인다.       사용자들의 정답 패턴을 각각의 배열에 저장한다.   사용자들이 정답을 맞추는 개수를 저장하는 배열을 선언한다. (0으로 초기화한다.)   사용자들의 정답 패턴의 length를 answers와의 나머지를 구하여 패턴을 일치시킨다.   사용자들의 정답의 개수를 저장하고, 해당 배열의 max값을 찾는다.   max값과 일치하는 사용자들의 정답 개수를 갖는 index를 answer 배열에 저장한다.   return answer      BadSolution을 보면 Solution보다 더 많은 조건문이 존재하는 것을 알 수 있다. 이렇듯, 완전 탐색 문제에서는 로직을 최대한 간결하게 작성하는 것이 중요하다.    코드         import java.util.*;              public class Main {       public static void main(String[] args){       int[] answers = {1,2,3,4,5};                      int[] answer = solution(answers);               System.out.println(Arrays.toString(answer));           }           public static int[] solution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};                      int[] answerList = {0,0,0};                      for(int i=0; i&lt;answers.length; i++){                   if(user1[i%user1.length]==answers[i]){                       answerList[0]++;                   }                   if(user2[i%user2.length]==answers[i]){                       answerList[1]++;                   }                   if(user3[i%user3.length]==answers[i]){                       answerList[2]++;                   }               }               int max=answerList[0];               for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]&gt;max) {                       max = answerList[i];                   }               }                      ArrayList&lt;Integer&gt; arrList = new ArrayList();                      for(int i=0; i&lt;answerList.length; i++){                   if(answerList[i]==max){                       arrList.add(i);                   }               }                      int size = arrList.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = arrList.get(i)+1;               }               return answer;           }                  public static int[] BadSolution(int[] answers){               int[] user1 = {1,2,3,4,5};               int[] user2 = {2,1,2,3,2,4,2,5};               int[] user3 = {3,3,1,1,2,2,4,4,5,5};               int j1=0,j2=0,j3=0;               int[] user_answer ={0,0,0};               List&lt;Integer&gt; answer_list = new ArrayList&lt;Integer&gt;();               for(int i=0; i&lt;answers.length; i++){                   if(j1&gt;=user1.length){                       j1=0;                   }                   if(answers[i] == user1[i]){                       user_answer[0]++;                   }                   j1++;                   if(j2&gt;=user2.length){                       j2=0;                   }                   if(answers[i] == user2[i]){                       user_answer[1]++;                   }                   j2++;                   if(j3&gt;=user3.length){                       j3=0;                   }                   if(answers[i] == user3[i]){                       user_answer[2]++;                   }                   j3++;               }               int max=user_answer[0];               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]&gt;max){                       max = user_answer[i];                   }               }               for(int i=0; i&lt;user_answer.length; i++){                   if(user_answer[i]==max){                       answer_list.add(i);                   }               }                      int size = answer_list.size();               int[] answer = new int[size];                      for(int i=0; i&lt;size; i++){                   answer[i] = answer_list.get(i)+1;               }               return answer;           }       }  ","categories": ["Algorithm"],
        "tags": ["Algorithm","Java","프로그래머스 코테"],
        "url": "/algorithm/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 쓰레드",
        "excerpt":"Part7 쓰레드   쓰레드란   동시에 여러가지 작업을 동시에 수행할 수 있게 하는것     동시에 여러가지 작업을 수행할 수 있다.   프로세스란 현재 실행되고 있는 프로그램을 말한다.   자바 프로그램은 JVM에 위해 실행된다. 이 JVM도 프로그램중에 하나이다.   운영체제 입장으로 보면 자바도 하나의 프로세스로 실행 하는 것이다.   워드프로세서가 하나의 프로세스라면, 하나의 프로세스 안에서도 여러개의 흐름이 동작할 수 있다. 이것은 Thread라고 말한다.   쓰레드 만들기   자바에서 Thread를 만드는 방법은 크게 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법이 있다.     Thread를 상속 받아서 쓰레드를 생성하는 방법            java.lang.Thread 클래스를 상속받는다. 그리고 Thread가 가지고 있는 run() 메소드를 오버라이딩한다.       10번 반복하면서 str를 찍는다.               public class MyThread1 extends Thread {         String str;         public MyThread1(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     //컴퓨터가 너무 빠르기 때문에 수행결과를 잘 확인 할 수 없어서 Thread.sleep() 메서드를 이용해서 조금씩                      //쉬었다가 출력할 수 있게한다.                      Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Thread 클래스를 상속받은 MyThread1을 사용하는 클래스            Thread를 상속 받았으므로 MyThread1은 Thread 이다.       쓰레드를 생성하고, Thread 클래스가 가지고 있는 start() 메소드를 호출 한다.               public class ThreadExam1 {         public static void main(String[] args) {             // MyThread인스턴스를 2개 만듭니다.              MyThread1 t1 = new MyThread1(\"*\");             MyThread1 t2 = new MyThread1(\"-\");              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }     Runnable 인터페이스를 구현해서 쓰레드를 만드는 방법            Runnable 인터페이스가 가지고 있는 run() 메소드를 구현한다.               public class MyThread2 implements Runnable {         String str;         public MyThread2(String str){             this.str = str;         }          public void run(){             for(int i = 0; i &lt; 10; i ++){                 System.out.print(str);                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }          }      }     Runnable 인터페이스를 구현한 MyYhread2 사용하는 방법            MyThread2는 Thread를 상속받지 않았기 때문에 Thread가 아니다.       Thread를 생성하고, 해당 생성자에 MyThread2를 넣어서 Thread를 생성한다.       Thread 클래스가 가진  start() 메소드를 호출한다.               public class ThreadExam2 {           public static void main(String[] args) {             MyThread2 r1 = new MyThread2(\"*\");             MyThread2 r2 = new MyThread2(\"-\");              Thread t1 = new Thread(r1);             Thread t2 = new Thread(r2);              t1.start();             t2.start();             System.out.print(\"!!!!!\");           }        }  쓰레드와 공유객체   하나의 객체를 여러개의 Thread가 사용한다는 것을 의미   MusicBox 라는 클래스가 있다고 가정한다. 해당 클래스는 3개의 메소드를 가지고 있다. 각각의 메소드는 1초 이하의 시간동안 10번 반복하면서,  어떤 음악을 출력한다. 이러한 MusicBox를 사용하는 MusicPlayer를 3명 만들어 보겠다.   MusicPlayer 3명은 하나의 MusicBox를 사용할 것이다. 이 때 어떤 일이 발생하는지 살펴보겠다.      공유객체 MusicBox       public class MusicBox {          //신나는 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicA(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"신나는 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicA          //슬픈 음악!!!이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicB(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"슬픈 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicB         //카페 음악!!! 이란 메시지가 1초이하로 쉬면서 10번 반복출력         public void playMusicC(){             for(int i = 0; i &lt; 10; i ++){                 System.out.println(\"카페 음악!!!\");                 try {                     Thread.sleep((int)(Math.random() * 1000));                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             } // for                 } //playMusicC       }     MusicBox를 가지는 Thread 객체 MusicPlayer       public class MusicPlayer extends Thread{         int type;         MusicBox musicBox;           // 생성자로 부터 musicBox와 정수를 하나 받아들여서 필드를 초기화         public MusicPlayer(int type, MusicBox musicBox){             this.type = type;             this.musicBox = musicBox;         }                // type이 무엇이냐에 따라서 musicBox가 가지고 있는 메소드가 다르게 호출         public void run(){             switch(type){                 case 1 : musicBox.playMusicA(); break;                 case 2 : musicBox.playMusicB(); break;                 case 3 : musicBox.playMusicC(); break;             }         }            }     MusicBox와 MusicPlayer를 이용하는 MusicBoxExam1 클래스       public class MusicBoxExam1 {          public static void main(String[] args) {             // MusicBox 인스턴스             MusicBox box = new MusicBox();              MusicPlayer kim = new MusicPlayer(1, box);             MusicPlayer lee = new MusicPlayer(2, box);             MusicPlayer kang = new MusicPlayer(3, box);              // MusicPlayer쓰레드를 실행합니다.              kim.start();             lee.start();             kang.start();                    }        }  동기화 메소드와 동기화 블록      고유객체가 가진 메소드를 동시에 호출 되지 않돚록 하는 방법            메소드 앞에 synchronized 를 붙힌다.       여러개의 Thread 들이 공유객체의 메소드를 사용할 때 메소드에 synchronized가 붙어 있을 경우 먼저 호출한 메소드가 객체의 사용권(Monitoring Lock)을 얻는다.               public synchronized void playMusicA(){         for(int i = 0; i &lt; 10; i ++){             System.out.println(\"신나는 음악!!!\");             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicA     메소드 앞에 synchronized 를 붙혀서 실행해 보면, 메소드 하나가 모두 실행된 후에 다음 메소드가 실행된다.   해당 모니터링 락은 메소드 실행이 종료되거나, wait() 와 같은 메소드를 만나기 전까지 유지된다.   다른 쓰레드들은 모니터링 락을 놓을 때 까지 대기한다.   synchronized를 붙히지 않은 메소드는 다른 쓰레드들이 synchronized메소드를실행하면서 모니터링 락을 획득했다 하더라도, 그것과 상관없이 실행된다.   synchronized를 메소드에 붙혀서 사용 할 경우, 메소드의 코드가 길어지면, 마지막에 대기하는 쓰레드가 너무 오래 ㅣㄱ다리는 것을 막기 위해서 메소드에 synchronized를 붙이지 않고, 문제가 있을 것 같은 부분만 synchronized 블록을 사용한다.       public void playMusicB(){         for(int i = 0; i &lt; 10; i ++){             synchronized(this){                 System.out.println(\"슬픈 음악!!!\");             }             try {                 Thread.sleep((int)(Math.random() * 1000));             } catch (InterruptedException e) {                 e.printStackTrace();             }         } // for             } //playMusicB  쓰레드와 상태제어   쓰레드가 3개가 있다면 JVM은 시간을 잘게 쪼갠 후에 한번은 쓰레드1을, 한번은 쓰레드 2를, 한번은 쓰레드3을 실행한다. 이것을 빠르게 일어나다 보니 쓰레드가 모두 동작하는 것처럼 보이는 것이다.      쓰레드는 실행가능상태인 Runnable과 실행상태인 Running상태로 나뉜다.   실행되는 쓰레드 안에서 Thread.sleep() 이나 Object가 가지고 있는 wait() 메소드가 호출이 되면 쓰레드는 블록상태가 된다.   Thread.sleep() 은 특정시간이 지나면 자신 스스로 블록상태에서 빠져나와 Runnable 이나 Running상태가 된다.   Object가 가지고 있는 wait() 메소드는 다른 쓰레드가 notify()나 notifyAll() 메소드를 호출하기 전에는 블록상태에서 해체되지 않는다.   wait()메소드는 호출이 되면 모니터링 락을 놓게 된다. 그래서 대기중인 다른 메소드가 실행한다.   쓰레드의 run메소드가 종료되면, 쓰레드는 종료된다. 즉 Dead상태가 된다.   Thread의 yeild메소드가 호출되면 해당 쓰레드는 다른 쓰레드에게 자원을 양보하게 된다.   Thread가 가지고 있는 join메소드를 호출하게 되면 해당 쓰레드가 종료될 때까지 대기하게 된다.   쓰레드와 상태제어 (join)   join() 메소드는 쓰레드가 멈출 때까지 기다리게 한다.      일단 0.5초씩 쉬면서 숫자를 출력하는 MyThread5를 작성해 보겠다.       public class MyThread5 extends Thread{         public void run(){             for(int i = 0; i &lt; 5; i++){                 System.out.println(\"MyThread5 : \"+ i);                 try {                     Thread.sleep(500);                 } catch (InterruptedException e) {                     e.printStackTrace();                 }             }         } // run     }     해당 쓰레드를 실행하고, 해당 쓰레드가 종료될 때 까지 기다린 후, 내용을 출력하는 joinExam 클래스       public class JoinExam {          public static void main(String[] args) {             MyThread5 thread = new MyThread5();             // Thread 시작              thread.start();              System.out.println(\"Thread가 종료될때까지 기다립니다.\");             try {                 // 해당 쓰레드가 멈출때까지 멈춤                 thread.join();             } catch (InterruptedException e) {                 e.printStackTrace();             }             System.out.println(\"Thread가 종료되었습니다.\");          }        }     실행 결과           Thread가 종료될때까지 기다립니다.         MyThread5 : 0         MyThread5 : 1         MyThread5 : 2         MyThread5 : 3         MyThread5 : 4         Thread가 종료되었습니다.  쓰레드와 상태제어 (wait, notify)   wait과 notify는 동기화된 블록 안에서 사용해야 한다. wait를 만나게 되면 해당 쓰레드는 해당 객체의 모니터링 락에 대한 권한을 가지고 있다면 모니터링 락의 권한을 놓고 대기한다.      Thread를 상속받는 ThreadB 클래스 작성       public class ThreadB extends Thread{        // 해당 쓰레드가 실행되면 자기 자신의 모니터링 락을 획득        // 5번 반복하면서 0.5초씩 쉬면서 total에 값을 누적        // 그후에 notify()메소드를 호출하여 wiat하고 있는 쓰레드를 깨움          int total;         @Override         public void run(){             synchronized(this){                 for(int i=0; i&lt;5 ; i++){                     System.out.println(i + \"를 더합니다.\");                     total += i;                     try {                         Thread.sleep(500);                     } catch (InterruptedException e) {                         e.printStackTrace();                     }                 }                 notify();             }         }     }     이번에는 ThreadB 를 사용하며 wait 하는 클래스 작성       public class ThreadA {         public static void main(String[] args){             // 앞에서 만든 쓰레드 B를 만든 후 start              // 해당 쓰레드가 실행되면, 해당 쓰레드는 run메소드 안에서 자신의 모니터링 락을 획득             ThreadB b = new ThreadB();             b.start();              // b에 대하여 동기화 블럭을 설정             // 만약 main쓰레드가 아래의 블록을 위의 Thread보다 먼저 실행되었다면 wait를 하게 되면서 모니터링 락을 놓고 대기                    synchronized(b){                 try{                     // b.wait()메소드를 호출.                     // 메인쓰레드는 정지                     // ThreadB가 5번 값을 더한 후 notify를 호출하게 되면 wait에서 깨어남                     System.out.println(\"b가 완료될때까지 기다립니다.\");                     b.wait();                 }catch(InterruptedException e){                     e.printStackTrace();                 }                  //깨어난 후 결과를 출력                 System.out.println(\"Total is: \" + b.total);             }         }     }     실행 결과           b가 완료될때까지 기다립니다.         0를 더합니다.         1를 더합니다.         2를 더합니다.         3를 더합니다.         4를 더합니다.         Total is: 10  데몬 쓰레드   데몬(Daemon)이란 보통 리눅스와 같은 유닉스계열의 운영체제에서 백그라운드로 동작하는 프로그램을 말한다.     데몬쓰레드를 만뜨는 방법은 쓰레드에 데몬 설정을 하면 된다.            이런 쓰레드는 자바프로그램을 만들 때 백그라운드에서 특별한 작업을 처리하게 하는 용도로 만든다.           데몬쓰레드는 일반 쓰레드(main 등)가 모두 종료되면 강저젝으로 종료되는 특징을 가지고 있다.       // Runnable을 구현하는 DaemonThread클래스를 작성     public class DaemonThread implements Runnable {          // 무한루프안에서 0.5초씩 쉬면서 데몬쓰레드가 실행중입니다를 출력하도록 run()메소드를 작성         @Override         public void run() {             while (true) {                 System.out.println(\"데몬 쓰레드가 실행중입니다.\");                  try {                     Thread.sleep(500);                  } catch (InterruptedException e) {                     e.printStackTrace();                     break; //Exception발생시 while 문 빠찌도록                  }             }         }          public static void main(String[] args) {             // Runnable을 구현하는 DaemonThread를 실행하기 위하여 Thread 생성             Thread th = new Thread(new DaemonThread());             // 데몬쓰레드로 설정             th.setDaemon(true);             // 쓰레드를 실행             th.start();              // 메인 쓰레드가 1초뒤에 종료되도록 설정.              // 데몬쓰레드는 다른 쓰레드가 모두 종료되면 자동종료.             try {                 Thread.sleep(1000);             } catch (InterruptedException e) {                 e.printStackTrace();             }                System.out.println(\"메인 쓰레드가 종료됩니다. \");             }        } ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_14/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 람다",
        "excerpt":"Part8 람다   람다식   람다식은 다른말로 익명 메소드라고도 한다.      인터페이스 중에서 메소드를 하나만 가지고 있는 인터페이스르함수형 인터페이스라고 한다.            쓰레드를 만들 때 사용하는 Runnable 인터페이스의 경우 run() 메소드를 하나만 가지고 있다.           Runnable을 이용하여 쓰레드를 만드는 방법       public class LambdaExam1 {          public static void main(String[] args) {             new Thread(new Runnable(){public void run(){                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }}).start();         }        }     쓰레드가 실행되면 쓰레드 생성자 안에 넣은 run()메소드가 실행된다.   자바는 메소드만 배개변수로 전달할 방법이 없다. 인스턴스만 전달할 수 있다.   그렇기 때문에 run()메소드를 가지고 있는 Runnable 객체를 만들어서 전달한다.   메소드만 전달할 수 있다면, 좀 더 편리하게 프로그래밍할 수 있을텐데, 자바는 메소드만 전달할 수 있는 방법은 없었기 때문에 매번 객체를 생성해서 매개변수로 전달해야 했다. 이러한 부분을 해결한 것이 람다 표현식이다.      람다식을 이용해서 수정한 코드       public class LambdaExam1 {           public static void main(String[] args) {             new Thread(()-&gt;{                 for(int i = 0; i &lt; 10; i++){                     System.out.println(\"hello\");                 }             }).start();         }        }     ()-&gt;{……} 부분이 람다식, 다른말로 익명 메소드   JVM은 Thread생성자를 보고 ()-&gt;{} 이 무엇인지 대상을 추론한다.   Thread 생성자 api를 보면 Runnable 인터페이스를 받아들이는 것을 알 수 있다.   JVM은 Thread 생성자가 Runnable 인터페이스를 구현한 것이 와야 하는 것을 알게 되고 람다식을 Runnable을 구현하는 객체로 자동으로 만들어서 매개변수로 넣어준다.        프로그래머스 자바 입문을 마무리하며  자바 초급 강의보다는 조금 덜 직관적으로 와닿은 강의였다. 자바 중급 강의에서 배우는 다양한 패키지와 IO 그리고 쓰레드와 람다를 정확히 어느 경우에 사용 하는지 모호하기 때문인 것 같다. 이러한 부분들은 향후 java 언어를 자주 사용하게 됨으로써 해당 기능들을 사용하게 되었을 때 더 직관적으로 이해할 수 있을 것 같다. 해당 기능들을 사용할 때 이해가 되지 않는다면, 이번에 포스팅한 프로그래머스 자바 중급 강의를 사용하면 좋을 것 같다.     해당 강의와 강의 노트는 프로그래머스 자바 중급에서 언제든지 다시 들을 수 있다!  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 중급"],
        "url": "/java/java_15/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.11 부동소수점 코드 ~ 3.12 요약)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져   3.8 배열의 할당과 접근   3.9 이기종 자료구조   3.10 기계수준 프로그램에서 제어와 데이터의 결합   3.11 부동소수점 코드   3.12 요약   3.11 부동소수점 코드      프로세서의 부동소수점 아키텍처는 부동소수점 데이터로 연산하는 방법이 기계에 매피되는 방법에 영향을 주는 다음과 같은 여러 가지 개념들로 구성된다.            부동소수점 값들이 저장되고 접근되는 방법                    이것은 대개 레지스터들의 일부 형태로 이뤄진다.                       부동소수점 데이터로 연산하는 인스트럭션       함수들의 인자와 리턴 값으로 부동소수점 값들을 전달하기 위해 이용되는 관례들       함수를 호출하는 동안에 레지스터들을 보존하는 관례들           x86-64 부동소수점 아키텍처를 이해하기 위해선 간략한 역사적 고찰을 해보는 것이 유용하다.            1997년에 펜티엄/MMX를 발표한 이래, 인텔과 AMD는 그래픽과 영상처리를 지원하기 위해 일련의 미디어 인스트럭션 세대들을 포함해왔다.       이들에 대한 확장현태가 진행되었고 MMX로부터 SSE, AVX로 개선되어갔다.       AVX 부동소수점 아키텍처는 %ymm0-%ymm15로 이름 붙인 16개의 YMM 레지스터들에 저장된다.       스칼라 데이터로 연산할 때, 이 레지스터들은 부동소수점 데이터만을 보관하며, 하위 32비트(float), 64비트(double)만이 사용된다.              3.11.1 부동소수점 이동 및 변환 연산      XMM 레지스터에서 다른 레지스터로 이동하는 것뿐만 아니라 메모리와 XMM 레지스터들 간의 부동소수점 데이터를 이동하는 인스트럭션들을 보여준다.   메모리를 참조하는 인스트럭션들은 스칼라 인스트럭션들이다.            이것은 이들이 묶인 데이터 값들이 아닌 개별 값들에 대해 연산한다는 것을 의미한다.           GCC는 데이터를 메모리에서 XMM 레지스터로,또는 XMM 레지스터에서 메모리로 이동하기 위해서만 스칼라 이동연산을 이용한다.        두 개의 XMM 레지스터들 간의 데이터 이동을 위해서는 한 개의 XMM 레지스터의 내용 전체를 다른 레지스터로 복사하기 위해 두 개의 인스트럭션 중 하나를 이용한다.       아래의 그림은 부동소수점 이동 명령. 이 연산들은 레지스터들 간, 레지스터와 메모리 간에 값을 이동한다.         아래의 그림은 두 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 부동소수점 데이터를 정수로 변환한다.         아래의 그림은 세 개의 오퍼랜드를 갖는 부동소수점 변환 연산. 이들은 첫번째 소스의 자료형으로부터 목적지의 자료형으로 변환한다. 두번째 소스 값은 결과의 하위 바이트에는 영향을 주지 않는다.      3.11.2 프로시저에서 부동소수점 코드      XMM 레지스터들이 함수로 부동소수점 인자를 전송하고 부동소수점 값들을 리턴할 때 사용된다.            최대 여덟 개의 부동소수점 인자들이 %xmm0-%xmm7 XMM 레지스터들로 전달될 수 있다.       한개의 부동소수점 값을 리턴하는 함수는 레지스터 %xmm0를 이용한다.       모든 XMM 레지스터들은 호출자 저장방식이다.           어떤 함수가 포인터, 정수, 부동소수점 인자들의 조합을 가지고 있을 때, 포인터와 정수들은 범용 레지스터로 전달되지만, 부동소수점 값들은 XMM 레지스터들로 전달된다.      3.11.3 부동소수점 산술연산      스칼라 부동소수점 산술연산. 이 인스트럭션들은 한 개 또는 두 개의 소스 오퍼랜드와 하나의 목적지 오퍼랜드를 갖는다.   첫번빼 소스 오퍼랜드 S1은 XMM 레지스터나 메모리 위치일 수 있다.   두번째 소스 오퍼랜드와 목적지 오퍼랜드는 XMM 레지스터만 가능하다.      3.11.4 부동소수점 상수의 정의 및 이용      AVX 부동소수점 연산은 즉시값immediate value을 오퍼랜드로 가질 수 없다.   그 대신, 컴파일러는 상수 값들을 위해 저장공간을 할당하고 초기화해야 한다.        그리고 나서 코드는 메모리에서 값들을 읽어들인다.       아래의 그림을 보면 값 1.8을 .LC2로 명명된 메모리 위치에서 읽어들이고, 32.0을 메모리 위치 .LC3에서 읽어들이는 것을 알 수 있다.      3.11.5 부동소수점 코드에서 비트연산 사용하기      아래의 그림은 통합데이터에 대한 비트 연산이다. 이 인스트럭션들은 XMM 레지스터에 들어 있는 128비트들에 대한 부울연산을 수행한다.      3.11.6 부동소수점 비교 연산      AVX2는 부동소수점 값들을 비교하기 위해 두 개의 인스트럭션을 제공한다.         부동소수점 비교 인스트럭션은 세 개의 조건코드를 설정한다: zero 영 플래그 ZF, 캐리 플래그 CF, 패리티 플래그 PF            패리티 플래그는 가장 최근 산술 또는 논리연산이 최소중요바이트를 짝수 패리티를 갖는 값을 생성했을 때 설정된다.                    패리티 플래그 무슨소린지 하나도 모르겠다… 이건 좀더 조사해보자!                            3.11.7 부동소수점 코드에 대한 관찰      AVX2로 부동소수점 데이터에 대해 연산하기 위해 생성된 머신코드의 일반적인 스타일이 정수데이터에 연산하는 경우에 대해 살펴본 것과 유사하다는 것을 알았다.   이 둘은 모두 값을 보관하고 연산하기 위해 레지스터들을 사용하며, 이들은 이 레지스터를 사용해서 함수의 인자를 전달한다.   3.12 요약     이 장에서는 기계어 수준 프로그래밍의 시각을 얻기 위해 C언어에서 제공하는 추상화 계층 아래를 살펴보았다.        컴파일러가 기계어 수준 프로그램의 어셈블리 코드 표현을 생성하게 해서 프로세서, 자료형, 인스트럭션 집합과 함께 컴파일러와 컴파일러의 최적화 능력에 대한 통찰을 얻을 수 있었다.       기계어 수준 프로그램들과 이들의 어셈블리 코드 표시는 C 프로그램들과는 여러모로 다른다.   서로 다른 자료형들 사이에 차이는 거의 없다.   프로그램은 인스트럭션들의 연속으로 표시되고, 각각은 한 개의 연산을 수행한다.   컴파일러는 여러 가지 자료구조를 생성하고 처리하기 위해서, 조건문, 루프, 프로시저 같은 제어문을 구현하기 위해서 다수의 인스트럭션들을 사용해야 한다.        C에서 경계 값을 체크하지 않기 때문에 많은 프로그램들이 버퍼 오버플로우의 위험에 놓인다는 것을 알게 되었다.       자바는 ‘자바 바이트 코드’라고 알려진 특별한 이진 표현이다.      Chapter3 또한 부동소수점을 마지막으로 마무리 하였다. 기계어 표현인 어셈블리어에 대한 내용이 한가득 있었던 챕터였다. 간단한 이동과 연산부터 배열, 조건문, 프로시저, 부동소수점 까지의 기계어 인스트럭션들을 살펴보았고, 이러한 인스트럭션을 통해서 컴퓨터는 연산 명령을 받게 된다. 이해하기 어려운 기계어는 실제로 C언어를 기계어 단계에서 디버깅 하면서 이해를 도왔다. &lt;- 이부분이 이해가 직관적으로 되어서 참 좋았다. Chapter2~3은 Chapter4의 빌드업이라고도 한다. 확실히 이해하고 Chapter 4로 넘어가자!   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_11/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.1 Y86-64 인스트럭션 집합 구조)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조      3장까지는 컴퓨터 시스템을 기계어 프로그램의 수준까지만 내려가서 살펴보았다.   프로세서가 일련의 명령어들을 샐힝하고, 각 명령으들은 두 개의 수를 더한다든지의 기본적인 기능을 수행하는 것을 알게 되었다.   한 개의 인스트럭션은 연속된 바이트들로 이진수의 형태로 인코딩된다.   인스트럭션들은 특정 프로세서에 의해 지원되며, 바이트수준의 인코딩을 인스트럭션 집합 구조instruction set architecture(ISA)라고 한다.   ISA는 어떤 인스트럭션들이 허용되고, 어떻게 그들이 인코딩되었는지 알고 있는 컴파일러 작성자와 이들 인스트럭션을 실행해야 하는 머신을 만들어야 하는 프로세서 설계자들에게 개념적 추상화 계층을 제공하고 있다.      4장에서는 프로세서 하드웨어의 설계를 간단히 살펴본다.   하드웨어 시스템이 어떻게 특정 ISA의 인스트럭션들을 실행할 수 있는지를 학습한다.   이러한 관점은 어떻게 컴퓨터들이 동작하는지와 컴퓨터 제작자들이 직면하고 있는 기술적인 도전들을 더 잘 이해할 수 있게 해준다.   왜 프로세서 설계를 공부해야 하는 것인가?            지적으로 흥미롭고 중요하기 때문이다.       프로세서의 동작방법을 이해하면 전체 컴퓨터 시스템의 동작 방법을 이해하는 데 도움을 준다.       비록 적은 수의 사람들만이 프로세서를 설꼐하지만 많은 사람들이 프로세서를 포함하는 하드웨어 시스템을 설계한다.              4장에서는 인스트럭션 집합을 정의한다 : “Y86-64” 인스트럭션 집합   x86-64에 비해서 적은 자료형, 인스트럭션, 주소지정 모드를 갖는다.   디지털 하드웨어 설계에 관한 약간의 배경지식을 제공한다.            기초 설계 블록과 이들이 어떻게 서로 연결되고 동작하는지 설명한다.       불 대수와 비트수준 연산에 관한 논의에 기초한다.       간단한 언어인 HCL : 하드웨어 시스템의 제어 부분을 설명하는 데 사용된다.           순차 설계를 기초로 해서 파이프라인형pipelined 프로세서를 만드는 일련의 변환을 적용한다.            각 인스트럭션의 실행단계를 5단계로 나누어서 각각 별도의 부분 또는 하드웨어 단계에서 처리되도록 한다.           4.1 Y86-64 인스트럭션 집합  인스트럭션 집합을 설계하기 위해서는 여러 가지 상태요소들, 인스트럭션 집합과 이들의 인코딩, 프로그래밍 관습들, 예외적 사건들의 처리 등에 대한 정의를 해야 한다.   4.1.1 프로그래머-가시성 상태programmer-visible state     Y86-64의 각 인스트럭션은 프로세서 상태의 일부를 읽거나 변경할 수 있다.            이것을 프로그래머-가시성상태programmer-visible state라고 한다.           프로세서를 구현할 때는 기계수준 프로그램이 프로그래머 가시 상태에 접근하는 것을 확실히 할 수만 있다면 이 상태를 ISA가 의미하는 방식대로 정확히 표시하거나 구성할 필요가 없다는 것을 알게 될 것이다.        아래의 그림은 Y86-64 프로그래머-가시성 상태이다. 프로그램 레지스터, 조건코드, 프로그램 카운터(PC), 메모리를 접근하고 수정할 수 있다. 상태코드는 이 프로그램이 정상적으로 실행되고 있는지, 어떤 특수한 사건이 발생했는지를 나타낸다.                     레지스터 %rsp는 push, pop, call, return 인스트럭션을 사용할 때 스택 포인터로 이용된다.       메모리는 개념적으로 커다란 바이트의 배열이다.                    Y86-64 프로그램들은 가상주소를 사용해서 메모리 위치를 참조한다.           운영체제와 하드웨어가 함께 이 가상주소를 실제주소, 즉 물리 주소로 번역한다.                       프로그램 상태의 마지막 부분은 상태코드 Stat이다.                    프로그램 실행의 전체적인 상태를 나타낸다.                           4.1.2 Y86-64 인스트럭션      아래의 그림은 Y86-64 인스트럭션 집합이다.            인스트럭션 인코딩은 1에서 10바이트가 쇼요된다.       한개의 인스트럭션은 1바이트의 인스트럭션 식별자와 1바이트 레지스터 식별자, 8바이트 상수 워드로 구성될 수 있다.       필드 fn은 특정 연수 연산(OPq), 데이터 이동 조건(cmovXX), 분기조건(jxx)을 나타낸다.       모든 숫자 값은 16진수로 나타낸다.                         movq 인스트럭션은 네 개의 인스트럭션으로 나누어진다.                    irmovq, rrmovq, mrmovq, rmmovq           소스와 목적지를 명시적으로 나타낸다.           소스는 상수 immediatde(i), 레지스터(r), 메모리(m) 중의 하나가 될 수 있다.                       OPq로 나타낸 것처럼 네 개의 정수 연산이 있다.                    addq, subq, andq, xorq           이 인스트럭션 집합은 ZF, SF, OF(zero, sign, overflow) 조건코드를 결정한다.                       일곱개의 jump 인스트럭션이 있다.                    jmp, jle, jl, je, jne, jge, jg                       여섯 개의 move 인스트럭션이 있다.                    cmovle, cmovl, cmove, cmovne, cmovge, cmovg           목적지 레지스터는 조건코드가 요구된 조건을 만족할 때에만 갱신된다.                       call 인스트럭션은 리턴주솔들 스택에 넣고 목적지 주소로 이동한다.       ret 인스트럭션은 call에서 리턴해준다.       pushq와 popq 인스트럭션은 push와 pop을 구현한다.       halt 인스트럭션은 인스트럭션의 실행을 정지시킨다.           4.1.3 인스트럭션 인코딩          아래의 그림은 인스트럭션들의 바이트 수준 인코딩을 보여준다.                     각 인스트럭션은 인스트럭션의 타입을 의미하는 첫 번째 바이트를 사용한다.                아래의 그림은 인스트럭션들에 대한 특정 인코딩을 보여준다.                     rrmovq가 조건부 이동과 동일한 인스트럭션 코드를 갖는 점에 유의하라.                    jmp 인스트럭션이 무조건적 점프인 것과 마찬가지로 이것은 “무조건적 move”로 생각 할 수 있다.                                아래의 그림은 Y86-64 프로그램 레지스터 식별자이다.                     15개의 프로그램 레지스터들은 0에서 0xE 사이의 식별자를 갖는다.       프로그램 레지스터들은 CPU 내의 레지스터 파일에 저장된다.       레지스터 파일은 레지스터 ID가 주소로 이용되는 작은 크기의 RAM이다.       식별자 0xF는 레지스터에 접근하지 말아야 한다는 것을 나타낼 필요가 있을 때, 인스트럭션 인코딩에서, 우리의 하드웨어 설계 내에서 이용된다.       일부 인스트럭션들은 1바이트 길이를 사용하지만, 오퍼랜드를 필요로 하는 경우에는 좀 더 긴 인코딩을 사용한다.       하나 또는 두 개의 레지스터를 명시하기 위해 추가적인 레지스터 식별자 바이트를 사용할 수 있다.       어떤 인스트럭션들은 추가로 8바이트 상수 워드를 필요로 한다.                    이 워드는 irmovq의 즉시 데이터가 될 수 있다.           rmmovq와 mrmovq 주소 지시자를 위한 변위값으로 그리고 분기와 call 명령의 목적지로 사용될 수 있다.                           모든 인스트럭션 집합에 있어서 한 가지 중요한 특성은 바이트 인코딩이 유일한 해석을 가져야 한다는 것이다.   모든 인스트럭션이 첫 번째 바이트에 코드와 기능의 유일한 조합을 갖기 때문이며, 바이트만 주어지면 추가적인 바이트들의 의미와 길이를 결정할 수 있다.   4.1.4 Y86-64 예외상황     프로그래머가 볼 수 있는 상태는 현재 실행하고 있는 프로그램의 전체적인 상태를 나타내는 Stat 상태코드를 포함한다.        아래의 그림은 Y86-64 상태코드이다.. 우리의 설계에서 프로세서는 AOK 이외의 모든 코드에서 정지한다.                     코드1, AOK라고 이름 붙인 이 프로그램이 정상적으로 실행되고 있음을 나타낸다.       코드2, HLT 인스트럭션을 실행한 것을 나타낸다.       코드3, ADR 인스트럭션을 선입하거나 데이터를 읽거나 쓰는 경우에 잘못된 메모리주소 읽어오거나 쓰려고 한 것을 나타낸다.       코드4, 잘못된 인스트럭션 코드를 만났다는 것을 의미한다.           4.1.5 Y86-64 프로그램          아래의 그림은 Y86-64 어셈블리 코드로 작성한 에제 프로그램이다. Sum함수는 4개의 원소를 갖는 배열의 합을 계산하기 이해 호출된다.                     이 프로그램은 데이터와 인스트럭션 모두를 가지고 있다.       지시자들은 코드나 데이터를 어느 위치에 저장하고 이것을 어떻게 정렬할지를 나타낸다.       스택 위치, 데이터 초기화, 프로그램 초기화, 프로그램 종료 같은 이슈들을 보여주고 있다.       ”.”로 시작하는 단어들은 어셈블러 지시자directive들로 어셈블러가 만드는 코드의 주소를 조정하고 일부 데이터 워드를 추가하도록 어셈블러에게 지시한다.                아래의 그림은 위의 그림을 YAS라고 하는 어셈블러를 사용해서 어셈블한 결과를 보여준다. == 어셈블러, 목적코드                     목적코드는 인스트럭션이나 데이터를 포함하는 어셈블리 파일의 각 줄에서 주소를 가지며, 다음에 1에서 10바이트의 값들이 따라온다.          ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_12/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 04. 프로세서 구조 (4.2 논리 설계와 하드웨어 제어 언어 HCL)",
        "excerpt":"Chapter 04. 프로세서 구조     4.1 Y86-64 인스트럭션 집합 구조   4.2 논리 설계와 하드웨어 제어 언어 HCL   4.2 논리 설계와 하드웨어 제어 언어 HCL      하드웨어를 설계할 때 전자회로를 사용해서 비트들의 함수를 계산하고 여러 가지 메모리 원소들에 비트들을 저장한다.   디지털 시스템을 만들기 위해서는 다음과 같은 세 개의 주요 컴포넌트가 있어야 한다.            비트연산을 위한 조합회로 combinational logic       비트를 저장하는 메모리 소자       메모리 소자의 갱신을 조절하는 클럭 신호           4.2.1 논리 게이트     논리 게이트는 디지털 회로에서 기초 연산 소자들이다.   아래의 그림은 AND, OR, NOT 논리 게이트의 유형이다. 각 게이트는 입력들의 불 함수 같은 출력을 만든다.      4.2.2 조합회로와 HCL 불 수식      여러 가지 논리 게이트를 모아서 네트워크를 만들면 조합회로라고 알려진 계산 블록을 만들 수 있다.   어떻게 네트워크가 구성되는지와 관련해서 몇가지 제한이 있다.            모든 논리 게이트 입력은 정확히 다음 중의 하나에 연결되어야 한다.                    시스템 입력중의 하나(주요입력이라고 알려진)           일부 메모리 소자의 출력 연결           일부 논리게이트의 출력                       두 개 이상의 논리 게이트의 출력은 서로 연결될 수 없다.       네트워크에는 순환회로가 없어야 한다.           아래의 그림은 비트 동일성을 시험하기 위한 조합회로이다. 출력은 입력이 모두 0이거나 1이면 1이된다.         아래의 그림은 멀티플렉서multiplexor로 알려진 간단하지만 유용한 조합회로의 에를 보여준다.            멀티플렉서는 제어 입력 신호 값에 따라 여러 데이터 신호 중에서 한 값을 선택한다.       제어신호 s가 1이면 출력은 a가 되고, s가 0이면 입력 b가 출력이된다.                 HCL 수식들은 조합논리회로와 C에서의 논리 수식 간에 분명한 연관관계를 보여준다.            이들은 모두 입력에 대한 함수를 계산하기 위해 불 연산을 사용한다. 계산을 표현하는 이들 간의 차이를 살펴보는 것은 의미가 있다.                    조합회로가 일련의 논리 게이트로 이루어지기 때문에 출력들이 입력 변화에 연속적으로 반응하는 특성을 갖는다.                            반대로 C 수식은 프로그램 실행 중에 이 식을 마난야 계산이 이루어진다.                                   C에서 논리 수식을 0을 거짓으로, 다른 값들을 참으로 해석한다.                            반대로 논리 게이트는 비트 값 0과 1에 대해서만 연산을 한다.                                                   4.2.3 워드수준 조합회로와 HCL 정수 수식     논리 게이트들의 커다란 네트워크를 연결해서 보다 복잡한 함수를 계산하는 조합회로를 구성할 수 있다.   데이터 워드를 가지고 동작하는 회로를 설계 하게 된다.   HCL에서 워드 크기를 명시하지 않고 모든 워드수준 신호를 int로 선언한다.            이것은 단순성을 위한 것이다.           아래의 그림은 워드수준 동일성 시험 회로다.         아래의 그림은 워드수준 멀티플렉서 회로다.         멀티플렉서 함수는 HCL의 case 수식을 사용해서 기술된다.            case 수식은 다음과 같은 일반 형태를 갖는다.       이 수식은 여러 개의 case를 가지고 있으며, 각 case i는 언제 이 case가 선택되어야 하는지를 나타내는 불 수식 selecti와 결과 값을 나타내는 정수수식 expri로 구성된다.               [         select1 : expr1;         select2 : expr2;           .           .           .         selectk : exprk;     ]     아래의 그림은 4입력 멀티플렉서이다. 제어신호 s1과 s2의 여러가지 조합에 의해 어떤 데이터 입력이 출력에 전송될지가 결정된다.            그 아래의 수식은 그림에 해당하는 수식이다.                  ex = [         !s1 &amp;&amp; !s0  : A; #00         !s1         : B; #01         !s0         : C; #10         1           : D; #11     ]     조합논리회로는 워드수준 데이터에 대해 여러 가지 많은 연산을 수행하도록 설계될 수 있다.   아래의 그림은 산술/논리 유닛 ALU이다. 함수 입력의 설정에 따라 이 회로는 4개의 서로 다른 산술 및 논리연산을 실행하게 된다.            제어 값들이 이 인스트럭션들을 위한 함수코드와 일치한다.              4.2.4 집합의 원소 관계     집합의 원소 여부를 시험하는 일반적인 형태는 다음과 같다.            iexpr in {iexprq, iexpr2, … , iexprk}           4.2.5 메모리와 클럭     조합회로들은 근본적으로 정보를 저장하지 않는다.   이들은 단순히 입력 신호들에 반응하여 그 입력을 갖는 함수와 동일한 출력을 만들어 낸다.   순차회로, 즉 상태를 가지며 이 상태에 대해 계산을 하는 회로를 만들기 위해서는 비트로 표시된 정보를 저장하는 장치를 이용해야한다.   저장장치들은 로딩되는 때를 결정하는 주기적 신호인 한 개의 클럭에 의해 새 값들이 모두 제어된다.            클럭을 사용하는 레지스터들 : 워드나 개별 비트를 저장한다.       랜덤 액세스 메모리 : 워드를 읽거나 쓰기 위해 주소를 사용해서 여러 워드를 저장한다.                    ex) 가상메모리 시스템, 레지스트 파일                           “레지스터”라는 단어는 하드웨어와 기계어 프로그램에서 사용할 때 다르다.            하드웨어에서 레지스터는 입력과 출력 전선들로 회로의 나머지 부분과 직접 연결된다.       기계어 수준 프로그래밍에서 레지스터는 주소가 레지스터의 ID인 CPU 내의 주소지정이 가능한 워드들의 작은 집합을 나타낸다.                아래의 그림은 레지스터 연산이다. 레지스터 출력은 클럭 신호가 상승할 때까지 현재 레지스터 상태를 유지한다. 클럭이 상승할 때, 레지스터의 입력 값들이 새로운 레지스터의 상태로 저장된다.                     하드웨어 레지스터의 보다 상세한 모습이다.       레지스터는 어떤 고정된 상태(x로 나타냄)로 남는데, 자신의 현재 상태와 동일한 출력을 낸다.       클럭이 올라가면 입력 신호들이 다음 상태(y)로 레지스터에 로딩되고, 이것이 다음 상승 클럭 에지edge까지 새로운 레지스터의 출력이된다.       레지스터들이 회로의 여러 부분에서 조합논리 간에 장벽으로의 역할을 수행한다는 것이다.                아래의 그림은 전형적인 레지스터 파일을 보여준다.                     다중포트 랜덤 액세스 메모리는 여러 번의 읽기와 쓰기 연산이 동시에 일어날 수 있도록 해준다.       레지스터 파일에서 이 회로는 두 프로그램 레지스터의 값을 읽을 수 있고 세 번째 레지스터의 상태를 갱신 할 수 있다.       두 개의 읽기 포트는 주소 입력 srcA, srcB와 데이터 출력 valA, valB를 갖는다.       쓰기 포트는 주소 입력 dstW, 데이터 입력 valW를 갖는다.       레지스터 파일은 조합회로는 아닌데, 이는 레지스터 파일이 내부 저장장치를 가지고 있기 때문이다.       데이터는 주소를 입력으로 가지며, 데이터를 출력으로 갖는 조합논리 블록인 것처럼 데이터가 레지스터 파일로부터 읽을 수 있다.       srcA, srcB가 어떤 레지스터 ID로 설정되었을 때, 해당 프로그램에 저장된 값은 valA, valB에 나타난다.       레지스터 파일에 워드를 쓰는 작업은 클럭이 있는 레지스터에 값을 로딩하는 것과 비슷하게 클럭 신호에 의해 제어된다.                아래의 그림은 프로세서는 다음과 같이 도식적으로 나타낸 것처럼 프로그램 데이터를 저장하기 위해 랜덤 액세스 메모리를 갖는다.                     한 개의 주소 입력, 쓰기를 위한 데이터 입력, 읽기를 위한 데이터 출력을 갖는다.       레지스터 파일처럼 우리의 메모리에서의 읽기 작업은 조합회로와 유사한 방식으로 동작한다.          ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_13/",
        "teaser": null
      }]
