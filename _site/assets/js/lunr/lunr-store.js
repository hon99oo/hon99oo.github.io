var store = [{
        "title": "블로그를 다시 시작해 보자",
        "excerpt":"4학년 1학기 졸업작품을 3월부터 6월까지 열심히 달렸다. 졸업작품을 끝마치고 나니 현업의 욕심이 생겨 열심히 인턴 지원을 진행하였다. 그렇게 자소서를 쓰고 대학생활을 하며 잰힝했던 포트폴리오를 정리하고 7월 11일에 ‘스페이스워크’라는 회사에 인턴 포지션으로 입사하게 되었다. 인턴 포지션에 입사한 이후로 코딩에 대한 열정이 팍 식은거 같다. 회사일은 내가 졸업작품을 했을 때 처럼 큰 열정을 쏟아 붓지 못한 채 시키는 일만 하는 수동적 인간이 되었다. 그렇게 거의 5개월을 따로 공부도 하지 않고 열정이 없는 채로 살아왔던 것 같다. 당장 내 앞에 펼쳐져 있는 숙제들도 해결하지 않고 뒤로 미뤄두고 기상 - 회사 일 쪼금 - 게임 - 취침의 쳇바퀴의 반복적 인생을 살아왔다.   인턴 포지션 종료일은 1월 11일이다. 이후 나는 졸업요건을 하나 충족하지 않아 초과학기를 해야하며 다음 취업을 준비해야 한다. 인턴 포지션 종료까지는 약 2개월 정도 남았다. 지금은 욕심이지만, 인턴 종료 이후 곧바로 다른 회사의 인턴 포지션으로 들어가거나 현재 있는 회사에 잔류 하는 것이 목표이다. 현재 다니고 있는 회사에서 열심히 하지 못했던 이유는 나에게 목표의식이 조금 사라졌다는 변명을 들 수 있을 것 같다. 다시금 목표가 생긴 현재 이를 정확히 인지하고 행동으로 실천할 때가 온 것 같다.   인턴 생활을 하기 전까지는 모두 뇌피셜로 코딩을 해오고 공부를 해왔다. 그 때는 BE와 FE의 차이점도 몰랐고 DE가 요즘 핫하다는 이야기만 듣고 무슨 일을 하는지도 모른채로 DE포지션으로 인턴을 지원했었다. 하지만, 현업 생활을 약 4개월정도 하고 난 뒤 내 주변에 현업 생활을 하고 있는 지인들의 이야기가 궁금해졌고 많은 사람들의 이야기를 듣고 싶어 일명 DevTalk을 요청하였다. 그리고 이제는 정확하지는 않지만, 개발자라는 직군이 어떻게 돌아가는지 그리고 내가 어떤 일을 할 수 있고 어떤 일을 하고 싶은지 조금은 알 수 있게 되었다.   우선 나의 문제점을 발견했다. 간단하고 명확하게 말하자면, 나는 현재 ‘코싸개’이다. 생각하지 않고 주어진 문제를 해결하기 위해 수단과 방법을 가리지 않고 그저 코드만을 작성했던 굉장히 질 나쁜 개발자였던 것이다. 생각해보면 내가 이 프로그래밍에 관해 진지하게 공부했던 적이 없다. 학문을 가르치는 대학에서 소프트웨어학과를 진학하고 전공 과목은 집중하지 않고 프로젝트를 어떻게든 이쁘게 만들기 위해서 프로젝트를 위한 공부만 했던 것 같다. 현재 사용하고 있는 기술들은 모두 근본이 되는 알고리즘과 컴퓨터구조론에서부터 비롯된 기술임을 몰랐던 것이다. 나에게 가장 부족한 점은 ‘근본 지식’을 모르는 것이다. 많이 늦었다고 말할 수 있지만, 오늘부터 ‘근본 지식’에 관련하여 몇가지를 체계적으로 공부할 생각이다.   첫번째, 알고리즘이다. 알고리즘을 제대로 배워본 적이 없다. 사실 우리학교의 전공 필수 과목이지만, 너무 어렵고 공부하기도 싫어서 대충 했던 기억이 있다. 그리고 모르는 지식이 있으면 그 때 그 때 구글링으로 일시적으로 지식의 빈자리를 매꿀 뿐이었다. 근본이 되는 알고리즘 서적으로 공부할 계획이다. 두번째, 컴퓨터구조론이다. 컴퓨터구조론 또한 우리학교의 전공 필수 과목이지만, 족보를 바탕으로 공부해서 학점은 좋게 받았지만 남아있는 지식은 없다. 알고리즘과 컴퓨터구조론을 우선 공부하여 인턴 포지션 종료 전 까지 어느정도의 지식을 확보하고 싶은 계획이다.   이후 나는 BE나 DE 직군으로 나아갈 예정이다. 현재 내가 사용하는 주 언어는 python이지만, java에도 관심이 조금씩 가고 있다. 알고리즘과 컴퓨터구조론 공부를 마치고 나면 DE의 근본책과 BE의 근본책 두가지를 구매해서 공부할 예정이다. 이 열정이 언제 식을지 모르겠지만, 현재 내 발등에는 불이 그것도 존나게 뜨거운 불이 떨어졌다.   화이팅이다 홍구야  ","categories": ["doodle"],
        "tags": ["doodle"],
        "url": "/doodle/doodle_01/",
        "teaser": null
      },{
        "title": "test post 입니다.",
        "excerpt":"You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.   Jekyll requires blog post files to be named according to the following format:   YEAR-MONTH-DAY-title.MARKUP   Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and MARKUP is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.   Jekyll also offers powerful support for code snippets:   def print_hi(name)   puts \"Hi, #{name}\" end print_hi('Tom') #=&gt; prints 'Hi, Tom' to STDOUT.  Check out the Jekyll docs for more info on how to get the most out of Jekyll. File all bugs/feature requests at Jekyll’s GitHub repo. If you have questions, you can ask them on Jekyll Talk.   ","categories": ["test post"],
        "tags": ["test","theme"],
        "url": "/test%20post/test/",
        "teaser": null
      },{
        "title": "2022년 초보 개발자의 취업 계획",
        "excerpt":"   곧 2022년이다. 2021년 한해를 마무리해보자.     2021년 : 마무리   3月-6月 졸업작품    7月-12月 인턴생활    졸업작품 하얗게 불태우고 바로 인턴 생활을 했다. 현업이 되게 궁금했는데 이 부분에 대해서는 굉장히 많은 도움이 된 것 같다. 그리고 Data Engineering 직무도 굉장히 관심 있었는데 직접 경험할 수 있어서 좋았다. 나는 조금 더 다양한 경험을 하고 싶어서  Back End 직무를 공략할 생각이다. 언어는 아무래도 java가 강력하다고 생각해서 java 공부를 시작할 것 같다.    2022년 : 11월 전까지 아래 서류들을 준비해보자      졸업요건 맞추기    토익 또는 오픽    정보처리기사    CS    Algorithm    Java 스킬    ~2022년 포트폴리오 정리    코딩 캠프(네이버부캠,우테코 등등…) 준비      Java Backend Roadmap   ","categories": ["doodle"],
        "tags": ["doodle"],
        "url": "/doodle/doodle_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Google's Neural Machine Translation System : Bridging the Gap between Human and Machine Translation 논문 리뷰",
        "excerpt":"Introduction     Neural Machine Translation            End-to-End 학습 접근 방식의 자동 번역       기존 구문 기반 번역의 약점을 극복           Neural Machine Translation 단점            데이터 양과 매개변수가 많아 훈련과 추론 속도가 느림       Rare Word 처리의 문제점       가끔씩 모든 단어에 대해 번역하지 못함           Google’s Neural Machine Translation            LSTM으로 이루어져 있는 8개의 ENCODER와 8개의 DECODER       병렬 처리 개선을 위해 DECODER의 최하층과 ENCODER의 최상층을 ATTENTION으로 연결       번역속도를 높이기 위해 low-precision arithmetic, Rare Word 처리를 위해 WordPiece 사용            Model Architecture       Model Parallelism            모델 병렬화와 데이터 병렬화 모두 사용함       Downpour SGD를 사용하여 데이터 병렬화                    여러개의 모델로 나누어, 여러개의 머신에서 동시에 학습함, 각각 학습된 gradient를 평균내어 모델에 적용           실험에서는 10개의 머신에서 128개의 문장을 Mini-batch로 사용                       모델 병렬화                    머신당 8개의 GPU 사용 ( 각 층 마다 서로 다른 GPU에 할당 )           i번째 레이어의 작업이 종료전에 i+1번째 작업 진행 가능                            Segmentation Approches     Wordpiece Model            띄어쓰기는 _, 단어는 내부단어 통계에 기반하여 띄어쓰기로 분리       띄어쓰기를 _로 치환한 이유는 차후에 문장 복원을 위해       실험에서는 wordpiece를 8K~32K에서 좋은 결과 얻음       wordpiece로도 얻을 수 없었던 rare word는 copy model을 사용                 Mixed Word/Character Model            OOV 처리를 로 하지 않고 문자 단위로 나누어 처리함       시작 문자 , 중간 문자 , 끝 문자        전체 작업 과정에서 유지한 채로 학습한 후 태그를 삭제함             Training Criteria     Maximum-liklihood 학습 방식은 로그 확률 값을 최대화하는 목적 함수 ( BLUE 평가 지표와 부합되지 않음 )        Reward개념의 목적함수 사용        r은 문장 단위 점수 ( 출력 문서와 실제 문서의 차이 계산 )   GLEU 점수 지표 사용 ( 출력 문장과 정답 문장을 1~4 토큰으로 만든 뒤 recall과 precision을 구한 뒤 더 작은 값을 GLEU로 정함 )   ML방식과 RL 방식 혼합하여 사용 이 때, a는 0.017        Quantizable Model And Quantized Inference     NMT은 연산량이 많아 Inference 시간이 오래 걸리는 것이 큰 단점   해결하기 위하여 Quantized inference 수행!        Decoder     Beam Search를 사용하여 점수 함수를 최대화 하는 시퀀스 Y를 찾음   Length normalization            길이가 더 긴 문장의 확률이 떨어지기 때문에 이를 보정하기 위하여 사용       하이퍼 파라미터 a 사용 ( 실험에서는 0.6 ~ 0.7 사용 )           Coverage Panelty            source word xi로 부터 attention weight의 합을 구함       로그를 취했기 때문에 attention weight이 편중되지 않은 source word의 값이 매우 작음 음수를 가지게 됨       실험에서는 a는 0.6 b는 0.2 사용                Experiments And Results     Data set            WMT En -&gt; Fr 36M       WMT En -&gt; De 5M           Evaluation Metrics            BLUE       implicit human evaluation ( BLUE는 번역 점수 잘 못메김 )           Training Procederue            TensorFlow 사용하여 구현       12개의 머신으로 병렬화       [-0.04, 0.04] 사이로 매개변수를 균일하게 초기화       Adam Optimizer와 SGD 혼합하여 사용 ( 첫 60k는 Adam으로 그 후로는 SGD 사용)           Learning Rate는 0.5 ( 1.2M 이후부터 200k 단위마다 반씩 줄여가며 학습 )          Conclusion     Wordpiece 모델은 번역 품질과 inference 속도를 효과적으로 높힘   모델과 데이터의 병렬화는 sequence-to-sequence NMT 모델을 일주일 안으로 효율적으로 훈련시킬 수 있음   Model quantization은 inference 속도를 가속화할 수 있어 대형 모델에 사용하기 용이함   Length-normalization, coverage penalty 등과 같은 추가 세부 사항이 NMT 시스템을 잘 작동시키게 도와줌  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_01/",
        "teaser": null
      },{
        "title": "Docker는 대충 이런 느낌인가?",
        "excerpt":"Docker   내가 느낀 전체적인 도커의 메커니즘 : 어떠어떠한 것을 빌드해서 이미지를 만들고  -&gt; 이미지를 도커로 띄운 뒤 -&gt; 이미지를 받아서 로컬에서 개발작업을 진행   !!많은 시행착오를 거쳐 도커의 메커니즘에 대해 이해가 조금 되었다.     Dockerfile을 만든다.   해당 디렉토리 위치에서 docker build를 한다.   docker build을 하면 이미지가 생성된다.   이미지가 생성됐으면, 해당 이미지로 docker run을 한다.   docker run을 하면 컨테이너가 만들어지고 해당 이미지를 컨테이너 안으로 넣는다?띄운다?   그럼 환경셋팅이 된다…?   틀린 부분도 있겠지만 아주 조오금 조오오오오금 메커니즘이 이해가 됐다.   앗 참고로 음… 저런 run이니 이미지 파일들이니 어떤 컨테이너가 실행중인지를 GUI로 확인할 수 있는 프로그램이 Docker Desktop 같다 ㅎㅎ..   추가적으로 환경세팅을 완료한 것 같다. 음… 위의 6번까지 진행한 후에          컨테이너를 만들면 어떠한 가상환경이 만들어지는 것 같다.            그럼 그 컨테이너에가 파이썬 환경으로 이루어져있고 추가로 다양한 패키지들이 들어있다.            그럼 그 환경을 내가 사용하고 있는 Pycharm과 연동을 하는 거다.       어떻게 하냐면 파이참 프로젝트의 인터프리터를 해당 컨테이너에 있는 파이썬path로 설정해주는거다. *https://i-am-eden.tistory.com/13        그리고 코딩하면 된다 ㅎㅎ ***            도커엔진 - 도커를 실행하면 Dockered라는 데몬 프로그램이 서버로 실행.   **여기서 잠깐! 데몬 프로그램이 뭘까?   https://blogger.pe.kr/770  (포그라운드, 백그라운드, 데몬 프로세스)    https://haruhiism.tistory.com/9            도커실행 : 도커 이미지를 받아서 컨테이너로 실행   ** -it 라는 명령어는 -i와 -t 옵션이 합쳐진 옵션, -i는 호스트와 컨테이너 상호 입출력을 맞추고, -t는 TTY를 활성화해서 컨테이너에 터미널로 입력이 가능하게 한다.   ** TTY가 뭐지?!   https://cosmosproject2015.tistory.com/143 (TTY, PTS, PTY)            도커 volume : 데이터를 컨테이너에 저장하지 않고 호스트에 저장하는 방식   https://www.daleseo.com/docker-volumes-bind-mounts/       도커빌드 : Dockerfile로 사용자 정의 이미지를 만듬   *공부하기 : 도커 아키텍쳐, 컨테이너-OS 간의 통신 구조   ** Docker의 개념 및 핵심 설명 :  https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90    Docker 예제 실습중 갱장히 이상한 오류가 발생했다.   failed to solve with frontend dockerfile.v0: failed to read dockerfile: open /var/lib/docker/tmp/buildkit-mount174403522/Dockerfile: no such file or directory   구글링을 계속 해봤지만 dockerfile -&gt; Dockerfile 로 이름을 바꾸라는 답변밖에 없었다.   하지만, 오류가 고쳐지지 않았고 터미널을 Open한 디렉토리 경로를 상위 폴더 위치로 open을 해서 났던 오류였다 ㅎㅎ  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/docker_01/",
        "teaser": null
      },{
        "title": "TDD와 each map",
        "excerpt":"TDD   TDD(Test Driven Development)란 본격적인 개발에 들어가기 전에 테스트 계획 및 코드를 작성하는 것을 의미한다. 테스트가 개발을 이끌어 나가는 것이다. 예를들어, 개발 중 에러가 발생했을 때 소규모 개발에서는 큰 문제가 되지는 않지만, 대규모의 개발 상황에서는 수 많은 모듈과 함수간 종속성들이 굉장히 많은 시간을 괴롭히게 된다. 이러한 문제점을 해결하기 위해서 테스트 주도 개발이 등장했다.   나는 pytest를 사용할 것이다. https://binux.tistory.com/47   일단, monkeypatch.setattr 살펴보자.  이것은 어떤것을 하냐면, mocking이다. Mocking은 실제 값이 아닌 가짜 값을 만들어내는 것이다.   음 예를들면 Upload 클래스가 있다.   Class Upload    |_ Def Extract   |_ Def Transform   |_ Def Load   이렇게 되어있을 때 나는 Transform 부분만 테스트하고 싶다. 하지만 함수의 종속성으로 인하여 Transform에서 사용되는 data는 Extract로 부터 참조되며 Extract에서 추출되는 data는  특정 라이브러리의 기능을 참조한다. 나는 Transform 부분만 테스트하고 싶지만 이런 경우에 Extract부터 특정 라이브러리으 기능까지 테스트해야되는 상황에 처한 것이다. 이런 경우에 이제 Mocking이라는 기술을 쓴다. pytest에서도 제공하는 function이 있지만, 단순한 예를 하나 들자면 정답과 인풋값을 csv파일이나 등등으로 미리 만들어서 로컬에서 참조하도록 코드를 작성하면 된다.   하지만 이때, 테스트 코드에서 원코드를 실행할 때 원코드의 Extract가 실행 되기 때문에 monkeypatch.setattr 같은 기능으로 해당 function을 사용하지 않고 넘겨주는 기능을 넣어줘야한다.    each map  each map을 알아야한다.  음 지금 내가 하는 것은 DB -&gt; transform -&gt; DB 적재이다. transform에서 전처리 및 parsing을 해주는데, transform에서 이뤄지는 작업은 모든 Dataframe이 메모리 상으로 올라가게 된다. 작은 task면 문제없이 실행 되겠지만, 큰 규모의 task는 메모리를 많이 차지하게 되어 에러가 날 수 있다. 이럴 때 사용 하는 것이 each map이다. each map은 dataframe에서 row 별로 메모리 상으로 올린다. 이후 해당 row에서 특정 처리를 진행 후에 buffer로 옮긴 뒤 DB로 적재를 한다. 이 때 조심해야 하는 부분은 seperate다. row에서 컬럼으로 구분하는 seperate값을 잘 이용해야지 에러가 나지 않을 것이다.    즉! pytest 부분을 더 공부하고 적절한 testset을 생각해보고, testcode를 작성해보자!  ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행",
        "excerpt":"CS:APP  Computer Systems A Programmer’s Perspective, CSAPP로도 잘 알려져있는 컴퓨터 구조론의 바이블이다. 이 책을 통해서 컴퓨터구조론을 다시 공부해볼 생각이다. 군대 전역 직후 2학년 2학기로 복학해서 컴퓨터 구조론 전공 수업을 들었지만 학점을 위한 공부만 해서 남아있는게 없는 것 같다. 인턴 생활을 하면서 다양한 부분에서 어려움을 겪었는데 기초를 몰라서 헤메고 있다는 느낌을 굉장히 많이 받았다.   첫 페이지를 읽었을 때 이 책으로 정하길 정말 잘했다는 생각이 들었다. 전공 수업때 사용했던 컴퓨터구조론 책은 제작자의 관점에서 기술 되었다는 느낌을 강하게 받았었다. 하지만, CSAPP는 프로그래머의 관점에서 기술하였고, 컴퓨터구조론의 시스템들을 어떻게 사용해서 좋은 프로그램을 개발할 수 있는지를 배울 수 있다고 한다.  인턴 생활을 하면서 실제 현업을 겪고 느꼇던 강한 의문들을 해결할 수 있을 것 같은 느낌이다.   책의 목차는 정보의 표현과 처리로 시작하여 프로그램의 기계어 표현, 프로세서 구조, 프로그램 성능 최적화, 메모리 계층구조, 링커, 예외적인 제어흐름, 가상메모리, 시스템 수준 입출력, 네트워크 프로그래밍, 동시성 프로그래밍  순서로 이어져 있다. 많은 사람들은 6장 메모리 계층구조, 7장 링커의 전까지 읽어도 좋다고 하지만, 가능하다면 12장 동시성 프로그래밍까지 읽어볼 생각이다.   Chapter 01. 컴퓨터 시스템으로의 여행     시스템 구현방식은 변하지만 근본적인 개념들은 변하지 않는다.   프로그래머들로 하여금 컴포넌트들이 어떻게 동작하고 프로그램 성능과 정확성에 어떤 영향을 주는지 알 수 있다.   1.1 정보는 비트와 컨텍스트로 이루어진다.     텍스트 문자 -&gt; 아스키(ASCII) 표준 사용하여 표현 -&gt; 각 문자를 바이트 길이의 정수 값으로 표현 -&gt; 연속된 바이트 파일 저장   1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.     hello.c 실행 -&gt; 저급 기계어 인스트럭션들로 번역 -&gt; (실행가능 목적 프로그램)으로 합쳐져 바이너리 디스크 파일로 저장  -&gt; 컴파일러 드라이브는 유닉스 시스템에서 소스파일에서 오브젝트 파일로 변경 -&gt; 4개의 단계를 거쳐서 실행            4개의 단계:                    전처리기           컴파일러           어셈블러           링커                           1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.     프로그램 성능 최적화하기            eg1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?       eg2) while 루프는 for 루프보다 더 효율적일까?       eg3) 포인터 참조가 배열 인덱스보다 더 효율적인가?           링크 에러 이해하기            eg1) 정적변수와 전역변수의 차이는 무엇인가?       eg2) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?           보안 약점 피하기            eg1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?           1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.     인스트럭션이란 : 컴퓨터에게 일을 시키는 단위(기계어)       시스템의 하드웨어 조직            버스 : 시스템 내를 관통하는 전기적 배선군       입출력 장치 : 시스템과 외부세계외의 연결 담당       메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치       프로세서 : 인스트럭션들을 해독(실행)하는 엔진                    인스트럭션의 요청에 의해 CPU(프로세서)가 실행하는 단순한 작업의 예                            적재(load), 저장(store), 작업(operate), 점프(jump)                                                   프로그램의 실행 (그림 추가 예정 ㅎㅎ..)   1.5 캐시가 중요하다.     hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다.   프로그램이 로딩될 때 이들은 메인 메모리로 복사된다.   이 작업이 시간이 너무 오래 걸려서 “단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하는” 캐시 메모리가 설계 되었다.   캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성을 활용하였다.   1.6 저장장치들은 계층구조를 이룬다.     모든 컴퓨터 시스템의 저장장치즈들은 메모리 계층구조로 구성되어 있다.   (그림 추가 예정 ㅎㅎ..)   1.7 운영체제는 하드웨어를 관리한다.     운영체제는 두 가지 주요 목적을 가지고 있다.            제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해       응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해           위 두가지 목표를 위해 근본적인 추상화를 통해 달성하고 있다.   추상화 결과            프로세스 : 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과       가상 메모리 : 메인 메모리와 디스크 입출력 장치의 추상화       파일 : 입출력장치의 추상화           1.8 시스템은 네트워크를 사용하여 다른 시스템과 통신한다.     네트워크는 또 다른 입력장치로 볼 수 있다.   시스템이 메인 메모리로부터 네트워크 어댑터로 일련의 바이트를 복사할 때, 데이터는 로컬디스크 드라이브 대신에 네트워크를 통해서 다른 컴퓨터로 이동된다.   1.9 중요한 주제들     Amdahl의 법칙            우리가 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 구 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계된다.           동시성과 병렬성            동시성 : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념       병렬성 : 동시성을 사용해서 시스템을 보다 더 빠르게 동작하도록 하는 것       쓰레드 수준 동시성                    쓰레드를 이용하면 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수 있음                       인스트럭션 수준 병렬성                    프로세서들은 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있음                           컴퓨터 시스템에서 추상화의 중요성            추상화의 사용은 전산학에서 가장 중요한 개념!           1.10 요약     컴퓨터 내의 정보는 비트들의 그룹으로 표시   컴파일러와 링커에 의해 바이너리 실행파일들로 번역   프로세서는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석   컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간에 데이터를 복사하고 쓰는 데 사용   위와 같은 이유로 시스템의 저장장치들은 계층구조 형성   운영체제 커널은 응용프로그램과 하드웨어 사이에서 중간자 역할 수행   네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법 제공   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_01/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.   비트 패턴            이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.       표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.           인코딩            비부호형 : 전통적인 이진수 표시 사용       부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법       부동소수점 : 2진수 버전의 소수 표시방법           이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.        2.1 정보의 저장     기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급   메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음   모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름   2.1.1 16진수 표시     1바이트는 8비트로 이루어짐        이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&gt; 16진수 사용              16진수 &lt;-&gt; 10진수 &lt;-&gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음            2.1.2 데이터의 크기     모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨            w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐       프로그램은 최대 2^w 바이트에 접근 가능                최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임              2.1.3 주소지정과 바이트 순서     여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정            객체의 주소가 무엇이 되어야 하는지       메모리에 바이트들을 어떻게 정렬해야 하는지           비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.            가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]       가장 덜 중요한 바이트 : [x7, x6, . . . , x0]           바이트 저장 방법            리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는       빅 엔디안 : 가장 중요한 바이트가 먼저 오는       대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작           바이트 순서가 이슈가 되는 경우            이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때                    리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜                       정수 데이터를 나타내는 바이트들을 살펴볼 때       프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때           2.1.4 스트링의 표시      그냥 ASCII를 사용한다는 내용,,,    2.1.5 코드의 표현          인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름                   컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것       2.1.6 부울 Boolean 대수     NOT : ~   AND : &amp;   OR : |        EXCLUSIVE-OR : ^              2.1.7 C에서의 비트수준 연산          C에서는 비트들 간의 부울 연산을 지원                   비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.             마스크: 비트 연산에 사용되는 데이터            2.1.9 C에서의 쉬프트 연산     비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공   x « k            x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.           x » k            좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.       논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움       산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움           부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용        2.2 정수의 표시          컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것              2.2.1 정수형 데이터 타입     서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.   64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위            음수의 범위가 양의 범위보다 1 더 넓은 것에 주목                  2.2.2 비부호형의 인코딩     음수 값을 포함하지 않음        B2U는 Binary 에서 Unsigned의 줄임말               2.2.3 2의 보수 two’s complement 인코딩     음수 값을 포함        B2T는 Binary 에서 Two’s complement의 줄임말                  모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며,  부호형 수에 대해서 특정 표시를 가정해서도 안된다.    2.2.4 비부호형과 부호형 간의 변환     C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.   2의 보수에서 비부호형으로의 변환            TMin ≤ x ≤ TMax를 만족하는 x에 대해  x가 0보다 크거나 같으면 x x가 0보다 작으면 x+2^w                  이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.            비부호형에서 2의 보수로의 변환            0 ≤ u ≤ UMax를 만족하는 u에 대해 u가 TMax보다 작거나 같으면 u u가 TMax보다 크면 u-2^w                  이유는 T2U의 이유와 동일하다.  이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)            2.2.5 C에서 부호형과 비부호형의 비교     C에서는 부호형과 비부호형 산술연산을 지원한다.            C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.            2.2.6 수의 비트 표시를 확장하기     비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.            영의 확장 zero extension 이라고 알려짐           2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.            부호 확장 sign extension 이라고 알려짐                  2.2.7 숫자의 절삭     진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.       비트의 개수를 줄이는 경우이다.            eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.           비부호형 수의 절삭            x’ = x mod 2^k 이다.                    삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.           자리값들은 모듈(mod) 계산으로 모두 0이 된다.                           2의 보수 숫자의 절삭            x’ = U2T(x mod 2^k) 이다.                    가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.                           2.2.8 Signed와 Unsigned에 관한 조언     부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.   비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.      2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다. 위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_02/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수                2.3 정수의 산술연산     두 개의 양수를 더해서 음수가 나오는 경우, x&lt;y와 x-y&lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,            그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.               2.3.1 비부호형 덧셈  x,y, 0≤x, y≤e^w가 있다고 하자, 두 합의 계산 범위는 0≤x+y≤2^(w+1)-2를 갖는다. 이 합의 크기를 표현 하기 위해서는 w+1개의 비트가 필요하게 된다.     “워드 크기 증가”는 산술연산의 결과를 완벽하게 표시하려면 필요한 워드 크기를 제한할 수 없다는 것을 의미한다.   프로그래밍 언어들은 고정길이 산술연산을 지원하며 따라서 “덧셈”과 “곱셈”같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.        x,y에 대해 x+y 정수합을 w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타낸다.                   정상적인 경우에는 x+y값을 유지하지만, 오버플로우의 경우에는 2^w만큼 줄어드는 효과를 낸다.                 산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때 이 연산은 “오버플로우한다”고 한다.         2.3.2 2의 보수의 덧셈  2의 보수 덧셈의 결과값이 너무 크거나(양수) 또는 너무 작아서(음수) 표시할 수 없을 때 우리는 어떻게 해야 할지 결정해야 한다.          x+y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산이다.                    2의 보수의 합이 2^(w-1)을 넘어간다면 양수 오버플로우가 생기고, -2^(w-1) 미만으로 내려간다면 음수 오버플로우가 생겨 각각에 2^w을 더해주거나 빼준다.         2.3.3 2의 보수에서의 비트반전 Negation          비부호형 비트반전                   2의보수 비트반전                   2.3.4 비부호형 곱셈     비부호형 곱셉은 2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것으로 정의된다.        비부호형 수를 w비트로 절삭하는 것은 해당 값을 2^w로 나눈 나머지를 계싼하는 것과 같다.                  2.3.5 2의 보수 곱셈          2^w로 나눈 나머지를 취하고 비부호형에서 2의 보수형태로 변환하는 것과 같다.                  2.3.6 상수를 사용한 곱셈     정수 곱셉은 매우 느리다. 컴파일러에서 수행되는 중요한 최적화는 상수를 곱하게 되는 경우들을 쉬프트와 덧셈의 조합으로 대체한다.   2의 제곱을 곱하는 경우            k≥0인 모든 k에 대해 x2^k의 w+k 비트수준 표현은 우측에 k개의 0을 추가한 것이다.       eg) 11은 w=4인 경우 [1011]이다. 이것을 왼쪽으로 k=2 쉬프트 하면 [101100]이 되며 이것은 11*4=44를 인코딩한 것이다.           2의 제곱을 곱하면 비부형이건 2의 보수 산술연산이건 오버플로우가 발생할 수 있다.            eg) 위의 예제를 예로 들자면, [101100]을 4비트로 절삭하면 1100을 얻는다.              정수 곱셈이 쉬프트와 덧셈을 사용하는 것보다 훨씬 비용이 많이 드는 연산이기 때문에 C 컴파일러들은 정수가 상수와 곱해지는 경우에 이들을 쉬프트, 덧셈, 뺄셈 등의 조합을 사용해서 제거하려고 노력한다.        2.3.7 2의 제곱으로 나눗셈하기     정수 나눗셈은 정수 곱셉보다 훨씬 느리다. 2의 제곱으로 나누는 것은 오른쪽 쉬프트를 사용한다.   비부호형은 논리 쉬프트, 2의 보수는 산술 쉬프트를 사용한다.   2의 보수 음수에서는 보정값을 더해서 결과값을 0 방향으로 근사하도록 한다.       2.3.8 정수 산술연산에 대한 마지막 고찰  컴퓨터에서 실행되는 “정수” 산술연산은 실제로는 modular 산술연산의 형태로 수행된다. 숫자를 표현하기 위해 유한한 길이의 워드를 사용하기 때문에 가능한 값의 범위가 제한되며 연산의 결과가 오버플로우될 수 있다.  ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_03/",
        "teaser": null
      },{
        "title": "[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성",
        "excerpt":"IntelliJ  학교에서는 java를 배울 때 이클립스(Eclipse)를 사용했다. 하지만 python을 주로 다루면서 파이참(Pycharm)에 익숙해졌다.  java 공부를 하면서 좀 더 친숙한 JetBrains 회사의 개발도구를 사용하려고 한다. 정보를 조금 찾아보니 IntelliJ가 현재 내가 사용하고 있는 환경인 Mac Os에서 이클립스보다 오류가 덜 발생한다고 한다. 통합 개발 환경도 제공한다고 하니 이보다 더 좋을 수가 없다!    해당 포스트는 Mac Os 환경에서 진행되었다.   1. IntelliJ 설치  우선 IntelliJ Mac Os 버전을 설치하려면  IntelliJ 설치 링크 에 접속한다.  각자 Mac 환경에 맞는 파일을 다운로드한다.          java 학습을 위해선 Community Edition으로도 충분하다고 한다. 하지만 본인이 학생 신분이라면 학생 라이센스를 이용한 Ultimate 버전을 추천한다.          아래와 같은 창이 뜨면 설치 성공!      2. Java Project 만들기  위의 창에서 Create New Project를 누르면 아래와 같은 창이 열린다.   왼쪽의 리스트에서는 Java 선택, 오른쪽 리스트에서는 아무것도 선택하지 않고, 오른쪽 아래의 “Next” 버튼을 누른다.          Java 프로젝트를 생성할 때 샘플코드를 생성할지 여부.   본인이 직접 생성할 것이기 때문에 아무것도 선택하지 않고 “Next” 버튼을 누른다.          프로젝트 이름을 정하고 “Next” 버튼을 누른다.      3. Hello World 출력하기  프로젝트 생성이 완료되면, main 메소드가 있는 새로운 Java 클래스를 생성하기 위해 src 폴더를 우클릭한다.  New &gt; Java Class 를 선택한다.          새로 생성할 Java Class 이름을 설정하고 Enter를 친다.          Hello World 출력 코드를 작성한다.  상단의 망치 버튼을 클릭하여 빌드하거나 “control + option + R”키를 눌러 빌드한다.          혹은 out &gt; production &gt; “project_name” &gt; “Class_name” 우클릭 후 Run을 선택해도 된다.          이제 IntelliJ와 함께 Java 공부를 시작해보자,,,!  ","categories": ["Java"],
        "tags": ["Java","IntelliJ"],
        "url": "/java/java_01/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산",
        "excerpt":"Part1 자바 시작하기  Java     객체지향언어   C,C++ 문법을 기본으로 개발            C언어에 객체지향 특성 확장           플랫폼에 독립적임            JVM으로 인해서 어떤 플랫폼에서도 실행 가능함           Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌   JDK : Java Development Kit        JAVA 개발순서     코드 작성   코드 컴파일   컴파일한 소스를 JVM을 이용하여 실행        주석문     // : 행단위 주석   /* */ : 블럭단위 주석   /** ..*.. */ : 문서화 주석       Part2 변수와 계산   변수  변수 값(Data)을 저장할 수 있는 메모리 공간     java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨   java 식별자 명명 규칙            첫 번째 글자는 문자 이거나 $,_ 이어야 함       $,_ 이외의 특수문자는 사용 불가능       키워드는 식별자로 사용할 수 없음           java 변수 명명 관례            첫 번째 문자가 소문자인 명사로 정함       여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)       _를 쓰지 않음               상수  상수란 수식에서 변하지 않는 값을 의미     상수의 선언            final 상수타입 상수명;                    eg) final int J;                           상수 명명 관례            대문자로만 구성된 명사로 정함       여러 단어로 구성된 이릠의 경우 단어 사이에 _을 써서 구분함           상수를 사용해야 하는 경우            값이 변하면 위험한 경우에 상수 사용       값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용               기본형 타입  기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.     논리형            boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음           문자형            char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능           정수형            int 4byte, long 8byte           실수형            float 4byte, double 9byte           리터럴            CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어       리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함           사용 방법            long : 값을 적을 때 뒤에 l이나 L 적어야함       float : 값을 적을 때 뒤에 f나 F를 적어야함               기본형 타입변환     묵시적 형변환            크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌           명시적 형변환            크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함       eg) long x = 20; int y = (int) x;               연산자 우선순위     최우선연산자 ( ., [], () )   단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&gt;부호&gt;증감)            단, 후위연산자(a++)은 우선순위가 낮음       eg) a=5, x = a++ - 5 라면 x는 0, a는6           산술연산자 ( *,/,%,+,-,shift) &lt; 시프트연산자 ( »,«,»&gt; ) &gt;   비교연산자 ( &gt;,&lt;,&gt;=,&lt;=,==,!= )   비트연산자 ( &amp;,|,,~ )   논리연산자 (&amp;&amp; , || , !)   삼항연산자 (조건식) ? :   대입연산자 =,*=,/=,%=,+=,-=  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_02/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part3 제어문",
        "excerpt":"Part3 제어문   if 조건문  조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.     if 문   if - else 문   if - else if - else 문       논리 연산자  논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.                                     OR :                                       AND : &amp;&amp;   NOT : !   EXCLUSIVE-Or : ^       삼항 연산자     조건식 ? 피연산자1 : 피연산자2            조건식의 결과가 true 라면 결과는 피연산자1       조건식의 결과가 false 라면 결과는 피연산자2               switch문  switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.   switch(변수){         case 값1 :              실행문;              break;         case 값2 :              실행문;              break;           default;         }     break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.   JDK7 이후에는 문자열 타입의 변수도 가능함      당연한걸 수도 있지만, case 에 조건문을 달면 오류가 난다 하하,,,        while문  조건문의 실행 결과가 true일 동안 반복해서 실행한다.   while(조건문){         실행문;      }      do while문  while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.      do{         실행문;     }while(조건문);     실행문을 한번은 실행하고 싶을 경우에 사용됨       for 반복문  for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨       for(초기화식; 조건식; 증감식){         실행문;         실행문;     }  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_03/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part4 배열",
        "excerpt":"Part4 배열   배열 만들기  배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다.   int[] array1 = new int[4]; int[] array2 = new int[]{1,2,3,4}; int[] array3 = {1,2,3,4};      배열 사용하기     배열에 접근할 때에는 인덱스를 통해서 접근한다.   배열의 길이를 알아내는 방법 : array.length        2차원 배열  2차원 배열이란 배열의 배열이다.   int[][] array4 = new int[3][4];  int[][] array5 = new int[3][]; //위와 같이 선언하면 array5는 3개짜리 배열을 참조한다. 3개짜리 배열은 아직 참조하는 배열이 없다는 것을 의미. array5[0] = new int[1]; //정수를 하나 담을 수 있는 배열을 생성해서 array5 의 0 번째 인덱스가 참조한다.   array5[1] = new int[2]; //정수를 두개 담을 수 있는 배열을 생성해서 array5 의 1 번째 인덱스가 참조한다.   array5[2] = new int[3]; //정수를 세개 담을 수 있는 배열을 생성해서 array5 의 2 번째 인덱스가 참조한다.       for each  for문 안에 (value:array), array의 값 하나씩 value로 매칭된다.     python for in 이랑 똑같은거 같아서 너무 반갑다!    int[] iarr = {10,20,30,40,50};  for(int value:iarr){     System.out.println(value); } ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_04/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)",
        "excerpt":"Chapter 02. 정보의 표현과 처리     2.1 정보의 저장            컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지           2.2 정수의 표시            인코딩, 비부호형 및 2의보수           2.3 정수의 산술연산            비부호형 및 2의보수의 덧셈,뺄셈,곱셉,나눗셈                2.4 부동소수점     부동소수점 표현은 V = x*2^y 형태의 소수를 인코딩한다.   거의 모든 컴퓨터가 IEEE 부동소수점이라고 알려지게 된 방식을 지원한다.        2.4.1 비율이진수(Fractional Binary Numbers)     부동소수점에 대해서 이해하기 위한 첫 단계는 비율 이진수에 대해 생각해보는 것이다.            숫자들의 자리값은 십진 소수점 부호(‘.’)에 상대적으로 정의된다.                  위와 같은 방식으로 binary 표기법으로 생각해보자.            부호 ‘.’는 이진 소수점이 되고, 좌측의 브트들은 비음수의 2의 제곱을 자리값으로 가지며, 우측은 2의 음의 제곱을 자리값으로 갖는다.       이진 소수점을 한 자리 우측으로 이동하면 2로 곱한 효과, 좌측으로 이동하면 2로 나눈 효과를 가진다.                  이진수 표기는 x*2^y로 나타낼 수 있는 수만 표시할 수 있다.   이진 표시를 길게 늘려서 정확도를 높이도록 근사해야 한다.        2.4.2 IEEE 부동소수점 표시     IEEE 부동소수점 표준은 수를 V = (-1)^sM2^E 형태로 나타낸다            s는 음수와 양수를 결정한다.       유효숫자 M은 비율 이진수다.       지수 E는 2의 제곱으로 자리값을 제공한다.           부동소수점 수의 비트 표시는 이 값들을 인코딩하기 위해 세 개의 필드로 나누어진다.            한 개의 부호 비트 s는 부호 s를 직접 인코딩한다.       k비트 지수 필드 exp = ek-1…e1e0는 지수 E를 인코딩한다.       n비트 비율 필드 frac = fn-1 … f1f0는 유효숫자 M을 인코딩한다.                 Case 1: 정규화 값 Normalized Values            가장 일반적인 경우       exp의 비트 패턴이 모두 0은 아니며, 모두 1이 아니어야 한다.       E = e - Bias (Bias = 2^(k-1) - 1)       비율 필드 frac은 비율 값 f       유효 숫자 M = 1 + f 로 정의           Case 2: 비정규화 값 Denormalized Values            지수 필드가 모두 0일 때 나타낸 수는 비정규화 형태를 갖는다.       E = 1 - Bias       M = f = 0       비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타냄                    이들은 점증적 언더플로우라고 알려진 특성을 제공 (가능한 숫자 값들이 0.0 근처에서 같은 간격을 갖는다는 의미)                           Case 3: 특수 값 Special Values            지수 필드가 모두 1인 경우                    비율 필드가 모두 0이면, 결과값은 무한대를 나타냄           비율 필드가 0이 아니면 NaN(not a numbuer)                                   2.4.3 숫자 예제      2.4.4 근사법 Rounding     부동소수점 산술연산은 표시방법이 제한된 범위와 정밀도를 갖기 때문에 실제 연산의 근사값을 사용할 수밖에 없다.   “가장 유사한” 값 x를 체계적으로 계산하는 방법을 근사rounding 연산이다.   네가지 근사 모드를 정의함            짝수근사법(round-to-even): 가장 가까운 값, 중간에 위치할 경우 짝수를 향해 근사함       영방향근사 모드(round toward-zero): 양수 값을 아래쪽으로, 음수를 위쪽으로 근사함       하향근사 모드(round-down): 양수와 음수를 모두 아래쪽으로 근사함       상향근사 모드(round-up): 양수와 음수를 모두 위쪽으로 근사함                2.4.5 부동소수점 연산     부동소수점 값 x,y를 실수로 보고, 일부 연산이 실수들에 대해 정의된다면 Round(x,y)가 되는데, 이것은 실수 연산의 정확한 결과 값을 근사한 것이다.   부동소수점 덧셈에서 결합법칙이 성립하지 않는 것은 그룹의 특징 중에서 빠진 가장 중요한 부분이다.   교환법칙은 성립하지만, 결합벅칙은 성립 되지 않는다.        C에서 부동소수점     C는 짝수 근사모드를 사용한다.   int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.   int나 float에서 double로, 정확한 수치 값은 보존될 수 있다.   double에서 float로 범위가 더 작아지기 때문에 값이 오버플로우하여 무한대가 될 수 있따.   float나 double에서 int로, 값은 0 방향으로 근사된다        2.5 요약     정보를 비트로 인코딩하며, 이들은 일반적으로 연속된 바이트들로 구성된다.   대부분의 머신들은 정수를 인코딩하기 위해 2의 보수를 사용하고 부동소수점을 인코딩하기 위해 IEEE 표준 754를 사용한다.   부호형 및 비부호형 정수를 캐스팅할 때 비트 패턴을 유지하려고 하는데, T2U, U2T 함수들에 의해 나타난다.   제한된 길이는 숫자들이 나타낼 수 있는 범위를 넘어설 때 오버플로우를 발생시킨다.   비부호형과 2의 보수 산술연산은 결합법칙, 교환법칙, 분배법칙 등의 정수 산술연산의 많은 특성을 만족한다.   결합법칙, 교환법칙, 분배법칙 특성을 쉬프트와 2의 제곱의 곱셈 간 관계와 함께 사용된다.   부동소수점 산술연산은 매우 조심스럽게 사용해야한다.            제한된 범위와 정밀도를 갖기 때문이며, 결합법칙 같은 일반적인 수학 법칙을 따르지 않기 때문이다.                   부동소수점을 마지막으로 Chapter2 정보의 표현과 처리를 마무리하였다. 데이터 엔지니어링 인턴 포지션에서 ETL 작업을 하며 소수점 데이터에 접근 했을 때  R코드와 Python의 소수 처리 방식이 달라서 해당 오류를 잡는데 많은 시간이 걸린 경험이 있었다. 그 때 당시에는 대충 방식이 다르구나~ 로 끝났지만, 이번 챕터를 공부하게 되면서 아 부동소수점의 표현 방식 때문에(책은 C를 기준으로 하고 있지만,,,) 그런 오류가 잡혔던 거구나 하고 시야가 조금 더 넓어진 것 같다.  2.2절의 캐스팅과 2.4절의 부동소수점을 공부하면서 꽤 많은 애를 먹었지만, 앞으로 코딩을 하면서 캐스팅이나 소수점을 다룰 때 더 주의 깊게 다룰 수 있을 것 같다.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_04/",
        "teaser": null
      },{
        "title": "[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰",
        "excerpt":"Introduction     Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나   Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델   NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음            Machine Translation, Abstract Text Summarization           자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨   Encoder-Attention-Decoder       Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형   Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조       Related Works       Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train   GPT는 Language Modeling을 위해 Decoder를 Pre-train   이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음       MASS:Masked Sequence to Sequence Pre-training       새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자   Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking   마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴   Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공   Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선   Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨        K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터   하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능   BERT Masked LM            K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐           GPT Standard LM            하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨       Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐                m - Input sequence의 전체길이   u - Maskinge된 Fragment의 시작점   v - Masking된 Fragment의 끝점   X^u - u부터 v까지의 fragment   X^\\u:v - u부터 v까지 Making된 Input Sequence       Experiments     Model Configuration            1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer           Datasets            2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M       MASS의 효과 검증을 위한 low-resource language Romanian           Pre-training Details            Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험               Experiment:Unsupervised Machine Translation       Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행   Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델   MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록        Experiment:Low-resource Translation       Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역   Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트   MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가   데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남        Experiment:Abstractive Summarization       Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교   MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가        Experiment:Conversational Response Generation       Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교   MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌        The probability formulation       (a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL   하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과   실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨            문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공           K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증       Couclusion     MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록   Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정   또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_02/",
        "teaser": null
      },{
        "title": "[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰",
        "excerpt":"Introduction     Pre-trained word representations are a key component in many neural language understanding models.   Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.   We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.   In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%       Related Works     Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.   워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.            context2vec       CoVe           이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.       Model     ELMO            ELMO word representations are functions of the entire input sentence.       They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.       This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.                 Pretrained BiLM          Task-specific ELMo Embedding         Using biLMs for supervised NLP tasks            기존의 임베딩 벡터와 함께 사용된다.       ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.                  Evaluation         6개의 NLP task에서 에러율을 6~20% 줄였다.   6개의 NLP task에서 높은 점수를 기록했다.        Analysis        기존에 top layer output만 사용 한 것 대비 성능 향상을 검증했다.   대부분의 경우 Regularization parameter λ 가 작을수록 성능이 더 좋아지는 경향이 있다.          일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.          GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.   biLM에서는 문맥을 고려한다는 것을 알 수 있다.          biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.   이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다.          ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.       Conclusion     We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.   Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_03/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속되 바이트인 기계어 코드를 실행한다.   컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 기계어 코드를 생성한다.   어셈블러 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는 저급 인스트럭션들을 명시해야 한다.   기계어 코드를 배우면 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내제된 비효율성을 분석할 수 있다.   이 장은 X86-64에 기초하고 있다.        3.1 역사적 관점     x86이라고 통칭하는 인텔 프로세서 제품군은 오랜 기간 진화를 통한 개발을 해왔다.            대충 엄청 많은 프로세서들이 나열 되는데, 팬티엄4E(2004, 125M 트랜지스터) 하이퍼쓰레딩 기법의 추가와 AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T가 추가된 해당 모델을 x86-64라고 부른다고 한다.                 3.2 프로그램의 인코딩     C 언어에서 gcc 명령은 소스 코드(test.c)를 실행 코드로 변환하기 위해 일련의 프로그램들을 호출한다.            C 전처리가 #include로 명시된 파일을 코드에 삽입해 주고 #define으로 선언된 매크로를 확장해준다.       컴파일러는 소스파일의 어셈블러 버전(test.s)를 생성한다.       어셈블러는 어셈블리 코드를 바이너리 목적코드인(test.o)로 변환한다.                    목적코드는 기계어 코드의 한 유형이다. - 모든 인스트럭션과 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았다.                       마지막으로 링커가 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.           커맨드 라인 옵션으로 -0g를 주면 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적호 수준을 적용한다.            높은 수준의 최적화를 적용하면 만들어진 코드가 너무 많이 변경되어 본래의 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.                3.2.1 기계수준 코드     컴퓨터 시스템은 보다 간단한 추상화 모델을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.            기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조 즉 “ISA”에 의해 정의된다.                    프로세서의 상태, 인스트럭션의 형식, 프로세서 상태에 대한 각 인스트럭션들의 영향들을 정의한다.                       기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.           컴파일러는 추상화된 실행모델로 표현된 프로그램을 프로세서가 실행하는 매우 기초적인 인스트럭션들로 변환하는 대부분의 일을 수행한다.        3.2.2 코드 예제       기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현에 주목할 필요가 있다.            x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.       인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을 기계어 인스트럭션으로 유일하게 디코딩할 수 있도록 설계한다.       역어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다.                3.3 데이터의 형식     인텔 프로세서들이 근본적으로 16비트 구조를 사용하다가 추후에 32비트로 확장했기 때문에 인텔은 “워드”라는 단어를 16비트 데이터 타입을 말할 때 사용한다.           3.4 정보 접근하기     x86-64 주처리장치 CPU는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.            이들 레지스터는 정수 데이터와 포인터를 저장하는데 사용한다.                   3.4.1 오퍼랜드 식별자 specifier     대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다.   오퍼랜드는 연산을 수행할 소스 값과 그 결과를 저장할 목적지의 위치를 명시한다.   소스 값은 상수로 주어지거나 레지스터나 메모리로부터 읽을 수 있다. 결과 값은 레지스터나 메모리에 저장된다.   세가지 타입으로 나뉘어짐            immediate로, 상수값을 말한다.       register는 레지스터의 내용을 나타내며       Memory, 메모리 참조로 유효주소라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.                   3.4.2 데이터 이동 인스트럭션     가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 복사하는 명령어다.            MOV 클래스 : 소스 위치에서 데이터를 목적지 위치로 어떤 변환도 하지 않고 복사한다.           소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다.   목적 오퍼랜드는 레지스터 또는 메모리 주소의 위치를 지정한다.   x86-64는 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다.              3.4.3 코드 예제           C언어에서 “포인터”라고 부르는 것이 어셈블리어에서는 단순히 주소를 나타낸다.     포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 과정으로 이루어진다.     지역변수들은 메모리에 저장되기보다는 종종 레지스터에 저장된다.           3.4.4 스택 데이터의 저장과 추출 push,pop     push와 pop은 프로그램 스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다.   스택은 프로시저 호출을 처리하는 데 중요한 역할을 한다.   프로그램 스택은 메모리의 특정 영역에 위치한다.   스택의 탑top 원소가 모든 스택 원소 중에서 가장 낮은 주소를 갖는 형태다.   스택은 pop이 되어도 stack의 top을 표현하는 주소가 올라간거지 값은 여전히 pop이 된 위치에 남아있다.   스택이 프로그램 코드와 다른 형태의 프로그램 데이터와 동일한 메모리에 저장되기 때문에 프로그램들은 표준 메모리 주소지정 방법을 사용해서 스택 내 임의의 위치에 접근할 수 있다.      ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_05/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.5 산술연산과 논리연산       위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.   인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.            addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.           연산들은 네 개의 그룹으로 나누어진다.            유효주소 적재, 단항unary, 이항binary, 쉬프트                    이항 연산은 두 개의 오퍼랜드를 가진다.           단항 연산은 한 개의 오퍼랜드를 가진다.                           3.5.1 유효주소 적재 Load Effective Address     유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.   메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.   가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.   이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.   또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다            ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.           목적 오퍼랜드는 반드시 레지스터만 올 수 있다.   3.5.2 단항 및 이항 연산     단항 연산            하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.       오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.       ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자           이항 연산            첫 번째 오퍼랜드는 상수나 레지스터, 메모리 위치가 올 수 있고 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.       C에서 x -= y와 유사하다.       두 개의 오퍼랜드가 모두 메모리 위치가 될 수 없다.       두 번째 오퍼랜드가 메모리 위치일 때 프로세서가 메모리에서 값을 읽고, 연산을 하고, 그 결과를 다시 메모리에 써야 한다는 점에 유의해야 한다.           3.5.3 쉬프트 연산     쉬프트하는 크기를 먼저 주고, 쉬프트할 값을 두 번째로 준다.   산술과 논리형 우측 쉬프트가 모두 가능하다.   쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 명시할 수 있다.   좌측 쉬프트 인스트럭션에는 두 가지 이름이 있다.            SAR: 산술 쉬프트, 부호비트를 복사해서 채운다       SHR: 논리 쉬프트, 0으로 채운다           쉬프트 연산의 목적 오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.   3.5.4 토의     인스트럭션들은 비부호형과 2의 보수 산술연산에 사용될 수 있다.   오직 우측 쉬프트만이 부호형과 비부호형 데이터를 구분하는 인스트럭션을 요구한다.   이것이 부호형 정수 산술연산을 구현하는 방식으로 2의 보수 산술연산을 선호하는 주요 특징이다.   3.5.5 특수 산술연산       두 개의 64비트 부호형 또는 비부호형 정수들 간의 곱셈 결과값을 표시하기 위해 128비트를 필요로한다.   x86064 인스트럭션 집합은 128비트 숫자와 관련된 연산에 대해서는 제한적인 지원을 제공한다.            워드(2바이트), 더블워드(4바이트), 쿼드워드(8바이트), 인텔은 16바이트 워드를 옥트워드oct word라고 명명한다.           IMUL 인스트럭션 클래스의 멤버인 형태            이 형식은 두 개의 64비트 오퍼랜드로부터 64비트 곱을 생성하는 “2 오퍼랜드” 곱셈 인스트럭션을 제공한다.           추가적으로 x86-64는 두 개의 다른 “단일 오퍼랜드” 곱셈 인스트럭션을 제공하며 64비트 값의 완전한 128비트 곱을 계산한다.            하나는 비부호형(mulq), 다른 하나는 2의 보수(imulq) 곱셈이다.       이들 모두 한 개의 인자는 레지스터 %rax에 보관해야 하고 다른 하나는 인스트럭션 소스 오퍼랜드로 주어진다.       곱은 레지스터 %rdx(상위 64비트)와  %rax(하위 64비트)에 저장된다.           곱을 저장하기 위해서는 아래의 그림처럼 두 개의 movq 인스트럭션이 필요하다.        단일 오퍼랜드 곱셈 인스트럭션과 비슷한 단일 오퍼랜드 나눈셈 인스트럭션으로 제공된다.   나눗셈 인스트럭션 idviq은 피제수dividened를 128비트로 레지스터 %rdx(상위 64비트)와 %rax(하위 64비트)에 저장한다.   제수divisor는 인스트럭션의 오퍼랜드로 주어진다.   인스트럭션은 몫은 레지스터 %rax에, 나머지는 레지스터 %rdx에 저장한다.   ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_06/",
        "teaser": null
      },{
        "title": "[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰",
        "excerpt":"Introduction     Multi-Task Learning(MTL)은 새로운 Task를 학습하는 데 도움이 되도록 이전 작업에서 학습된 지식을 적용하는 인간 학습 활동에서 영감을 받음   Deep neural networks(DNN)를 이용한 representation learning에 MTL을 적용하는 것에 대한 관심이 높아지고 있음            DNN을 이용한 representation learning은 많은 양의 데이터를 요구함, MTL은 많은 task에서의 supervised labeled data를 제공함       MTL은 특정 Task에 Overfitting 되지 않도록 Regularization 효과를 줌           MTL과 대조적으로, Language Model은 대용량의 unsupervised dataset을 활용하여 모델을 학습함            ELMo, GPT, BERT           MT-DNN은 Language Model Pre-Training을 활용한 BERT에 Multi-task learning을 적용하여 성능을 개선한 모델      Tasks     GLUE의 9개 task를 MTL에 활용   Single Sentence Classification            하나의 문장이 주어졌을 때 문장의 Class를 분류하는 Task       CoLA : 문장이 문법적으로 맞는지 분류 (True/False)       SST-2 : 영화 Review 문장의 감정 분류 (Poistive/Negative)           Text Similarity            문장 쌍이 주어졌을 때, 점수를 예측하는 Regression Task       STB-B : 문장 간의 의미적 유사도를 점수로 예측           Pairwise Text Classification            문장 쌍이 주어졌을 때, 문장의 관계를 분류하는 Task       RTE, MNLI : 문장 간의 의미적 관계를 3가지로 분류 (Entailment, Contradiction, Neutral) – QQP, MRPC : 문장 간 의미가 같음 여부를 분류 (True/False) – Relevance Ranking – QNLI : 질문과 해당 지문 중 한 문장이 쌍으로 주어졌을 때 해당 지문 문장에 질문의 답이 있는지 여부를 분류 (True/False) – MT-DNN에서는 이를 Rank 방식으로 바꾸어 모든 지문 문장에 정답이 있을 가능성을 Scoring 하여 가장 Score가 높은 지문 문장을 True로 분류하는 방식으로 Task 수행              Model Architecture         Lexicon Encoder            Token Embedding                    맨 앞에 [CLS] 토큰을 추가. 추후 Output에서 Classification 등을 위해 사용됨           만약 문장쌍이 들어온다면 각 문장은 Wordpiece로 Toenization 되며 [SEP] Token이 두 문장 사이의 구분자로 사용됨                       Sentence Embedding - 1번째 혹은 2번째 문장임을 표현하는 Vector       Positional Embedding - 각 Token의 위치 정보를 표현하는 Vector                 Transformer Encoder            Lexicon Encoder로 부터 각 Token의 Input Vector를 입력으로 받아 Ouput Vector 추출       BERT 모델과 달리 task별로 fine-tunning하지 않고 MTL로 fine-tunning 함                 Single-Sentence Classification Ouput            [CLS] Token과 Task Specific Parameter의 곱에 Softmax를 취하여 Ouput 추출                  Text Similarity Ouput            [CLS] Token을 활용하여 Task Specific Parameter와 곱한 후 sigmoid function을 사용하여 Score를 예측                  Pairwise Text Classification Ouput            BERT와 다르게 Stochastic Answer Network(SAN)를 이용함                    NLI의 기존 SOTA 모듈, 주어진 문장들에 대한 Multi-step Reasoning을 모델링하는 구조 (한번에 classification 결과를 예측하지 않고 여러번의 예측을 통한 Reasoning으로 결과를 예측)           SAN은 GRU모듈에 주어진 문장쌍의 representation을 Input 및 hidden state로 넣는 과정을 k번 반복함으로써 정제된 representation을 얻고 이를 이용하여 최종 예측                                 각 step을 진행할때마다 linear classifier를 거쳐 각 클래스에 대한 확률 분포 계산         모든 K-step output을 평균하여 클래스에 대한 최종 확률 분포를 계산, averaging 연산 전에 stochastic prediction droput을 적용         Relevance Ranking Ouput            Question과 문장 Pair Input으로 넣어 생성한 [CLS] Token에 Sigmoid를 취하여 문장 별로 점수를 Scoring하고 가장 높은 점수 만 Question에 해당하는 정답이 있다고 예측하는 방식              Training Procedure      Experiments     Datasets            GLUE 벤치마크는 QA, Sentiment Analysis, Text Similarity, Textual Entailment를 포함한 NLU task       SNLI 데이터셋은 570K개의 문장 쌍       SciTail은 Science Question Answering 데이터셋에서 파생된 Textual Entailment 데이터셋임                    주어진 전제가 주어진 가설을 수반하는지 여부를 평가                                  Implementation details            Optimizer : Adamax       learning rate : 5e-5       Batch Size : 32       Maximum number of epoch : 5       Fine-tuning layer dropout : task마다 다르게 설정(MNLI:0.3, CoLA:0.05, Else:0.1)       Tokenizer : WordPiece           Experiments - GLUE Results         MT-DNN이 BERT보다 전체 성능이 약 1.8% 향상됨   각각의 Task 결과가 대부분 SOTA임        Dataset이 적은 Task(MRPC, RTE)의 경우 비교적 높은 성능 향상이 있음              Specific layer로 SAN 사용, pairwise ranking을 한 효과를 보여주는 실험   BERT vs ST-DNN            ST-DNN은 BERT처럼 single-task로 fine-tunning함       MNLI, QQP, MRPC, QNLI에서 BERT보다 성능이 좋음           ST-DNN vs MT-DNN            데이터가 적은 실험에서 더 큰 성능향상이 있음           Experiments - Domain Adaptation Results         SNLI와 SciTail에 MT-DNN을 적용한 실험   MT-DNN은 데이터를 0.1%만 써도 성능이 잘나옴   MT-DNN이 BERT보다 데이터가 적을 때, 압도적인 성능을 보여줌   Conclusion      Multi-task learning model과 pre-training을 결합한 MT-DNN 모델 제안   MT-DNN은 SNLI, SchiTail 및 GLUE에서 10가 NLU task에 높은 성능 향상 결과를 얻음   MT-DNN은 Domain Adaption 실험에서도 탁월한 일반화 기능을 보여줌   MT-DNN 개선을 위해 MTL에서의 모델 구조 공유에 더 깊은 이해, fine-tuning과 pre-training을 위한 더 효과적인 훈련 방법을 더 연구해야함  ","categories": ["NLP"],
        "tags": ["paper review","nlp"],
        "url": "/nlp/NLP_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part5 클래스와 객체",
        "excerpt":"Part5 클래스와 객체   클래스 선언     클래스            자바는 객체를 만들기 위해 반드 클래스를 먼저 만들어야 한다. 클래스는 객체를 만들기 위한 일종의 틀이다.                    붕어빵이 객체라면, 붕어빵 틀은 클래스           자동차 클래스 생성           컴파일하여 디스크에 Car라는 클래스를 생성한다.           자동차 클래스가 생성되었다고 해서 자동차가 만들어 진것은 아니다.                                   public class Car{         }        Car객체 생성하기 (자동차 만들기)            new 연산자는 new 연산자 뒤에 나오는 생성자를 이용하여 메모리에 객체를 만들라는 명령.       메모리에 만들어진 객체를 인스턴스(instance)라고도 한다.       이렇게 만들어진 객체를  참조하는 변수가 c1, c2 이다.       위의 코드가 실행되면 Car라는 객체가 2개가 만들어지고 각각의 객체를 참조하는 c1과 c2변수가 선언된다.                   public class CarExam{              public static void main(String args[]){                 Car c1 = new Car();                 Car c2 = new Car();             }          }  참조타입  참조형 타입은 기본형 타입을 제외한 모든 타입입니다. 앞서 배웠던, 배열도 참조형이고, 클래스도 모두 참조 타입이다.     기본형 타입: boolean, char, byte, short, int, long, float, double   참조형 타입: 기본형 타입을 제외한 모든 타입   참조형 변수            Stirng str = new String(“Hello);                    str 변수 앞에 기본형 타입이 아닌 String 클래스가 적혀있다.           이퀄(=) 뒤에는 new 다음에 생성자라는 것이 있다.           new 라는 키워드는 객체를 메모리에 올려준다. 이렇게 메모리에 올라간 객체를 인스턴스라고 말한다.                       메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 레퍼런스 하는 변수가 str 이다. 레퍼런스 한다라는 것은 변수가 인스턴스를 가지고 있는게 아니라 말 그대로 가리킨다는 의미이다.       str이라는 변수에는 메모리의 위치 값이 저장되는 것이다. 메모리의 위치값이 저장된다고 하더라도,  어떤 메모리에 저자오디는지 그 정보를 알 수 있는 방법은 없다. 그렇기 때문에 str변수는 String 인스턴스를 참조한다라고만 알면 된다.           String 클래스  문자열을 표현하는 자바에서 가장 많이 사용하는 클래스    자바 인스턴스 생성 방법     new 연산자를 이용하지 않고 인스턴스를 만드는 경우            “hello”라는 문자열이 메모리 중에서 상수가 저장되는 영역에 저장된다. 상수는 변하지 않는 값을 의미.       String str2 = “hello”; 이 문장이 실행될 때에 hello 라는 문자열 상수는 이미 만들어져 있으므로 str1이 참조하는 인스턴스를 str2도 참조한다.               String str1 = \"hello\";     String str2 = \"hello\";      new 연산자를 이용해서 인스턴스를 만드는 경우            new연산자를 이용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어진다.       String str4 = new String(“hello”); 이 문장이 실행될때도 새롭게 만들게 되므로, str3 과 str4는 서로 다른 인스턴스를 참조한다.       변수끼리 == 로 비교하면 서로 같은 것을 참조하는지 비교한다.       String은 다른 클래스와 다르게 new를 사용하지 않고 사용할 수 있다. 메모리를 아끼려면 String은 new를 사용하지 않고 사용하는 것이 좋다.       String은 불변 클래스이다. 불변이란 String이 인스턴스가 될때 가지고 있던 값을 나중에 수정할 수 없다.       String은 문자열과 관련된 다양한 메소드를 가지고 있다. 메소드를 호출한다 하더라도 String은 내부의 값이 변하지 않는다.       String이 가지고 있는 메소드중 String을 반환하는 메소드는 모두 새로운 String을 생성해서 반환한다.               String str3 = new String(\"hello\");     String str4 = new String(\"hello\");  필드(filed) 선언  자동차는 자동차 이름, 자동차 번호를 가지고 있고, 자동차는 달리고 멈추는 기능이 있따. 여기에서 가지고 있는 것을 속성이라고 한다. 자바에서는 이러한 속성을 필드(Field)라는 용어로 사용한다.     이름과 번호를 필드로 가지고 있는 Car 클래스 선언       public class Car{         String name;             int number;     }     Car 클래스를 인스턴스화 하기       Car c1 = new Car();     Car c2 = new Car();     //Car라는 인스턴스가 메모리에 2개 만들어 진다. 객체별로 name과 number라는 속성을 가진다.     속성 이용하기            참조 변수 다음에 나오는 점(dot)은 참조변수가 참조하는 객체가 가지고 있는 것을 사용할 때 사용               //c1.name은  c1이 참조하는 객체의 name 을 의미.      c1.name = \"소방차\";  //c1이 참조하는 객체의 name을 소방차로 설정      c1.number = 1234;   // c1.number = 1234란 c1이 참조하는 객체의 number를 1234 로 설정       c2.name = \"구급차\"  //c2가 가리키는 객체의name을 구급차로 설정     c2.number = 1004;  //c2가 가리키는 객체의 number를 1004로 설정       System.out.println(c1.name);  //콘솔에 c1이 참조하는 객체의 name 을 출력합니다.      System.out.println(c1.number); //콘솔에 c1이 참조하는 객체의 number 를 출력합니다.       String name = c2.name;   //c2가 참조하는 객체의 name 을 String 타입 변수 name 도 참조하게 합니다.  메소드란?     필드가 물체의 상태라면, 물체의 행동에 해당하는게 메소드다. car에 이름과 번호가 있기도 하지만, car는 앞으로 전진할 수도 있고 후진하는 행동도 할 수 있다.            메소드는 입력값이 있고, 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념이다.       이때 입력값을 매개변수라고 하고, 결과값을 리턴값이라고 한다.                    인자(Argument)는 어떤 함수를 호출시에 전달되는 값을 의미한다.           매개 변수(Parameter)는 그 전달된 인자를 받아들이는 변수를 의미한다.                       메소드란 클래스가 가지고 있는 기능이다. 클래스 안에 선언된다.           메소드(Method) 선언     매개변수도 없고 리턴하는 것도 없는 형태의 메소드            리턴하는 것이 없을 경우 void라고 작성합니다.               public class MyClass{         public void method1(){             System.out.println(\"method1이 실행됩니다.\");         }     }          정수를 받아들인 후, 리턴하지 않는 메소드            받아 들이는 값은 어떤 타입이라도 상관없다.       받아 들이는 값의 수는 여러개 일 수 있다. 여러개일 경우 콤마(,)로 구분한다.               public class MyClass{                public void method2(int x, int y){             System.out.println(x + \" 를 이용하는 method2입니다.\");         }        }          정수를 받아들인 후, 정수를 반환하는 메소드       public int method3(int y){         System.out.println(y + \" 를 이용하는 method5입니다.\");         return 5;     }       String 클래스의 메소드     문자열 길이 구하기            str.length()는 str이 참조하는 문자열의 길이를 구해서 int 타입으로 리턴해주는 메소드이다.           문자열 붙이기(concat)            str.concat(“world”) 메소드는 str이 참조하는 문자열 hello 에다가 메소드의 인자로 들어온 문자열 world를 붙여서 String 타입으로 리턴하는 메소드다.       String Class는 불변 클래스로, 메소드가 수행되면, 새로운 문자열을 만든다. 그러므로, 원래 클래스는 변하지 않는다.           문자열 자르기(subString)            str.subString(1,3)은 str이 참조하는 문자열을 인덱스 1번부터 3번까지 자른 결과이다.       str.subString(2)는 str이 참조하는 문자열을 2번 인덱스부터 마지막까지 자른 결과를 의미한다.           변수의 scope와 static  변수의 scope: 프로그램상에서 사용되는 변수들은 사용 가능한 범위를 가진다. 그 범위를 변수의스코프라고 한다.     변수가 선언된 블럭이 그 변수의 사용범위이다.            클래스의 속성으로 선언된 변수 globalScope의 사용 범위는 클래스 전체이다.       매개변수로 선언된 int value는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭 내이다.       메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭 내이다.               public class ValableScopeExam{          int globalScope = 10;   // 인스턴스 변수           public void scopeTest(int value){                int localScope = 10;             System.out.println(globalScope);             System.out.println(localScpe);             System.out.println(value);         }     }          main메소드에서 사용하기            같은 클래스 안에 있는데 globalScope 변수를 사용 할 수 없다.       main은 static한 메소드이다. static한 메소드에서는 static 하지 않은 필드를 사용 할 수 없다.               public class VariableScopeExam {         int globalScope = 10;           public void scopeTest(int value){             int localScope = 20;                         System.out.println(globalScope);             System.out.println(localScope);             System.out.println(value);         }            public static void main(String[] args) {             System.out.println(globalScope);  //오류             System.out.println(localScope);   //오류             System.out.println(value);        //오류           }        }          static            같은 클래스 내에 있음에도 해당 변수들을 사용할 수 없다.       main 메소드는 static 이라는 키워드로 메소드가 정의되어 있다. 이런 메소드를 static 한 메소드라고 한다.       static한 필드(필드 앞에 static 키워드를 붙임)나, static한 메소드는 Class가 인스턴스화 되지 않아도 사용할 수 있다.               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }          static한 변수는 공유된다.            static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성된다. 그러므로, 인스턴스가 여러개 생성되도 static한 변수는 하나다.       globalScope같은 변수(필드)는 인스턴스가 생성될 때 생성되기 때문에 인스턴스 변수라고 한다.       staticVal같은 static한 필드를 클래스 변수라고 한다.       클래스 변수는 레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는 것이 더 바람직하다.                    VariableScopeExam.staticVal                               public class VariableScopeExam {         int globalScope = 10;          static int staticVal = 7;          public void scopeTest(int value){             int localScope = 20;                 }          public static void main(String[] args) {             System.out.println(staticVal);      //사용가능          }      }       열거형(enum)     자바는 열거타입을 이용하여 변수를 선언할 때 변수타입으로 사용할 수 있다.            열거형은 JDK5에서 추가되었다.       JDK5 이전에는 상수를 열거형 대신 사용                    상수를 이요한는 방법                               public class EnumExam {         public static final String MALE = \"MALE\";         public static final String FEMALE = \"FEMALE\";          public static void main(String[] args) {             String gender1;              gender1 = EnumExam.MALE;             gender1 = EnumExam.FEMALE;                           }     }          상수를 사용했을 때의 문제점            String으로 선언된 gender1 에는 MALE,FEMALE 둘 중 한가지 값을 갖기 원하는데, gender1의 type이 String 이기 때문에   gender1 = “소년”; 이렇게 수행 되어도 전혀 문제가 되지 않는다.       실행할 때 원했던 값인 MALE,FEMALE이 아닌 다른 값이 들어오게 되므로 문제를 발생시킬 수 있다.           해결 방법            이런 문제를 발생시키지 않게 하기 위해 열거형을 사용한다.       열거형 정의 및 사용 방법               // 정의 방법     enum Gender{         MALE, FEMALE;     }            // 사용 방법     Gender gender2;      gender2 = Gender.MALE;     gender2 = Gender.FEMALE;      //Gender타입의 변수에는 MALE이나 FEMALE만 대입이 가능. 다른 값은 저장할 수가 없다.            enum에 대해서 좀 더 궁금하다면!! enum의 뿌리   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_05/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part6 클래스 다듬기 ",
        "excerpt":"Part6 클래스 다듬기   생성자  모든 클래스는 인스턴스화 될 때 생성자를 사용한다.      생성자의 특징            생성자는 리턴타입이 없다.       생성자를 프로그래머가 만들지 않으면 매개변수가 없는 생성자가 컴파일할 때 자동으로 만들어진다.       매개변수가 없는 생성자를 기본생성자라고 한다.       생성자를 하나라도 프로그래머가 만들었따면 기본생성자는 자동으로 만들어지지 않는다.           생성자의 역할            생성자가 하는 일은 객체가 될 때 필드를 초기화 하는 역할을 수행한다.       자동차가 객체가 될 때 반드시 이름을 가지도록 하려면, Car 클래스를 다음과 같이 만들어야 한다.               public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }            // 위의 Car 클래스를 이용하여 Car 인스턴스를 생성하는 방법     public class CarExam2{         public static void main(String args[]){                  Car c1 = new Car(\"소방차\");             Car c2 = new Car(\"구급차\");             //Car c3 = new Car(); // 컴파일 오류가 발생합니다.                  System.out.println(c1.name);                  System.out.println(c2.name);         }     }     // Car클래스는 기본 생성자를 가지지 않는다. 그래서 기본생성자로 Car 객체를 생성할 수 없다.       this  this는 현재 객체, 자기 자신을 나타낸다.      this의 사용       public class Car{         String name;         int number;              public Car(String n){             name = n;         }     }                 Car 클래스의 생성자 매개변수의 이름이 n 이다. n 이라는 변수명은 무엇을 의미하는지 쉽게 알 수 없다.       n 으로 쓰기 보다는 name 으로 사용하는 것이 좋다.               public Car(String name){         name = name;     }                 “name=name”이라고 코드를 바꾸면, 가깝게 선언된 변수를 우선 사용하기 때문에 “name=name”이라는 코드는 매개변수의 name의 값을 매개변수 name에 대입하라는 의미가 된다.       즉, 필드는 바뀌지 않는다. 이런 경우 필드라는 것을 컴파일러와 JVM에게 알려주기 위해서 this 키워드를 사용해야 한다.               public Car(String name){         this.name = name;     }                 앞의 this.name은 필드 name을 말하고 =(이퀄) 뒤의 name은 매개변수를 의미한다.       즉 매개변수의 값을 필드에 대입하라는 의미가 된다.           클래스 안에서 자기 자신이 가지고 있는 메소드를 사용할 때도 this.메소드명()으로 호출할 수 있다.   메소드 오버로딩     매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게하는 기술   메소드 오버로딩            이름은 같지만 매개변수가 다른 메소드       메소드 오버로딩은 매개변수 부분이 달라야 한다.       매개변수의 타입과 개수가 동일한 메소드를 또 정의 할 수는 없다.           오버로딩된 메소드 이용하기            메소드의 인자에 어떤 값이 쓰이냐에 따라서 각기 다른 메소드가 호출된다.               public MethodOverloadExam{         public static void main(String args[]){             MyClass2 m = new MyClass2();             System.out.println(m.plus(5,10));             System.out.println(m.plus(5,10,15));             System.out.println(m.plus(\"hello\" + \" world\"));         }     }  생성자 오버로딩과 this     생성자의 매개변수의 유형과 개수가 다르게 하여 같은 이름의 생성자를 여러 개 가질 수 있다.            생성자도 메소드와 마찬가지로 여러개를 선언할 수 있다.       매개변수의 수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.               public class Car{         String name;         int number;          public Car(){          }          public Car(String name){             this.name = name;         }          public Car(String name, int number){             this.name = name;             this.number = number;         }     }     오버로딩된 생성자 이용하기   public class CarExam4{     public static void main(String args[]){         Car c1 = new Car();         Car c2 = new Car(\"소방차\");         Car c3 = new Car(\"구급차\", 1234);     } }     자기 생성자 호출하는 this()            기본생성자를 호출하였을 때 name을 “이름없음”, 숫자를 0으로 초기화 하기               public Car(){         this.name = \"이름없음\";         this.number = 0;     }       -     - 위처럼 작성했을 경우 코드의 중복이 일어난다.     - 자신이 가지고 있는 다른 생성자를 이용할 수 있다.       public Car(){         this(\"이름없음\", 0);     }       패키지  패키지(package)란 서로 관련이 있는 클래스 또는 인터페이스들을 묶어 놓은 묶음이다. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록 하고, 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 관리를 편하게 해준다.     패키지 정의방법            package이름은 보통 도메인 이름을 거꾸로 적은 후, 그 뒤에 프로젝트 이름을 붙여서 만든다. 물론, 프로젝트 이름 뒤에 또 다른 이름이 나올 수도 있다.       package이름은 폴더명 점 폴더명 점 폴더명 과 같은 형식으로 만들어진다. 각각의 폴더명은 숫자로 시작할 수 없다.       도메인 이름이 8cruz.com 이고 프로젝트 이름이 javastudy 라면 com.eightcruz.javastudy.Hello 로 패키지를 지정 할 수 있다.                    도메인이 숫자로 시작되는데 패키지명은 첫글자에 숫자를 사용할 수 없으므로 적절하게 수정한다.           도메인으로 사용하는 이유는 패키지가 중복되는것을 방지하기 위함이므로, 반드시 존재하는 도메인이 아니라도 상관없다.                           패키지에 생성된 클래스 사용하기            java.lang 패키지를 제외하고는 다른 패키지에 있는 클래스를 사용하려면 import라는 구문을 적어줘야 한다.                    import com.eightcruz.javastudy.Hello;           import com.eightcruz.javastudy.*;                            해당 패키지에 있는 모든 클래스를 사용한다는 의미                                                   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_06/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part7 상속",
        "excerpt":"Part7 상속   상속     상속이란? 부모가 가진것을 자식에게 물려주는 것을 의미한다.            노트북은 컴퓨터의 한 종류다.       침대는 가구의 한 종류다. 혹은 침대는 가구다.       소방차는 자동차다.           이렇게 말할 수 있는 관계를 is a 관계 혹은 kind of 관계라고 한다.      Car를 상속받은 Bus를 class로 표현하는 방법            자바는 클래스 이름 뒤에 extends 키워드를 적고 부모 클래스 이름을 적게 되면 부모 클래스가 가지고 있는 것을 상속받을 수 있게 된다.       상속이란 부모가 가지고 있는 것을 자식이 물려받는 것을 말한다. 즉, 부모가 가지고 있는 것을 자식이 사용할 수 있께 된다.               public class Car{      }      public class Bus extends Car{      }     부모 클래스와 자식 클래스의 메소드            자식 클래스는 부모 클래스에 선언된 메소드를 사용할 수 있다.       자식 클래스는 부모가 가지고 있는 메소드 외에 추가로 메소드를 선언할 수 있다.                    이것을 확장하였다고 표현한다.                           접근제한자  접근 제한자란 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.      접근 제한자의 종류            public                    어떤 클래스든 접근할 수 있다는 것을 의미                       protected                    자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속받은 자식 클래스에서는 접근할 수 있다는 것을 의미                       private                    자기 자신만 접근할 수 있다는 것을 의미                       접근제한자를 적지 않으면 default 접근 지정자                    자기자신과 같은 패키지에서만 접근할 수 있다는 것을 의미(상속X)                       public &gt; protectd &gt; default &gt; private           추상클래스  추상 클래스란 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하는데 새, 포유류 같은 것은 구체적이지 않다.     추상 클래스 정의하기            추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.       추상 클래스는 미완성의 추상 메소드를 포함할 수 있다.                    추상 메소드란, 내용이 없는 메소드이다. 즉 구현이 되지 않은 메소드이다.           추상 메소드는 리턴 타입 앞에 abstract라는 키워드를 붙여야 한다.                       추상 클래스는 인스턴스를 생성할 수 없다.               public abstract class Bird{         public abstract void sing();          public void fly(){             System.out.println(\"날다.\");         }     }     추상 클래스를 상속받는 클래스 생성하기            추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메소드를 반드시 구현해야 한다.       추상 클래스를 상속받고, 추상 클래스가 갖고 있는 추상 메소드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다.           super와 부모생성자     class가 인스턴스화 될 때 생성자가 실행되면서 객체의 초기화를 한다. 그 때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.            new 연산자로 자식 객체를 생성하면, 자식객체가 메모리에 올라갈 때 부모인 객체도 함께 메모리에 올라간다.       생성자는 객체를 초기화 하는 일을한다.       생성자가 호출될 때 자동으로 부모의 생성자가 호출되면서 부모객체를 초기화 하게된다.           super            자신을 가리키는 키워드가 this 라면, 부모를 가리키는 키워드는 super       super()는 부모의 생성자를 의미한다.       부모의 생성자를 임의로 호출하지 않으면, 부모 class의 기본 생성자가 자동으로 호출된다.           부모의 기본생성자가 아닌 다른 생성자를 호출하는 방법            클래스는 기본 생성자가 없는 경우도 존재한다.               public Bus(){         super(\"소방차\"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.         System.out.println(\"Bus의 기본생성자입니다.\");     }  super 키워드는 자식에서 부모의 메소드나 필드를 사용할 때도 사용한다.   오버라이딩  오버라이딩이란 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것이다. 즉 오버라이딩이란 메소드를 재정의 하는 것이다.     메소드 오버라이딩            메소드를 오버라이드 하면, 항상 자식클래스에서 정의된 메소드가 호출된다.       오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.                    super 키워드를 이용하면, 부모의 메소드를 호출 할 수 있다.                               //run 메소드를 가지고 있는  Car클래스      public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      //Car 를 상속받는 Bus 클래스      public class Bus extends Car{      }          //오버라이딩     public class Bus extends Car{         public void run(){             System.out.println(\"Bus의 run메소드\");         }     }        //super 키워드     public class Bus extends Car{         public void run(){             **super.run();**  // 부모의  run()메소드를 호출              System.out.println(\"Bus의 run메소드\");         }     }     오버라이딩 vs 오버로딩  오버로딩(Overloading) : 같은 이름의 메소드를 여러개를 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술  오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의해서 사용    클래스 형변환  부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.     형변환       public class Car{         public void run(){             System.out.println(\"Car의 run메소드\");         }     }      public class Bus extends Car{         public void ppangppang(){             System.out.println(\"빵빵.\");         }        }  상속 관계란 is a 관계다. “Bus는 Car다.”라는 관계가 성립된다.      부모타입으로 자식객체를 참조할 수 있다.            부모타입으로 자식객체를 참조하게 되면 부모가 있는 메소드만 사용할 수 있다.               public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             car.ppangppang(); // 컴파일 오류 발생         }     }     ppangppang()메소드를 호출하고 싶다면 Bus 타입의 참조변수로 참조 해야한다.       public class BusExam{         public static void main(String args[]){             Car car = new Bus();             car.run();             //car.ppangppang(); // 컴파일 오류 발생              Bus bus = (Bus)car;  //부모타입을 자식타입으로 형변환              bus.run();             bus.ppangppang();         }     }     객체들 끼리도 형변환이 가능하다. 단 상속관계에 있었을 때만 가능하다.   부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환이 일어난다.   부모타입의 객체를 자식타입으로 참조하게 할 때는 명시적으로 형변환 해주어야 한다. 단, 이렇게 형변활 할때에는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능하다.      과연 이 형변환을 왜 언제 사용할까! 라는 의문을 가졌다면,,,, 이런 상황들을 생각해보자  첫번째, VIP 회원을 VVIP 회원으로 등급을 올려줄 때  두번째, 모험가 직업을 가진 플레이어가 전사 직업을 가지게 되었을 때…  보통 다형성을 활용하려고 사용한다고 한다… 코드 한줄만 바꿔도 돌아갈수 있도록…?   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.6 제어문)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.6 제어문     일부 구문인 반복문, 스위치문들은 데이터에 적용된 시험결과에 따라 일련의 연산이 실행되는 조건부 실행이 요구된다.   기계어 코드에서는 조건부 동작을 구현하기 위해 두 개의 기본적인 낮은 수준의 방법을 제공한다.            데이터 값들을 시험해서 이 시험 결과에 따라 데이터흐름이나 제어흐름을 변경한다.           기계어 인스트럭션들의 실행 순서는 점프jump 인스트럭션으로 변경할 수 있다.   점프 인스트럭션은 때에 따라서는 어떤 시험의 결과에 따라 프로그램의 다른 일부분으로 제어를 넘겨준다.   3.6.1 조건 코드     정수 레지스터들과 함께 CPU는 가장 최근 산술 또는 논리연산의 특성을 설명하는 단일 비트 조건 코드로 구성된 레지스터들을 운영한다.   이 레지스터들은 조건부 분기를 수행하기 위해서 시험될 수 있다.            CF: 캐리 플래그Carry flag. 가장 중요한 비트로부터 받아 올림이 발생한 것을 표시. 비부호형 연산에서 오버플로우를 검출할 때 사용       ZF: 영 플래그Zero flag. 연산의 결과가 0인 것을 표시       SF: 부호 플래그Sign flag. 연산이 음수를 생성한 것을 표시       OF: 오버플로우 플래그Overflow flag. 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시           leaq 인스트럭션은 주소계산에 사용하기 위한 것이므로 조건 코드를 변경하지 않는다.           반면에, 위의 그림에 나열된 모든 인스트럭션들은 조건 코드 값을 변경한다.            XOR 같은 논리연산에서는 캐리와 오버플로우 플래그가 0으로 세팅된다.       쉬프트 연산에서는 캐리 플래그가 쉬프트되어 없어지는 마지막 비트로 설정되며, 오버플로우 플래그는 0으로 세팅된다.           위의 그림의 인스트럭션들에 의해 조건 코드 값이 변경될 뿐만 아니라, 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 두 개의 인스트럭션 클래스가 있다.(아래의 그림 참조)    CMP 인스트럭션들은 만일 두 오퍼랜드가 같으면 영 플래그르 1로 설정한다. 다른 플래그들은 두 오퍼랜드의 순서관계를 결정하는 데 사용될 수 있다.   TEST 인스트럭션은 목적지 오퍼랜드를 변경하지 않으면서 조건 코드를 설정하는 점만 제외하고는 AND 인스트럭션과 같은 방식으로 동작한다.   3.6.2 조건 코드 사용하기     조건 코드를 이용하는 보편적인 세 가지 방법이 있다.            조건 코드의 조합에 따라 0 또는 1을 한 개의 바이트에 기록       조건에 따라 프로그램의 다른 부분으로 이동하는 방법       조건에 따라 데이터를 전송하는 방법              SET 인스트럭션         첫 번째 경우의 인스트럭션의 클래스를 SET 인스트럭션이라고 부른다.   이 인스트럭션들은 접미어를 이용해서 오퍼랜드의 크기를 나타내는 것이 아니라, 조건 코드의 어떤 조합을 사용할 것인지를 나타낸다.            ex) setl, setb -&gt; long word와 byte를 의미하지 않고 less와 below를 의미한다.           SET 인스트럭션은 목적지로 하위 단일 바이트 레지스터 가운데 한 개나 단일 바이트 메모리 주소를 사용하며, 이 바이트를 0이나 1로 기록한다.            32비트나 64비트 결과를 만드려면, 다른 상위 비트들을 0으로 만들어줘야 한다.           a&lt;b를 계산하는 전형적인 인스트럭션은 아래의 그림과 같이 작성된다.    3.6.3 점프jump 인스트럭션     일반적인 실행의 경우, 인스트럭션들은 나열된 순서에 따라 순차적으로 실행된다.   점프 인스트럭션은 프로그램이 완전히 새로운 위치로 실행을 전환하도록 한다.   점프의 목적지는 일반적으로 어셈블리 코드에서는 레이블label로 표시한다.        인스트럭션 jmp .L1은 프로그램이 movq 인스트럭션을 건너뛰는 대신에 popq로 실행을 다시 시작하게 한다.   어셈블러는 모든 레이블이 붙은 인스트럭션들의 주소를 결정하고, 점프 인스트럭션의 일부분인 “점프 목적지jump target”을 인코딩한다.        위 그림은 여러 가지 점프 인스트럭션을 보여준다.   jmp 인스트럭션은 무조건적으로 점프한다.            점프 목적지가 인스트럭션의 일부로 인코딩 되는 경우에는 직접 점프       점프 대상을 레지스터나 메모리 위치로부터 읽어들여야 하는 경우에는 간접 점프           3.6.4 점프 인스트럭션 인코딩     점프 인스트럭션의 대상이 어떻게 인코딩 되는지 이해하는 것은 7장의 링커를 공부할 때 중요한 역할을 하게 된다.   어셈블리 코드에서, 점프 목적지는 심벌 레이블을 사용해서 작성한다.   점프를 인코딩하는 가장 일반적인 방법은 PC 상대적PC relative 방법이다.            대상 인스트럭션과 점프 인스트럭션 바로 다음에 오는 인스트럭션 주소와의 차이를 인코딩한다.                첫 번째 점프 인스트럭션의 목적지가 0x03으로 인코딩, 다음 인스트럭션의 주소인 0x05에 더하면 점프 목적지 주쇤 0x8을 얻을 수 있다.   PC-상대 주소지정을 수행할 때 프로그램 카운터의 값은 점프 인스트럭션 자신의 주소가 아니라, 점프 다음에 나오는 인스트럭션의 주소가 된다.   PC-상대 방식으로 점프 목적지를 인코딩하면, 인스트럭션들이 간결하게 인코딩(2바이트만 필요)될 수 있고, 목적코드는 수정 없이 메모리 상의 다른 위치로 이동될 수 있다.   3.6.5 조건부 분기를 조건제어로 구현하기     C에서 조건부 수식과 문장을 기계어 코드로 번역하는 가장 일반적인 방법은 조건부 및 무조건 점프를 함께 사용하는 것이다.   어셈블리 코드에서의 무조건 점프와 유사한 C의 goto문을 사용한다.            어셈블리 코드의 제어흐름을 설명하는 C 프로그램을 구성하는 방법으로 사용됨                     위의 그림은 조건문의 컴파일이다.            if-else             컴파일러는 else-문과 then-문에 대해 별도의 코드 블록을 생성한다.       정확한 블록이 실행되도록 조건부와 무조건 분기를 삽입한다.             3.6.6 조건부 이동으로 조건부 분기 구현하기     조건부 동작을 구현하는 전형적인 방법은 조건이 만족되면 프로그램의 한 가지 실행경로를 따르고, 아닌 경우에는 다른 경로를 따라가도록 하는 제어의 조건부 전환을 통해 이루어진다.            이 방법은 간단하고 일반적이지만 최신 프로세서들에서는 매우 비효율적일 수 있다.           또 다른 전략은 데이터의 조건부 전송을 이용하는 것이다.            이 방법은 조건부 동작의 산출물 모두를 계싼하고 조건에 따라 하나만 선택하는 방식이다.       최신 프로세서의 성능특성과 잘 일치하는 간단한 조건부 이동move 인스트럭션으로 구현될 수 있다.                C버전을 공부하면, 이것이 y-x와 x-y 모두를 계산해서 rval, eval로 명명한다는 것을 알 수 있다.            x가 y보다 크거나 같은지 테스트하고, 만일 그렇다면, eval을 Rval로 명명한다는 것을 알 수 있다.           조건부 제어 이동 기반 코드보다 조건부 데이터 이동 코드가 성능이 우수한 이유를 이해하기 위해서는 최신 프로세서들이 어떻게 동작하는지 이해해야 한다.            프로세서들은 각 인스트럭션을 일련의 단계로 처리하며, 이 단계들은 각각 요구된 동작의 작은 부분만을 실행하는 파이프라인을 통해 높은 성능을 얻는다.       이를 위해서는 파이프라인을 실행할 인스트럭션들로 미리 채우기 위해 실행할 인스트럭션들의 순서를 훨씬 일찍 결정할 수 있어야 한다.       결과적으로 분기의 예측오류 손실이 함수의 성능을 결정한다.                    위의 그림은 x86-64로 가능한 조건부 이동 move 인스트럭션을 보여준다.   이들 인스트럭션은 두 개의 오퍼랜드를 갖는다.            소스 레지스터 또는 메모리 위치 S, 그리고 목적지 레지스터 R.           인스트럭션들의 결과는 조건 코드 값에 따라 달라진다.   소스 값은 메모리나 소스 레지스터로부터 읽히지만, 목적지에는 명시된 조건이 만족될 때만 복사된다.      이 이후로 조건부 분기의 “분기의 예측 오류”에 관한 내용이 나온다.   조건부 이동은 조건부 점프와는 달리 결과를 예측하지 않고서도 해당 인스트럭션을 실행할 수 있다.  조건부 이동을 사용한다고 해서 언제나 코드 효율성을 개선할 수 있는 것은 아니다.  컴파일러는 낭비되는 계산량과 분기 예측오류에 의한 잠재적 성능 손실 사이의 상대적 성능을 고려해야 한다.   등의 내용이 담겨져 있는데 이해하기 조금 힘들다….   3.6.6은 뒷부분을 좀 더 읽고 다시 읽으러 돌아오자!!!!!!!    조건부 분기에 따른 실제 어셈블리 코드     조건부 분기를 구하는 방법은 3.6.2에서 세가지 방법이 있다고 했으며, 3.6.5절과 3.6.6절에 조건제어와 조건부이동 두가지로 더욱 자세한 설명으로 풀어냈다. 두 가지의 방법은 예제코드를 활용하여 설명해줬는데 다음의 예제코드와 같다. (C 언어로 작성 되어있다.)    long absdiff(long x, long y){   long result;   if(x&lt;y) result = y - x;   else reuslt = x - y;   return result; }     이 코드를 가지고 if문의 여러가지 어셈블리어로 표현할 수 있다고 표현하는데, 나는 같은 코드인데 기계는 어떻게 알고 다른 어셈블리어들을 생성해내는지가 너무 긍금했다.  다시말해 기계는 언제 조건부 이동을 하여 컴파일을하고, 언제 조건제어를 하여 컴파일을 하는지 너무 궁금했다!!!  궁금증을 참지 못하고 윈도우 환경에서 gcc 컴파일을 진행하였다.          tdm-gcc를 설치했다.     터미널에 gcc -v 명령어를 입력하면 설치 완료를 확인할 수 있다.     위 예제의 코드를 txt 파일로 작성했다.(파일 이름은 p1으로 하였다.)     gcc -S p1.c 명령어를 입력하면 어셈블리 코드를 생성할 수 있다.     gcc -S -Og p1.c 명령어를 입력하면 컴파일 최적화를 진행한다.     -Og, -O1, -O2 …으로 설정하면 단계별로 최적화를 적용한다.        다음의 그림은 default, -Og, -O1, -O2 의 결과다.  가독성을 위해서 main문과 디렉티브문은 삭제하였다.(*디렉티브: 어셈블러와 링커에 지시하기 위한 문장)       //최적화 없음 absdiff:    pushq   %rbp    .seh_pushreg   %rbp    movq   %rsp, %rbp    .seh_setframe   %rbp, 0    subq   $16, %rsp    .seh_stackalloc   16    .seh_endprologue    movl   %ecx, 16(%rbp)    movl   %edx, 24(%rbp)    movl   16(%rbp), %eax    cmpl   24(%rbp), %eax    jge   .L2    movl   24(%rbp), %eax    subl   16(%rbp), %eax    movl   %eax, -4(%rbp)    jmp   .L3 .L2:    movl   16(%rbp), %eax    subl   24(%rbp), %eax    movl   %eax, -4(%rbp) .L3:    movl   -4(%rbp), %eax    addq   $16, %rsp    popq   %rbp    ret  //Og로 최적화함 absdiff:    cmpl   %edx, %ecx    jge   .L2    movl   %edx, %eax    subl   %ecx, %eax .L1:    ret .L2:    movl   %ecx, %eax    subl   %edx, %eax    jmp   .L1   //O1으로 최적화함 absdiff:    movl   %edx, %r8d    subl   %ecx, %r8d    movl   %ecx, %eax    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret   //O2으로 최적화함 absdiff:    movl   %edx, %r8d    movl   %ecx, %eax    subl   %ecx, %r8d    subl   %edx, %eax    cmpl   %edx, %ecx    cmovl   %r8d, %eax    ret     Og가 본문의 조건제어, O1이 조건이동에서 설명한 어셈블리어로 표현되어있다.  유레카를 발견한 것처럼…. 너무 속이 시원했다….  컴파일 명령어에서 최적화의 수준에 따라 어셈블리어 인코딩이 달라진다는 것을 직접 확인할 수 있었다.    3.6.7 반복문     C에서는 여러가지 반복문 구문을 제공한다.            do-while, while, for       기계어에는 반복문에 대응되는 인스트럭션이 없다.       그렇기 때문에 조건부 테스트와 점프를 함께 사용해서 반복문의 효과를 구현한다.                 do-while            body-statement를 반복적으로 실행하고, test-expr를 계산하여 조건에 따라 반복 수행을 계속한다.       body-statement가 적어도 한 번은 실행되는 점이 특이사항이다.               do         body-statement         while (test-expr);        while            while문은 test-expr를 먼저 계산해서, body-statement를 실행하기 전에 종료될 수 있다.       do-while 루프에서 우리가 본 것과 루프 구조가 동일하고, 초기 테스트의 구현방법에서만 다르다.               while (test-expr)         body-statement                     while문은 두가지 번역 방법이 있다.                    중간으로-점프jump-to-middle            조건부 do 번역 사용guarded-do                            for       while (test-expr)         body-statement           init-expr;     while (test-expr){         body-statement         update-expr;     }                 두 반복문이 동일한 동작을 한다.       먼저 초기화 수식인 init-expr를 계산한다.       테스트 조건인 test-expr를 계산하는 곳에서 루프에 들어가며       테스트가 실패하면 루프를 빠져나오고, 반복문 body-statement를 실행한다.       마지막으로 update-expr를 계산한다.       for 루프에 대해 생성된 어셈블리 코드는 최적화 수준에 따라 while 루프의 번역 전략중 하나를 따른다.           3.6.8 Switch문     Switch문은 정수 인덱스 값에 따라 다중분기 기능을 제공한다.   C 코드를 읽기 쉽게 해줄 뿐만 아니라 점프 테이블이라는 자료구조를 사용해서 효율적인 구현을 간응하게 한다.   switch문을 실행하는 데 걸리는 시간이 case의 수에 관계없다는 점이 장점이다.   switch문을 실행하는 데 있어서 핵심 단계는 점프 테이블을 통해서 코드의 위치로 접근하는 것이다.      ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_07/",
        "teaser": null
      },{
        "title": "[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.7 프로시져)",
        "excerpt":"Chapter 03. 프로그램의 기계수준 표현     3.1 역사적 관점   3.2 프로그램의 인코딩   3.3 데이터의 형식   3.4 정보 접근하기   3.5 산술연산과 논리연산   3.6 제어문   3.7 프로시져  ","categories": ["CS:APP"],
        "tags": ["CS:APP","CS"],
        "url": "/cs:app/csapp_08/",
        "teaser": null
      },{
        "title": "[GitBlog] GitBlog 글 포스팅 후 커밋은 했지만, github.io에 적용이 안될 때",
        "excerpt":"사건의 개요    지금은 새벽 한시… csapp 공부가 조금 밀려서 공부를 하던 중에…   3.7절 프로시져에 대한 포스팅을 하려고 미리 csapp 포스트 탭을 만들고 커밋을 해두었다..  하지만, 아무리 새로고침을 해도 새로 포스팅한 글이 github.io에 업데이트가 안된다..    삽질    처음 깃블로그를 만들 때도 github.io에 업데이트가 되지 않는 끔찍함을 겪어서  몇번이고 레포를 새로 만들었던 끔찍한 기억이 떠올랐다.   지금까지 열심히 블로그에 글을 포스팅 했는데 이 글들을 다 날리는건가…?  무슨 캐시 충돌…? 뭐 서버 오류…? 어디선가 꼬였나…?  등등의 오만가지 생각이 들면서 지금까지 포스팅한 글을 지켜야겠다는 생각에 하던 공부를 올스탑했다..    새로운 레포도 파보고,, 글을 하나씩도 올려보고,, config파일을 수정도 해보고,, 캐시도 삭제해보고,,  커밋도 돌려보고,,, 별에 별짓을 다해보았다,,,   사건 해결    한가지의 특징을 알게 되었다.   포스팅 날짜가 오늘 1월 31일로 되어있는 글만 업데이트가 되지 않는 것이었다.  오늘은 1월 31일 오전 1시였다.  드디어 알게되었다….  현재 날짜는 1월 31일이지만, 아직 새벽이기 때문에? (git 서버 시간의 기준이 다른 나라인가…?)   1월 31일로 작성된 글은 아직 github.io에 업데이트 되지 않는 것이구나!   결론  깃블로그를 처음 만들 때 글이 업데이트 되지 않는 오류 때문에 굉장히 힘들었었다.  하지만, 해당 오류는 서버와의 시간과 포스팅 시간이 맞지 않기 때문이었다!   다음부터 시간이 애매(새벽)하면 어제 날짜로 포스팅 하자!  이제부터 맘편히 깃블로그 포스팅을 하자!!!!      시간 날린게 너무 아깝다ㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜㅜ  다시는 이런 바보같은 짓은 하지 말자…!   ","categories": ["Docker"],
        "tags": ["Docker"],
        "url": "/docker/doodle_04/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part8 인터페이스와 다른 형식의 클래스",
        "excerpt":"Part8 인터페이스와 다른 형식의 클래스   인터페이스 만들기  인터페이스: 서로 관계까 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템     인터페이스 정의하는 방법            추상 메소드와 상수를 정의 할 수 있다.               public interface TV{         public int MAX_VOLUME = 100;         public int MIN_VOLUME = 0;          public void turnOn();         public void turnOff();         public void changeVolume(int volume);         public void changeChannel(int channel);     }     인터페이스에서 변수를 선언하면 컴파일시 자동으로 아래와 같이 바뀐다.       public static final int MAX_VOLUME = 100;     public static final int MIN_VOLUME = 0;     인터페이스에서 정의된 메소드는 모두 추상 메소드이다. 위에서 선언된 모든 메소드는 컴파일 시에 다음과 같이 자동으로 변경된다.       public abstract void on();     public abstract void off();     public abstract void volume(int value);     public abstract void channel(int number);  인터페이스 사용하기     인터페이스 사용하는 방법            인터페이스는 사용할 때 해당 인터페이스를 구현하는 클래스에서 implements 키워드를 이용한다.               public class LedTV implements TV{         public void on(){             System.out.println(\"켜다\");         }         public void off(){             System.out.println(\"끄다\");            }         public void volume(int value){             System.out.println(value + \"로 볼륨조정하다.\");           }         public void channel(int number){             System.out.println(number + \"로 채널조정하다.\");                  }     }     인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않는다면 해당 클래스는 추상클래스가 된다.(추상클래스는 인스턴스를 만들 수 없음)       public class LedTVExam{         public static void main(String args[]){             TV tv = new LedTV();             tv.on();             tv.volume(50);             tv.channel(6);             tv.off();         }     }     참조변수의 타입으로 인터페이스를 사용할 수 있다. 이 경우 인터페이스가 가지고 있는 메소드만 사용할 수 있다.   만약 TV인터페이스를 구현하는 LcdTV를 만들었따면 위의 코드에서 new LedTV부분만 new LcdTV로 변경해도 똑같이 프로그램이 동작할 것이다. 동일한 인터페이스를 구현 한다는 것은 클래스 사용법이 같다는 것을 의미한다.   클래스는 이러한 인터페이스를 여러개 구현할 수 있다.   인터페이스의 default method  JAVA 8이 등장하면서 interface에 대한 정의가 몇 가지 변경되었다.      default 메소드     인터페이스가 default키워드로 선언되면 메소드가 구현될 수 있다. 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.             return i + j;         }     }      //Calculator인터페이스를 구현한 MyCalculator클래스     public class MyCalculator implements Calculator {          @Override         public int plus(int i, int j) {             return i + j;         }          @Override         public int multiple(int i, int j) {             return i * j;         }     }      public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);         }     }     인터페이스가 변경이 되면, 인터페이스를 구현하는 모든 클래스들이 해당 메소드를 구현해야 하는 문제가 있다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현해 놓을 수 있도록 하였다.      static 메소드     인터페이스에 static 메소드를 선언함으로써, 인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.       public interface Calculator {         public int plus(int i, int j);         public int multiple(int i, int j);         default int exec(int i, int j){             return i + j;         }         public static int exec2(int i, int j){   //static 메소드              return i * j;         }     }      //인터페이스에서 정의한 static메소드는 반드시 인터페이스명.메소드 형식으로 호출해야한다.        public class MyCalculatorExam {         public static void main(String[] args){             Calculator cal = new MyCalculator();             int value = cal.exec(5, 10);             System.out.println(value);              int value2 = Calculator.exec2(5, 10);  //static메소드 호출              System.out.println(value2);         }     }  내부클래스  내부 클래스란 클래스 안에 선언된 클래스    어느 위치에 선언하느냐에 따라서 4가지 형태가 있을 수 있다.     첫번째는 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언되는 경우. 보통 중첩클래스 혹은 인스턴스 클래스라고 한다.            내부에 있는 Cal객체를 생성하기 위해서는, 밖에는 InnerExam1의 객체를 만든 후에 InnerExam1.Cal cal -= t.new Cal();과 같은 방법으로 Cal 객체를 생성한 후 사용한다.               public class InnerExam1{         class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam1 t = new InnerExam1();             InnerExam1.Cal cal = t.new Cal();             cal.plus();             System.out.println(cal.value);          }     }     두번째는 내부 클래스가 static으로 정의된 경우, 정적 중첩 클래스 또는 static 클래스라고 한다.            필드 선언할 때 스태틱한 필드로 선언한 것과 같다. 이 경우에는 InnerExam2 객체를 생성할 필요없이 new InnerExam2.Cal()로 객체를 생성할 수 있다.               public class InnerExam2{         static class Cal{             int value = 0;             public void plus(){                 value++;             }         }          public static void main(String args[]){             InnerExam2.Cal cal = new InnerExam2.Cal();             cal.plus();             System.out.println(cal.value);          }     }     세번째로는 메소드 안에 클래스를 선언한 경우, 지역 중첩 클래스 또는 지역 클래스라고 한다.            메소드 안에서 해당 클래스를 이용할 수 있다.               public class InnerExam3{         public void exec(){             class Cal{                 int value = 0;                 public void plus(){                     value++;                 }             }             Cal cal = new Cal();             cal.plus();             System.out.println(cal.value);         }                public static void main(String args[]){             InnerExam3 t = new InnerExam3();             t.exec();         }     }     네번째로는 익명클래스가 있다.            아래의 절로 이동하여 설명하겠다!           익명클래스  익명 중첩 클래스는 익명 클래스라고 보통 말하며, 내부 클래스이기도 하다.       //추상클래스 Action      public abstract class Action{         public abstract void exec();     }      //추상클래스 Action을 상속받은 클래스 MyAction     public class MyAction extends Action{         public void exec(){             System.out.println(\"exec\");         }     }      //MyAction을 사용하는 클래스 ActionExam      public class ActionExam{         public static void main(String args[]){             Action action = new MyAction();             action.exec();         }     }      //MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.     public class ActionExam{         public static void main(String args[]){             Action action = new Action(){                 public void exec(){                     System.out.println(\"exec\");                 }             };             action.exec();         }     }     생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻한다.   괄호 안에는 메소드를 구현하거나 메소드를 추가할 수 있다. 이렇게 생성된 이름 없는 객체를 action이라는 참조변수가 참조하도록 하고, exec() 메소드를 호출한다.   익명클래스를 만드는 이유는 Action을 상속받는 클래스를 만들 필요가 없을 경우이다.   Action을 상속받는 클래스가 해당 클래스에서만 사용되고 다른 클래스에서는 사용되지 않는 경우이다.   ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_08/",
        "teaser": null
      },{
        "title": "[Java/프로그래머스] Part9 예외처리",
        "excerpt":"Part9 예외처리   Exception  프로그램 실행중 예기치 못한 사건을 예외라고 한다. 예외 상황을 미리 예측하고 처리할 수 있는데, 이렇게 하는 것을 예외 처리라고 한다.       public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 5;             int k = i / j;             System.out.println(k);             System.out.println(main 종료!!);         }     }     위 코드에서 j를 0으로 바꾸면 Exception 발생            j를 0으로 바꾸면 Arithmetic Exception이 발생하면서 프로그램이 종료된다.       Java는 정수를 정수로 나눌 때 0으로 나누면 오류가 발생한다.           예외 처리            프로그래머는 j라는 변수에 0이 들어올지도 모르는 예외 상황을 미리 예측하고 처리할 수 있다.           예외 처리하는 문법            오류가 발생할 예상 부분을 try라는 블록으로 감싼 후, 발생할 오류와 관련된 Exception을 catch라는 블록에서 처리한다.       오류가 발생했든 안했든 무조건 실행되는 finally라는 블록을 가질 수 있다.       finally 블록은 생략가능하다.               public class ExceptionExam {         public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = i / j;                 System.out.println(k);             }catch(ArithmeticException e){                 System.out.println(\"0으로 나눌 수 없습니다. : \" + e.toString());             }finally {                 System.out.println(\"오류가 발생하든 안하든 무조건 실행되는 블록입니다.\");             }         }     }     실행결과            0으로 나눌 수 없습니다. :java.lang.ArithmeticException:/by zero  오류가 발생하든 안하든 무조건 실행되는 블록입니다.           Exception 처리하지 않았을 때는 프로그램이 강제 종료되었는데 catch라는 블록으로 Exception을 처리하니 강제종료되지 않고 잘 실행되는 것을 알 수 있다.   try 블록에서 여러종류의 Exception이 발생한다면 catch라는 블록을 여러개 둘 수 있다.   Exception 클래스들은 모두 Exception 클래스를 상속받으므로, 예외 클래스에 Exception을 두게 되면 어떤 오류가 발생하든지 간에 하나의 catch 블록에서 모든 오류를 처리 할 수 있다.   Throws  throws는 예외가 발생했을 때 예외를 호출한 쪽에서 처리하도록 던져준다.       public class ExceptionExam2 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j){             int k = i / j;             return k;         }     }  정수를 매개변수로 2개를 받아들인 후 나눗셈을 한 후 그 결과를 반환하는 divide 메소드  main 메소드에서는 divide 메소드를 호출   다음과 같이 divide 메소드를 수정       public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);         }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }     }  메소드 선언 뒤에 throws ArithmeticException이 적혀있는 것을 알 수 있다. 이렇게 적어놓으면 divide 메소드는 ArithmeticException이 발생하니 divide 메소드를 호출하는 쪽에서 오류를 처리하라는 뜻이다.       package javaStudy;     public class ExceptionExam2 {          public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             } catch(ArithmeticException e){                 System.out.println(\"0으로 나눌수 없습니다.\");             }          }          public static int divide(int i, int j) throws ArithmeticException{             int k = i / j;             return k;         }      }  Exception 발생시키기  강제로 오류를 발생시키는 throw   throw는 오류를 떠넘기는 trhows와 보통 같이 사용된다.       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j){             int k = i / j;             return k;         }        }     divide 메소드는 2번째 파라미터의 값이 0일 경우 나누기를 할 때 Exception이 발생한다.      위의 코드를 에러가 발생하지 않게 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);               }          public static int divide(int i, int j){             if(j == 0){                 System.out.println(\"2번째 매개변수는 0이면 안됩니다.\");                 return 0;             }             int k = i / j;             return k;         }     }     j가 0일 경우 안된다는 메시지가 출력되도록 수정하고 0을 리턴   이렇게 할 경우 main 메소드의 k변수는 0값을 가지게 되고 0을 출력하게 된다.   0으로 나눈 결과는 0이 아니다. 0으로 반환하면 더 큰 문제가 발생할 수도 있다.      에러도 발생하지 않고, 올바르지 않은 결과를 리턴하지 않도록 수정       public class ExceptionExam3 {         public static void main(String[] args) {             int i = 10;             int j = 0;             int k = divide(i, j);             System.out.println(k);          }                public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     j가 0일 경우에 new연산자를 통하여 IllegalArgumentException 객체가 만들어 진다.   new 앞에 throw는 해당 라인에서 Exception이 발생한다는 의미이다.   즉 그 줄에서 오류가 발생했다는 것이다. 0으로 나눌 수 없습니다. 라는 오류가 발생한 것이다.   Exception 클래스 이름을 보면 argument가 잘못되었기 때문에 발생한 오류라는 것을 알 수 있다.      divide 메소드를 호출한 쪽에서의 오류 처리       public class ExceptionExam3 {            public static void main(String[] args) {             int i = 10;             int j = 0;             try{                 int k = divide(i, j);                 System.out.println(k);             }catch(IllegalArgumentException e){                 System.out.println(\"0으로 나누면 안됩니다.\");             }                    }          public static int divide(int i, int j) throws IllegalArgumentException{             if(j == 0){                 throw new IllegalArgumentException(\"0으로 나눌 수 없어요.\");             }             int k = i / j;             return k;         }        }     divide 메소드 뒤에 throws IllegalArgumentException은 해당 오류는 divide를 호출한 쪽에서 처리를 해야한다는 것을 의미한다.   사용자 정의 Exception     Exception 클래스를 상속 받아 정의한 checked Exception            반드시 오류를 처리 해야만 하는 Exception       예외 처리하지 않으면 컴파일 오류를 발생 시킨다.           RuntimeException 클래스를 상속 받아 정의한 unChecked Exception            예외 처리하지 않아도 컴파일 시에는 오류를 발생시키지 않는다.              RuntimeException을 상속받은 BizException 객체       public class BizException extends RuntimeException {         public BizException(String msg){             super(msg);         }                public BizException(Exception ex){             super(ex);         }     }     BizSerice 클래스는 업무를 처리하는 메소드를 가지고 있다고 가정한다.       public class BizService {         public void bizMethod(int i)throws BizException{             System.out.println(\"비지니스 로직이 시작합니다.\");             if(i &lt; 0){                 throw new BizException(\"매개변수 i는 0이상이어야 합니다.\");             }             System.out.println(\"비지니스 로직이 종료됩니다.\");         }     }     앞에서 만든 BizService를 이용하는 BizExam 클래스     매개변수 값을 -1을 넘길 때는 Exception이 발생하기 때문에 try catch 블록으로 처리한다.       public class BizExam {           public static void main(String[] args) {             BizService biz = new BizService();             biz.bizMethod(5);             try{                 biz.bizMethod(-3);             }catch(Exception ex){                 ex.printStackTrace();             }         }     }      프로그래머스 자바 입문을 마무리하며  강의 자체는 굉장히 깔끔했다. 개념 설명 이후 실습을 진행하고, 해당 개념에 대한 의문점도 강의에서는 미리 지적하여 설명해준다. 입문 강의를 들으니 대학 2학년 때 들었던 java 강의가 생각났다. 그 때 이정도 수준의 이해도를 얻었다면 어땠을까… 라는 생각이 스쳐 지나갔다. 이제 입문 강의를 들은 것 뿐이지만, java의 j정도 알게 되었다. 인터페이스나 내부클래스 같은 개념은 실제로 사용해봐야지 더 확실하게 개념이 와닿을 것 같다.   강의를 모두 수강하고도 개념이 조금 헷갈리는 것들을 적어두고 한번 더 복습을 해야할 것 같다.     인스턴스를 만들 때 Parents c = new Child(); &lt;- Parents와 Child가 정확히 어떤 역할을 하는지   인터페이스와 추상클래스의 차이점   내부 클래스들 각각의 쓰임   사용자 정의 Exception   java의 얕은 복사와 깊은 복사   super()   클래스 형변환     해당 강의와 강의 노트는 프로그래머스 자바 입문에서 언제든지 다시 들을 수 있다!  ","categories": ["Java"],
        "tags": ["Java","프로그래머스 자바 입문"],
        "url": "/java/java_09/",
        "teaser": null
      }]
