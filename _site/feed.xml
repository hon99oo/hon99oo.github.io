<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-25T12:26:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">[CS:APP] Chapter 06 메모리 계층구조(캐시)</title><link href="http://localhost:4000/cs:app/csapp_21/" rel="alternate" type="text/html" title="[CS:APP] Chapter 06 메모리 계층구조(캐시)" /><published>2022-03-24T00:00:00+09:00</published><updated>2022-03-24T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_21</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_21/">&lt;h1 id=&quot;chapter-06-메모리-계층구조&quot;&gt;Chapter 06 메모리 계층구조&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;저장장치 기술&lt;/li&gt;
  &lt;li&gt;지역성&lt;/li&gt;
  &lt;li&gt;메모리 계층구조&lt;/li&gt;
  &lt;li&gt;캐시메모리&lt;/li&gt;
  &lt;li&gt;캐시 친화적 코드 작성하기&lt;/li&gt;
  &lt;li&gt;프로그램 성능에 대한 캐시의 영향&lt;/li&gt;
  &lt;li&gt;요약&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;64-캐시-메모리&quot;&gt;6.4 캐시 메모리&lt;/h1&gt;

&lt;h1 id=&quot;65-캐시-친화적-코드-작성하기&quot;&gt;6.5 캐시 친화적 코드 작성하기&lt;/h1&gt;

&lt;h1 id=&quot;66-프로그램-성능에-대한-캐시의-영향&quot;&gt;6.6 프로그램 성능에 대한 캐시의 영향&lt;/h1&gt;

&lt;h1 id=&quot;67-요약&quot;&gt;6.7 요약&lt;/h1&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 21</summary></entry><entry><title type="html">[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)</title><link href="http://localhost:4000/cs:app/csapp_20/" rel="alternate" type="text/html" title="[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)" /><published>2022-03-21T00:00:00+09:00</published><updated>2022-03-21T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_20</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_20/">&lt;h1 id=&quot;chapter-06-메모리-계층구조&quot;&gt;Chapter 06. 메모리 계층구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 시스템은 용량, 비용, 접근시간을 갖는 저장장치들의 계층구조다.
    &lt;ul&gt;
      &lt;li&gt;캐시메모리는 CPU 부근에서 비교적 느린 메인메모리에 대한 준비장소&lt;/li&gt;
      &lt;li&gt;메인메모리는 크고 느린 디스크들에 대한 준비장소&lt;/li&gt;
      &lt;li&gt;디스크들은 네트워크로 연결된 다른 머신들의 준비장소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리의 계층별로 접근 속도가 상이하다.
    &lt;ul&gt;
      &lt;li&gt;레지스터가 가장 빠르고, 그 다음은 메인메모리, 그 다음은 디스크이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터를 계층의 상부에 저장시켜서 CPU가 보다 빨리 접근할 수 있도록 프로그램을 작성해야한다.
    &lt;ul&gt;
      &lt;li&gt;이 개념은 지역성locality라고 알려진 컴퓨터 프로그램의 근본특징에 근거를 두고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;61-저장장치-기술&quot;&gt;6.1 저장장치 기술&lt;/h1&gt;

&lt;h2 id=&quot;611-랜덤-접근-메모리&quot;&gt;6.1.1 랜덤-접근 메모리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;랜덤-접근 메모리(RAM)은 두 종류를 가진다.
    &lt;ul&gt;
      &lt;li&gt;정적 SRAM : 동적램 DRAM 보다 더 빠르고 훨 씬 비싸다. 캐시메모리로 사용된다.&lt;/li&gt;
      &lt;li&gt;동적 DRAM : 메인메모리와 그래픽 시스템의 프레임 버퍼로도 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정적-sram&quot;&gt;정적 SRAM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SRAM은 각 비트를 이중안정bistable 메모리 셀cell에 저장한다.&lt;/li&gt;
  &lt;li&gt;SRAM은 전원이 공급되는 한 지속성을 갖는다.&lt;/li&gt;
  &lt;li&gt;리프레시가 필요없다.&lt;/li&gt;
  &lt;li&gt;DRAM보다 트랜지스터를 더 많이 사용하여 밀도가 낮으며 비싸고 전력을 많이 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동적-dram&quot;&gt;동적 DRAM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM은 각 비트를 전하로 캐패시터에 저장한다.&lt;/li&gt;
  &lt;li&gt;리프레시가 필요하다.
    &lt;ul&gt;
      &lt;li&gt;메모리 시스템은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-dram&quot;&gt;일반 DRAM&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_3.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 DRAM 칩의 구조이다.&lt;/li&gt;
  &lt;li&gt;DRAM 칩 내의 셀들은 d 슈퍼셀들로 나누어지며, 각각은 w DRAM 셀들로 이루어진다.&lt;/li&gt;
  &lt;li&gt;슈퍼셀 (i,j)의 내용을 읽으려면 메모리 컨트롤러는 행 주소 i를 DRAM에 보내고, 다음에 열 주소 j를 보낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_1.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 DRAM 슈퍼셀의 내용을 읽는 과정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-모듈&quot;&gt;메모리 모듈&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM 칩은 메인 시스템(머더보드)의 확상슬롯에 꽂을 수 있는 메모리 모듈 형태로 패키징 된다.&lt;/li&gt;
  &lt;li&gt;DRAM을 여러개 추가하여 바이트를 순서대로 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비휘발성-메모리&quot;&gt;비휘발성 메모리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM과 SRAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.&lt;/li&gt;
  &lt;li&gt;비휘발성 메모리는 이들의 전원 꺼져도 정보를 유지한다.&lt;/li&gt;
  &lt;li&gt;Read-only memory : ROM 이라고 부른다.&lt;/li&gt;
  &lt;li&gt;ROM 디바이스에 저장된 프로그램들은 종종 펌웨어firmware라고 부른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리에-접근하기&quot;&gt;메모리에 접근하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터는 ‘버스’라고 하는 공유된 전기회로를 통해서 프로세서와 DRAM메인메모리간에 앞뒤로 교환한다.&lt;/li&gt;
  &lt;li&gt;CPU와 메모리 간의 매 전송은 버스 트랜잭션bus transaction이라고 부르는 일련의 단계들을 통해 이뤄진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_2.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 CPU와 메인메모리를 연결하는 버스 구조다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;읽기 트랜잭션(movq A,%rax)
    &lt;ol&gt;
      &lt;li&gt;CPU는 주소 A를 시스템 버스에 보낸다. I/O브릿지는 신호를 메모리 버스를 따라 보낸다.&lt;/li&gt;
      &lt;li&gt;메인메모리는 메모리 버스에서 주소 신호를 감지하고, 메모리 버스로부터 주소를 읽고 DRAM에서 데이터 워드를 선입, 데이터를 메모리 버스에 쓴다.&lt;/li&gt;
      &lt;li&gt;I/O 브릿지는 신호를 시스템 버스 신호로 변환해서 시스템 버스를 따라 보낸다. CPU는 시스템 버스에서 데이터를 감지하고 %rax에 복사한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;쓰기 트랜잭션(movq %rax,A)
    &lt;ol&gt;
      &lt;li&gt;CPU는 주소를 시스템 버스에 보낸다. 메모리는 메모리 버스에서 주소를 읽고 데이터가 도착하기를 기다린다.&lt;/li&gt;
      &lt;li&gt;CPU는 %rax에 있는 데이터를 시스템 버스에 복사한다.&lt;/li&gt;
      &lt;li&gt;메인메모리는 데이터를 메모리 버스에서 읽고 비트들을 저장한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;612-디스크-저장장치&quot;&gt;6.1.2 디스크 저장장치&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;디스크는 RAM 메모리의 수천 메가바이트 단위에 비해 수백에서 수천 기가비이트 단위의 엄청난 양의 데이터를 저장하는 대표적인 저장장치다.&lt;/li&gt;
  &lt;li&gt;디스크 용량
    &lt;ul&gt;
      &lt;li&gt;기록밀도: 1인치의 트랙에 집어넣을 수 있는 비트의 수&lt;/li&gt;
      &lt;li&gt;트랙밀도: 원판 중심에서 반지름의 1인치 길이에 넣을 수 있는 트랙의 수&lt;/li&gt;
      &lt;li&gt;면적밀도: 기록밀도와 트랙밀도의 곱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크의 동작
    &lt;ul&gt;
      &lt;li&gt;탐색시간: 섹터의 내용을 읽기위해 헤드를 타깃 섹터를 보유한 트랙 위로 위치시키는 시간&lt;/li&gt;
      &lt;li&gt;회전 지연시간: 헤드가 트랙 위에 위치하면 타깃 섹터의 첫번째 비트가 헤드 아래로 지나가는 것을 기다리는 시간.(헤드의 위치와 디스크의 회전 속도 모두 관련됨)&lt;/li&gt;
      &lt;li&gt;전송시간: 하나의 섹터를 전송하는 시간(회전속도와 트랙당 섹터 수에 관련됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크 접근하기(디스크 섹터 읽기)
    &lt;ol&gt;
      &lt;li&gt;CPU는 명령어, 논리블록 번호, 목적지 메모리 주소를 디스크와 관련된 메모리 매핑한 주소에 써주어서 디스크 읽기를 개시한다.&lt;/li&gt;
      &lt;li&gt;디스크 컨트롤러는 이 섹터를 읽고 메인메모리로 DMA 전송을 수행한다.&lt;/li&gt;
      &lt;li&gt;DMA 전송이 완료될 때, 디스크 컨트롤러는 CPU에 인터럽트로 알려준다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;62-지역성&quot;&gt;6.2 지역성&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;잘 작성한 컴퓨터 프로그램은 좋은 지역성locality를 보여준다.
    &lt;ul&gt;
      &lt;li&gt;최근에 참조했던 데이터 아이템 근처의 데이터 아이템이나 최근에 자신을 참조했던 데이터 아이템을 참조하려는 경향이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지역성은 두가지 형태가 있다.
    &lt;ul&gt;
      &lt;li&gt;시간 지역성 : 한번 참조된 메모리 위치는 여러 번 참조될 가능성이 높다.&lt;/li&gt;
      &lt;li&gt;공간 지역성 : 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 메모리 : 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장
    &lt;ul&gt;
      &lt;li&gt;캐시 메모리라는 작고 빠른 메모리를 도입하여 메인메모리를 빠르게 돌릴 수 있게 됐다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;621-프로그램-데이터-참조의-지역성&quot;&gt;6.2.1 프로그램 데이터 참조의 지역성&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드는 좋은 지역성을 갖는다.
    &lt;ul&gt;
      &lt;li&gt;행 우선 순서로 접근되기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드는 나쁜 지역성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드도 썩 좋은 지역성을 갖고 있지는 않다.
    &lt;ul&gt;
      &lt;li&gt;보폭이 존재하기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;622-지역성-요약&quot;&gt;6.2.2 지역성 요약&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;동일한 변수들을 반복적으로 참조하는 프로그램은 좋은 시간 지역성&lt;/li&gt;
  &lt;li&gt;Stride-k참조 패턴에서 stride가 적으면 적을수록 공간 지역성도 좋아진다.&lt;/li&gt;
  &lt;li&gt;루프는 인스트럭션 선입에 대해 좋은 시간 및 공간 지역성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;63-메모리-계층구조&quot;&gt;6.3 메모리 계층구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;아래 두가지를 보완하기 위해 ‘메모리 계층구조’라고 알려진 메모리 시스템 조직을 위한 접근 방법을 사용한다.
    &lt;ul&gt;
      &lt;li&gt;저장장치 기술 : 다양한 저장장치 기술들은 매우 광범위한 접근시간을 갖는다.&lt;/li&gt;
      &lt;li&gt;컴퓨터 소프트웨어 : 잘 작성한 프로그램들은 좋은 지역성을 나타내는 경향이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 메모리 계층구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;631-메모리-계층구조에서의-캐시&quot;&gt;6.3.1 메모리 계층구조에서의 캐시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐시는 보다 크고 느린 디바이스에 저장된 데이터 객체를 위한 준비 영역으로 사용하는 작고 빠른 저장장치다.&lt;/li&gt;
  &lt;li&gt;메모리 계층구조의 중심 개념은, 레벨 k에 있는 보다 빠르고 더 작은 장치가 레벨 k+1을 위한 캐시 서비스를 제공한다는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_5.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 메모리 계층구조에서 캐싱의 기본 원리이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-적중&quot;&gt;캐시 적중&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;레벨 k+1로부터 특정 데이터 객체 d를 필요로 한다.&lt;/li&gt;
  &lt;li&gt;현재 레벨 k에 저장된 블록들 중의 하나에서 d를 찾는다.&lt;/li&gt;
  &lt;li&gt;만일 d가 레벨 k에서 우연히 캐시되어 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스&quot;&gt;캐시 미스&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;만일 d가 레벨 k에서 캐시되지 않는다면 ‘캐시 미스’가 발생한 것이다.&lt;/li&gt;
  &lt;li&gt;k+1에 있는 캐시로부터 d를 포함하는 블록을 가져온다.&lt;/li&gt;
  &lt;li&gt;만일 레벨 k 캐시가 이미 꽉 찬 상태full라면 기존 블록에 덮어쓴다.
    &lt;ul&gt;
      &lt;li&gt;축출 : 기존 블록을 덮어쓰는 과정&lt;/li&gt;
      &lt;li&gt;희생블록 : 축출되는 블록&lt;/li&gt;
      &lt;li&gt;교체정책 : 어떤 블록을 교체할지에 관한 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스-종류&quot;&gt;캐시 미스 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cold cache : 캐시가 비어있을 때&lt;/li&gt;
  &lt;li&gt;충돌미스conflict miss : 캐시의 배치 정책으로 인한 캐시 미스&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-관리&quot;&gt;캐시 관리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 계층 구조의 핵심은 각 레벨에 있는 저장장치가 다음 낮은 레벨을 위한 캐시&lt;/li&gt;
  &lt;li&gt;레벨 L1,L2,L3의 캐시들은 캐시에 구현된 하드웨어 로직으로 전적으로 관리된다.&lt;/li&gt;
  &lt;li&gt;가상모메리를 사용하는 시스템에서 DRAM메인메모리는디스크에 저장된 데이터 블록에 대한 캐시 서비스를 제공한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 20</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)</title><link href="http://localhost:4000/cs:app/csapp_18/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_18</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_18/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
  &lt;li&gt;4.4 파이프라이닝의 일반 원리&lt;/li&gt;
  &lt;li&gt;4.5 파이프라인형 Y86-64의 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;45-파이프라인형-y86-64의-구현&quot;&gt;4.5 파이프라인형 Y86-64의 구현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;순차적 프로세서 SEQ를 약간 변형해서 PC의 계산을 선입 단계로 이동하는 것으로 프로세서를 변경한다.&lt;/li&gt;
  &lt;li&gt;이후 파이프라인 레지스터들을 단계별로 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국은 이 파이프라인형 Y86-64 “PIPE”를 만들기 위해 2장부터 4장까지 달려온 것이다.&lt;br /&gt;
우선 컴퓨터가 해석할 수 있는 정수와 부동소수점 표현과 기본 산술에 대해서 2장에서 배웠고,&lt;br /&gt;
3장에서는 프로그래머가 작성한 코드를 컴퓨터가가 해석할 수 있는 기계어로 변경하는 것을 배웠고,&lt;br /&gt;
4장 초반에서는 해당 기계어를 컴퓨터가 해석할 수 있도록 인스트럭션 집합으로 변경하는 것을 배웠고,&lt;br /&gt;
4장 후반 SEQ 구현에서는 해당 인스트럭션을 컴퓨터가 어떻게 해석하는지를 배웠고,&lt;br /&gt;
4장 후반 파이프라인 구현에서는 인스트럭션을 해석하는데에 있어 속도를 증가시키기 위해서 SEQ에 파이프라인을 구축하고,
파이프라인 구축할 때의 예외처리를 다룬 뒤 프로세서를 완성시킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;451-seq-계산-단계들을-재배치하기&quot;&gt;4.5.1 SEQ+: 계산 단계들을 재배치하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;PC 갱신 단계가 클럭 사이클의 마지막이 아니라 맨 처음에 오도록 한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 단계에서의 순차적인 동작을 더 잘 수행할 수 있다.&lt;/li&gt;
      &lt;li&gt;수정된 설계를 “SEQ+”라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PC 계산 타이밍의 변경이다.
    &lt;ul&gt;
      &lt;li&gt;SEQ+에서 인스트럭션 실행의 첫 단계로 현재 상태에 대한 프로그램 카운터 값을 계산한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;452-파이프라인-레지스터의-삽입&quot;&gt;4.5.2 파이프라인 레지스터의 삽입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ+의 단계들간에 파이프라인 레지스터들을 삽입하였으며 신호들을 재배치해서 PIPE- 프로세서를 만들었다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터들은 다음과 같이 명명하였다
    &lt;ul&gt;
      &lt;li&gt;F : 프로그램 카운터의 예측 값을 저장한다.&lt;/li&gt;
      &lt;li&gt;D : 선입과 해동 단계 사이에 위치한다. 해독 단계가 처리하기 위해서 가장 최근에 선입한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;E : 해독과 실행 단계 사이에 위치한다. 실행 단계가 처리하기 위해서 레지스터 파일로부터 읽어들인 값과 가장 최근에 해독한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;M : 실행과 메모리 단계 사이에 위치한다. 메모리 단계가 처리하기 위한 가장 최근에 실행 인스트럭션 결과와 조건부에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;W : 레지스터 파일에 기록을 위한 결과, 리턴주소, PC 선택 로직을 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_1.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 SEQ+ 하드웨어 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_2.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE- 의 하드웨어 구조, 초기 파이프라인 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 코드 배열이 어떻게 5단계 파이프라인을 통해 흘러가는지를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;453-신호의-재배치와-재명명&quot;&gt;4.5.3 신호의 재배치와 재명명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ에서는 한 번에 한 개의 인스트럭션만을 처리했지만, 파이프라인 설계에서는 인스트럭션에 연계된 여러 버전의 값이 존재한다.&lt;/li&gt;
  &lt;li&gt;PIPE-의 상세 설계에서 네 개의 서로 다른 인스트럭션을 위한 상태코드를 저장하는 “Stat”이 있다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터의 이름은 대문자를 사용한다. D_stat, E_stat, M_stat, W_stat&lt;/li&gt;
  &lt;li&gt;계산된 일부 신호의 이름은 소문자를 사용한다 f_stat, m_stat&lt;/li&gt;
  &lt;li&gt;전체 프로세서의 실제 상태 Stat이 파이프라인 레지스터 W에 기록된 상태값에 따라 재기록 단계에서 계산된다.&lt;/li&gt;
  &lt;li&gt;일반적인 원칙으로 특정 인스트럭션에 관한 모든 정보를 한 개의 파이프라인 단계 내에 유지하는 것을 원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;454-다음-pc-값의-추정&quot;&gt;4.5.4 다음 PC 값의 추정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이며, 새 인스트럭션이 실행 단계로 진행해서 궁극적으로는 완료되는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;리턴이나 조건부 점프 인스트럭션은 선입 단계에 계산된 정보를 사용해서 다음 인스트럭션의 주소를 결정할 수 없다.&lt;/li&gt;
  &lt;li&gt;따라서 매 클럭 사이클마다 하나의 새 인스트럭션을 실행하려는 우리의 목표를 달성하기 위해서 대부분의 경우에 PC의 새로운 값을 예측해야 한다.
    &lt;blockquote&gt;
      &lt;p&gt;이부분이 처음에 조금 이해가 안됐지만, 파이프라인 해저드를 공부하고 이해가 됐다. 해저드를 통해 이러한 분기예측을 제어한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;분기의 방향을 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술을 분기예측branch prediction 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;455-파이프라인-해저드&quot;&gt;4.5.5 파이프라인 해저드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;피드백이 있는 시스템에 파이프라인을 도입하면 연속되는 인스트럭션들 간에 의존성이 존재할 때 문제가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존성은 두 가지 형태를 띈다.
    &lt;ul&gt;
      &lt;li&gt;데이터 의존성: 한개의 인스트럭션이 계산한 결과가 다음에 오는 인스트럭션을 위한 데이터로 사용되는 경우&lt;/li&gt;
      &lt;li&gt;제어 의존성: jump, call, ret와 같이 한 개의 인스트럭션이 다음에 따라오는 인스트럭션의 위치를 결정하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성들이 파이프라인으로 인해 잘못된 계산을 야기할 가능서이 있을 때 해저드라고 부른다.&lt;/li&gt;
  &lt;li&gt;해저드 또한 데이터 해저드, 제어 해저드로 구분할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러x&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러X)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러o&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러O)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스톨을-사용한-데이터-해저드의-회피&quot;&gt;스톨을 사용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해저드를 회피하는 매우 일반적인 기술은 프로세서가 하나 또는 여러 인스트럭션을 해저드 조건이 사라질 때까지 파이프라인 내에 유지하는 스톨과 관련된다.&lt;/li&gt;
  &lt;li&gt;해독 단계에서 인스트럭션을 소스 오퍼랜드를 생성하는 인스트럭션들이 재기록 단계를 통과할 때까지 스톨시키는 방법으로 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;스톨링은 한 그룹의 인스트럭션들을 이들의 단계에 붙잡아두지만, 다른 인스트럭션들은 파이프라인을 계속 흘러가도록 한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션을 해독단계에 붙잡아 놓을 때마다 실행 단계에 버블을 삽입하는 방식으로 처리한다.&lt;/li&gt;
  &lt;li&gt;버블은 동적으로 생성된 nop 인스트럭션과 비슷하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포워딩forwarding을-이용한-데이터-해저드의-회피&quot;&gt;포워딩Forwarding을 이용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재기록 단계에서 이들 소스 레지스터 중의 하나에 대기하고 있는 쓰기 작업이 존재할 수 있다.&lt;/li&gt;
  &lt;li&gt;쓰기 작업이 완료될 때까지 스톨하기보다는 소스 오퍼랜드로 파이프라인 레지스터 E에 기록될 값을 단순히 전달할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터 포워딩은 메모리 단계에서 대기하고 있는 레지스터 쓰기 작업이 있을 때에도 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;위 그림은 해독 단계 로직이 레지스터 파일에서 온 값을 사용할지, 포워딩된 값을 사용할지 여부를 어떻게 결정할 수 있는지 보여준다.
    &lt;ul&gt;
      &lt;li&gt;레지스터 파일에 재기록되는 모든 값과 관련된 것은 목적지 레지스터 ID이다.&lt;/li&gt;
      &lt;li&gt;이 로직은 이 ID들을 소스 레지스터 ID인 srcA, srcB와 비교해서 포워딩을 위한 경우를 검출할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다섯개의 포워딩 소스가 해독 단계에 “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로드사용-데이터-해저드&quot;&gt;로드/사용 데이터 해저드&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_10.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 데이터 해저드는 순수하게 포워딩만 가지고는 처리할 수 없다.&lt;/li&gt;
  &lt;li&gt;해당 경우는 스톨링과 포워딩을 함께 사용해서 로드/사용 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것을 로드 인터록load interlock이라고 부른다.&lt;/li&gt;
  &lt;li&gt;포워딩과 결합된 로드 인터록은 가능한 모든 형태의 데이터 해저드를 충분히 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-해저드의-회피&quot;&gt;제어 해저드의 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제어 해저드는 프로세서가 선입 단계에서 현재 인스트럭션에 기초하여 다음 인스트럭션의 주소를 안정적으로 결정할 수 없을 때 발생한다.&lt;/li&gt;
  &lt;li&gt;제어 해저드는 ret와 점프 인스트럭션에 대해서만 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_11.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 ret가 해독, 실행, 메모리 단계를 통과하며 세개의 버블을 삽입하는 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;PC 선택 로직은 ret가 재기록 단계에 도착하면(사이클 7) 인스트럭션 선입 주소로 리턴주소를 선택하게 된다.
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_12.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 잘못 예측한 분기 인스트럭션의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 분기를 할 것이라고 예측하고, 따라서 점프 목적지에서 인스트럭션 선입을 시작한다.&lt;/li&gt;
      &lt;li&gt;점프 인스트럭션이 실행 단계를 통해 흘러갈 때 두 인스트럭션은 사이클 4에서 예측오류가 검출되기 전에 선입된다.&lt;/li&gt;
      &lt;li&gt;사이클 5에서 파이프라인은 해독과 실행단계에 버블을 삽입해서 두 목적지 인스트럭션을 취소하고, 점프 다음에 오는 인스트럭션을 선입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;간단히 두 개의 잘못 선입한 인스트럭션을 취소할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 스쿼싱squashing이라고 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;programmers-visible state에는 아무런 영향을 주지 않지만 단점은 두 클럭 사이클 만큼의 인스트럭션 처리 능력이 낭비된다는 점이다.&lt;/li&gt;
  &lt;li&gt;스톨링과 파이프라인에 버블을 삽입하는 기술들은 특수한 상황이 발생할 때 파이프라인의 흐름을 동적으로 조절한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;456-예외처리&quot;&gt;4.5.6 예외처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서의 다양한 동작은 예외적인 제어흐름을 발생시키며, 이 경우 정상적인 프로그램 실행의 연결은 끊어진다.&lt;/li&gt;
  &lt;li&gt;예외들은 프로그램 실행에 의해 내부적으로 발생하거나 외부 신호에 의해 외부적으로 생성될 수 있다.&lt;/li&gt;
  &lt;li&gt;세 가지 서로 다른 내부 생성 예외
    &lt;ol&gt;
      &lt;li&gt;halt 인스트럭션에 의한 예외&lt;/li&gt;
      &lt;li&gt;인스트럭션과 함수코드의 잘못된 조합을 갖는 인스트럭션&lt;/li&gt;
      &lt;li&gt;인스트럭션 선입 또는 데이터 읽기나 쓰기를 위해 유효하지 않은 주소에 접근하려 하는 경우&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세서가 예외를 만나면 정지하고 적절한 생태코드를 설정한다.&lt;/li&gt;
  &lt;li&gt;프로세서는 운영체제의 일부인 예외핸들러라는 프로시저를 계속 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인과-예외처리&quot;&gt;파이프라인과 예외처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인을 사용한 시스템에서 예외처리는 여러 가지 미묘한 부분들이 관계되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;예외상황이 다수의 인스트럭션들에 의해 동시에 발생할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;기본 규칙은 파이프라인에서 가장 멀리 있는 인스트럭션이 유발한 예외상황에 우선순위를 둔다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어떤 인스트럭션이 선입되고, 실행을 시작해서 예외를 발생시키고, 나중에 잘못 예측한 분기명령으로 인해 취소할 때 발생한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 제어로직은 인스트럭션을 취소한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라인 프로세서가 서로 다른 단계에서 시스템 상태의 서로 다른 부분을 갱신하기 때문에 발생한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 제어로직은 메모리나 재기록 단계의 인스트럭션이 예외를 발생시켰을 때 데이터 메모리나 조건코드 레지스터를 갱신하는 것을 김지한다.&lt;/li&gt;
  &lt;li&gt;파이프라인의 하나 이상의 단계에서 예외가 발생할 때 정보는 단순히 파이프라인 레지스터의 상태 필드에 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;457-pipe-단계의-구현&quot;&gt;4.5.7 PIPE 단계의 구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 레지스터, 재구성 가능한 로직 블록, 추가적인 파이프라인 제어로직을 추가하고, 이전의 순차적 설계 같은 하드웨어 유닛들을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pc-선택과-선입-단계&quot;&gt;PC 선택과 선입 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_13.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 카운터의 현재 값을 선택해야하며, 다음 PC 값을 예측해야 한다.&lt;/li&gt;
  &lt;li&gt;메모리에서 인스트럭션을 읽고 여러 가지 인스트럭션 필드들을 추출하기 위한 하드웨어 유닛들은 SEQ를 위해 고려한 것과 동일하다.&lt;/li&gt;
  &lt;li&gt;하나의 사이클 시간의 범위 내에 프로세서는 다음 인스트럭션의 주소를 예측만 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해독-및-재기록-단계&quot;&gt;해독 및 재기록 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_14.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;valP와 레지스터 포트 A로부터 읽은 값을 동시에 요구하는 인스트럭션은 없으며 따라서 이들은 다음 단계를 위한 신호 valA를 구성하기 위해 통합할 수 있따.
    &lt;ul&gt;
      &lt;li&gt;“Sel+FwdA” 블록이 해당 일을 수행하고 valA를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
      &lt;li&gt;“FwdB” 블록은 소스 오퍼랜드 valB를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 쓰기 위치는 해독 단계보다는 재기록 단계에서 가져온 dstE와 dstM으로 나타낸다.
    &lt;ul&gt;
      &lt;li&gt;해독 단계가 현재 재기록 단계에 있는 인스트럭션의 결과를 기록하고 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_15.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 HCL 코드에서 다섯 개의 포워딩 소스에 주어진 우선순위는 매우 종요하다.&lt;/li&gt;
  &lt;li&gt;우선순위는 HCL코드에서 다섯 개의 목적지 레지스터 ID가 시험되는 순서에 의해 결정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실행-단계&quot;&gt;실행 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_16.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 실행 단계 로직이다. 이 부분의 설계는 SEQ의 로직과 매우 유사하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-단계&quot;&gt;메모리 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_17.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 메모리 단계 로직이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 레지스터 M, W의 많은 신호들이 앞 단계들로 전달되어 재기록한 결과, 인스트럭션 주소, 포워드된 값들을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;458-파이프라인-제어로직&quot;&gt;4.5.8 파이프라인 제어로직&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 포워딩과 분기예측과 같이 다른 방법들로는 처리할 수 없는 다음과 같은 네 개의 제어 경우를 처리해야 한다.
    &lt;ul&gt;
      &lt;li&gt;로드/사용 해저드 : 메모리에서 값을 읽은 인스트럭션과 이 값을 사용하는 인스트럭션 사이에 한 사이클 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;잘못 예측한 분기 : 예측으로 인해 잘못 선입된 인스트럭션들은 취소되어야 하며, 선입 단계는 점프 인스트럭션 다음의 인스트럭션에서 시작해야한다.&lt;/li&gt;
      &lt;li&gt;예외 : 어떤 인스트럭션이 예외를 발생시키면 programmer-visible state가 갱신되는 것을 막아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수한-제어-상황들의-바람직한-처리&quot;&gt;특수한 제어 상황들의 바람직한 처리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_18.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션의 상세한 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;선입 단계는 ret 인스트럭션 다음의 rrmovq 인스트럭션을 반복적으로 선입하지만, 파이프라인 제어회로는 rrmovq 인스트럭션이 진행하는 것을 허용하는 대신에 해독 단계에 한 개의 버블을 삽입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_19.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 유효하지 않은 메모리 참조 예외의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;사이클 6에서 pushq 인스트럭션으로 인한 유효하지 않은 메모리 차몾는 조건코드 갱신을 금지시킨다.&lt;/li&gt;
      &lt;li&gt;파이프라인은 메모리 단계에 버블을 삽입하기 시작하고 재기록 단계에 있는 예외 인스트럭션을 스톨시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수-제어-조건의-감지&quot;&gt;특수 제어 조건의 감지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ret 인스트럭션이 파이프라인을 통과해 갈 때 검출하려면 해독, 실행, 메모리 단계에 있는 인스트럭션들의 인스트럭션 코드를 단순히 체크하면 된다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 검출하려면 실행 단계에 있는 인스트럭션의 종류(mrmovq, popq)를 체크해야 하고, 해독 단계에 있는 인스트럭션의 소스 레지스터들과 목적지 레지스터들을 비교해야 한다.&lt;/li&gt;
  &lt;li&gt;파이프라인 제어로직은 인스트럭션이 해독 단계에 있는 동안 잘못 예측한 분기를 검출해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인-제어-과정&quot;&gt;파이프라인 제어 과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_20.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 파이프라인 레지스터 동작이다.
    &lt;ul&gt;
      &lt;li&gt;a. 정상 조건 시 레지스터의 상태와 출력은 클럭이 상승할 때 입력 값으로 설정된다.&lt;/li&gt;
      &lt;li&gt;b. 스톨 모드에서 동작할 때, 상태는 이전 값으로 고정된다.&lt;/li&gt;
      &lt;li&gt;c. 버블 모드에서 동작할 때 상태는 연산의 결과로 기록된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-조건들의-조합&quot;&gt;제어 조건들의 조합&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_21.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 특수한 제어 조건들에 대한 파이프라인 상태이다.
    &lt;ul&gt;
      &lt;li&gt;표시한 두 쌍은 동시에 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-로직의-구현&quot;&gt;제어 로직의 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_22.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE 파이프라인 제어로직이다.
    &lt;ul&gt;
      &lt;li&gt;이 로직은 프로시저 리턴, 잘못 예측한 분기, 로드/사용 해저드, 프로그램 예외 같은 특수한 조건들을 처리하기 위해서 정상적인 인스트럭션 흐름이 파이프라인을 통과하는 것을 정지시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;459-성능-분석&quot;&gt;4.5.9 성능 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스트럭션마다 걸리는 평균 클럭 사이클 수는 CPIcycles per instruction라는 단위로 추정값을 계산한다.
    &lt;ul&gt;
      &lt;li&gt;Ci 인스트르럭션, Cb 버블을 처리한다면, 프로세서는 Ci + Cb개의 클럭 사이클을 필요로한다.&lt;/li&gt;
      &lt;li&gt;CPI = 1.0 + Cb/Ci 이다.&lt;/li&gt;
      &lt;li&gt;오직 세개의 인스트럭션 타입만이 버블을 추가하기 때문에
        &lt;ul&gt;
          &lt;li&gt;CPI = 1.0 lr(load penalty) + mp(mispredicted branch penalty) + rp(return penalty)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4510-남아-있는-작업&quot;&gt;4.5.10 남아 있는 작업&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중 사이클 인스트럭션
    &lt;ul&gt;
      &lt;li&gt;다중 인스트럭션을 구현하는 한 가지 간단한 방법은 실행 단계 로직의 성능을 정수와 부동 소수점 산술연산 유닛들을 포함하도록 단순히 확장하는 것이다.
        &lt;ul&gt;
          &lt;li&gt;한 개의 인스트럭션이 해독 단계에 들어갈 때 특수 유닛으로 보낸다.(ex. 부동소수점 유닛)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 시스템과의 인터페이스&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;46-요약&quot;&gt;4.6 요약&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;해당 장을 통해 인스트럭션 집합 아키텍처 ISA는 프로세서의 동작과 프로세서가 어떻게 구현되는지 간에 추상화 계층을 제공한다는 것을 알 수 있었다.&lt;/li&gt;
  &lt;li&gt;ISA는 프로그램 실행을 하나의 인스트럭션이 다음 인스트럭션이 시작되기 전에 실행되어 종료되는 순차적인 프로그램 실행의 모습을 제공한다.&lt;/li&gt;
  &lt;li&gt;여러 가지 인스트럭션들이 요구하는 처리작업을 5단계로 구성하였으며, 전체 인스트럭션이 다섯 단계를 통해 들어가서 매 클럭 사이클마다 실행된다.&lt;/li&gt;
  &lt;li&gt;파이프라인은 여러 단계들이 동시에 동작하도록 하여 시스템의 처리량 성능을 개선한다.&lt;/li&gt;
  &lt;li&gt;예외를 적절히 처리하는 것은 높은 파이프라인 단계와 병렬성을 사용하는 시스템에서 보다 복잡해진다.&lt;/li&gt;
  &lt;li&gt;교훈
    &lt;ul&gt;
      &lt;li&gt;복잡성을 관리하는 것이 최우선순위를 갖는다.
        &lt;ul&gt;
          &lt;li&gt;모든 인스트럭션 타입을 처리하기 위한 매우 간단하고 통일된 프레임워크를 만들어서 구현하였다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ISA를 직접 구현할 필요는 없다.
        &lt;ul&gt;
          &lt;li&gt;파이프라인 설계를 사용하였고 파이프라인 해저드를 처리할 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하드웨어 설계자는 꼼꼼해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2장부터 4장이 하드웨어까지의 모든 부분들을 살펴본 것 같다. 4장은 꼭 한번 더 읽어보자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 18</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)</title><link href="http://localhost:4000/cs:app/csapp_17/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_17</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_17/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;44-파이프라이닝의-일반-원리&quot;&gt;4.4 파이프라이닝의 일반 원리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 시스템의 일반적인 특징과 원리들을 생각해보자.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 시스템에서 수행해야 할 일은 여러 개의 일련의 단계뜰로 나누어진다.&lt;/li&gt;
      &lt;li&gt;식당의 예를들면, 샐러드를 먼저 제공하고, 메인 음식, 디저트 그리고 음료의 순으로 제공하는 것과 비슷하다.&lt;/li&gt;
      &lt;li&gt;컨베이어 벨트와 비슷하게 여러 고객이 동시에 시스템을 진행하도록 한다.&lt;/li&gt;
      &lt;li&gt;비록 어떤 사람은 일부 음식만을 원할지라도 모든 단계를 통과해 간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라이닝의 주요 특징
    &lt;ul&gt;
      &lt;li&gt;시스템 처리량(단위시간당 처리하는 고객의 수)을 증가시킨다.&lt;/li&gt;
      &lt;li&gt;지연시간(고객을 지원하는 데 걸리는 시간)을 증가시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;441-계산용-파이프라인&quot;&gt;4.4.1 계산용 파이프라인&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;위의 식당의 예를 계산용 파이프라인으로 초점을 옮기면
    &lt;ul&gt;
      &lt;li&gt;“고객들”은 인스트럭션&lt;/li&gt;
      &lt;li&gt;단계들은 인스트럭션 실행의 일부분을 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 간단한 비파이프라인 하드웨어 시스템의 예이다.
    &lt;ul&gt;
      &lt;li&gt;계산을 수행하는 일부 로직으로 이루어진다.&lt;/li&gt;
      &lt;li&gt;계산 결과를 저장하는 레지스터가 따라온다.&lt;/li&gt;
      &lt;li&gt;클럭 신호는 규칙적인 시간간격으로 레지스터에 로딩되는 것을 제어한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 조합로직은 300ps를 필요로하고 레지스터 로딩은 20ps를 필요로 한다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/320 * 1,000 = 3.12&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 320ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 3단계 파이프라인 계산 하드웨어이다.
    &lt;ul&gt;
      &lt;li&gt;시스템에서 수행하는 계산을 세 단계 A,B,C로 나눌 수 있다고 가정한다.&lt;/li&gt;
      &lt;li&gt;파이프라인 레지스터들을 단계 사이에 배치해서 각 인스트럭션이 3단계로 시스템을 통해 이동한다.&lt;/li&gt;
      &lt;li&gt;시작부토 종료할 때까지 세 개의 클럭 사이클이 소요된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 클럭을 매 100+20=120ps이고 한 개의 인스트럭션을 처리하는 데 3클럭 사이클이 필요하다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/120 * 1,000 = 8.33&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 360ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비파이프라인 보다 처리량은 빠르지만 지연시간이 증가한 이유는 추가된 파이프라인 레지스터에 의한 오버헤드 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;442-파이프라인-연산의-상세한-고찰&quot;&gt;4.4.2 파이프라인 연산의 상세한 고찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 단계들 간에 인스트럭션의 이동은 위의 파이프라인 다이어그램에 나타낸 것과 같이 클럭 신호에 의해 제어된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 한 사이클 동안의 파이프라인 동작이다.
    &lt;ul&gt;
      &lt;li&gt;신호들은 파이프라인 레지스터 입력들로 전달되지만, 클럭이 상승할 때까지 레지스터의 상태는 바뀌지 않는다.&lt;/li&gt;
      &lt;li&gt;클럭을 늦추는 것이 파이프라인의 동작을 변화시키지 않는다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;443-파이프라이닝의-한계&quot;&gt;4.4.3 파이프라이닝의 한계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인의 효과를 축소시키는 여러 요소들이 종종 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비균일-분리-nonuniform-partitioning&quot;&gt;비균일 분리 Nonuniform Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 이전처럼 세 단계로 나눈 시스템이지만 각 단계에서 발생하는 지연시간은 50에서 150 ps까지 변화한다.&lt;/li&gt;
  &lt;li&gt;우리가 구동할 수 있는 클럭의 속도는 가장 늦은 단계의 시간지연 값에 의해 결정된다.&lt;/li&gt;
  &lt;li&gt;실제 시스템 설계에서는 타이밍을 최적화하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;줄어드는-깊은-파이프라이닝의-효과&quot;&gt;줄어드는 깊은 파이프라이닝의 효과&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 여섯 단계로 나누었고, 각각은 50ps를 소모한다.&lt;/li&gt;
  &lt;li&gt;이 시스템의 클럭 주기는 50+20=70ps, 처리량은 14.29, 지연시간은 480이다.&lt;/li&gt;
  &lt;li&gt;각 계산 블록에서 소요되는 시간을 2분의 1로 줄였지만 파이프라인 레지스터를 통과하는 시간지연으로 인해 처리량은 두 배를 얻지 못했다.&lt;/li&gt;
  &lt;li&gt;이 지연시간은 파이프라인의 처리량에 있어서 제한요소가 된다.&lt;/li&gt;
  &lt;li&gt;최신 프로세서들은 프로세서의 클럭속도를 최대로 올리기 위해 매우 깊은(15단계 이상) 파이프라인을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;444-피드백을-갖는-파이프라인-시스템&quot;&gt;4.4.4 피드백을 갖는 파이프라인 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기계어 프로그램을 실행하는 시스템에서는 연속적인 인스트럭션들 간에는 잠재적인 의존성이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_5.png&quot; width=&quot;30%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;예를들어 위의 코드 배열은 각각의 연속되는 인스트럭션들 간에 원으로 표시한 레지스터 이름에 데이터 의존성이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_6.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 피드백을 갖는 시스템에 파이프라인을 추가할 때의 위험을 보여준다.
    &lt;ul&gt;
      &lt;li&gt;피드백이 있는 파이프라인을 사용하지 않는 시스템(a)에서 파이프라인 시스템(c)으로 전환하기 위해서 두 파이프라인 다이어그램에서 보는 바와 같이 계산적인 동작을 변경한다(b와d)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 17</summary></entry><entry><title type="html">[CS:APP] Chapter 05 프로그램 성능 최적화하기</title><link href="http://localhost:4000/cs:app/csapp_19/" rel="alternate" type="text/html" title="[CS:APP] Chapter 05 프로그램 성능 최적화하기" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_19</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_19/">&lt;h1 id=&quot;chapter-05-프로그램-성능-최적화하기&quot;&gt;Chapter 05. 프로그램 성능 최적화하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램을 작성하는 주목적은 모든 가능한 조건에서 프로그램이 정확하게 동작하도록 하는 것이다.&lt;/li&gt;
  &lt;li&gt;프로그래머는 명확하고 간결한 코드를 작성해야하고, 이해하기 쉽고, 코드를 검토할 때와 수정할 때 다른사람들도 코드를 읽고 이해할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;효율적인 프로그램을 작성하는 방법
    &lt;ol&gt;
      &lt;li&gt;적절한 알고리즘과 자료구조를 선택해야한다.&lt;/li&gt;
      &lt;li&gt;컴파일러가 효과적으로 최적화해서 효율적인 실행코드로 바꿀 수 있는 소스코드를 작성해야 한다.&lt;/li&gt;
      &lt;li&gt;작업을 부분으로 나누어 멀티코어와 멀티프로세서의 조합을 갖는 컴퓨터에서 병렬로 계산한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머는 컴파일러를 도와서 쉽게 최적화될 수 있는 코드를 작성해야한다.
    &lt;ol&gt;
      &lt;li&gt;불필요한 작업 제거
        &lt;ul&gt;
          &lt;li&gt;불필요한 함수호출 제거&lt;/li&gt;
          &lt;li&gt;조건 테스트 제거&lt;/li&gt;
          &lt;li&gt;메모리 참조 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인스트럭션-수준 병렬성을 제공&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;51-최적화-컴파일러의-능력과-한계&quot;&gt;5.1 최적화 컴파일러의 능력과 한계&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일러는 프로그래머의 코드를 자동으로 최적화 해준다.&lt;/li&gt;
  &lt;li&gt;하지만 특정 코드는 컴파일러가 자동으로 최적화해줄 수 없다.
    &lt;ul&gt;
      &lt;li&gt;두 개의 포인터가 같은 메모리 위치를 가리킬 수 있는 경우(메모리 연결memory aliasing)&lt;/li&gt;
      &lt;li&gt;함수 호출
        &lt;ul&gt;
          &lt;li&gt;ex) 호출되는 횟수에 따라 프로그램의 동작이 변경 되는 경우(부가효과 side effect)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위 항목들이 ‘최적화 장애물blocker’이 되는데, 이것은 컴파일러가 최적화된 코드를 생성하기 위한 기회를 제한한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;52-프로그램-성능의-표현&quot;&gt;5.2 프로그램 성능의 표현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CPE : 요소당 측정 사이클metric cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;53-프로그램-예제&quot;&gt;5.3 프로그램 예제&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;코드를 최적화하는 방법은 다음과 같은 방법들이 존재한다.
    &lt;ul&gt;
      &lt;li&gt;타깃 머신의 특징을 고려하지 않은 최적화 기법
        &lt;ul&gt;
          &lt;li&gt;루프 비효율성 제거하기&lt;/li&gt;
          &lt;li&gt;프로시저 호출 줄이기&lt;/li&gt;
          &lt;li&gt;불필요한 메모리 참조 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;최신 프로세서의 인스트럭션 수준 병렬성을 고려한 최적화 기법
        &lt;ul&gt;
          &lt;li&gt;루프풀기&lt;/li&gt;
          &lt;li&gt;병렬성 높이기&lt;/li&gt;
          &lt;li&gt;재결합 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최신프로세서의 인스트럭션 수준 병렬성을 고려하기 위해 5.7절에서 최신프로세서에 대해서 조금 다루고 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;54-루프-비효율성-제거하기&quot;&gt;5.4 루프 비효율성 제거하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 조건이 루프의 매 실행마다 평가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_1.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_2.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;lower1은 n^2&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lower2는 n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;겉보기에는 의미 없는 코드가 감춰진 잠재적 비효율성을 갖고 있다.&lt;/li&gt;
  &lt;li&gt;적은 데이터 셋으로 시험하고 분석되지만, 프로그램이 궁극적으로 배포되면, 프로시저가 백만 개 문자들의 스트리에 적용될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;이러한 상황에 안전했던 코드조각이 주요 성능 병목이 되게된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;경쟁력 있는 프로그래머 역할의 한 부분은 지속적으로 소개되는 그러한 잠재적 비효율성을 피하는것이다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;55-프로시저-호출-줄이기&quot;&gt;5.5 프로시저 호출 줄이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로시저 호출은 오버헤드를 발생시키고 대부분의 프로그램 최적화 작업을 방해할 수 있다.&lt;/li&gt;
  &lt;li&gt;경계값을 체크하는 것은 배열의 임의로 접근하는 경우를 처리할 때에는 유용할 수 있지만, 특정 경우에는 모든 참조 시도가 유효하다.&lt;/li&gt;
  &lt;li&gt;예제에서 각 벡터의 원소를 가져오기 위해서 작성된 함수(벡터 경계값 체크 함수)를 매번 호출하는 대신 배열에 직접 접근한다.
    &lt;ul&gt;
      &lt;li&gt;결벽주의자들은 이렇게 변환하는 것이 프로그램 모듈성을 심각하게 훼손한다고 말할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실용적인 프로그래머라면 이러한 변환과정이 고성능 결과를 얻기 위해서 필요한 단계라고 주장할 것이다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;56-불필요한-메모리-참조의-제거&quot;&gt;5.6 불필요한 메모리 참조의 제거&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_3.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결과값을 임시로 누적한다.
    &lt;ul&gt;
      &lt;li&gt;누적값을 지역변수 acc에 저장하면 매 루프 반복실행마다 메모리에서 가져오고 갱신된 값을 다시 기록할 필요가 없어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;57-최신-프로세서-이해하기&quot;&gt;5.7 최신 프로세서 이해하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;코드의 성능을 더 개선하기 위해서는 프로세서의 마이크로구조, 즉 프로세서가 인스트럭션을 실행하도록 하는 하부 시스템 설계를 활용하는 최적화 기법을 고려해야한다.&lt;/li&gt;
  &lt;li&gt;실제 프로세서에서 많은 인스트럭션들이 동시에 처리된다.
    &lt;ul&gt;
      &lt;li&gt;이것을 인스트럭션 수준 병렬성이라고 부른다.&lt;/li&gt;
      &lt;li&gt;두 개의 서로 다른 하위 경계값lower bounds가 프로그램의 최대 성능을 결정한다.
        &lt;ul&gt;
          &lt;li&gt;지연시간 경계값 : 일련의 연산들이 엄격하게 순서를 준수하여 수행되어야 할 때 발생&lt;/li&gt;
          &lt;li&gt;처리량 경계값: 프로세서의 기능 유닛들의 기본 계산 능력을 결정한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;571-전체적인-동작&quot;&gt;5.7.1 전체적인 동작&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최신 프로세서는 인스트럭션이 실행되는 순서가 기계어 수준 프로그램에서의 순서와 일치할 필요가 없다.
    &lt;ul&gt;
      &lt;li&gt;무순서 out-of-order라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_5.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 최신 프로세서의 블록 다이어그램이다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 제어 유닛(ICU)은 인스트럭션들을 메모리에서 읽고 일련의 기본연산들을 생성하는 역할을 수행한다.&lt;/li&gt;
      &lt;li&gt;그 이후 실행 유닛(EU)은 연산을 수행하여 분기가 정확히 예측되었는지 여부를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최신 프로세서들은 ‘분기 예측branch prediction’이라는 기술을 사용한다.&lt;/li&gt;
  &lt;li&gt;‘추정 실행speculative execution’이라는 기술을 사용해서 분기가 이동해야 하는 위치에 있는 인스트럭션을 선입하고 해독한다.&lt;/li&gt;
  &lt;li&gt;Fetch control 블록은 분기예측과 연동해서 어떤 인스트럭션을 선입할지를 결정한다.&lt;/li&gt;
  &lt;li&gt;추정 실행을 사용해서 연산들이 계산되지만, 확실할 때까지 최종 결과값들은 데이터 메모리나 레지스터에 저장되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국 최신 프로세서들은 ‘무순서로 연산들을 병렬로 진행한다.’라고 말하는 것 같다. 하지만, 데이터 의존성이 있는 경우에는 병렬로 진행할 수 없기 때문에 지연이 발생하고,
이런 데이터 의존성은 컴파일러가 최적화를 할 수 없다.(다른 코드로 변경시 무조건적으로 무결성하다는 것을 입증할 수 없어서) 그렇기 때문에 우리는 데이터 의존성을 줄일 수 있는 코드를 작성하여
최적화를 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;572-함수유닛의-성능&quot;&gt;5.7.2 함수유닛의 성능&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;발급시간 issue time: 두 연산 사이에 소요되는 최소 사이클 수&lt;/li&gt;
  &lt;li&gt;용량 capacity: 해당 연산을 수행할 수 있는 함수 유닛의 수&lt;/li&gt;
  &lt;li&gt;지연 latency: 실제 연산을 수행하는 데 걸린 클럭 사이클 수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_6.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 인텔 코어 i7의 지연시간과 발급시간 특성이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기계수준-코드로부터-데이터흐름-그래프로의-변환&quot;&gt;기계수준 코드로부터 데이터흐름 그래프로의 변환&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_7.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;combine4에 대한 내부 루프의 그림
    &lt;ul&gt;
      &lt;li&gt;인스트럭션들은 동적으로 하나 또는 두 개의 연산으로 번역된다.&lt;/li&gt;
      &lt;li&gt;각각은 다른 연산들 또는 레지스터들로부터 값들을 받고 다른 연산과 레지스터를 위한 값들을 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;루프를 구성하는 코드부분에 대해서 접근하게 되는 레지스터들을 다음의 네 종류로 구분할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;읽기전용 Read-only : 데이터 또는 메모리 주소를 계산하기 위한 소스 값들로 사용된다.&lt;/li&gt;
      &lt;li&gt;쓰기전용 Write-only : 데이터 이동 연산의 목적지로 사용된다.&lt;/li&gt;
      &lt;li&gt;지역적 Local : 루프 내에서 사용되고 갱신되지만, 한 번의 반복 실행에서 다른 실행으로의 의존성은 없다.
        &lt;ul&gt;
          &lt;li&gt;ex) cmp에 의해 갱신되며 jne 연산에 의해 사용된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;루프 Loop : 한 번의 반복실행에서 생성된 값은 다른 실행에서 사용되는 방식으로 소스 값들로 사용되며 루프의 목적지로도 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;루프 레지스터들 간의 연산들의 연결이 성능을 제한하는 데이터 의존성을 결정한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_9.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 combine4 연산들을 데이터 흐름 그래프로 추상화하였다.
    &lt;ul&gt;
      &lt;li&gt;(b)를 보면 데이터의존성을 확인할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;58-루프풀기&quot;&gt;5.8 루프풀기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;루프 풀기는 루프의 매 반복실행마다 계산되는 원소의 수를 증가시켜 루프에서의 반복 실행 횟수를 줄이는 방법이다.&lt;/li&gt;
  &lt;li&gt;루프 풀기는 두가지 측면에서 성능을 개선할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;루프 인덱스 계산과 조건부 분기와 같이 프로그램의 결과와는 직접적으로 관련 없는 연산들의 수를 줄인다.&lt;/li&gt;
      &lt;li&gt;전체 계산의 핵심 경로에 있는 연산의 수를 줄이기 위한 추가적인 코드변환을 할 수 있는 방법들을 적용할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Combine 2 elements at a time (2X1 루프풀기)*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위 코드와 같이 반복 횟수를 줄인다.
    &lt;ul&gt;
      &lt;li&gt;kX1로 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;59-병렬성-높이기&quot;&gt;5.9 병렬성 높이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 의존성을 줄이고자 병렬성을 높이는 방법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다수의-누산기-사용&quot;&gt;다수의 누산기 사용&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Combine 2 elements at a time (2X1 루프풀기)*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;acc1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위 코드와 같이 홀수와 짝수를 나누면 데이터 의존성이 사라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재결합-변환&quot;&gt;재결합 변환&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* reassociation transform (2X1a 루프풀기) */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;511-일부-제한-요인들&quot;&gt;5.11 일부 제한 요인들&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;최적화중 프로그램의 성능을 제한하는 다른 요소들이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5111-레지스터-넘기기&quot;&gt;5.11.1 레지스터 넘기기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램이 사용 가능한 레지스터의 수를 넘어가는 병렬성을 가지면, 메모리에 저장하게 되는 &lt;strong&gt;레지스터 넘기기 spilling&lt;/strong&gt; 방법이 사용된다.
    &lt;ul&gt;
      &lt;li&gt;이 때 런타임 스택에 공간을 할당하기 때문에 성능이 저하된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5112-분기예측과-예측비용&quot;&gt;5.11.2 분기예측과 예측비용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;if문보다 삼항연산자가 더 빠르다.
    &lt;blockquote&gt;
      &lt;p&gt;if문은 statement, 삼항연산자는 expression이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;512-메모리-성능의-이해&quot;&gt;5.12 메모리 성능의 이해&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Load의 성능
    &lt;ul&gt;
      &lt;li&gt;반복실행에 대한 로드 연산은 이전 반복실행에 대한 로드 연산이 완료되었을 때까지는 시작할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Store의 성능
    &lt;ul&gt;
      &lt;li&gt;store 연산은 레지스터 값을 메모리로 기록한다.&lt;/li&gt;
      &lt;li&gt;store 연산은 데이터 의존성을 발생시키지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;load 연산만이 store 연산의 결과에 영향을 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;513-실제상황-성능개선-기술&quot;&gt;5.13 실제상황: 성능개선 기술&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 성능의 최적화하는 기본적인 전략들
    &lt;ul&gt;
      &lt;li&gt;상위수준 설계 : 적절한 알고리즘과 자료구조를 선택&lt;/li&gt;
      &lt;li&gt;기본 코딩원칙 : 최적화 장애물 피하기
        &lt;ul&gt;
          &lt;li&gt;함수 호출 제거&lt;/li&gt;
          &lt;li&gt;계산은 루프 밖으로 이동&lt;/li&gt;
          &lt;li&gt;불필요한 메모리 참조 제거&lt;/li&gt;
          &lt;li&gt;중간 값들을 저장하는 임시 변수 사용(데이터 의존성 피하기)&lt;/li&gt;
          &lt;li&gt;최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하위수준 최적화 : 하드웨어의 성능을 활용할 수 있는 코드 작성
        &lt;ul&gt;
          &lt;li&gt;루프풀기&lt;/li&gt;
          &lt;li&gt;다중누산기와 재결합 기법 사용&lt;/li&gt;
          &lt;li&gt;statement보다 expression 사용하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;마무리&quot;&gt;마무리&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;2장부터 4장까지 컴퓨터가 해석할 수 있는 언어들과 해당 언어들을 컴퓨터가 어떻게 해석하는지를 공부했다.
해당 방법들을 통해서 5장에서는 프로그래머들이 어떻게 코드를 작성해야 하는지를 배웠다. 
만약 컴퓨터가 코드를 해석하는 방법을 몰랐더라면, 코드 최적화 방법을 공부할 때 정확히 이해할 수 없었을 것이다.
작성한 코드에서 인스트럭션 조합과 기계어가 어떻게 동작하는지를 항상 생각하자.&lt;/p&gt;

  &lt;p&gt;추가적으로, CSAPP 포스팅 방식을 조금 변경해야할 것 같다. 4장 초반까지는 솔직히 굉장히 어려웠다. “무슨 말을 하는지 이걸 도대체 컴퓨터가 어떻게 해석한다는거지?”
라고 생각하며 의문으로 가득차 거의 모든 내용을 포스팅한 것 같다. 하지만, 4장 후반 SEQ와 파이프라이닝을 공부하고 “아! 이래서 지금까지 이런 내용들을 공부했구나!”
그리고 5장을 공부하면서 뭔가 “득도”를 하게 된 것 같다. 다양한 부분들의 이해가 빨라졌다. 앞으로 챕터를 공부하고 나의 방식으로 녹인 후 포스팅을 하는 것으로 포스팅 방향을 바꿀 것이다.&lt;/p&gt;

  &lt;p&gt;6장은 드디어 메모리 파트이다. 너무 기대된다!&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 19</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)</title><link href="http://localhost:4000/cs:app/csapp_16/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)" /><published>2022-03-17T00:00:00+09:00</published><updated>2022-03-17T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_16</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_16/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;434-seq-단계의-구현&quot;&gt;4.3.4 SEQ 단계의 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ를 구현하는 데 필요한 제어로직 블록을 위한 HCL작성방법을 설명한다.&lt;/li&gt;
  &lt;li&gt;여러가지 인스트럭션 코드, 함수코드, 레지스트 이름, ALU 연산, 상태코드 등을 위한 상수 값뿐만 아니라 여러가지 하드웨어 신호의 이름이 포함된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 표는 HCL 문장에 사용된 상수 값들이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선입-단계&quot;&gt;선입 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선입 단계는 인스트럭션 메모리 하드웨어 유닛을 포함한다.&lt;/li&gt;
  &lt;li&gt;유닛은 PC를 첫 바이트(0번 바이트)의 주소로 사용해서 메모리로부터 한 번에 10바이트를 읽어들인다.&lt;/li&gt;
  &lt;li&gt;이 바이트는 인스트럭션 바이트로 해석되고, 두 개의 4비트 값으로 나누어진다.(“Split”이라고 표시된 유닛에 의해 icode와 ifun으로 나뉜다.)&lt;/li&gt;
  &lt;li&gt;icode 값에 따라 세 개의 1비트 신호를 계산할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;instr_valid: 이 신호는 부정 인스트럭션을 검출하기 위해 사용된다.&lt;/li&gt;
      &lt;li&gt;need_regids: 레지스터 지정 바이트를 포함하는가&lt;/li&gt;
      &lt;li&gt;need_valC: 상수 워드를 포함하는가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;instr_valid, imem_error 신호(인스트럭션 주소가 범위를 벗어날 때 만들어지는)는 메모리 단계에서 상태코드를 만들기 위해 사용된다.&lt;/li&gt;
  &lt;li&gt;need_regids를 위한 HCL 표현은 icode 값이 레지스터 지정자 바이트를 갖는 인스트럭션인지를 결정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;need_regids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;icode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IRRMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IOPQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IPUSHQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IPOPQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;no&quot;&gt;IIRMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IRMMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IMRMOVQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;인스트럭션 메모리에서 읽은 나머지 바이트는 레지스터 지정자와 상수 워드들이다.
    &lt;ul&gt;
      &lt;li&gt;Align 이라고 이름 붙인 하드웨어 유닛이 레지스터 필드들과 상수 워드에 대해 처리작업을 수행한다.&lt;/li&gt;
      &lt;li&gt;계산된 need_regids가 1이면, 레지스터 지정자 rA와 rB로 나누어진다.&lt;/li&gt;
      &lt;li&gt;상수 워드 valC도 만든다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PC 증가 하드웨어 유닛은 현재의 PC 값, need_regids, need_ValC에 따라 valP를 만든다. (p+1+r+8i)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해동과-재기록-단계&quot;&gt;해동과 재기록 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ에서 해독과 재기록 단계 모두를 구현하는 로직의 상세한 모습을 보여준다.
    &lt;ul&gt;
      &lt;li&gt;해동과 재기록 단계 모두 레지스터 파일에 접근하기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 파일은 네 개의 포트를 가지고 있다.
    &lt;ul&gt;
      &lt;li&gt;두 개의 동시 읽기(포트 A와 B), 두 개의 동시 쓰기(포트 E와 M)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 포트는 한 개의 주소 연결과 데이터 연결을 모두 갖는다.
    &lt;ul&gt;
      &lt;li&gt;주소 연결은 레지스터 ID, 데이터 연결은 레지스터 파일의 출력 워드 이거나 입력워드로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 개의 읽기 포트는 주소 입력 srcA와 srcB를 가진다.&lt;/li&gt;
  &lt;li&gt;두 개의 쓰기 포트는 dstE와 dstM을 주소 입력으로 갖느다.&lt;/li&gt;
  &lt;li&gt;네 개의 블록은 인스트럭션 코드 icode, 레지스터 지정자 rA, rB, 실행 단계에서 계산된 조건신호 Cnd에 기초하여 네 개의 레지스터 ID를 만들어 낸다.&lt;/li&gt;
  &lt;li&gt;레지스터 ID dstE는 쓰기 포트 E를 위한 목적지 레지스터를 나타내며 계싼된 valE가 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실행-단계&quot;&gt;실행 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;실행 단계는 산술/논리 유닛(ALU)을 포함한다.&lt;/li&gt;
  &lt;li&gt;이 유닛은 ADD, SUBTRACT, AND, EXCLUSIVE-OR를 입력 aluA, aluB에 alufun 신호의 설정에 따라 실행한다.&lt;/li&gt;
  &lt;li&gt;ALU가 대부분의 경우에 덧셈기로 사용된다.
    &lt;ul&gt;
      &lt;li&gt;OPq 인스트럭션에 대해서는 인스트럭션의 ifun 필드에 인코딩된 연산을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 단계는 조건코드 레지스터를 포함한다.
    &lt;ul&gt;
      &lt;li&gt;조건코드 레지스터가 갱신되어야 할지 여부는 제어하는 set_cc 신호를 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;“cond”로 명명된 하드웨어 유닛은 조건부 분기나 데이터 이동이 일어나야 할지를 결정하기 위한 조건코드들과 함수코드의 조합을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-단계&quot;&gt;메모리 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 단계는 프로그램 데이터를 읽거나 쓰는 일을 수행한다.&lt;/li&gt;
  &lt;li&gt;두 개의 제어 블록이 메모리주소와 메모리 입력 데이터(쓰기 연산을 위한)를 위한 값을 만들어낸다.&lt;/li&gt;
  &lt;li&gt;메모리 단계에서 마지막 기능은 icode, imem_error, 선입 단계에서 만들어진 instr_valid, 데이터 메모리에서 만든 dmem_error 신호에 따라 인스트럭션 실행에서 결정되는 상태코드 Stat을 계산하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pc-갱신-단계&quot;&gt;PC 갱신 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ의 최종 단계는 새로운 프로그램 카운터 값을 생성하는 것이다.&lt;/li&gt;
  &lt;li&gt;새로운 PC 값은 인스트럭션 타입과 분기를 택할지 여부에 따라 valC, valM, valP가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;seq-현황-조사&quot;&gt;SEQ 현황 조사&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 인스트럭션을 통일된 흐름으로 실행하기 위해 필요한 단계를 구성하면서 프로세서 전체를 적은 수의 여러 하드웨어 유닛들과 계산을 순서화하기 위한 한 개이의 클럭으로 구현할 수 있다.&lt;/li&gt;
  &lt;li&gt;SEQ에서 유일한 문제는 매우 느리다.
    &lt;ul&gt;
      &lt;li&gt;그 이유는 각 유닛들이 전체 클럭 사이클의 일부 동안만 사용되기 때문이다.&lt;/li&gt;
      &lt;li&gt;그렇기 때문에 파이프라인을 사용해서 보다 좋은 성능을 얻을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세서의 구조를 자세히 살펴보았는데, 굉장히 이해하기 어려운 부분이 많았다. 이번 챕터는 자주 보고 다른 자료도 더 찾아봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 16</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)</title><link href="http://localhost:4000/cs:app/csapp_15/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)" /><published>2022-03-17T00:00:00+09:00</published><updated>2022-03-17T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_15</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_15/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;432-seq-하드웨어-구조&quot;&gt;4.3.2 SEQ 하드웨어 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스트럭션을 구현하는 데 필요한 계산들은 여섯 개의 순차적인 기본 단계로 구성될 수 있다.
    &lt;ol&gt;
      &lt;li&gt;선입&lt;/li&gt;
      &lt;li&gt;해독&lt;/li&gt;
      &lt;li&gt;실행&lt;/li&gt;
      &lt;li&gt;메모리&lt;/li&gt;
      &lt;li&gt;재기록&lt;/li&gt;
      &lt;li&gt;PC 갱신&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;SEQ에서는 하드웨어 유닛에 처리되는 모든 일들은 하나의 클럭 사이클 내에서 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/15/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 순차적인 구현인 SEQ의 추상적인 모습이다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션을 실행하는 동안 처리된 정보는 그림의 좌측 하단 구석에 있는 PC를 사용해서 인스트럭션 선입으로 시작해서 시계방향을 따라 진행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드웨어 유닛들은 여러가지 처리 단계들과 연계되어있다.
    &lt;ul&gt;
      &lt;li&gt;선입
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터 레지스터를 주소로 사용해서 인스트럭션 메모리는 인스트럭션의 바이트들을 읽어들인다.&lt;/li&gt;
          &lt;li&gt;PC 가산기는 valP, 증가된 프로그램 카운터를 계산한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;해독
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일은 두 개의 읽기 포트 A,B를 가지고 있다.&lt;/li&gt;
          &lt;li&gt;이를 통해서 레지스터 값 valA, valB를 동시에 읽어들일 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실행
        &lt;ul&gt;
          &lt;li&gt;인스트럭션의 종류에 따라 여러 가지 목적을 위해 산술/유닛 유닛(ALU)을 사용한다.&lt;/li&gt;
          &lt;li&gt;조건코드 레지스터(CC)는 세 개의 조건코드 비트를 저장한다. 목적지 레지스터를 갱신할지 여부를 결정하는 조건코드와 이동 조건에 의해 계산된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리
        &lt;ul&gt;
          &lt;li&gt;메모리 인스트럭션을 실행할 때 메모리 워드를 읽거나 쓴다.&lt;/li&gt;
          &lt;li&gt;인스트럭션과 데이터 메모리는 같은 메모리 위치에 접근하지만, 목적은 서로 다르다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;재기록
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일은 두 개의 쓰기 포트를 가지고 있다.&lt;/li&gt;
          &lt;li&gt;E 포트는 ALU가 계산한 값을 기록하기 위해 사용된다.&lt;/li&gt;
          &lt;li&gt;M 포트는 데이터 메모리에서 읽어온 값을 기록할 때 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PC 갱신
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터의 새로운 값은 다음 인스트럭션의 주소 valP, call이나 점프 인스트럭션에 의해 지정된 목적지 주소, 또는 메모리에서 읽어온 리턴주소 valM 중에서 선택된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/15/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 SEQ, 순차적 구현의 하드웨어 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/15/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 표는 순차적 구현에서 여러가지 계산 단계 식별 표이다.
    &lt;ul&gt;
      &lt;li&gt;두번째 열은 SEQ의 단계에서 계산되는 값 또는 수행되는 연산을 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;433-seq-타이밍&quot;&gt;4.3.3 SEQ 타이밍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ는 조합논리회로와 두 가지 형태의 메모리 장치로 이루어진다.
    &lt;ul&gt;
      &lt;li&gt;레지스터(프로그램 카운터와 조건코드 레지스터)&lt;/li&gt;
      &lt;li&gt;랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조합논리회로는 순차처리나 제어를 필요로 하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;입력이 바뀔 때마다 논리 게이트의 네트워크를 통해 값들이 전파된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;랜덤 액세스 메모리를 읽는 것은 출력 워드가 주소 입력에 따라 생성되는 방식으로 조합논리회로와 매우 유사하게 동작한다.&lt;/li&gt;
  &lt;li&gt;순차실행을 위해 명시적인 제어를 필요로 하는 네 개의 하드웨어 유닛
    &lt;ul&gt;
      &lt;li&gt;프로그램 카운터, 조건코드 레지스터, 데이터 메모리, 레지스터 파일&lt;/li&gt;
      &lt;li&gt;이들은 새로운 값을 레지스터에 로딩하는 것과 값들을 랜덤 액세스 메모리에 기록하는 작업을 만드는 한 개의 클럭 신호를 통해서 제어된다.&lt;/li&gt;
      &lt;li&gt;프로그램 카운터 : 매 클럭 사이클마다 새로운 인스트럭션 주소를 적재한다.&lt;/li&gt;
      &lt;li&gt;조건코드 레지스터 : 정수연산 인스트럭션이 실행될 때에만 값이 적재된다.&lt;/li&gt;
      &lt;li&gt;데이터 메모리 : rmmovq, pushq, call 인스트럭션이 실행될 때에만 값이 기록된다.&lt;/li&gt;
      &lt;li&gt;레지스터 파일 : 두 개의 쓰기 포트를 통해서 두 개의 프로그램 레지스터가 매 사이클마다 갱신될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위와 같이 레지스터들과 메모리에 클럭을 공급하는 것은 프로세서에서 여러 동작들을 순서대로 제어하기 위해 필요한 모든 거싱다.&lt;/li&gt;
  &lt;li&gt;프로세서는 인스트럭션의 처리를 완료하기 위해 어떤 인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 절대 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/15/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 SEQ의 두 실행 사이클 추적이다.
    &lt;ul&gt;
      &lt;li&gt;각 사이클은 이전 인스트럭션에 의해 설정된 상태 원소들(프로그램 카운터, 조건코드 레지스터, 레지스터 파일, 데이터 메모리)을 가지고 시작된다.&lt;/li&gt;
      &lt;li&gt;신호들은 이 상태 원소들을 위한 새로운 값을 만들면서 조합회로를 지나면서 전파된다.&lt;/li&gt;
      &lt;li&gt;이 값들은 다음 사이클을 시작하기 위해 상태 원소들에 적재된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태 원소들의 갱신을 제어하기 위해서 조합회로를 통한 값들의 전파와 함께 클럭을 사용하면 SEQ에서 각 인스트럭션을 위해 수행한 계산들을 충분히 제어할 수 있다.&lt;/li&gt;
  &lt;li&gt;클럭이 low에서 high로 전환이 이루어지는 매 시점마다 프로세서는 새 인스트럭션의 실행을 시작한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 15</summary></entry><entry><title type="html">[NLP/Paper]Deep contextualized word representations 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_05/" rel="alternate" type="text/html" title="[NLP/Paper]Deep contextualized word representations 논문 리뷰" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_05</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_05/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-trained word representations are a key component in many neural language understanding models.&lt;/li&gt;
  &lt;li&gt;Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.&lt;/li&gt;
  &lt;li&gt;We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.&lt;/li&gt;
  &lt;li&gt;In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;related-work&quot;&gt;Related Work&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.&lt;/li&gt;
  &lt;li&gt;워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.
    &lt;ul&gt;
      &lt;li&gt;context2vec&lt;/li&gt;
      &lt;li&gt;CoVe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;model&quot;&gt;Model&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ELMo
    &lt;ul&gt;
      &lt;li&gt;ELMo word representations are functions of the entire input sentence.&lt;/li&gt;
      &lt;li&gt;They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.&lt;/li&gt;
      &lt;li&gt;This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pretrained BiLM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Task-specific ELMo Embedding&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Using biLMs for supervised NLP tasks
    &lt;ul&gt;
      &lt;li&gt;기존의 임베딩 벡터와 함께 사용된다.&lt;/li&gt;
      &lt;li&gt;ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_5.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_6.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;6개의 NLP task에서 에러율을 6~20% 줄였다.&lt;/li&gt;
  &lt;li&gt;6개의 NLP task에서 높은 점수를 기록했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;analysis&quot;&gt;Analysis&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_7.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_8.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.&lt;/li&gt;
  &lt;li&gt;biLM에서는 문맥을 고려한다는 것을 알 수 있다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_9.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.&lt;/li&gt;
  &lt;li&gt;이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_9.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.&lt;/li&gt;
  &lt;li&gt;Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...5</summary></entry><entry><title type="html">[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리</title><link href="http://localhost:4000/dataengineering/de_01/" rel="alternate" type="text/html" title="[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/dataengineering/de_01</id><content type="html" xml:base="http://localhost:4000/dataengineering/de_01/">&lt;h1 id=&quot;data-development&quot;&gt;Data Development&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Crawler&lt;/li&gt;
  &lt;li&gt;ETL&lt;/li&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;k8s&lt;/li&gt;
  &lt;li&gt;airflow
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;data-platform&quot;&gt;Data Platform&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Data Orchestration&lt;/li&gt;
  &lt;li&gt;Data Storage
    &lt;ul&gt;
      &lt;li&gt;Data Lake&lt;/li&gt;
      &lt;li&gt;Data Warehouse&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Catalog&lt;/li&gt;
  &lt;li&gt;Data Monitoring
    &lt;ul&gt;
      &lt;li&gt;Data Validation&lt;/li&gt;
      &lt;li&gt;Data Notification
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;data-governance&quot;&gt;Data Governance&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;하둡 스파크 카프카 스칼라…? 알아야할게 산더미군..!!!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="DataEngineering" /><category term="DataEngineering" /><summary type="html">인턴 하면서 끄적였던 것들...4</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)</title><link href="http://localhost:4000/cs:app/csapp_14/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_14</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_14/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;431-작업을-단계로-구성하기&quot;&gt;4.3.1 작업을 단계로 구성하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;인스트럭션을 처리하는 데는 다수의 연산이 관련되어 있다.&lt;/li&gt;
  &lt;li&gt;이들은 특정한 단계들Stages로 구성해서 비록 인스트럭션들의 동작은 다를지라도 모든 인스트럭션들이 일정한 순서를 따르도록 한다.&lt;/li&gt;
  &lt;li&gt;각 단계에서의 세부 처리내용은 실행하는 인스트럭션에 따라 달라진다.
    &lt;ul&gt;
      &lt;li&gt;선입 fetch
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터 PC를 메모리주소로 사용해서 메모리로부터 인스트럭션 바이트들을 읽어들인다.&lt;/li&gt;
          &lt;li&gt;icode(인스트럭션 코드)와 ifun(instruction function)을 추출한다.&lt;/li&gt;
          &lt;li&gt;한 개의 레지스터 지시자 바이트를 선입해서 한 개 또는 두 개의 레지스터 오퍼랜드 지시자 rA와 rB를 얻어내는 경우도 있다. 또한 8바이트 상수 워드 valC를 선입할 수도 있다.&lt;/li&gt;
          &lt;li&gt;이것은 지금 실행 중인 인스트럭션의 순차적인 다음 인시트럭션의 주소가 되는 valP를 계산한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;해독 decode
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일에서 최대 두 개의 오퍼랜드를 읽어서 valA, valB를 얻어온다.&lt;/li&gt;
          &lt;li&gt;일부 인스트럭션에 대해서는 레지스터 %rsp를 읽어온다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실행 excution
        &lt;ul&gt;
          &lt;li&gt;산술/논리 연산 유닛(ALU)이 인스트럭션이 지시하는 연산을 수행하거나(ifun 값에 따라), 메모리 참조 시 유효주소를 계산하거나, 스택 포인터 값을 변경한다. 이 결과를 valE라고 부른다.&lt;/li&gt;
          &lt;li&gt;조건 코드들은 이 경우에 설정될 수 있다. 조건부 이동 인스트럭션에 대해서 조건코드와 분기 조건(ifun에서 주어진)을 평가하고 조건이 참이 되는 경우에만 목적지 레지스터를 갱신한다. 점프 인스트럭션도 마찬가지이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리
        &lt;ul&gt;
          &lt;li&gt;데이터를 메모리에 쓰거나 메모리에서 데이터를 읽어올 수 있다. 이 값을 valM이라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;재기록 write back
        &lt;ul&gt;
          &lt;li&gt;두 결과를 레지스터 파일에 기록한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PC 갱신
        &lt;ul&gt;
          &lt;li&gt;PC는 다음 인스트럭션의 주소로 설정된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세서는 위의 사항들을 무한히 반복하면서 이 단계들을 실행한다.&lt;/li&gt;
  &lt;li&gt;한 개의 인스트럭션을 실행하는 데는 놀라운 양의 작업을 요구한다.
    &lt;ul&gt;
      &lt;li&gt;각 인스트럭션에 대해 기술한 연산을 싫애해야하고&lt;/li&gt;
      &lt;li&gt;주소를 계산하고&lt;/li&gt;
      &lt;li&gt;스택 포인터를 갱신하고&lt;/li&gt;
      &lt;li&gt;다음 인스트럭션을 결정해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;y86-64-인스트럭션-처리과정&quot;&gt;Y86-64 인스트럭션 처리과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/14/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 Y86-64 인스트럭션 예제이다. 해당 코드를 사용해서 여러가지 Y86-64 인스트럭션들의 처리과정을 그림으로 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OPq 인스트럭션 타입(정수와 논리연산), rrmovq(레지스터-레지스터 이동), irmovq(상수-레지스터 이동)에 대해 요구되는 작업을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;선입 단계에서 상수 워드는 필요하지 않기 때문에 valP는 PC+2로 계산된다.&lt;/li&gt;
  &lt;li&gt;해석 단계에서 두 개의 오퍼랜드를 읽어들인다.&lt;/li&gt;
  &lt;li&gt;실행단계에서 함수 지시자 ifun과 함께 ALU에 제공된다.&lt;/li&gt;
  &lt;li&gt;valE는 인스트럭션 결과가 된다.&lt;/li&gt;
  &lt;li&gt;rrmovq인스트럭션을 실행하면 산술연산과 매우 비슷하게 진행한다.&lt;/li&gt;
  &lt;li&gt;irmovq의 경우에도 첫 번째 ALU 입력 대신에 상수 값 valC를 사용한다는 점을 제외하고는 유사한 처리가 발생한다.
    &lt;ul&gt;
      &lt;li&gt;프로그램 카운터를 10 증가시켜야 하는데, 그 이유는 irmovq가 긴 인스트럭션 형식을 가지기 때문이다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/14/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;메모리 쓰기와 읽기 인스트럭션인 rmmovq와 mrmovq를 위해 필요한 처리작업을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;valC를 valB에 더하기 위해 ALU를 사용해서 메모리 연산을 위한 유효주소를 만들어 낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;pushq와 popq 인스트럭션을 처리하기 위해 요구되는 단계들을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;메모리에 접근 하면서 동시에 스택 포인터를 변경한다.&lt;/li&gt;
  &lt;li&gt;pushq 인스트럭션은 해석단계에서 %rsp를 두 번째 레지스터 오퍼랜드의 식별자로 사용해서 스택 포인터를 valB로 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;세 개의 제어 전환 인스트럭션에서의 처리과정을 나타낸다: jump, call, ret&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;정수연산에서처럼 분기를 할지 말지 결정할 때에만 이들이 다르기 때문에 모든 점프를 통합된 방법으로 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;점프 인스트럭션은 선입에서 해독까지는 레지스터 명시자를 필요로 하지 않는다.&lt;/li&gt;
  &lt;li&gt;실행단계에서 조건코드와 점프 조건을 체크해서 분기를 할지 말지 결정하고, 1비트 신호 Cnd를 만든다.&lt;/li&gt;
  &lt;li&gt;PC갱신단계 동안에 이 플래그를 시험하고, 만일 플래그가 1이면 PC를 valC(점프 목적지)로 설정하고, 만일 0이면 valP(다음 인스트럭션의 주소)로 설정한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션 call과 ret은 프로그램 카운터 값을 push, pop한다는점 외에는 pushq, popq와 약간의 유사성을 갖는다.&lt;/li&gt;
  &lt;li&gt;call할 때는 call 인스트럭션의 다음 인스트럭션의 주소인 valP를 push한다.&lt;/li&gt;
  &lt;li&gt;PC 갱신 단계 동안에 PC를 call 목적지인 valC로 설정한다.&lt;/li&gt;
  &lt;li&gt;ret 인스트럭션에서 스택에서 pop한 값인 valM을 PC 갱신 단계에서 PC에 저장한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 14</summary></entry></feed>