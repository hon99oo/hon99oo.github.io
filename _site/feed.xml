<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-26T04:02:39+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산 ~ 3.7 프로시저)</title><link href="http://localhost:4000/cs:app/csapp_06/" rel="alternate" type="text/html" title="[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.5 산술연산과 논리연산 ~ 3.7 프로시저)" /><published>2022-01-26T00:00:00+09:00</published><updated>2022-01-26T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_06</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_06/">&lt;h1 id=&quot;chapter-03-프로그램의-기계수준-표현&quot;&gt;Chapter 03. 프로그램의 기계수준 표현&lt;/h1&gt;

&lt;h1 id=&quot;35-산술연산과-논리연산&quot;&gt;3.5 산술연산과 논리연산&lt;/h1&gt;

&lt;h1 id=&quot;36-제어문&quot;&gt;3.6 제어문&lt;/h1&gt;

&lt;h1 id=&quot;37-프로시저&quot;&gt;3.7 프로시저&lt;/h1&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 06</summary></entry><entry><title type="html">[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_04/" rel="alternate" type="text/html" title="[NLP/Paper]Multi-Task Deep Neural Networks for Natural Language Understanding 논문 리뷰" /><published>2022-01-26T00:00:00+09:00</published><updated>2022-01-26T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_04</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_04/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Multi-Task Learning(MTL)은 새로운 Task를 학습하는 데 도움이 되도록 이전 작업에서 학습된 지식을 적용하는 인간 학습 활동에서 영감을 받음&lt;/li&gt;
  &lt;li&gt;Deep neural networks(DNN)를 이용한 representation learning에 MTL을 적용하는 것에 대한 관심이 높아지고 있음
    &lt;ul&gt;
      &lt;li&gt;DNN을 이용한 representation learning은 많은 양의 데이터를 요구함, MTL은 많은 task에서의 supervised labeled data를 제공함&lt;/li&gt;
      &lt;li&gt;MTL은 특정 Task에 Overfitting 되지 않도록 Regularization 효과를 줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MTL과 대조적으로, Language Model은 대용량의 unsupervised dataset을 활용하여 모델을 학습함
    &lt;ul&gt;
      &lt;li&gt;ELMo, GPT, BERT&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MT-DNN은 Language Model Pre-Training을 활용한 BERT에 Multi-task learning을 적용하여 성능을 개선한 모델
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tasks&quot;&gt;Tasks&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;GLUE의 9개 task를 MTL에 활용&lt;/li&gt;
  &lt;li&gt;Single Sentence Classification
    &lt;ul&gt;
      &lt;li&gt;하나의 문장이 주어졌을 때 문장의 Class를 분류하는 Task&lt;/li&gt;
      &lt;li&gt;CoLA : 문장이 문법적으로 맞는지 분류 (True/False)&lt;/li&gt;
      &lt;li&gt;SST-2 : 영화 Review 문장의 감정 분류 (Poistive/Negative)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Text Similarity
    &lt;ul&gt;
      &lt;li&gt;문장 쌍이 주어졌을 때, 점수를 예측하는 Regression Task&lt;/li&gt;
      &lt;li&gt;STB-B : 문장 간의 의미적 유사도를 점수로 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pairwise Text Classification
    &lt;ul&gt;
      &lt;li&gt;문장 쌍이 주어졌을 때, 문장의 관계를 분류하는 Task&lt;/li&gt;
      &lt;li&gt;RTE, MNLI : 문장 간의 의미적 관계를 3가지로 분류 (Entailment, Contradiction, Neutral)
– QQP, MRPC : 문장 간 의미가 같음 여부를 분류 (True/False)
– Relevance Ranking
– QNLI : 질문과 해당 지문 중 한 문장이 쌍으로 주어졌을 때 해당 지문 문장에 질문의 답이 있는지 여부를 분류 (True/False)
– MT-DNN에서는 이를 Rank 방식으로 바꾸어 모든 지문 문장에 정답이 있을 가능성을 Scoring 하여 가장 Score가 높은 지문 문장을 True로 분류하는 방식으로 Task 수행
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;model-architecture&quot;&gt;Model Architecture&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Lexicon Encoder
    &lt;ul&gt;
      &lt;li&gt;Token Embedding
        &lt;ul&gt;
          &lt;li&gt;맨 앞에 [CLS] 토큰을 추가. 추후 Output에서 Classification 등을 위해 사용됨&lt;/li&gt;
          &lt;li&gt;만약 문장쌍이 들어온다면 각 문장은 Wordpiece로 Toenization 되며 [SEP] Token이 두 문장 사이의 구분자로 사용됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Sentence Embedding - 1번째 혹은 2번째 문장임을 표현하는 Vector&lt;/li&gt;
      &lt;li&gt;Positional Embedding - 각 Token의 위치 정보를 표현하는 Vector&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transformer Encoder
    &lt;ul&gt;
      &lt;li&gt;Lexicon Encoder로 부터 각 Token의 Input Vector를 입력으로 받아 Ouput Vector 추출&lt;/li&gt;
      &lt;li&gt;BERT 모델과 달리 task별로 fine-tunning하지 않고 MTL로 fine-tunning 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Single-Sentence Classification Ouput
    &lt;ul&gt;
      &lt;li&gt;[CLS] Token과 Task Specific Parameter의 곱에 Softmax를 취하여 Ouput 추출&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_3.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Text Similarity Ouput
    &lt;ul&gt;
      &lt;li&gt;[CLS] Token을 활용하여 Task Specific Parameter와 곱한 후 sigmoid function을 사용하여 Score를 예측&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pairwise Text Classification Ouput
    &lt;ul&gt;
      &lt;li&gt;BERT와 다르게 Stochastic Answer Network(SAN)를 이용함
        &lt;ul&gt;
          &lt;li&gt;NLI의 기존 SOTA 모듈, 주어진 문장들에 대한 Multi-step Reasoning을 모델링하는 구조 (한번에 classification 결과를 예측하지 않고 여러번의 예측을 통한 Reasoning으로 결과를 예측)&lt;/li&gt;
          &lt;li&gt;SAN은 GRU모듈에 주어진 문장쌍의 representation을 Input 및 hidden state로 넣는 과정을 k번 반복함으로써 정제된 representation을 얻고 이를 이용하여 최종 예측&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 step을 진행할때마다 linear classifier를 거쳐 각 클래스에 대한 확률 분포 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_6.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 K-step output을 평균하여 클래스에 대한 최종 확률 분포를 계산, averaging 연산 전에 stochastic prediction droput을 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_7.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Relevance Ranking Ouput
    &lt;ul&gt;
      &lt;li&gt;Question과 문장 Pair Input으로 넣어 생성한 [CLS] Token에 Sigmoid를 취하여 문장 별로 점수를 Scoring하고 가장 높은 점수 만 Question에 해당하는 정답이 있다고 예측하는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_8.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;training-procedure&quot;&gt;Training Procedure&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_10.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experiments&quot;&gt;Experiments&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Datasets
    &lt;ul&gt;
      &lt;li&gt;GLUE 벤치마크는 QA, Sentiment Analysis, Text Similarity, Textual Entailment를 포함한 NLU task&lt;/li&gt;
      &lt;li&gt;SNLI 데이터셋은 570K개의 문장 쌍&lt;/li&gt;
      &lt;li&gt;SciTail은 Science Question Answering 데이터셋에서 파생된 Textual Entailment 데이터셋임
        &lt;ul&gt;
          &lt;li&gt;주어진 전제가 주어진 가설을 수반하는지 여부를 평가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_11.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation details
    &lt;ul&gt;
      &lt;li&gt;Optimizer : Adamax&lt;/li&gt;
      &lt;li&gt;learning rate : 5e-5&lt;/li&gt;
      &lt;li&gt;Batch Size : 32&lt;/li&gt;
      &lt;li&gt;Maximum number of epoch : 5&lt;/li&gt;
      &lt;li&gt;Fine-tuning layer dropout : task마다 다르게 설정(MNLI:0.3, CoLA:0.05, Else:0.1)&lt;/li&gt;
      &lt;li&gt;Tokenizer : WordPiece&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;experiments---glue-results&quot;&gt;Experiments - GLUE Results&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_12.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MT-DNN이 BERT보다 전체 성능이 약 1.8% 향상됨&lt;/li&gt;
  &lt;li&gt;각각의 Task 결과가 대부분 SOTA임&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dataset이 적은 Task(MRPC, RTE)의 경우 비교적 높은 성능 향상이 있음&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_13.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Specific layer로 SAN 사용, pairwise ranking을 한 효과를 보여주는 실험&lt;/li&gt;
  &lt;li&gt;BERT vs ST-DNN
    &lt;ul&gt;
      &lt;li&gt;ST-DNN은 BERT처럼 single-task로 fine-tunning함&lt;/li&gt;
      &lt;li&gt;MNLI, QQP, MRPC, QNLI에서 BERT보다 성능이 좋음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ST-DNN vs MT-DNN
    &lt;ul&gt;
      &lt;li&gt;데이터가 적은 실험에서 더 큰 성능향상이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;experiments---domain-adaptation-results&quot;&gt;Experiments - Domain Adaptation Results&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/04/img_14.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SNLI와 SciTail에 MT-DNN을 적용한 실험&lt;/li&gt;
  &lt;li&gt;MT-DNN은 데이터를 0.1%만 써도 성능이 잘나옴&lt;/li&gt;
  &lt;li&gt;MT-DNN이 BERT보다 데이터가 적을 때, 압도적인 성능을 보여줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Multi-task learning model과 pre-training을 결합한 MT-DNN 모델 제안&lt;/li&gt;
  &lt;li&gt;MT-DNN은 SNLI, SchiTail 및 GLUE에서 10가 NLU task에 높은 성능 향상 결과를 얻음&lt;/li&gt;
  &lt;li&gt;MT-DNN은 Domain Adaption 실험에서도 탁월한 일반화 기능을 보여줌&lt;/li&gt;
  &lt;li&gt;MT-DNN 개선을 위해 MTL에서의 모델 구조 공유에 더 깊은 이해, fine-tuning과 pre-training을 위한 더 효과적인 훈련 방법을 더 연구해야함&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...4</summary></entry><entry><title type="html">[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)</title><link href="http://localhost:4000/cs:app/csapp_05/" rel="alternate" type="text/html" title="[CS:APP] Chapter 03. 프로그램의 기계수준 표현 (3.1 역사점 관점 ~ 3.4 정보 접근하기)" /><published>2022-01-25T00:00:00+09:00</published><updated>2022-01-25T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_05</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_05/">&lt;h1 id=&quot;chapter-03-프로그램의-기계수준-표현&quot;&gt;Chapter 03. 프로그램의 기계수준 표현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속되 바이트인 기계어 코드를 실행한다.&lt;/li&gt;
  &lt;li&gt;컴파일러는 프로그램 언어의 규칙, 대상 컴퓨터의 인스트럭션 집합, 운영체제의 관례 등에 따라 기계어 코드를 생성한다.&lt;/li&gt;
  &lt;li&gt;어셈블러 코드로 프로그램을 짤 때는 프로그래머가 계산을 하기 위해 사용해야 하는 저급 인스트럭션들을 명시해야 한다.&lt;/li&gt;
  &lt;li&gt;기계어 코드를 배우면 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내제된 비효율성을 분석할 수 있다.&lt;/li&gt;
  &lt;li&gt;이 장은 X86-64에 기초하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;31-역사적-관점&quot;&gt;3.1 역사적 관점&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;x86이라고 통칭하는 인텔 프로세서 제품군은 오랜 기간 진화를 통한 개발을 해왔다.
    &lt;blockquote&gt;
      &lt;p&gt;대충 엄청 많은 프로세서들이 나열 되는데, 팬티엄4E(2004, 125M 트랜지스터) 하이퍼쓰레딩 기법의 추가와 AMD사에서 개발한 IA32의 64비트 확장 구현인 EM64T가
추가된 해당 모델을 x86-64라고 부른다고 한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;32-프로그램의-인코딩&quot;&gt;3.2 프로그램의 인코딩&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;C 언어에서 gcc 명령은 소스 코드(test.c)를 실행 코드로 변환하기 위해 일련의 프로그램들을 호출한다.
    &lt;ol&gt;
      &lt;li&gt;C 전처리가 #include로 명시된 파일을 코드에 삽입해 주고 #define으로 선언된 매크로를 확장해준다.&lt;/li&gt;
      &lt;li&gt;컴파일러는 소스파일의 어셈블러 버전(test.s)를 생성한다.&lt;/li&gt;
      &lt;li&gt;어셈블러는 어셈블리 코드를 바이너리 목적코드인(test.o)로 변환한다.
        &lt;ul&gt;
          &lt;li&gt;목적코드는 기계어 코드의 한 유형이다. - 모든 인스트럭션과 바이너리 표현을 포함하고 있지만 전역 값들의 주소는 아직 채워지지 않았다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;마지막으로 링커가 목적코드 파일을 라이브러리 함수들을 구현한 코드와 함께 합쳐서 최종 실행 파일인 p를 생성한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;커맨드 라인 옵션으로 -0g를 주면 C 코드의 전체 구조를 따르는 기계어 코드를 생성하는 최적호 수준을 적용한다.
    &lt;ul&gt;
      &lt;li&gt;높은 수준의 최적화를 적용하면 만들어진 코드가 너무 많이 변경되어 본래의 코드와 생성된 기계어 코드 간의 관계를 이해하기 어렵다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;321-기계수준-코드&quot;&gt;3.2.1 기계수준 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 시스템은 보다 간단한 추상화 모델을 이용해서 세부 구현내용을 감추면서 추상화의 여러 가지 다른 형태를 사용하고 있다.
    &lt;ol&gt;
      &lt;li&gt;기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조 즉 “ISA”에 의해 정의된다.
        &lt;ul&gt;
          &lt;li&gt;프로세서의 상태, 인스트럭션의 형식, 프로세서 상태에 대한 각 인스트럭션들의 영향들을 정의한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델을 제공한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일러는 추상화된 실행모델로 표현된 프로그램을 프로세서가 실행하는 매우 기초적인 인스트럭션들로 변환하는 대부분의 일을 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;322-코드-예제&quot;&gt;3.2.2 코드 예제&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기계어 코드의 몇몇 특징과 이들의 역어셈블된 표현에 주목할 필요가 있다.
    &lt;ul&gt;
      &lt;li&gt;x86-64 인스트럭션들은 1에서 15바이트 길이를 갖는다.&lt;/li&gt;
      &lt;li&gt;인스트럭션의 형식은 주어진 시작 위치에서부터 바이트들을 기계어 인스트럭션으로 유일하게 디코딩할 수 있도록 설계한다.&lt;/li&gt;
      &lt;li&gt;역어셈블러는 기계어 코드 파일의 바이트 순서에만 전적으로 의존한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;33-데이터의-형식&quot;&gt;3.3 데이터의 형식&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;인텔 프로세서들이 근본적으로 16비트 구조를 사용하다가 추후에 32비트로 확장했기 때문에 인텔은 “워드”라는 단어를 16비트 데이터 타입을 말할 때 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;34-정보-접근하기&quot;&gt;3.4 정보 접근하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;x86-64 주처리장치 CPU는 64비트 값을 저장할 수 있는 16개의 범용 레지스터를 보유하고 있다.
    &lt;ul&gt;
      &lt;li&gt;이들 레지스터는 정수 데이터와 포인터를 저장하는데 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;341-오퍼랜드-식별자-specifier&quot;&gt;3.4.1 오퍼랜드 식별자 specifier&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다.&lt;/li&gt;
  &lt;li&gt;오퍼랜드는 연산을 수행할 소스 값과 그 결과를 저장할 목적지의 위치를 명시한다.&lt;/li&gt;
  &lt;li&gt;소스 값은 상수로 주어지거나 레지스터나 메모리로부터 읽을 수 있다. 결과 값은 레지스터나 메모리에 저장된다.&lt;/li&gt;
  &lt;li&gt;세가지 타입으로 나뉘어짐
    &lt;ol&gt;
      &lt;li&gt;immediate로, 상수값을 말한다.&lt;/li&gt;
      &lt;li&gt;register는 레지스터의 내용을 나타내며&lt;/li&gt;
      &lt;li&gt;Memory, 메모리 참조로 유효주소라고 부르는 계산된 주소에 의해 메모리 위치에 접근하게 된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;342-데이터-이동-인스트럭션&quot;&gt;3.4.2 데이터 이동 인스트럭션&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가장 많이 사용되는 인스트럭션은 데이터를 한 위치에서 다른 위치로 복사하는 명령어다.
    &lt;ul&gt;
      &lt;li&gt;MOV 클래스 : 소스 위치에서 데이터를 목적지 위치로 어떤 변환도 하지 않고 복사한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;소스 오퍼랜드는 상수, 레지스터 저장 값, 메모리 저장 값을 표시한다.&lt;/li&gt;
  &lt;li&gt;목적 오퍼랜드는 레지스터 또는 메모리 주소의 위치를 지정한다.&lt;/li&gt;
  &lt;li&gt;x86-64는 데이터 이동 인스트럭션에서 두 개의 오퍼랜드 모두가 메모리 위치에 올 수 없도록 제한하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_6.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;343-코드-예제&quot;&gt;3.4.3 코드 예제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;C언어에서 “포인터”라고 부르는 것이 어셈블리어에서는 단순히 주소를 나타낸다.&lt;/li&gt;
    &lt;li&gt;포인터를 역참조하는 것은 포인터를 레지스터에 복사하고, 이 레지스터를 메모리 참조에 사용하는 과정으로 이루어진다.&lt;/li&gt;
    &lt;li&gt;지역변수들은 메모리에 저장되기보다는 종종 레지스터에 저장된다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;344-스택-데이터의-저장과-추출-pushpop&quot;&gt;3.4.4 스택 데이터의 저장과 추출 push,pop&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;push와 pop은 프로그램 스택에 데이터를 저장(push)하거나 스택에서 데이터를 추출(pop)하기 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;스택은 프로시저 호출을 처리하는 데 중요한 역할을 한다.&lt;/li&gt;
  &lt;li&gt;프로그램 스택은 메모리의 특정 영역에 위치한다.&lt;/li&gt;
  &lt;li&gt;스택의 탑top 원소가 모든 스택 원소 중에서 가장 낮은 주소를 갖는 형태다.&lt;/li&gt;
  &lt;li&gt;스택은 pop이 되어도 stack의 top을 표현하는 주소가 올라간거지 값은 여전히 pop이 된 위치에 남아있다.&lt;/li&gt;
  &lt;li&gt;스택이 프로그램 코드와 다른 형태의 프로그램 데이터와 동일한 메모리에 저장되기 때문에 프로그램들은 표준 메모리 주소지정 방법을 사용해서 스택 내 임의의 위치에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/05/img_7.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 05</summary></entry><entry><title type="html">[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_03/" rel="alternate" type="text/html" title="[NLP/Paper]ELMO - Deep contextualized word representations 논문 리뷰" /><published>2022-01-24T00:00:00+09:00</published><updated>2022-01-24T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_03</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_03/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-trained word representations are a key component in many neural language understanding models.&lt;/li&gt;
  &lt;li&gt;Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.&lt;/li&gt;
  &lt;li&gt;We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.&lt;/li&gt;
  &lt;li&gt;In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;related-works&quot;&gt;Related Works&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.&lt;/li&gt;
  &lt;li&gt;워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.
    &lt;ul&gt;
      &lt;li&gt;context2vec&lt;/li&gt;
      &lt;li&gt;CoVe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;model&quot;&gt;Model&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ELMO
    &lt;ul&gt;
      &lt;li&gt;ELMO word representations are functions of the entire input sentence.&lt;/li&gt;
      &lt;li&gt;They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.&lt;/li&gt;
      &lt;li&gt;This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pretrained BiLM&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;
&lt;img src=&quot;../../assets/img/nlp/03/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Task-specific ELMo Embedding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Using biLMs for supervised NLP tasks
    &lt;ul&gt;
      &lt;li&gt;기존의 임베딩 벡터와 함께 사용된다.&lt;/li&gt;
      &lt;li&gt;ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;6개의 NLP task에서 에러율을 6~20% 줄였다.&lt;/li&gt;
  &lt;li&gt;6개의 NLP task에서 높은 점수를 기록했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;analysis&quot;&gt;Analysis&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/03/img_6.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기존에 top layer output만 사용 한 것 대비 성능 향상을 검증했다.&lt;/li&gt;
  &lt;li&gt;대부분의 경우 Regularization parameter λ 가 작을수록 성능이 더 좋아지는 경향이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/nlp/03/img_7.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/nlp/03/img_8.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.&lt;/li&gt;
  &lt;li&gt;biLM에서는 문맥을 고려한다는 것을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/nlp/03/img_9.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.&lt;/li&gt;
  &lt;li&gt;이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/nlp/03/img_10.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.&lt;/li&gt;
  &lt;li&gt;Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...3</summary></entry><entry><title type="html">[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_02/" rel="alternate" type="text/html" title="[NLP/Paper]MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰" /><published>2022-01-23T00:00:00+09:00</published><updated>2022-01-23T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_02</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_02/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나&lt;/li&gt;
  &lt;li&gt;Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델&lt;/li&gt;
  &lt;li&gt;NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음
    &lt;ul&gt;
      &lt;li&gt;Machine Translation, Abstract Text Summarization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;encoder-attention-decoder&quot;&gt;Encoder-Attention-Decoder&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형&lt;/li&gt;
  &lt;li&gt;Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;related-works&quot;&gt;Related Works&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train&lt;/li&gt;
  &lt;li&gt;GPT는 Language Modeling을 위해 Decoder를 Pre-train&lt;/li&gt;
  &lt;li&gt;이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;massmasked-sequence-to-sequence-pre-training&quot;&gt;MASS:Masked Sequence to Sequence Pre-training&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자&lt;/li&gt;
  &lt;li&gt;Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking&lt;/li&gt;
  &lt;li&gt;마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴&lt;/li&gt;
  &lt;li&gt;Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공&lt;/li&gt;
  &lt;li&gt;Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선&lt;/li&gt;
  &lt;li&gt;Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터&lt;/li&gt;
  &lt;li&gt;하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능&lt;/li&gt;
  &lt;li&gt;BERT Masked LM
    &lt;ul&gt;
      &lt;li&gt;K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GPT Standard LM
    &lt;ul&gt;
      &lt;li&gt;하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨&lt;/li&gt;
      &lt;li&gt;Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;m - Input sequence의 전체길이&lt;/li&gt;
  &lt;li&gt;u - Maskinge된 Fragment의 시작점&lt;/li&gt;
  &lt;li&gt;v - Masking된 Fragment의 끝점&lt;/li&gt;
  &lt;li&gt;X^u - u부터 v까지의 fragment&lt;/li&gt;
  &lt;li&gt;X^\u:v - u부터 v까지 Making된 Input Sequence&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;experiments&quot;&gt;Experiments&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Model Configuration
    &lt;ul&gt;
      &lt;li&gt;1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datasets
    &lt;ul&gt;
      &lt;li&gt;2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M&lt;/li&gt;
      &lt;li&gt;MASS의 효과 검증을 위한 low-resource language Romanian&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pre-training Details
    &lt;ul&gt;
      &lt;li&gt;Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;experimentunsupervised-machine-translation&quot;&gt;Experiment:Unsupervised Machine Translation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행&lt;/li&gt;
  &lt;li&gt;Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델&lt;/li&gt;
  &lt;li&gt;MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentlow-resource-translation&quot;&gt;Experiment:Low-resource Translation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_6.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역&lt;/li&gt;
  &lt;li&gt;Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트&lt;/li&gt;
  &lt;li&gt;MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가&lt;/li&gt;
  &lt;li&gt;데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentabstractive-summarization&quot;&gt;Experiment:Abstractive Summarization&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_7.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교&lt;/li&gt;
  &lt;li&gt;MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentconversational-response-generation&quot;&gt;Experiment:Conversational Response Generation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_8.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교&lt;/li&gt;
  &lt;li&gt;MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-probability-formulation&quot;&gt;The probability formulation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_9.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL&lt;/li&gt;
  &lt;li&gt;하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과&lt;/li&gt;
  &lt;li&gt;실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨
    &lt;ul&gt;
      &lt;li&gt;문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;couclusion&quot;&gt;Couclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록&lt;/li&gt;
  &lt;li&gt;Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정&lt;/li&gt;
  &lt;li&gt;또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...2</summary></entry><entry><title type="html">[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)</title><link href="http://localhost:4000/cs:app/csapp_04/" rel="alternate" type="text/html" title="[CS:APP] Chapter 02. 정보의 표현과 처리 (2.4 부동소수점)" /><published>2022-01-23T00:00:00+09:00</published><updated>2022-01-23T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_04</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_04/">&lt;h1 id=&quot;chapter-02-정보의-표현과-처리&quot;&gt;Chapter 02. 정보의 표현과 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;2.1 정보의 저장
    &lt;ul&gt;
      &lt;li&gt;컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.2 정수의 표시
    &lt;ul&gt;
      &lt;li&gt;인코딩, 비부호형 및 2의보수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.3 정수의 산술연산
    &lt;ul&gt;
      &lt;li&gt;비부호형 및 2의보수의 덧셈,뺄셈,곱셉,나눗셈&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;24-부동소수점&quot;&gt;2.4 부동소수점&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;부동소수점 표현은 V = x*2^y 형태의 소수를 인코딩한다.&lt;/li&gt;
  &lt;li&gt;거의 모든 컴퓨터가 IEEE 부동소수점이라고 알려지게 된 방식을 지원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;241-비율이진수fractional-binary-numbers&quot;&gt;2.4.1 비율이진수(Fractional Binary Numbers)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;부동소수점에 대해서 이해하기 위한 첫 단계는 비율 이진수에 대해 생각해보는 것이다.
    &lt;ul&gt;
      &lt;li&gt;숫자들의 자리값은 십진 소수점 부호(‘.’)에 상대적으로 정의된다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/04/img.png&quot; width=&quot;20%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;위와 같은 방식으로 binary 표기법으로 생각해보자.
    &lt;ul&gt;
      &lt;li&gt;부호 ‘.’는 이진 소수점이 되고, 좌측의 브트들은 비음수의 2의 제곱을 자리값으로 가지며, 우측은 2의 음의 제곱을 자리값으로 갖는다.&lt;/li&gt;
      &lt;li&gt;이진 소수점을 한 자리 우측으로 이동하면 2로 곱한 효과, 좌측으로 이동하면 2로 나눈 효과를 가진다.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/04/img_1.png&quot; width=&quot;20%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이진수 표기는 x*2^y로 나타낼 수 있는 수만 표시할 수 있다.&lt;/li&gt;
  &lt;li&gt;이진 표시를 길게 늘려서 정확도를 높이도록 근사해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;242-ieee-부동소수점-표시&quot;&gt;2.4.2 IEEE 부동소수점 표시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IEEE 부동소수점 표준은 수를 V = (-1)^s&lt;em&gt;M&lt;/em&gt;2^E 형태로 나타낸다
    &lt;ul&gt;
      &lt;li&gt;s는 음수와 양수를 결정한다.&lt;/li&gt;
      &lt;li&gt;유효숫자 M은 비율 이진수다.&lt;/li&gt;
      &lt;li&gt;지수 E는 2의 제곱으로 자리값을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부동소수점 수의 비트 표시는 이 값들을 인코딩하기 위해 세 개의 필드로 나누어진다.
    &lt;ul&gt;
      &lt;li&gt;한 개의 부호 비트 s는 부호 s를 직접 인코딩한다.&lt;/li&gt;
      &lt;li&gt;k비트 지수 필드 exp = ek-1…e1e0는 지수 E를 인코딩한다.&lt;/li&gt;
      &lt;li&gt;n비트 비율 필드 frac = fn-1 … f1f0는 유효숫자 M을 인코딩한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/04/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Case 1: 정규화 값 Normalized Values
    &lt;ul&gt;
      &lt;li&gt;가장 일반적인 경우&lt;/li&gt;
      &lt;li&gt;exp의 비트 패턴이 모두 0은 아니며, 모두 1이 아니어야 한다.&lt;/li&gt;
      &lt;li&gt;E = e - Bias (Bias = 2^(k-1) - 1)&lt;/li&gt;
      &lt;li&gt;비율 필드 frac은 비율 값 f&lt;/li&gt;
      &lt;li&gt;유효 숫자 M = 1 + f 로 정의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Case 2: 비정규화 값 Denormalized Values
    &lt;ul&gt;
      &lt;li&gt;지수 필드가 모두 0일 때 나타낸 수는 비정규화 형태를 갖는다.&lt;/li&gt;
      &lt;li&gt;E = 1 - Bias&lt;/li&gt;
      &lt;li&gt;M = f = 0&lt;/li&gt;
      &lt;li&gt;비정규화 숫자들의 기능은 0.0에 매우 가까운 값들을 나타냄
        &lt;ul&gt;
          &lt;li&gt;이들은 점증적 언더플로우라고 알려진 특성을 제공 (가능한 숫자 값들이 0.0 근처에서 같은 간격을 갖는다는 의미)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Case 3: 특수 값 Special Values
    &lt;ul&gt;
      &lt;li&gt;지수 필드가 모두 1인 경우
        &lt;ul&gt;
          &lt;li&gt;비율 필드가 모두 0이면, 결과값은 무한대를 나타냄&lt;/li&gt;
          &lt;li&gt;비율 필드가 0이 아니면 NaN(not a numbuer)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/04/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;243-숫자-예제&quot;&gt;2.4.3 숫자 예제&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/04/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;244-근사법-rounding&quot;&gt;2.4.4 근사법 Rounding&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;부동소수점 산술연산은 표시방법이 제한된 범위와 정밀도를 갖기 때문에 실제 연산의 근사값을 사용할 수밖에 없다.&lt;/li&gt;
  &lt;li&gt;“가장 유사한” 값 x를 체계적으로 계산하는 방법을 근사rounding 연산이다.&lt;/li&gt;
  &lt;li&gt;네가지 근사 모드를 정의함
    &lt;ul&gt;
      &lt;li&gt;짝수근사법(round-to-even): 가장 가까운 값, 중간에 위치할 경우 짝수를 향해 근사함&lt;/li&gt;
      &lt;li&gt;영방향근사 모드(round toward-zero): 양수 값을 아래쪽으로, 음수를 위쪽으로 근사함&lt;/li&gt;
      &lt;li&gt;하향근사 모드(round-down): 양수와 음수를 모두 아래쪽으로 근사함&lt;/li&gt;
      &lt;li&gt;상향근사 모드(round-up): 양수와 음수를 모두 위쪽으로 근사함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;245-부동소수점-연산&quot;&gt;2.4.5 부동소수점 연산&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;부동소수점 값 x,y를 실수로 보고, 일부 연산이 실수들에 대해 정의된다면 Round(x,y)가 되는데, 이것은 실수 연산의 정확한 결과 값을 근사한 것이다.&lt;/li&gt;
  &lt;li&gt;부동소수점 덧셈에서 결합법칙이 성립하지 않는 것은 그룹의 특징 중에서 빠진 가장 중요한 부분이다.&lt;/li&gt;
  &lt;li&gt;교환법칙은 성립하지만, 결합벅칙은 성립 되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;c에서-부동소수점&quot;&gt;C에서 부동소수점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;C는 짝수 근사모드를 사용한다.&lt;/li&gt;
  &lt;li&gt;int에서 float로, 숫자는 오버플로우할 수 없지만, 근사될 수 있다.&lt;/li&gt;
  &lt;li&gt;int나 float에서 double로, 정확한 수치 값은 보존될 수 있다.&lt;/li&gt;
  &lt;li&gt;double에서 float로 범위가 더 작아지기 때문에 값이 오버플로우하여 무한대가 될 수 있따.&lt;/li&gt;
  &lt;li&gt;float나 double에서 int로, 값은 0 방향으로 근사된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;25-요약&quot;&gt;2.5 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정보를 비트로 인코딩하며, 이들은 일반적으로 연속된 바이트들로 구성된다.&lt;/li&gt;
  &lt;li&gt;대부분의 머신들은 정수를 인코딩하기 위해 2의 보수를 사용하고 부동소수점을 인코딩하기 위해 IEEE 표준 754를 사용한다.&lt;/li&gt;
  &lt;li&gt;부호형 및 비부호형 정수를 캐스팅할 때 비트 패턴을 유지하려고 하는데, T2U, U2T 함수들에 의해 나타난다.&lt;/li&gt;
  &lt;li&gt;제한된 길이는 숫자들이 나타낼 수 있는 범위를 넘어설 때 오버플로우를 발생시킨다.&lt;/li&gt;
  &lt;li&gt;비부호형과 2의 보수 산술연산은 결합법칙, 교환법칙, 분배법칙 등의 정수 산술연산의 많은 특성을 만족한다.&lt;/li&gt;
  &lt;li&gt;결합법칙, 교환법칙, 분배법칙 특성을 쉬프트와 2의 제곱의 곱셈 간 관계와 함께 사용된다.&lt;/li&gt;
  &lt;li&gt;부동소수점 산술연산은 매우 조심스럽게 사용해야한다.
    &lt;ul&gt;
      &lt;li&gt;제한된 범위와 정밀도를 갖기 때문이며, 결합법칙 같은 일반적인 수학 법칙을 따르지 않기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부동소수점을 마지막으로 Chapter2 정보의 표현과 처리를 마무리하였다. 데이터 엔지니어링 인턴 포지션에서 ETL 작업을 하며 소수점 데이터에 접근 했을 때 
R코드와 Python의 소수 처리 방식이 달라서 해당 오류를 잡는데 많은 시간이 걸린 경험이 있었다. 그 때 당시에는 대충 방식이 다르구나~ 로 끝났지만, 이번 챕터를
공부하게 되면서 아 부동소수점의 표현 방식 때문에(책은 C를 기준으로 하고 있지만,,,) 그런 오류가 잡혔던 거구나 하고 시야가 조금 더 넓어진 것 같다. 
2.2절의 캐스팅과 2.4절의 부동소수점을 공부하면서 꽤 많은 애를 먹었지만, 앞으로 코딩을 하면서 캐스팅이나 소수점을 다룰 때 더 주의 깊게 다룰 수 있을 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 04</summary></entry><entry><title type="html">[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)</title><link href="http://localhost:4000/cs:app/csapp_02/" rel="alternate" type="text/html" title="[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_02</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_02/">&lt;h1 id=&quot;chapter-02-정보의-표현과-처리&quot;&gt;Chapter 02. 정보의 표현과 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.&lt;/li&gt;
  &lt;li&gt;비트 패턴
    &lt;ul&gt;
      &lt;li&gt;이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.&lt;/li&gt;
      &lt;li&gt;표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인코딩
    &lt;ul&gt;
      &lt;li&gt;비부호형 : 전통적인 이진수 표시 사용&lt;/li&gt;
      &lt;li&gt;부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법&lt;/li&gt;
      &lt;li&gt;부동소수점 : 2진수 버전의 소수 표시방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-정보의-저장&quot;&gt;2.1 정보의 저장&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급&lt;/li&gt;
  &lt;li&gt;메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음&lt;/li&gt;
  &lt;li&gt;모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;211-16진수-표시&quot;&gt;2.1.1 16진수 표시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1바이트는 8비트로 이루어짐&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&amp;gt; 16진수 사용&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;16진수 &amp;lt;-&amp;gt; 10진수 &amp;lt;-&amp;gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;212-데이터의-크기&quot;&gt;2.1.2 데이터의 크기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨
    &lt;ul&gt;
      &lt;li&gt;w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐&lt;/li&gt;
      &lt;li&gt;프로그램은 최대 2^w 바이트에 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/01.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;213-주소지정과-바이트-순서&quot;&gt;2.1.3 주소지정과 바이트 순서&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정
    &lt;ul&gt;
      &lt;li&gt;객체의 주소가 무엇이 되어야 하는지&lt;/li&gt;
      &lt;li&gt;메모리에 바이트들을 어떻게 정렬해야 하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.
    &lt;ul&gt;
      &lt;li&gt;가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]&lt;/li&gt;
      &lt;li&gt;가장 덜 중요한 바이트 : [x7, x6, . . . , x0]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바이트 저장 방법
    &lt;ul&gt;
      &lt;li&gt;리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는&lt;/li&gt;
      &lt;li&gt;빅 엔디안 : 가장 중요한 바이트가 먼저 오는&lt;/li&gt;
      &lt;li&gt;대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바이트 순서가 이슈가 되는 경우
    &lt;ul&gt;
      &lt;li&gt;이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때
        &lt;ul&gt;
          &lt;li&gt;리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정수 데이터를 나타내는 바이트들을 살펴볼 때&lt;/li&gt;
      &lt;li&gt;프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;214-스트링의-표시&quot;&gt;2.1.4 스트링의 표시&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;그냥 ASCII를 사용한다는 내용,,,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;215-코드의-표현&quot;&gt;2.1.5 코드의 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img02.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;216-부울-boolean-대수&quot;&gt;2.1.6 부울 Boolean 대수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;NOT : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;AND : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;OR : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EXCLUSIVE-OR : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;217-c에서의-비트수준-연산&quot;&gt;2.1.7 C에서의 비트수준 연산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C에서는 비트들 간의 부울 연산을 지원&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_1.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;마스크: 비트 연산에 사용되는 데이터&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;219-c에서의-쉬프트-연산&quot;&gt;2.1.9 C에서의 쉬프트 연산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공&lt;/li&gt;
  &lt;li&gt;x « k
    &lt;ul&gt;
      &lt;li&gt;x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;x » k
    &lt;ul&gt;
      &lt;li&gt;좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.&lt;/li&gt;
      &lt;li&gt;논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움&lt;/li&gt;
      &lt;li&gt;산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-정수의-표시&quot;&gt;2.2 정수의 표시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;221-정수형-데이터-타입&quot;&gt;2.2.1 정수형 데이터 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.&lt;/li&gt;
  &lt;li&gt;64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위
    &lt;ul&gt;
      &lt;li&gt;음수의 범위가 양의 범위보다 1 더 넓은 것에 주목&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;222-비부호형의-인코딩&quot;&gt;2.2.2 비부호형의 인코딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;음수 값을 포함하지 않음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B2U는 Binary 에서 Unsigned의 줄임말&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;
&lt;img src=&quot;../../assets/img/csapp/02/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;223-2의-보수-twos-complement-인코딩&quot;&gt;2.2.3 2의 보수 two’s complement 인코딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;음수 값을 포함&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B2T는 Binary 에서 Two’s complement의 줄임말&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;
&lt;img src=&quot;../../assets/img/csapp/02/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며, 
부호형 수에 대해서 특정 표시를 가정해서도 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;224-비부호형과-부호형-간의-변환&quot;&gt;2.2.4 비부호형과 부호형 간의 변환&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.&lt;/li&gt;
  &lt;li&gt;2의 보수에서 비부호형으로의 변환
    &lt;ul&gt;
      &lt;li&gt;TMin ≤ x ≤ TMax를 만족하는 x에 대해&lt;br /&gt; x가 0보다 크거나 같으면 x&lt;br /&gt;x가 0보다 작으면 x+2^w&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;비부호형에서 2의 보수로의 변환
    &lt;ul&gt;
      &lt;li&gt;0 ≤ u ≤ UMax를 만족하는 u에 대해&lt;br /&gt;u가 TMax보다 작거나 같으면 u&lt;br /&gt;u가 TMax보다 크면 u-2^w&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;이유는 T2U의 이유와 동일하다.&lt;br /&gt;
이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;225-c에서-부호형과-비부호형의-비교&quot;&gt;2.2.5 C에서 부호형과 비부호형의 비교&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;C에서는 부호형과 비부호형 산술연산을 지원한다.
    &lt;ul&gt;
      &lt;li&gt;C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.
&lt;img src=&quot;../../assets/img/csapp/02/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;226-수의-비트-표시를-확장하기&quot;&gt;2.2.6 수의 비트 표시를 확장하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;영의 확장 zero extension 이라고 알려짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.
    &lt;ul&gt;
      &lt;li&gt;부호 확장 sign extension 이라고 알려짐&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;227-숫자의-절삭&quot;&gt;2.2.7 숫자의 절삭&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비트의 개수를 줄이는 경우이다.
    &lt;ul&gt;
      &lt;li&gt;eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비부호형 수의 절삭
    &lt;ul&gt;
      &lt;li&gt;x’ = x mod 2^k 이다.
        &lt;ul&gt;
          &lt;li&gt;삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.&lt;/li&gt;
          &lt;li&gt;자리값들은 모듈(mod) 계산으로 모두 0이 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 보수 숫자의 절삭
    &lt;ul&gt;
      &lt;li&gt;x’ = U2T(x mod 2^k) 이다.
        &lt;ul&gt;
          &lt;li&gt;가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;228-signed와-unsigned에-관한-조언&quot;&gt;2.2.8 Signed와 Unsigned에 관한 조언&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.&lt;/li&gt;
  &lt;li&gt;비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다.
위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 02</summary></entry><entry><title type="html">[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)</title><link href="http://localhost:4000/cs:app/csapp_03/" rel="alternate" type="text/html" title="[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산)" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_03</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_03/">&lt;h1 id=&quot;chapter-02-정보의-표현과-처리&quot;&gt;Chapter 02. 정보의 표현과 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;2.1 정보의 저장
    &lt;ul&gt;
      &lt;li&gt;컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.2 정수의 표시
    &lt;ul&gt;
      &lt;li&gt;인코딩, 비부호형 및 2의보수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-정수의-산술연산&quot;&gt;2.3 정수의 산술연산&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개의 양수를 더해서 음수가 나오는 경우, x&amp;lt;y와 x-y&amp;lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,
    &lt;ul&gt;
      &lt;li&gt;그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;231-비부호형-덧셈&quot;&gt;2.3.1 비부호형 덧셈&lt;/h3&gt;
&lt;p&gt;x,y, 0≤x, y≤e^w가 있다고 하자, 두 합의 계산 범위는 0≤x+y≤2^(w+1)-2를 갖는다. 이 합의 크기를 표현 하기 위해서는 w+1개의 비트가 필요하게 된다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“워드 크기 증가”는 산술연산의 결과를 완벽하게 표시하려면 필요한 워드 크기를 제한할 수 없다는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어들은 고정길이 산술연산을 지원하며 따라서 “덧셈”과 “곱셈”같은 연산은 정수에 대응하는 일반적인 연산들과는 다르다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;x,y에 대해 x+y 정수합을 w비트 길이로 절삭한 후에 다시 비부호형 정수로 나타낸다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상적인 경우에는 x+y값을 유지하지만, 오버플로우의 경우에는 2^w만큼 줄어드는 효과를 낸다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_1.png&quot; width=&quot;30%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;산술연산에서 완전한 정수 결과가 그 데이터 타입의 제한된 워드 길이로 나타낼 수 없을 때 이 연산은 “오버플로우한다”고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;232-2의-보수의-덧셈&quot;&gt;2.3.2 2의 보수의 덧셈&lt;/h3&gt;
&lt;p&gt;2의 보수 덧셈의 결과값이 너무 크거나(양수) 또는 너무 작아서(음수) 표시할 수 없을 때 우리는 어떻게 해야 할지 결정해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;x+y를 w비트 길이로 절삭한 후에 2의 보수로 결과를 나타내는 연산이다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;
  &lt;img src=&quot;../../assets/img/csapp/03/img_3.png&quot; width=&quot;30%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2의 보수의 합이 2^(w-1)을 넘어간다면 양수 오버플로우가 생기고, -2^(w-1) 미만으로 내려간다면 음수 오버플로우가 생겨 각각에 2^w을 더해주거나 빼준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;233-2의-보수에서의-비트반전-negation&quot;&gt;2.3.3 2의 보수에서의 비트반전 Negation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비부호형 비트반전&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_4.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2의보수 비트반전&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_5.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;234-비부호형-곱셈&quot;&gt;2.3.4 비부호형 곱셈&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비부호형 곱셉은 2w비트 정수 곱의 하위 w비트로 주어지는 w비트 값을 만드는 것으로 정의된다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비부호형 수를 w비트로 절삭하는 것은 해당 값을 2^w로 나눈 나머지를 계싼하는 것과 같다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_6.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;235-2의-보수-곱셈&quot;&gt;2.3.5 2의 보수 곱셈&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;2^w로 나눈 나머지를 취하고 비부호형에서 2의 보수형태로 변환하는 것과 같다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/03/img_7.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;236-상수를-사용한-곱셈&quot;&gt;2.3.6 상수를 사용한 곱셈&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정수 곱셉은 매우 느리다. 컴파일러에서 수행되는 중요한 최적화는 상수를 곱하게 되는 경우들을 쉬프트와 덧셈의 조합으로 대체한다.&lt;/li&gt;
  &lt;li&gt;2의 제곱을 곱하는 경우
    &lt;ul&gt;
      &lt;li&gt;k≥0인 모든 k에 대해 x2^k의 w+k 비트수준 표현은 우측에 k개의 0을 추가한 것이다.&lt;/li&gt;
      &lt;li&gt;eg) 11은 w=4인 경우 [1011]이다. 이것을 왼쪽으로 k=2 쉬프트 하면 [101100]이 되며 이것은 11*4=44를 인코딩한 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 제곱을 곱하면 비부형이건 2의 보수 산술연산이건 오버플로우가 발생할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;eg) 위의 예제를 예로 들자면, [101100]을 4비트로 절삭하면 &lt;a href=&quot;십진수 12 = 44mod16&quot;&gt;1100&lt;/a&gt;을 얻는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정수 곱셈이 쉬프트와 덧셈을 사용하는 것보다 훨씬 비용이 많이 드는 연산이기 때문에 C 컴파일러들은 정수가 상수와 곱해지는 경우에 이들을 쉬프트, 덧셈, 뺄셈 등의 조합을 사용해서 제거하려고 노력한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;237-2의-제곱으로-나눗셈하기&quot;&gt;2.3.7 2의 제곱으로 나눗셈하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;정수 나눗셈은 정수 곱셉보다 훨씬 느리다. 2의 제곱으로 나누는 것은 오른쪽 쉬프트를 사용한다.&lt;/li&gt;
  &lt;li&gt;비부호형은 논리 쉬프트, 2의 보수는 산술 쉬프트를 사용한다.&lt;/li&gt;
  &lt;li&gt;2의 보수 음수에서는 보정값을 더해서 결과값을 0 방향으로 근사하도록 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;238-정수-산술연산에-대한-마지막-고찰&quot;&gt;2.3.8 정수 산술연산에 대한 마지막 고찰&lt;/h3&gt;
&lt;p&gt;컴퓨터에서 실행되는 “정수” 산술연산은 실제로는 modular 산술연산의 형태로 수행된다. 숫자를 표현하기 위해 유한한 길이의 워드를 사용하기 때문에 가능한 값의 범위가 제한되며 연산의 결과가 오버플로우될 수 있다.&lt;/p&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 03</summary></entry><entry><title type="html">[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산</title><link href="http://localhost:4000/java/java_02/" rel="alternate" type="text/html" title="[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_02</id><content type="html" xml:base="http://localhost:4000/java/java_02/">&lt;h1 id=&quot;part1-자바-시작하기&quot;&gt;Part1 자바 시작하기&lt;/h1&gt;
&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향언어&lt;/li&gt;
  &lt;li&gt;C,C++ 문법을 기본으로 개발
    &lt;ul&gt;
      &lt;li&gt;C언어에 객체지향 특성 확장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플랫폼에 독립적임
    &lt;ul&gt;
      &lt;li&gt;JVM으로 인해서 어떤 플랫폼에서도 실행 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌&lt;/li&gt;
  &lt;li&gt;JDK : Java Development Kit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;java-개발순서&quot;&gt;JAVA 개발순서&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;코드 작성&lt;/li&gt;
  &lt;li&gt;코드 컴파일&lt;/li&gt;
  &lt;li&gt;컴파일한 소스를 JVM을 이용하여 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;주석문&quot;&gt;주석문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//&lt;/code&gt; : 행단위 주석&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/* */&lt;/code&gt; : 블럭단위 주석&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/** ..*.. */&lt;/code&gt; : 문서화 주석&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;part2-변수와-계산&quot;&gt;Part2 변수와 계산&lt;/h1&gt;

&lt;h2 id=&quot;변수&quot;&gt;변수&lt;/h2&gt;
&lt;p&gt;변수 값(Data)을 저장할 수 있는 메모리 공간&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨&lt;/li&gt;
  &lt;li&gt;java 식별자 명명 규칙
    &lt;ul&gt;
      &lt;li&gt;첫 번째 글자는 문자 이거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 이어야 함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 이외의 특수문자는 사용 불가능&lt;/li&gt;
      &lt;li&gt;키워드는 식별자로 사용할 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;java 변수 명명 관례
    &lt;ul&gt;
      &lt;li&gt;첫 번째 문자가 소문자인 명사로 정함&lt;/li&gt;
      &lt;li&gt;여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;를 쓰지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;상수&quot;&gt;상수&lt;/h2&gt;
&lt;p&gt;상수란 수식에서 변하지 않는 값을 의미&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상수의 선언
    &lt;ul&gt;
      &lt;li&gt;final 상수타입 상수명;
        &lt;ul&gt;
          &lt;li&gt;eg) final int J;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상수 명명 관례
    &lt;ul&gt;
      &lt;li&gt;대문자로만 구성된 명사로 정함&lt;/li&gt;
      &lt;li&gt;여러 단어로 구성된 이릠의 경우 단어 사이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;을 써서 구분함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상수를 사용해야 하는 경우
    &lt;ul&gt;
      &lt;li&gt;값이 변하면 위험한 경우에 상수 사용&lt;/li&gt;
      &lt;li&gt;값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;기본형-타입&quot;&gt;기본형 타입&lt;/h2&gt;
&lt;p&gt;기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;논리형
    &lt;ul&gt;
      &lt;li&gt;boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문자형
    &lt;ul&gt;
      &lt;li&gt;char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정수형
    &lt;ul&gt;
      &lt;li&gt;int 4byte, long 8byte&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실수형
    &lt;ul&gt;
      &lt;li&gt;float 4byte, double 9byte&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리터럴
    &lt;ul&gt;
      &lt;li&gt;CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어&lt;/li&gt;
      &lt;li&gt;리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 방법
    &lt;ul&gt;
      &lt;li&gt;long : 값을 적을 때 뒤에 l이나 L 적어야함&lt;/li&gt;
      &lt;li&gt;float : 값을 적을 때 뒤에 f나 F를 적어야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;기본형-타입변환&quot;&gt;기본형 타입변환&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;묵시적 형변환
    &lt;ul&gt;
      &lt;li&gt;크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명시적 형변환
    &lt;ul&gt;
      &lt;li&gt;크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함&lt;/li&gt;
      &lt;li&gt;eg) long x = 20; int y = (int) x;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;연산자-우선순위&quot;&gt;연산자 우선순위&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최우선연산자 ( ., [], () )&lt;/li&gt;
  &lt;li&gt;단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&amp;gt;부호&amp;gt;증감)
    &lt;ul&gt;
      &lt;li&gt;단, 후위연산자(a++)은 우선순위가 낮음&lt;/li&gt;
      &lt;li&gt;eg) a=5, x = a++ - 5 라면 x는 0, a는6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;산술연산자 ( *,/,%,+,-,shift) &amp;lt; 시프트연산자 ( »,«,»&amp;gt; ) &amp;gt;&lt;/li&gt;
  &lt;li&gt;비교연산자 ( &amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,==,!= )&lt;/li&gt;
  &lt;li&gt;비트연산자 ( &amp;amp;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;,,~ )&lt;/li&gt;
  &lt;li&gt;논리연산자 (&amp;amp;&amp;amp; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; , !)&lt;/li&gt;
  &lt;li&gt;삼항연산자 (조건식) ? :&lt;/li&gt;
  &lt;li&gt;대입연산자 =,*=,/=,%=,+=,-=&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="프로그래머스 자바 입문" /><summary type="html">프로그래머스 자바 입문 강의 - 01</summary></entry><entry><title type="html">[Java/프로그래머스] Part3 제어문</title><link href="http://localhost:4000/java/java_03/" rel="alternate" type="text/html" title="[Java/프로그래머스] Part3 제어문" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_03</id><content type="html" xml:base="http://localhost:4000/java/java_03/">&lt;h1 id=&quot;part3-제어문&quot;&gt;Part3 제어문&lt;/h1&gt;

&lt;h2 id=&quot;if-조건문&quot;&gt;if 조건문&lt;/h2&gt;
&lt;p&gt;조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;if 문&lt;/li&gt;
  &lt;li&gt;if - else 문&lt;/li&gt;
  &lt;li&gt;if - else if - else 문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;논리-연산자&quot;&gt;논리 연산자&lt;/h2&gt;
&lt;p&gt;논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;OR :&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;AND : &amp;amp;&amp;amp;&lt;/li&gt;
  &lt;li&gt;NOT : !&lt;/li&gt;
  &lt;li&gt;EXCLUSIVE-Or : ^&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;삼항-연산자&quot;&gt;삼항 연산자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조건식 ? 피연산자1 : 피연산자2
    &lt;ul&gt;
      &lt;li&gt;조건식의 결과가 true 라면 결과는 피연산자1&lt;/li&gt;
      &lt;li&gt;조건식의 결과가 false 라면 결과는 피연산자2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;switch문&quot;&gt;switch문&lt;/h2&gt;
&lt;p&gt;switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;변수&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
            &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
            &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.&lt;/li&gt;
  &lt;li&gt;JDK7 이후에는 문자열 타입의 변수도 가능함&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;당연한걸 수도 있지만, case 에 조건문을 달면 오류가 난다 하하,,,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;while문&quot;&gt;while문&lt;/h2&gt;
&lt;p&gt;조건문의 실행 결과가 true일 동안 반복해서 실행한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조건문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;do-while문&quot;&gt;do while문&lt;/h2&gt;
&lt;p&gt;while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;   &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조건문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;실행문을 한번은 실행하고 싶을 경우에 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;for-반복문&quot;&gt;for 반복문&lt;/h2&gt;
&lt;p&gt;for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;초기화식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;증감식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="프로그래머스 자바 입문" /><summary type="html">프로그래머스 자바 입문 강의 - 02</summary></entry></feed>