<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-01T01:31:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">[CS:APP] Chapter 07 링커</title><link href="http://localhost:4000/csapp/csapp_23/" rel="alternate" type="text/html" title="[CS:APP] Chapter 07 링커" /><published>2022-03-29T00:00:00+09:00</published><updated>2022-03-29T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_23</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_23/"></content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 23</summary></entry><entry><title type="html">[CS:APP] Part 1 프로그램의 구조와 실행 리뷰</title><link href="http://localhost:4000/csapp/csapp_22/" rel="alternate" type="text/html" title="[CS:APP] Part 1 프로그램의 구조와 실행 리뷰" /><published>2022-03-28T00:00:00+09:00</published><updated>2022-03-28T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_22</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_22/">&lt;h1 id=&quot;2-정보의-표현과-처리&quot;&gt;2 정보의 표현과 처리&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;컴퓨터가 실제로 해석하는 비트들과 연산들이 무엇이 있는지 배운다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터는 두 개의 값을 갖는 신호로 정보를 처리한다.&lt;/li&gt;
  &lt;li&gt;이러한 비트를 이진수 체계를 사용해서 양수들로 인코딩하여 사용한다.
    &lt;ul&gt;
      &lt;li&gt;비부호형&lt;/li&gt;
      &lt;li&gt;부호형(2의 보수)&lt;/li&gt;
      &lt;li&gt;부동소수점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정보의-저장&quot;&gt;정보의 저장&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2진수: 컴퓨터의 비트 표현&lt;/li&gt;
  &lt;li&gt;16진수: 비트 패턴을 표시하는데 사용됨(2진수와 10진수는 불편함)&lt;/li&gt;
  &lt;li&gt;비트 표시 방법(xw-1,xw-2,…,x1,x0)
    &lt;ul&gt;
      &lt;li&gt;리틀 엔디안: 가장 덜 중요한 바이트가 먼저 온다.(x0,x1…)&lt;/li&gt;
      &lt;li&gt;빅 엔디안: 가장 중요한 바이트가 먼저 온다.(xw-1,xw-2…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비트 수준 연산
    &lt;ul&gt;
      &lt;li&gt;부울 대수: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;(not),&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;(and),&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;(or),&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt;(exclusive-or)&lt;/li&gt;
      &lt;li&gt;쉬프트
        &lt;ul&gt;
          &lt;li&gt;좌측 쉬프트: « 우측에는 k개의 0 채워짐&lt;/li&gt;
          &lt;li&gt;논리 우측 쉬프트 » 좌측에는 k개의 0 채워짐&lt;/li&gt;
          &lt;li&gt;산술 우측 쉬프트 » 좌측에는 k개의 중요한 비트들이 채워짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정수의-표시&quot;&gt;정수의 표시&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;비부호형과 부호형(2의보수)의 표현 방법에 차이점에 포인트를 두어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부호형(2의 보수) : 맨 앞자리의 비트가 0이면 양수, 1이면 음수로 표현한다.
    &lt;ul&gt;
      &lt;li&gt;ex) 1101 -&amp;gt; 앞자리가 1이므로 -8, 앞자리를 제외한 값이 5 -&amp;gt; -8+5=-3 이렇게 계산한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비부호형과 부호형 간의 변환과 확장, 절삭에서 부호형의 오버플로우가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정수의-계산&quot;&gt;정수의 계산&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;부호형의 덧셈, 곱셈에서 음의 오버플로우와 양의 오버플로우가 발생한다.&lt;/li&gt;
  &lt;li&gt;쉬프트를 사용해서 곱셈이 가능하다.(비용이 훨씬 적게 듬)
    &lt;ul&gt;
      &lt;li&gt;ex) 11(1011[2])*4 = 44(101100[2])&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부동소수점&quot;&gt;부동소수점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;부동소수점 V = x*2^y 형태로 인코딩한다. y는 1/2, 1/4… 와 같은 값&lt;/li&gt;
  &lt;li&gt;근사법 rounding
    &lt;ul&gt;
      &lt;li&gt;부동소수점은 정확한 값을 얻을 수 없다. 그렇기 때문에 근사 연산을 한다.
        &lt;ul&gt;
          &lt;li&gt;짝수근사법, 영방향근사, 하향근사, 상향근사 모드가 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-프로그램의-기계수준-표현&quot;&gt;3 프로그램의 기계수준 표현&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;우리가 코드를 작성하면 컴파일러는 소스파일의 어셈블러 버전을 생성한다. 어셈블러는 해당 어셈블리 코드를 바이너리 목적코드로 변환한다. 이후 목적코드를 컴퓨터가 해석한다.
이번 챕터에서는 어셈블리 코드에 대해 배운다. 이것을 배우게 되면 컴파일러의 최적화 방법을 알 수 있고 코드의 비효율성을 분석할 수 있게된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;프로그램의-인코딩&quot;&gt;프로그램의 인코딩&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 호출방법(c언어 기)
    &lt;ol&gt;
      &lt;li&gt;C 전처리가 #include와 #define을 확장해준다.&lt;/li&gt;
      &lt;li&gt;컴파일러는 소스파일의 어셈블리 코드를 생성한다.(test.c -&amp;gt; test.s)&lt;/li&gt;
      &lt;li&gt;어셈블러는 어셈블리 코드를 바이너리 목적코드로 변환한다.(test.s -&amp;gt; test.o)&lt;/li&gt;
      &lt;li&gt;링커가 목적코드를 라이브러리 함수와 함꼐 최종 실행 파일인 test.p를 생성한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ISA(Instruction Set Architecture): 인스트럭션 집합구조, 프로세서의 상태 및 인스트럭션 형식과 영향을 정의한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션 특성 요약
    &lt;ul&gt;
      &lt;li&gt;오퍼랜드: 데이터와 목적지 위치를 명시한다.&lt;/li&gt;
      &lt;li&gt;레지스터나 메모리로부터 읽고 저장한다.&lt;/li&gt;
      &lt;li&gt;immediate(상수값), register, memory 세가지 타입이 존재한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인스트럭션-종류&quot;&gt;인스트럭션 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 이동: mov
    &lt;ul&gt;
      &lt;li&gt;두 개의 오퍼랜드 모두 메모리 위치에 올 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스택의 저장과 추출: push, pop&lt;/li&gt;
  &lt;li&gt;산술연산: add, sub, imul, idiv, sal(left shift), inc(++1), or, and…&lt;/li&gt;
  &lt;li&gt;유효주소 적재: leaq
    &lt;ul&gt;
      &lt;li&gt;포인터 생성하기 위한 인스트럭션&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조건코드&lt;/code&gt;: CF(carry flag), ZF(zero flag), SF(sign flag), OF(overflow flag)
    &lt;ul&gt;
      &lt;li&gt;cf: 중요한 비트로부터 받아올림이 발생한 것을 표시(오버플로우 검출)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제어문: cmp, test, set
    &lt;ul&gt;
      &lt;li&gt;cmp는 두 오퍼랜드가 같으면 zf를 1로 설정&lt;/li&gt;
      &lt;li&gt;test는 조건 코드만 설정&lt;/li&gt;
      &lt;li&gt;set은 비교후 조건코드를 설정해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;점프: jmp, je, jle…&lt;/li&gt;
  &lt;li&gt;조건부 이동: cmove, cmovg…&lt;/li&gt;
  &lt;li&gt;콜 리턴: call, ret&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;조건부-분기if-else&quot;&gt;조건부 분기(if else)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조건제어: cmp와 jump를 사용함&lt;/li&gt;
  &lt;li&gt;조건부이동: cmove등을 사용함(더 빠름)
    &lt;ul&gt;
      &lt;li&gt;경우를 다 계산하고 이동만함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;반복문for-while&quot;&gt;반복문(for, while)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;cmp와 jump를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로시저&quot;&gt;프로시저&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;call: call하게 되면 이전 주소와 함께 스택 메모리에 올라감&lt;/li&gt;
  &lt;li&gt;return: 후입선출 구조이기 때문에 스택에 있던 이전 주소가 pop되며 retrun 하게됨&lt;/li&gt;
  &lt;li&gt;데이터 전송: 인자는 레지스터로 전송되지만, 6개 이상의 인자를 가지면 초과되는 인자는 스택으로 전달된다.&lt;/li&gt;
  &lt;li&gt;지역 변수: 지역변수 또한 스택 프레임 내에서 생성된다.&lt;/li&gt;
  &lt;li&gt;레지스터: 레지스터는 프로시저 모두가 굥유함. 기존에 사용하던 레지스터를 새로 호출한 함수에서 “saved registers”라는 스택의 일부분을 할당해서 저장하고 보존한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_1.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터의-정렬&quot;&gt;데이터의 정렬&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;사용 가능한 주소를 k의 배수가 되도록 요구한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;버퍼-오버플로우&quot;&gt;버퍼 오버플로우&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스택의 saved registers와 return address 범위를 침범하면 심각한 오류를 발생시킨다.&lt;/li&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;스택 랜덤화: 스택의 위치를 프로그램 실행마다 다르게 해준다.&lt;/li&gt;
      &lt;li&gt;스택 손상 검출: 스택에 canary값을 추가하여 손상되는 것을 감지한다.&lt;/li&gt;
      &lt;li&gt;실행코드 영역 제한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;부동소수점-1&quot;&gt;부동소수점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;정수 연산과 유사하다.&lt;/li&gt;
  &lt;li&gt;부동소수점을 위한 레지스터를 따로 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-프로세서-구조&quot;&gt;4 프로세서 구조&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;하드웨어 시스템이 ISA의 인스트럭션들을 어떻게 실행할 수 있는지를 학습한다. ISA인 “Y86-64”를 직접 만들어보며 학습한다.
이후 SEQ를 기초로 파이프라인형 프로세서 PIPE를 만들어본다. 프로세서는 각 인스트럭션의 실행단계를 5단계로 나누어 처리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머-가시성 상태(programmer-visible state) : 프로그램 레지스터, CC(조건코드), PC, 메모리, Stat(상태코드)를 포함한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인스트럭션-집합y86-64&quot;&gt;인스트럭션 집합(Y86-64)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림처럼 인스트럭션이 인코딩된다.
    &lt;ul&gt;
      &lt;li&gt;인코딩에 1에서 10바이트가 소요된다.&lt;/li&gt;
      &lt;li&gt;OPq는 정수연산이며 ZF,SF,OF 조건코드를 결정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림처럼 인스트럭션에 대한 상세한 특정 인코딩으로 변환된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예외상황y86-64&quot;&gt;예외상황(Y86-64)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Stat(상태코드)를 나타낸다.
    &lt;ul&gt;
      &lt;li&gt;AOK: 정상 실행&lt;/li&gt;
      &lt;li&gt;HLT: halt 인스트럭션 실행(정지 인스트럭션)&lt;/li&gt;
      &lt;li&gt;ADR: 잘못된 메모리 주소를 읽거나 쓸 때&lt;/li&gt;
      &lt;li&gt;INS: 잘못된 인스트럭션을 만났을 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어셈블러를-사용해-어셈블한-결과--목적코드&quot;&gt;어셈블러를 사용해 어셈블한 결과 == 목적코드&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;seq-설계-1-레지스터-파일&quot;&gt;SEQ 설계 1 (레지스터 파일)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEQ는 sequential 프로세서를 의미한다. SEQ를 설계하기 위해서는 SEQ 내에 있는 레지스터 파일을 이해해야 한다.
레지스터 파일을 이해하기 위해서는 논리게이트와 클럭을 이해해야한다.(레지스터 파일이 논리게이트로 이루어져있다.)&lt;/p&gt;

  &lt;p&gt;논리게이트 -&amp;gt; 조합회로 -&amp;gt; (레지스터 연산 = 클럭) -&amp;gt; 레지스터 파일 -&amp;gt; SEQ -&amp;gt; SEQ+ -&amp;gt; PIPE&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리게이트: AND, OR, NOT등의 입력들의 불 함수 출력을 만들어낸다.
    &lt;ul&gt;
      &lt;li&gt;출력과 입력은 0과 1이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조합회로: 여러 논리 게이트를 모아 네트워크를 만들어 계산 블록을 만든다.다&lt;/li&gt;
  &lt;li&gt;클럭: 주기적 신호인 한 개의 클럭에 의해 새 값들이 제어된다.
    &lt;ul&gt;
      &lt;li&gt;클럭을 사용하는 레지스터: 워드나 개별 비트 저장&lt;/li&gt;
      &lt;li&gt;RAM: 주소를 사용해서 여러 워드를 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 연산: 클럭이 상승할 때 레지스터의 입력값이 새값을 가진다.&lt;/li&gt;
  &lt;li&gt;레지스터 파일:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_5.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;seq-설계-2-하드웨어-구조&quot;&gt;SEQ 설계 2 (하드웨어 구조)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 SEQ 하드웨어 구조다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;작업 단계
    &lt;ol&gt;
      &lt;li&gt;선입 fetch: PC를 메모리주소로 사용해 인스트럭션 바이트를 읽어들인다.&lt;/li&gt;
      &lt;li&gt;해독 decode: 레지스터 파일에서 오퍼랜드를 읽어서 valA, valB를 얻는다.&lt;/li&gt;
      &lt;li&gt;실행 excution: ALU(산술/논리 연산)이 인스트럭션이 지시하는 연산을 수행하거나 유효주소 계산 및 스택 포인터 값 변경한다. 조건 코드 및 점프 인스트럭션도 갱신한다. valE&lt;/li&gt;
      &lt;li&gt;메모리 memory: 데이터를 메모리에서 쓰거나 읽어온다. valM&lt;/li&gt;
      &lt;li&gt;재기록 write back: 두 결과를 레지스터 파일에 기록한다.&lt;/li&gt;
      &lt;li&gt;PC 갱신 PC update: PC는 다음 인스트럭션의 주소로 설정된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;SEQ 타이밍
    &lt;ul&gt;
      &lt;li&gt;메모리와 레지스터에 클럭을 공급하며 프로세서의 여러 동작들을 순서대로 제어한다.&lt;/li&gt;
      &lt;li&gt;인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라이닝-원리&quot;&gt;파이프라이닝 원리&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEQ에서는 하나의 인스트럭션을 처리하는데 3~5 클럭정도 소요된다. 하지만, 다양한 단계에서 하나의 인스트럭션이 끝날 때 까지 쉬고 있는 단계가 많다.
이를 사용하기 위해 파이프라이닝 개념을 도입하였다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;파이프라이닝 주요 특징 : 시스템 처리량, 지연시간을 증가 시킨다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_7.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_8.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 그림은 비파이프라인과 파이프라인
    &lt;ul&gt;
      &lt;li&gt;수행 시간을 계산하면 파이프라인이 약 2.5배 빠르지만, 지연시간은 40ps정도 늘어났다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라이닝의-한계&quot;&gt;파이프라이닝의 한계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;각 단계별로 처리 시간이 다르면, 가장 늦은 단계의 시간지연 값에 의해 클럭의 속도가 결정된다.&lt;/li&gt;
  &lt;li&gt;인스트럭션들 간에 데이터 의존성이 존재하면 파이프라이닝이 제한된다.
    &lt;ul&gt;
      &lt;li&gt;피드백을 갖는 파이프라인 시스템이라고도 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pipe-설계&quot;&gt;PIPE 설계&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;SEQ 구조에서 PC갱신 단계를 맨 처음으로 바꾼 SEQ+를 설계한 후 파이프라인을 적용하여 PIPE구조를 설계한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE-의 하드웨어 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다음-pc값의-추정&quot;&gt;다음 PC값의 추정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이다.&lt;/li&gt;
  &lt;li&gt;목표를 달성하기 위해서 PC의 새로운 값을 예측해야 한다.
    &lt;ul&gt;
      &lt;li&gt;조건제어나 분기등으로 인해서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분기 방향을 추측하는 기술을 branch prediction이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-해저드&quot;&gt;파이프라인 해저드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;피드백이 있는 시스템에 파이프라인을 도입하면 인스트럭션들 간에 의존성으로 인해 문제가 발생한다.
    &lt;ul&gt;
      &lt;li&gt;데이터 의존성: 현재의 계산의 결과가 다음 인스트럭션을 위한 데이터로 사용되는 경우&lt;/li&gt;
      &lt;li&gt;제어 의존성: jump, call, ret과 같은 인스트럭션을 처리할 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해저드: 의존성들이 파이프라인으로 인해 잘못된 계산을 하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스톨을-사용한-데이터-해저드-회피&quot;&gt;스톨을 사용한 데이터 해저드 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;해저드 조건이 사라질 때 까지 파이프 라인 내에 유지한다.&lt;/li&gt;
  &lt;li&gt;스톨링동안 실행 단계에 버블을 삽입한다.&lt;/li&gt;
  &lt;li&gt;버블은 동적으로 생성된 nop인스트럭션과 비슷하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포워딩을-이용한-데이터-해저드-회피&quot;&gt;포워딩을 이용한 데이터 해저드 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;소스 오퍼랜드로 이전에 실행된 인스트럭션 결과 값을 전달할 수 있다.&lt;/li&gt;
  &lt;li&gt;“Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로드사용-데이터-해저드-회피&quot;&gt;로드/사용 데이터 해저드 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 포워딩으로 처리할 수 없다.&lt;/li&gt;
  &lt;li&gt;스톨링과 포워딩을 함께 사용한다.&lt;/li&gt;
  &lt;li&gt;load interlock: 로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-해저드의-회피&quot;&gt;제어 해저드의 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ret: 스톨을 사용한다.&lt;/li&gt;
  &lt;li&gt;jump: 분기할 것을 예측한다. -&amp;gt; 잘못 예측된 것을 확인한다. -&amp;gt; 버블을 삽입하여 인스트럭션을 취소한다. -&amp;gt; 점프 다음에 오는 인스트럭션을 선입한다.&lt;/li&gt;
  &lt;li&gt;instruction squashing: 잘못 선입한 인스트럭션을 취소하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파이프라인-예외처리&quot;&gt;파이프라인 예외처리&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/22/img_10.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;제어로직을 사용하여 예외처리를한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-프로그램-성능-최적화하기&quot;&gt;5 프로그램 성능 최적화하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;상위 수준 설계: 적절한 알고리즘과 자료구조 선택&lt;/li&gt;
  &lt;li&gt;최적화 장애물 피하기
    &lt;ul&gt;
      &lt;li&gt;함수 호출제거&lt;/li&gt;
      &lt;li&gt;계산은 루프 밖으로 이동&lt;/li&gt;
      &lt;li&gt;불필요한 메모리 참조 제거&lt;/li&gt;
      &lt;li&gt;중간 값을 저장하는 임시 변수 사용(데이터 의존성 피하기)&lt;/li&gt;
      &lt;li&gt;최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위수준 최적화: 병렬성 이용
    &lt;ul&gt;
      &lt;li&gt;루프풀기&lt;/li&gt;
      &lt;li&gt;다중누산기와 재결합 기법 사용&lt;/li&gt;
      &lt;li&gt;statement 보다 expression 사용하기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;6-메모리-계층구조&quot;&gt;6 메모리 계층구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;랜덤-접근 메모리(RAM)
    &lt;ul&gt;
      &lt;li&gt;SRAM: 캐시메모리로 사용
        &lt;ul&gt;
          &lt;li&gt;메모리셀에 저장한다.&lt;/li&gt;
          &lt;li&gt;지속성을 갖는다.&lt;/li&gt;
          &lt;li&gt;리프레시가 필요없다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DRAM: 메인메모리로 사용
        &lt;ul&gt;
          &lt;li&gt;캐패시터에 저장한다.&lt;/li&gt;
          &lt;li&gt;리프레시가 필요하다.&lt;/li&gt;
          &lt;li&gt;메모리 컨트롤러는 행 주소 -&amp;gt; 열 주소를 보낸다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;RAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비휘발성 메모리
    &lt;ul&gt;
      &lt;li&gt;전원이 꺼져도 정보를 유지한다.&lt;/li&gt;
      &lt;li&gt;Read-only memory ROM이라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;버스
    &lt;ul&gt;
      &lt;li&gt;프로세서와 메인메모리간에 데이터를 교환한다.&lt;/li&gt;
      &lt;li&gt;버스 트랜잭션이라고 부르는 일련의 단계들을 통해 이뤄진다.&lt;/li&gt;
      &lt;li&gt;읽기와 쓰기 트랜잭션이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;지역성&quot;&gt;지역성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최근에 참조했던 데이터 아이템 근처나 자신을 참조하려는 경향이 있다.&lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;시간 지역성: 한번 참조된 메모리 위치는 여러번 참조될 가능성이 높다.&lt;/li&gt;
      &lt;li&gt;공간 지역성: 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 메모리: 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;캐시&quot;&gt;캐시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐시 종류
    &lt;ul&gt;
      &lt;li&gt;직접매핑 캐시&lt;/li&gt;
      &lt;li&gt;집합결합성 캐시&lt;/li&gt;
      &lt;li&gt;완전결합성 캐시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 동작 방법
    &lt;ol&gt;
      &lt;li&gt;집합 선택&lt;/li&gt;
      &lt;li&gt;라인 매칭&lt;/li&gt;
      &lt;li&gt;워드 추출
        &lt;ul&gt;
          &lt;li&gt;Thrashing: 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는경우
            &lt;ul&gt;
              &lt;li&gt;해결법: 패딩을준다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;인덱스를 중간비트로 쓰는 이유: 연속적인 메모리의 동일한 캐시 집합으로의 매핑을 피하기 위해&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 쓰기
    &lt;ul&gt;
      &lt;li&gt;Write-through: 즉시 하위 레벨로 쓴다. 버스 트래픽 일으키는 단점 있다.&lt;/li&gt;
      &lt;li&gt;Write-back: 갱신을 지연시켜 교체 알고리즘에 의해 축출될 때 쓴다. dirty bit을 라인마다 추가로 유지해야한다.&lt;/li&gt;
      &lt;li&gt;Write-allocate: 하위 레벨에서 캐시로 가져오고 난 뒤 캐시 블록을 갱신한다.&lt;/li&gt;
      &lt;li&gt;No-write-allocate: 캐시를 통과하고 직접 하위 레벨에 써준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;part1-프로그램의-구조와-실행-리뷰&quot;&gt;Part1 프로그램의 구조와 실행 리뷰&lt;/h1&gt;
&lt;p&gt;처음 csapp 책을 읽기 시작한 날이 1월 21일이다. 총 세파트로 나뉘어져 있는데, 파트1을 1회독한 시점이 3월 29일 대략 2개월정도 걸렸다.
CS부터 공부하기로 다짐했을 때 매일매일 공부하려고 노력했지만, 부트캠프 지원 이슈로 인해 대략 2-3주정도는 공부를 안한 것 같다. 
또 어려운 내용이 나오기 시작하면, 예를들어 부동소수점, 프로시저, SEQ구현 등… 책을 덮게되었던 것 같다. 
하루빨리 CS, OS, 네트워크, 디비 이론적인 부분들에 대해 공부를 마치고 지식적으로 성장하고 싶다. 컨디션 조절을 하되 2-3주동안 공부를 안했던 것은 반성하자.&lt;/p&gt;

&lt;p&gt;SEQ 설계 단원을 공부하기 전까지는 공부하는 내용들이 머리속에서 잘 그려지지 않았다. 하지만 SEQ 설계를 공부하고 나니 그 이전에 공부했던 부분들에 대해 조금 더 이해가 되었고,
그 이후에 최적화 부분에서 정말 말 그대로 신이났다. CS의 매력에 흠뻑 빠지게 된 것 같다. 대학에서 컴구를 공부할 때는 이론적인 부분 또는 하드웨어적인 부분에서의 설명만 하고 
추가 설명은 없었다. 그래서, 나는 이런 하드웨어와 프로그램들이 어떻게 상호작용이 되는지 이해하지 못했고 재미도 못 느꼈던 것 같다. 하지만, csapp에서는 하드웨어와 프로그램의 상호작용에 대해 설명을 하면
그 이후에 실제 c코드로 예시를 들어준다. 이러한 예시코드가 프로그래밍과 접목도 되고 이해의 수준이 상승하는 것 같다.&lt;/p&gt;

&lt;p&gt;앞으로 남은 part2,3를 4월 중순 안으로 끝마치고 운영체제 공부를 빨리 하고 싶다. 화이팅이다! 아자아자!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 22(하드웨어와 프로그램 사이의 상호작용 요약 및 리뷰)</summary></entry><entry><title type="html">[프로그래머스/Python] Level1 모의고사 Python 풀이</title><link href="http://localhost:4000/programmers/python_02/" rel="alternate" type="text/html" title="[프로그래머스/Python] Level1 모의고사 Python 풀이" /><published>2022-03-26T00:00:00+09:00</published><updated>2022-03-26T00:00:00+09:00</updated><id>http://localhost:4000/programmers/python_02</id><content type="html" xml:base="http://localhost:4000/programmers/python_02/">&lt;h1 id=&quot;프로그래머스programmers-코딩테스트-연습&quot;&gt;프로그래머스(Programmers) 코딩테스트 연습&lt;/h1&gt;

&lt;h2 id=&quot;level1-완전탐색-모의고사-파이썬python-풀이&quot;&gt;Level1 완전탐색 모의고사 파이썬(Python) 풀이&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42840&quot;&gt;풀이로 이동!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;반복문의 횟수를 줄이는 것이 핵심인 문제인 것 같다. 반복문의 횟수를 줄이기 위해 접근하는 index를 학생들의 정답 패턴의 길이로 나누는 아이디어를 채택하였다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;정답의 길이로 반복문을 돌린다.&lt;/li&gt;
  &lt;li&gt;학생 a,b,c의 정답 패턴의 길이로 현재 반복문의 index를 나누어 각 학생의 정답 패턴에 접근한다.&lt;/li&gt;
  &lt;li&gt;정답이 각각 일치하면, answer_list의 a-&amp;gt;0, b-&amp;gt;1, c-&amp;gt;2 인덱스에 맞게 +1을 해준다.&lt;/li&gt;
  &lt;li&gt;answer_list를 enumerate를 사용하여 인덱스와 밸류값으로 함께 반복문을 돌린다.&lt;/li&gt;
  &lt;li&gt;answer_list의 max값을 찾아 해당 max값과 밸류값이 같은 인덱스값을 answer배열에 저장한다.&lt;/li&gt;
  &lt;li&gt;return answer&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answer_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;answers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="programmers" /><category term="Algorithm" /><category term="Python" /><category term="프로그래머스 코테" /><summary type="html">Python Algorithm Study - 02</summary></entry><entry><title type="html">[프로그래머스/Python] Level2 가장 큰 수 Python 풀이</title><link href="http://localhost:4000/programmers/python_03/" rel="alternate" type="text/html" title="[프로그래머스/Python] Level2 가장 큰 수 Python 풀이" /><published>2022-03-26T00:00:00+09:00</published><updated>2022-03-26T00:00:00+09:00</updated><id>http://localhost:4000/programmers/python_03</id><content type="html" xml:base="http://localhost:4000/programmers/python_03/">&lt;h1 id=&quot;프로그래머스programmers-코딩테스트-연습&quot;&gt;프로그래머스(Programmers) 코딩테스트 연습&lt;/h1&gt;

&lt;h2 id=&quot;level2-정렬-가증-큰-수-파이썬python-풀이&quot;&gt;Level2 정렬 가증 큰 수 파이썬(Python) 풀이&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42746?language=python3&quot;&gt;풀이로 이동!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;가장 큰 수를 만드려면, 예를 들어 9와 91이 있을 때 991이 919보다 더 큰 수가 된다. 수의 가장 큰 값이 1000이기 때문에, ‘9’&lt;em&gt;3, ‘91’&lt;/em&gt;3을 해서 비교를 하면,
‘999’ &amp;gt; ‘919191’ 이다. 그렇기 때문에 int-&amp;gt;str-&amp;gt;*3을 하여 비교를 하여 정렬을 하고 해당 숫자들을 원래 숫자로 변경하여 return 해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;배열의 값들을 str type으로 변경해준뒤 *3을 해준다.&lt;/li&gt;
  &lt;li&gt;이후 sorted 함수를 사용하여 정렬한다.(내림차순으로 정렬하기 위해 reverse=True로 설정해준다.)&lt;/li&gt;
  &lt;li&gt;다시 배열의 값들의 길이를 1/4로 나누어 slicing해준다.&lt;/li&gt;
  &lt;li&gt;해당 배열들을 ‘‘로 join해준다.&lt;/li&gt;
  &lt;li&gt;return answer&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'0'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="programmers" /><category term="Algorithm" /><category term="Python" /><category term="프로그래머스 코테" /><summary type="html">Python Algorithm Study - 03</summary></entry><entry><title type="html">[프로그래머스/Python] Level1 K번째수 Python 풀이</title><link href="http://localhost:4000/programmers/python_01/" rel="alternate" type="text/html" title="[프로그래머스/Python] Level1 K번째수 Python 풀이" /><published>2022-03-26T00:00:00+09:00</published><updated>2022-03-26T00:00:00+09:00</updated><id>http://localhost:4000/programmers/python_01</id><content type="html" xml:base="http://localhost:4000/programmers/python_01/">&lt;h1 id=&quot;프로그래머스programmers-코딩테스트-연습&quot;&gt;프로그래머스(Programmers) 코딩테스트 연습&lt;/h1&gt;

&lt;h2 id=&quot;level1-정렬-k번째수-파이썬python-풀이&quot;&gt;Level1 정렬 K번째수 파이썬(Python) 풀이&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42748?language=python3&quot;&gt;풀이로 이동!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;반복문과 slicing, sort 함수를 사용하면 간단하게 해결되는 가장 기초적인 정렬 문제이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;2차원 배열인 commands를 반복문을 통해 하나씩 접근한다.&lt;/li&gt;
  &lt;li&gt;1차원 배열인 command에서 0번 index와 1번 index에 해당되도록 slicing 한다.&lt;/li&gt;
  &lt;li&gt;slicing된 배열을 정렬한다.&lt;/li&gt;
  &lt;li&gt;정렬된 배열에서 index 2번에 해당되는 인자값을 answer 배열에 append 한다.&lt;/li&gt;
  &lt;li&gt;return answer&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;answer&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="programmers" /><category term="Algorithm" /><category term="Python" /><category term="프로그래머스 코테" /><summary type="html">Python Algorithm Study - 01</summary></entry><entry><title type="html">[CS:APP] Chapter 06 메모리 계층구조(캐시)</title><link href="http://localhost:4000/csapp/csapp_21/" rel="alternate" type="text/html" title="[CS:APP] Chapter 06 메모리 계층구조(캐시)" /><published>2022-03-24T00:00:00+09:00</published><updated>2022-03-24T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_21</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_21/">&lt;h1 id=&quot;chapter-06-메모리-계층구조&quot;&gt;Chapter 06 메모리 계층구조&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;저장장치 기술&lt;/li&gt;
  &lt;li&gt;지역성&lt;/li&gt;
  &lt;li&gt;메모리 계층구조&lt;/li&gt;
  &lt;li&gt;캐시메모리&lt;/li&gt;
  &lt;li&gt;캐시 친화적 코드 작성하기&lt;/li&gt;
  &lt;li&gt;프로그램 성능에 대한 캐시의 영향&lt;/li&gt;
  &lt;li&gt;요약&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;64-캐시-메모리&quot;&gt;6.4 캐시 메모리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CPU와 메인메모리 사이의 성능 격차가 커짐에 따라 L1 캐시 및 L2 캐시를 삽입하였다.&lt;/li&gt;
  &lt;li&gt;캐시는 SRAM이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/21/img.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 캐시 메모리를 위한 일반적인 버스 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;641-기본-캐시-메모리-구조&quot;&gt;6.4.1 기본 캐시 메모리 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐시의 구성은 순서쌍 S,E,B,m 으로 규정할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;S : 2^s개의 캐시 집합&lt;/li&gt;
      &lt;li&gt;E : 집합에 포함되는 캐시 라인&lt;/li&gt;
      &lt;li&gt;B : 2^b 바이트의 데이터 블록&lt;/li&gt;
      &lt;li&gt;m : M = 2^m 개의 교유의 주소를 구성하는 m비트&lt;/li&gt;
      &lt;li&gt;C : 모든 블록의 크기 S&lt;em&gt;E&lt;/em&gt;B&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시는 요청된 워드를 간단히 주소비트만 조사해서 찾아ㅓ낼 수 있도록 구성되어있다.
    &lt;ul&gt;
      &lt;li&gt;해당 방식은 해시 함수를 사용하는 해시 테이블과 유사하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/21/img_1.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 캐시의 일반적인 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;642-캐시-종류&quot;&gt;6.4.2 캐시 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;직접매핑 캐시
    &lt;ul&gt;
      &lt;li&gt;집합당 정확히 한개의 라인을 갖는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;집합결합성 캐시
    &lt;ul&gt;
      &lt;li&gt;집합당 k개의 라인을 갖는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완전결합성 캐시
    &lt;ul&gt;
      &lt;li&gt;모든 캐시 라인들을 갖는 하나의 집합으로 구성된 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;643-캐시-동작-방법&quot;&gt;6.4.3 캐시 동작 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐시의 동작 방법은 세 단계로 이루어진다.
    &lt;ol&gt;
      &lt;li&gt;집합 선택&lt;/li&gt;
      &lt;li&gt;라인 매칭&lt;/li&gt;
      &lt;li&gt;워드 추출&lt;/li&gt;
    &lt;/ol&gt;

    &lt;ul&gt;
      &lt;li&gt;위와 같은 방법으로 캐시가 어떤 요청이 적중인지 미스인지 결정하고, 요청한 워드를 뽑아내기 위해 작업을 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;집합 선택
    &lt;ul&gt;
      &lt;li&gt;s개의 집합 인덱스 비트를 w의 주소 중에서 뽑아낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라인 매칭
    &lt;ul&gt;
      &lt;li&gt;워드 w의 사본이 집합 i에 포함된 캐시 라인에 들어 있는지 결정한다.&lt;/li&gt;
      &lt;li&gt;유효비트 valid가 1이고, 태그비트들이 일치해야한다. -&amp;gt; 캐시 적중&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;워드 선택
    &lt;ul&gt;
      &lt;li&gt;캐시 적중이 발생하면 원하는 워드가 블록 내 어디에서 시작하는지 결정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/21/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/21/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 집합 선택과 라인 매칭 그리고 워드 선택이다.(직접매핑 캐시)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Thrashing : 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는 경우
    &lt;ul&gt;
      &lt;li&gt;해결 방법 : 예를들어 x배열, y배열에서 쓰레싱이 일어나면 x배열에 패딩을 주어 x[i]와 y[i]가 서로 다른 집합에 매핑되도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인덱스를 중간 비트로 사용하는 이유
    &lt;ul&gt;
      &lt;li&gt;연속적인 메모리 블록들은 동일한 캐시 집합으로 매핑된다. -&amp;gt; 어떠한 특정 순간에 한 개의 블록 크기의 배열 묶음만을 저장하게 되며 캐시를 비효율적으로 사용하게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/21/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 중간 비트로 캐시 인덱스를 사용하는 이유다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;집합결합성 캐시에서의 동작 방법
    &lt;ul&gt;
      &lt;li&gt;직접매핑 캐시와 동작이 비슷하지만,&lt;/li&gt;
      &lt;li&gt;라인 매칭에서 캐시 내 태그와 주소의 태그가 일치하는 라인을 찾기위해 탐색을 한다.&lt;/li&gt;
      &lt;li&gt;캐시에서 미스 발생시 : LFU(최소 빈도 사용), LRU(최소 최근 사용) 정책 활용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완전결합성 캐시
    &lt;ul&gt;
      &lt;li&gt;집합결합성 캐시와 동작이 비슷하지만,&lt;/li&gt;
      &lt;li&gt;많은 수의 태그를 병렬로 검색해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;644-쓰기와-관련된-이슈&quot;&gt;6.4.4 쓰기와 관련된 이슈&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Write-through: 즉시 w의 캐시 블록 전체를 다음 하위 레벨로 써준다.
    &lt;ul&gt;
      &lt;li&gt;버스 트래픽을 발생시키는 단점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Write-back : 갱신을 지연시켜 이 블록이 블록 교체 알고리즘에 의해 캐시에서 축출될 때에만 하위 레벨에 써준다.
    &lt;ul&gt;
      &lt;li&gt;캐시 블록이 수정되었는지 여부를 나타내는 dirty bit 을 각 라인마다 추가로 유지해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Write-allocate : 해당 블록을 다음 하위 레벨에서 캐시로 가져오고 난 뒤에 캐시 블록을 갱신한다.&lt;/li&gt;
  &lt;li&gt;No-write-allocate : 캐시를 통과하고 워드를 직접 다음 하위 레벨에 써준다.&lt;/li&gt;
  &lt;li&gt;Write-through &amp;amp; no-write-allocate, Write-back &amp;amp; Write-allocate&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;645-실제-캐시-계층구조의-해부&quot;&gt;6.4.5 실제 캐시 계층구조의 해부&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;i-cache : 인스트럭션만을 보관하는 캐시&lt;/li&gt;
  &lt;li&gt;d-cache : 데이터만 보관하는 캐시&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;646-캐시-매개변수의-성능에-대한-효과&quot;&gt;6.4.6 캐시 매개변수의 성능에 대한 효과&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;미스 비율 Miss rate : 미스하는 메모리를 참조하는 비율&lt;/li&gt;
  &lt;li&gt;적중 비율 Hit rate : 1 - miss rate&lt;/li&gt;
  &lt;li&gt;적중 시간 Hit Time : 캐시에 있는 워드를 CPU 로 전달하는 데 걸리는 시간&lt;/li&gt;
  &lt;li&gt;미스 비용 Miss Penalty : 미스로 인해서 추가적으로 요구되는 시간&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-크기의-영향&quot;&gt;캐시 크기의 영향&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;큰 캐시는 적중비율을 높여주지만 더 적중시간이 길어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;블록-크기의-영향&quot;&gt;블록 크기의 영향&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;적중 비율을 높여주지만 전송시간이 길어진다.&lt;/li&gt;
  &lt;li&gt;시간 지역성이 더 많은 프로그램에서 적중 비율에 타격을 줄 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;결합도의-영향&quot;&gt;결합도의 영향&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;집합당 캐시 라인 수의 선택이 미치는 영향&lt;/li&gt;
  &lt;li&gt;충돌미스로 인해 쓰레싱하는 위험성을 감소시킨다&lt;/li&gt;
  &lt;li&gt;라인당 더 많은 태그비트 필요, LRU 상태비트 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;65-캐시-친화적-코드-작성하기&quot;&gt;6.5 캐시 친화적 코드 작성하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;좋은 프로그래머란 항상 캐시 친화적으로, 즉 좋은 지역성을 가지도록 프로그램을 작성해야 한다.
    &lt;ul&gt;
      &lt;li&gt;공통적인 경우를 빠르게 동작하게 만들어야한다.&lt;/li&gt;
      &lt;li&gt;각 내부 루프의 캐시 미스 수를 최소화 해야한다.&lt;/li&gt;
      &lt;li&gt;지역변수들에 대한 반복적인 참조는 좋다.(시간 지역성)&lt;/li&gt;
      &lt;li&gt;Stride-1 참조 패턴은 좋다.(공간 지역성)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;66-프로그램-성능에-대한-캐시의-영향&quot;&gt;6.6 프로그램 성능에 대한 캐시의 영향&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;읽기 처리량 or 읽기 대역폭 : 프로그램이 메모리 시스템에서 데이터를 읽는 비율&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;67-요약&quot;&gt;6.7 요약&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;이렇게 메모리까지 하드웨어와 프로그램 사이의 상호작용에 대해 공부했다.
메모리에 대해서 좀 더 자세히 살펴볼 필요가 있어 보인다. 대학 2학년 때 컴구 수업에서 캐시 매핑 관련 내용이 생각나는데,
이 책에는 수록되어 있지 않은 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 21</summary></entry><entry><title type="html">[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)</title><link href="http://localhost:4000/csapp/csapp_20/" rel="alternate" type="text/html" title="[CS:APP] Chapter 06 메모리 계층구조(메모리 계층구조와 지역성)" /><published>2022-03-21T00:00:00+09:00</published><updated>2022-03-21T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_20</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_20/">&lt;h1 id=&quot;chapter-06-메모리-계층구조&quot;&gt;Chapter 06. 메모리 계층구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 시스템은 용량, 비용, 접근시간을 갖는 저장장치들의 계층구조다.
    &lt;ul&gt;
      &lt;li&gt;캐시메모리는 CPU 부근에서 비교적 느린 메인메모리에 대한 준비장소&lt;/li&gt;
      &lt;li&gt;메인메모리는 크고 느린 디스크들에 대한 준비장소&lt;/li&gt;
      &lt;li&gt;디스크들은 네트워크로 연결된 다른 머신들의 준비장소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리의 계층별로 접근 속도가 상이하다.
    &lt;ul&gt;
      &lt;li&gt;레지스터가 가장 빠르고, 그 다음은 메인메모리, 그 다음은 디스크이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터를 계층의 상부에 저장시켜서 CPU가 보다 빨리 접근할 수 있도록 프로그램을 작성해야한다.
    &lt;ul&gt;
      &lt;li&gt;이 개념은 지역성locality라고 알려진 컴퓨터 프로그램의 근본특징에 근거를 두고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;61-저장장치-기술&quot;&gt;6.1 저장장치 기술&lt;/h1&gt;

&lt;h2 id=&quot;611-랜덤-접근-메모리&quot;&gt;6.1.1 랜덤-접근 메모리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;랜덤-접근 메모리(RAM)은 두 종류를 가진다.
    &lt;ul&gt;
      &lt;li&gt;정적 SRAM : 동적램 DRAM 보다 더 빠르고 훨 씬 비싸다. 캐시메모리로 사용된다.&lt;/li&gt;
      &lt;li&gt;동적 DRAM : 메인메모리와 그래픽 시스템의 프레임 버퍼로도 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정적-sram&quot;&gt;정적 SRAM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SRAM은 각 비트를 이중안정bistable 메모리 셀cell에 저장한다.&lt;/li&gt;
  &lt;li&gt;SRAM은 전원이 공급되는 한 지속성을 갖는다.&lt;/li&gt;
  &lt;li&gt;리프레시가 필요없다.&lt;/li&gt;
  &lt;li&gt;DRAM보다 트랜지스터를 더 많이 사용하여 밀도가 낮으며 비싸고 전력을 많이 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동적-dram&quot;&gt;동적 DRAM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM은 각 비트를 전하로 캐패시터에 저장한다.&lt;/li&gt;
  &lt;li&gt;리프레시가 필요하다.
    &lt;ul&gt;
      &lt;li&gt;메모리 시스템은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-dram&quot;&gt;일반 DRAM&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_3.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 DRAM 칩의 구조이다.&lt;/li&gt;
  &lt;li&gt;DRAM 칩 내의 셀들은 d 슈퍼셀들로 나누어지며, 각각은 w DRAM 셀들로 이루어진다.&lt;/li&gt;
  &lt;li&gt;슈퍼셀 (i,j)의 내용을 읽으려면 메모리 컨트롤러는 행 주소 i를 DRAM에 보내고, 다음에 열 주소 j를 보낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_1.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 DRAM 슈퍼셀의 내용을 읽는 과정이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-모듈&quot;&gt;메모리 모듈&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM 칩은 메인 시스템(머더보드)의 확상슬롯에 꽂을 수 있는 메모리 모듈 형태로 패키징 된다.&lt;/li&gt;
  &lt;li&gt;DRAM을 여러개 추가하여 바이트를 순서대로 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비휘발성-메모리&quot;&gt;비휘발성 메모리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM과 SRAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.&lt;/li&gt;
  &lt;li&gt;비휘발성 메모리는 이들의 전원 꺼져도 정보를 유지한다.&lt;/li&gt;
  &lt;li&gt;Read-only memory : ROM 이라고 부른다.&lt;/li&gt;
  &lt;li&gt;ROM 디바이스에 저장된 프로그램들은 종종 펌웨어firmware라고 부른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리에-접근하기&quot;&gt;메모리에 접근하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터는 ‘버스’라고 하는 공유된 전기회로를 통해서 프로세서와 DRAM메인메모리간에 앞뒤로 교환한다.&lt;/li&gt;
  &lt;li&gt;CPU와 메모리 간의 매 전송은 버스 트랜잭션bus transaction이라고 부르는 일련의 단계들을 통해 이뤄진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_2.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 CPU와 메인메모리를 연결하는 버스 구조다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;읽기 트랜잭션(movq A,%rax)
    &lt;ol&gt;
      &lt;li&gt;CPU는 주소 A를 시스템 버스에 보낸다. I/O브릿지는 신호를 메모리 버스를 따라 보낸다.&lt;/li&gt;
      &lt;li&gt;메인메모리는 메모리 버스에서 주소 신호를 감지하고, 메모리 버스로부터 주소를 읽고 DRAM에서 데이터 워드를 선입, 데이터를 메모리 버스에 쓴다.&lt;/li&gt;
      &lt;li&gt;I/O 브릿지는 신호를 시스템 버스 신호로 변환해서 시스템 버스를 따라 보낸다. CPU는 시스템 버스에서 데이터를 감지하고 %rax에 복사한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;쓰기 트랜잭션(movq %rax,A)
    &lt;ol&gt;
      &lt;li&gt;CPU는 주소를 시스템 버스에 보낸다. 메모리는 메모리 버스에서 주소를 읽고 데이터가 도착하기를 기다린다.&lt;/li&gt;
      &lt;li&gt;CPU는 %rax에 있는 데이터를 시스템 버스에 복사한다.&lt;/li&gt;
      &lt;li&gt;메인메모리는 데이터를 메모리 버스에서 읽고 비트들을 저장한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;612-디스크-저장장치&quot;&gt;6.1.2 디스크 저장장치&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;디스크는 RAM 메모리의 수천 메가바이트 단위에 비해 수백에서 수천 기가비이트 단위의 엄청난 양의 데이터를 저장하는 대표적인 저장장치다.&lt;/li&gt;
  &lt;li&gt;디스크 용량
    &lt;ul&gt;
      &lt;li&gt;기록밀도: 1인치의 트랙에 집어넣을 수 있는 비트의 수&lt;/li&gt;
      &lt;li&gt;트랙밀도: 원판 중심에서 반지름의 1인치 길이에 넣을 수 있는 트랙의 수&lt;/li&gt;
      &lt;li&gt;면적밀도: 기록밀도와 트랙밀도의 곱&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크의 동작
    &lt;ul&gt;
      &lt;li&gt;탐색시간: 섹터의 내용을 읽기위해 헤드를 타깃 섹터를 보유한 트랙 위로 위치시키는 시간&lt;/li&gt;
      &lt;li&gt;회전 지연시간: 헤드가 트랙 위에 위치하면 타깃 섹터의 첫번째 비트가 헤드 아래로 지나가는 것을 기다리는 시간.(헤드의 위치와 디스크의 회전 속도 모두 관련됨)&lt;/li&gt;
      &lt;li&gt;전송시간: 하나의 섹터를 전송하는 시간(회전속도와 트랙당 섹터 수에 관련됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크 접근하기(디스크 섹터 읽기)
    &lt;ol&gt;
      &lt;li&gt;CPU는 명령어, 논리블록 번호, 목적지 메모리 주소를 디스크와 관련된 메모리 매핑한 주소에 써주어서 디스크 읽기를 개시한다.&lt;/li&gt;
      &lt;li&gt;디스크 컨트롤러는 이 섹터를 읽고 메인메모리로 DMA 전송을 수행한다.&lt;/li&gt;
      &lt;li&gt;DMA 전송이 완료될 때, 디스크 컨트롤러는 CPU에 인터럽트로 알려준다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;62-지역성&quot;&gt;6.2 지역성&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;잘 작성한 컴퓨터 프로그램은 좋은 지역성locality를 보여준다.
    &lt;ul&gt;
      &lt;li&gt;최근에 참조했던 데이터 아이템 근처의 데이터 아이템이나 최근에 자신을 참조했던 데이터 아이템을 참조하려는 경향이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지역성은 두가지 형태가 있다.
    &lt;ul&gt;
      &lt;li&gt;시간 지역성 : 한번 참조된 메모리 위치는 여러 번 참조될 가능성이 높다.&lt;/li&gt;
      &lt;li&gt;공간 지역성 : 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 메모리 : 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장
    &lt;ul&gt;
      &lt;li&gt;캐시 메모리라는 작고 빠른 메모리를 도입하여 메인메모리를 빠르게 돌릴 수 있게 됐다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;621-프로그램-데이터-참조의-지역성&quot;&gt;6.2.1 프로그램 데이터 참조의 지역성&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드는 좋은 지역성을 갖는다.
    &lt;ul&gt;
      &lt;li&gt;행 우선 순서로 접근되기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드는 나쁜 지역성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위의 코드도 썩 좋은 지역성을 갖고 있지는 않다.
    &lt;ul&gt;
      &lt;li&gt;보폭이 존재하기 때문&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;622-지역성-요약&quot;&gt;6.2.2 지역성 요약&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;동일한 변수들을 반복적으로 참조하는 프로그램은 좋은 시간 지역성&lt;/li&gt;
  &lt;li&gt;Stride-k참조 패턴에서 stride가 적으면 적을수록 공간 지역성도 좋아진다.&lt;/li&gt;
  &lt;li&gt;루프는 인스트럭션 선입에 대해 좋은 시간 및 공간 지역성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;63-메모리-계층구조&quot;&gt;6.3 메모리 계층구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;아래 두가지를 보완하기 위해 ‘메모리 계층구조’라고 알려진 메모리 시스템 조직을 위한 접근 방법을 사용한다.
    &lt;ul&gt;
      &lt;li&gt;저장장치 기술 : 다양한 저장장치 기술들은 매우 광범위한 접근시간을 갖는다.&lt;/li&gt;
      &lt;li&gt;컴퓨터 소프트웨어 : 잘 작성한 프로그램들은 좋은 지역성을 나타내는 경향이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 메모리 계층구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;631-메모리-계층구조에서의-캐시&quot;&gt;6.3.1 메모리 계층구조에서의 캐시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;캐시는 보다 크고 느린 디바이스에 저장된 데이터 객체를 위한 준비 영역으로 사용하는 작고 빠른 저장장치다.&lt;/li&gt;
  &lt;li&gt;메모리 계층구조의 중심 개념은, 레벨 k에 있는 보다 빠르고 더 작은 장치가 레벨 k+1을 위한 캐시 서비스를 제공한다는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/20/img_5.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 메모리 계층구조에서 캐싱의 기본 원리이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-적중&quot;&gt;캐시 적중&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;레벨 k+1로부터 특정 데이터 객체 d를 필요로 한다.&lt;/li&gt;
  &lt;li&gt;현재 레벨 k에 저장된 블록들 중의 하나에서 d를 찾는다.&lt;/li&gt;
  &lt;li&gt;만일 d가 레벨 k에서 우연히 캐시되어 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스&quot;&gt;캐시 미스&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;만일 d가 레벨 k에서 캐시되지 않는다면 ‘캐시 미스’가 발생한 것이다.&lt;/li&gt;
  &lt;li&gt;k+1에 있는 캐시로부터 d를 포함하는 블록을 가져온다.&lt;/li&gt;
  &lt;li&gt;만일 레벨 k 캐시가 이미 꽉 찬 상태full라면 기존 블록에 덮어쓴다.
    &lt;ul&gt;
      &lt;li&gt;축출 : 기존 블록을 덮어쓰는 과정&lt;/li&gt;
      &lt;li&gt;희생블록 : 축출되는 블록&lt;/li&gt;
      &lt;li&gt;교체정책 : 어떤 블록을 교체할지에 관한 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;캐시-미스-종류&quot;&gt;캐시 미스 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cold cache : 캐시가 비어있을 때&lt;/li&gt;
  &lt;li&gt;충돌미스conflict miss : 캐시의 배치 정책으로 인한 캐시 미스&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-관리&quot;&gt;캐시 관리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 계층 구조의 핵심은 각 레벨에 있는 저장장치가 다음 낮은 레벨을 위한 캐시&lt;/li&gt;
  &lt;li&gt;레벨 L1,L2,L3의 캐시들은 캐시에 구현된 하드웨어 로직으로 전적으로 관리된다.&lt;/li&gt;
  &lt;li&gt;가상모메리를 사용하는 시스템에서 DRAM메인메모리는디스크에 저장된 데이터 블록에 대한 캐시 서비스를 제공한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 20</summary></entry><entry><title type="html">[CS:APP] Chapter 05 프로그램 성능 최적화하기</title><link href="http://localhost:4000/csapp/csapp_19/" rel="alternate" type="text/html" title="[CS:APP] Chapter 05 프로그램 성능 최적화하기" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_19</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_19/">&lt;h1 id=&quot;chapter-05-프로그램-성능-최적화하기&quot;&gt;Chapter 05. 프로그램 성능 최적화하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램을 작성하는 주목적은 모든 가능한 조건에서 프로그램이 정확하게 동작하도록 하는 것이다.&lt;/li&gt;
  &lt;li&gt;프로그래머는 명확하고 간결한 코드를 작성해야하고, 이해하기 쉽고, 코드를 검토할 때와 수정할 때 다른사람들도 코드를 읽고 이해할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;효율적인 프로그램을 작성하는 방법
    &lt;ol&gt;
      &lt;li&gt;적절한 알고리즘과 자료구조를 선택해야한다.&lt;/li&gt;
      &lt;li&gt;컴파일러가 효과적으로 최적화해서 효율적인 실행코드로 바꿀 수 있는 소스코드를 작성해야 한다.&lt;/li&gt;
      &lt;li&gt;작업을 부분으로 나누어 멀티코어와 멀티프로세서의 조합을 갖는 컴퓨터에서 병렬로 계산한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머는 컴파일러를 도와서 쉽게 최적화될 수 있는 코드를 작성해야한다.
    &lt;ol&gt;
      &lt;li&gt;불필요한 작업 제거
        &lt;ul&gt;
          &lt;li&gt;불필요한 함수호출 제거&lt;/li&gt;
          &lt;li&gt;조건 테스트 제거&lt;/li&gt;
          &lt;li&gt;메모리 참조 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인스트럭션-수준 병렬성을 제공&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;51-최적화-컴파일러의-능력과-한계&quot;&gt;5.1 최적화 컴파일러의 능력과 한계&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일러는 프로그래머의 코드를 자동으로 최적화 해준다.&lt;/li&gt;
  &lt;li&gt;하지만 특정 코드는 컴파일러가 자동으로 최적화해줄 수 없다.
    &lt;ul&gt;
      &lt;li&gt;두 개의 포인터가 같은 메모리 위치를 가리킬 수 있는 경우(메모리 연결memory aliasing)&lt;/li&gt;
      &lt;li&gt;함수 호출
        &lt;ul&gt;
          &lt;li&gt;ex) 호출되는 횟수에 따라 프로그램의 동작이 변경 되는 경우(부가효과 side effect)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위 항목들이 ‘최적화 장애물blocker’이 되는데, 이것은 컴파일러가 최적화된 코드를 생성하기 위한 기회를 제한한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;52-프로그램-성능의-표현&quot;&gt;5.2 프로그램 성능의 표현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;CPE : 요소당 측정 사이클metric cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;53-프로그램-예제&quot;&gt;5.3 프로그램 예제&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;코드를 최적화하는 방법은 다음과 같은 방법들이 존재한다.
    &lt;ul&gt;
      &lt;li&gt;타깃 머신의 특징을 고려하지 않은 최적화 기법
        &lt;ul&gt;
          &lt;li&gt;루프 비효율성 제거하기&lt;/li&gt;
          &lt;li&gt;프로시저 호출 줄이기&lt;/li&gt;
          &lt;li&gt;불필요한 메모리 참조 제거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;최신 프로세서의 인스트럭션 수준 병렬성을 고려한 최적화 기법
        &lt;ul&gt;
          &lt;li&gt;루프풀기&lt;/li&gt;
          &lt;li&gt;병렬성 높이기&lt;/li&gt;
          &lt;li&gt;재결합 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최신프로세서의 인스트럭션 수준 병렬성을 고려하기 위해 5.7절에서 최신프로세서에 대해서 조금 다루고 넘어간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;54-루프-비효율성-제거하기&quot;&gt;5.4 루프 비효율성 제거하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;테스트 조건이 루프의 매 실행마다 평가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_1.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_2.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;lower1은 n^2&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lower2는 n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;겉보기에는 의미 없는 코드가 감춰진 잠재적 비효율성을 갖고 있다.&lt;/li&gt;
  &lt;li&gt;적은 데이터 셋으로 시험하고 분석되지만, 프로그램이 궁극적으로 배포되면, 프로시저가 백만 개 문자들의 스트리에 적용될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;이러한 상황에 안전했던 코드조각이 주요 성능 병목이 되게된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;경쟁력 있는 프로그래머 역할의 한 부분은 지속적으로 소개되는 그러한 잠재적 비효율성을 피하는것이다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;55-프로시저-호출-줄이기&quot;&gt;5.5 프로시저 호출 줄이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로시저 호출은 오버헤드를 발생시키고 대부분의 프로그램 최적화 작업을 방해할 수 있다.&lt;/li&gt;
  &lt;li&gt;경계값을 체크하는 것은 배열의 임의로 접근하는 경우를 처리할 때에는 유용할 수 있지만, 특정 경우에는 모든 참조 시도가 유효하다.&lt;/li&gt;
  &lt;li&gt;예제에서 각 벡터의 원소를 가져오기 위해서 작성된 함수(벡터 경계값 체크 함수)를 매번 호출하는 대신 배열에 직접 접근한다.
    &lt;ul&gt;
      &lt;li&gt;결벽주의자들은 이렇게 변환하는 것이 프로그램 모듈성을 심각하게 훼손한다고 말할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실용적인 프로그래머라면 이러한 변환과정이 고성능 결과를 얻기 위해서 필요한 단계라고 주장할 것이다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;56-불필요한-메모리-참조의-제거&quot;&gt;5.6 불필요한 메모리 참조의 제거&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_3.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결과값을 임시로 누적한다.
    &lt;ul&gt;
      &lt;li&gt;누적값을 지역변수 acc에 저장하면 매 루프 반복실행마다 메모리에서 가져오고 갱신된 값을 다시 기록할 필요가 없어진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;57-최신-프로세서-이해하기&quot;&gt;5.7 최신 프로세서 이해하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;코드의 성능을 더 개선하기 위해서는 프로세서의 마이크로구조, 즉 프로세서가 인스트럭션을 실행하도록 하는 하부 시스템 설계를 활용하는 최적화 기법을 고려해야한다.&lt;/li&gt;
  &lt;li&gt;실제 프로세서에서 많은 인스트럭션들이 동시에 처리된다.
    &lt;ul&gt;
      &lt;li&gt;이것을 인스트럭션 수준 병렬성이라고 부른다.&lt;/li&gt;
      &lt;li&gt;두 개의 서로 다른 하위 경계값lower bounds가 프로그램의 최대 성능을 결정한다.
        &lt;ul&gt;
          &lt;li&gt;지연시간 경계값 : 일련의 연산들이 엄격하게 순서를 준수하여 수행되어야 할 때 발생&lt;/li&gt;
          &lt;li&gt;처리량 경계값: 프로세서의 기능 유닛들의 기본 계산 능력을 결정한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;571-전체적인-동작&quot;&gt;5.7.1 전체적인 동작&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최신 프로세서는 인스트럭션이 실행되는 순서가 기계어 수준 프로그램에서의 순서와 일치할 필요가 없다.
    &lt;ul&gt;
      &lt;li&gt;무순서 out-of-order라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_5.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 최신 프로세서의 블록 다이어그램이다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 제어 유닛(ICU)은 인스트럭션들을 메모리에서 읽고 일련의 기본연산들을 생성하는 역할을 수행한다.&lt;/li&gt;
      &lt;li&gt;그 이후 실행 유닛(EU)은 연산을 수행하여 분기가 정확히 예측되었는지 여부를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최신 프로세서들은 ‘분기 예측branch prediction’이라는 기술을 사용한다.&lt;/li&gt;
  &lt;li&gt;‘추정 실행speculative execution’이라는 기술을 사용해서 분기가 이동해야 하는 위치에 있는 인스트럭션을 선입하고 해독한다.&lt;/li&gt;
  &lt;li&gt;Fetch control 블록은 분기예측과 연동해서 어떤 인스트럭션을 선입할지를 결정한다.&lt;/li&gt;
  &lt;li&gt;추정 실행을 사용해서 연산들이 계산되지만, 확실할 때까지 최종 결과값들은 데이터 메모리나 레지스터에 저장되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국 최신 프로세서들은 ‘무순서로 연산들을 병렬로 진행한다.’라고 말하는 것 같다. 하지만, 데이터 의존성이 있는 경우에는 병렬로 진행할 수 없기 때문에 지연이 발생하고,
이런 데이터 의존성은 컴파일러가 최적화를 할 수 없다.(다른 코드로 변경시 무조건적으로 무결성하다는 것을 입증할 수 없어서) 그렇기 때문에 우리는 데이터 의존성을 줄일 수 있는 코드를 작성하여
최적화를 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;572-함수유닛의-성능&quot;&gt;5.7.2 함수유닛의 성능&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;발급시간 issue time: 두 연산 사이에 소요되는 최소 사이클 수&lt;/li&gt;
  &lt;li&gt;용량 capacity: 해당 연산을 수행할 수 있는 함수 유닛의 수&lt;/li&gt;
  &lt;li&gt;지연 latency: 실제 연산을 수행하는 데 걸린 클럭 사이클 수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_6.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 인텔 코어 i7의 지연시간과 발급시간 특성이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기계수준-코드로부터-데이터흐름-그래프로의-변환&quot;&gt;기계수준 코드로부터 데이터흐름 그래프로의 변환&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_7.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;combine4에 대한 내부 루프의 그림
    &lt;ul&gt;
      &lt;li&gt;인스트럭션들은 동적으로 하나 또는 두 개의 연산으로 번역된다.&lt;/li&gt;
      &lt;li&gt;각각은 다른 연산들 또는 레지스터들로부터 값들을 받고 다른 연산과 레지스터를 위한 값들을 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;루프를 구성하는 코드부분에 대해서 접근하게 되는 레지스터들을 다음의 네 종류로 구분할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;읽기전용 Read-only : 데이터 또는 메모리 주소를 계산하기 위한 소스 값들로 사용된다.&lt;/li&gt;
      &lt;li&gt;쓰기전용 Write-only : 데이터 이동 연산의 목적지로 사용된다.&lt;/li&gt;
      &lt;li&gt;지역적 Local : 루프 내에서 사용되고 갱신되지만, 한 번의 반복 실행에서 다른 실행으로의 의존성은 없다.
        &lt;ul&gt;
          &lt;li&gt;ex) cmp에 의해 갱신되며 jne 연산에 의해 사용된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;루프 Loop : 한 번의 반복실행에서 생성된 값은 다른 실행에서 사용되는 방식으로 소스 값들로 사용되며 루프의 목적지로도 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;루프 레지스터들 간의 연산들의 연결이 성능을 제한하는 데이터 의존성을 결정한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/19/img_9.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 combine4 연산들을 데이터 흐름 그래프로 추상화하였다.
    &lt;ul&gt;
      &lt;li&gt;(b)를 보면 데이터의존성을 확인할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;58-루프풀기&quot;&gt;5.8 루프풀기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;루프 풀기는 루프의 매 반복실행마다 계산되는 원소의 수를 증가시켜 루프에서의 반복 실행 횟수를 줄이는 방법이다.&lt;/li&gt;
  &lt;li&gt;루프 풀기는 두가지 측면에서 성능을 개선할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;루프 인덱스 계산과 조건부 분기와 같이 프로그램의 결과와는 직접적으로 관련 없는 연산들의 수를 줄인다.&lt;/li&gt;
      &lt;li&gt;전체 계산의 핵심 경로에 있는 연산의 수를 줄이기 위한 추가적인 코드변환을 할 수 있는 방법들을 적용할 수 있게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Combine 2 elements at a time (2X1 루프풀기)*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위 코드와 같이 반복 횟수를 줄인다.
    &lt;ul&gt;
      &lt;li&gt;kX1로 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;59-병렬성-높이기&quot;&gt;5.9 병렬성 높이기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 의존성을 줄이고자 병렬성을 높이는 방법이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다수의-누산기-사용&quot;&gt;다수의 누산기 사용&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Combine 2 elements at a time (2X1 루프풀기)*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;acc0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;acc1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;위 코드와 같이 홀수와 짝수를 나누면 데이터 의존성이 사라진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재결합-변환&quot;&gt;재결합 변환&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* default */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* reassociation transform (2X1a 루프풀기) */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OP&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;511-일부-제한-요인들&quot;&gt;5.11 일부 제한 요인들&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;최적화중 프로그램의 성능을 제한하는 다른 요소들이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5111-레지스터-넘기기&quot;&gt;5.11.1 레지스터 넘기기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램이 사용 가능한 레지스터의 수를 넘어가는 병렬성을 가지면, 메모리에 저장하게 되는 &lt;strong&gt;레지스터 넘기기 spilling&lt;/strong&gt; 방법이 사용된다.
    &lt;ul&gt;
      &lt;li&gt;이 때 런타임 스택에 공간을 할당하기 때문에 성능이 저하된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5112-분기예측과-예측비용&quot;&gt;5.11.2 분기예측과 예측비용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;if문보다 삼항연산자가 더 빠르다.
    &lt;blockquote&gt;
      &lt;p&gt;if문은 statement, 삼항연산자는 expression이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;512-메모리-성능의-이해&quot;&gt;5.12 메모리 성능의 이해&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Load의 성능
    &lt;ul&gt;
      &lt;li&gt;반복실행에 대한 로드 연산은 이전 반복실행에 대한 로드 연산이 완료되었을 때까지는 시작할 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Store의 성능
    &lt;ul&gt;
      &lt;li&gt;store 연산은 레지스터 값을 메모리로 기록한다.&lt;/li&gt;
      &lt;li&gt;store 연산은 데이터 의존성을 발생시키지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;load 연산만이 store 연산의 결과에 영향을 받는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;513-실제상황-성능개선-기술&quot;&gt;5.13 실제상황: 성능개선 기술&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 성능의 최적화하는 기본적인 전략들
    &lt;ul&gt;
      &lt;li&gt;상위수준 설계 : 적절한 알고리즘과 자료구조를 선택&lt;/li&gt;
      &lt;li&gt;기본 코딩원칙 : 최적화 장애물 피하기
        &lt;ul&gt;
          &lt;li&gt;함수 호출 제거&lt;/li&gt;
          &lt;li&gt;계산은 루프 밖으로 이동&lt;/li&gt;
          &lt;li&gt;불필요한 메모리 참조 제거&lt;/li&gt;
          &lt;li&gt;중간 값들을 저장하는 임시 변수 사용(데이터 의존성 피하기)&lt;/li&gt;
          &lt;li&gt;최종 값이 계산되었을 때에만 전역변수나 배열에 결과 저장(load 의존성 피하기)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하위수준 최적화 : 하드웨어의 성능을 활용할 수 있는 코드 작성
        &lt;ul&gt;
          &lt;li&gt;루프풀기&lt;/li&gt;
          &lt;li&gt;다중누산기와 재결합 기법 사용&lt;/li&gt;
          &lt;li&gt;statement보다 expression 사용하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;마무리&quot;&gt;마무리&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;2장부터 4장까지 컴퓨터가 해석할 수 있는 언어들과 해당 언어들을 컴퓨터가 어떻게 해석하는지를 공부했다.
해당 방법들을 통해서 5장에서는 프로그래머들이 어떻게 코드를 작성해야 하는지를 배웠다. 
만약 컴퓨터가 코드를 해석하는 방법을 몰랐더라면, 코드 최적화 방법을 공부할 때 정확히 이해할 수 없었을 것이다.
작성한 코드에서 인스트럭션 조합과 기계어가 어떻게 동작하는지를 항상 생각하자.&lt;/p&gt;

  &lt;p&gt;추가적으로, CSAPP 포스팅 방식을 조금 변경해야할 것 같다. 4장 초반까지는 솔직히 굉장히 어려웠다. “무슨 말을 하는지 이걸 도대체 컴퓨터가 어떻게 해석한다는거지?”
라고 생각하며 의문으로 가득차 거의 모든 내용을 포스팅한 것 같다. 하지만, 4장 후반 SEQ와 파이프라이닝을 공부하고 “아! 이래서 지금까지 이런 내용들을 공부했구나!”
그리고 5장을 공부하면서 뭔가 “득도”를 하게 된 것 같다. 다양한 부분들의 이해가 빨라졌다. 앞으로 챕터를 공부하고 나의 방식으로 녹인 후 포스팅을 하는 것으로 포스팅 방향을 바꿀 것이다.&lt;/p&gt;

  &lt;p&gt;6장은 드디어 메모리 파트이다. 너무 기대된다!&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 19</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)</title><link href="http://localhost:4000/csapp/csapp_18/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_18</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_18/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
  &lt;li&gt;4.4 파이프라이닝의 일반 원리&lt;/li&gt;
  &lt;li&gt;4.5 파이프라인형 Y86-64의 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;45-파이프라인형-y86-64의-구현&quot;&gt;4.5 파이프라인형 Y86-64의 구현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;순차적 프로세서 SEQ를 약간 변형해서 PC의 계산을 선입 단계로 이동하는 것으로 프로세서를 변경한다.&lt;/li&gt;
  &lt;li&gt;이후 파이프라인 레지스터들을 단계별로 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국은 이 파이프라인형 Y86-64 “PIPE”를 만들기 위해 2장부터 4장까지 달려온 것이다.&lt;br /&gt;
우선 컴퓨터가 해석할 수 있는 정수와 부동소수점 표현과 기본 산술에 대해서 2장에서 배웠고,&lt;br /&gt;
3장에서는 프로그래머가 작성한 코드를 컴퓨터가가 해석할 수 있는 기계어로 변경하는 것을 배웠고,&lt;br /&gt;
4장 초반에서는 해당 기계어를 컴퓨터가 해석할 수 있도록 인스트럭션 집합으로 변경하는 것을 배웠고,&lt;br /&gt;
4장 후반 SEQ 구현에서는 해당 인스트럭션을 컴퓨터가 어떻게 해석하는지를 배웠고,&lt;br /&gt;
4장 후반 파이프라인 구현에서는 인스트럭션을 해석하는데에 있어 속도를 증가시키기 위해서 SEQ에 파이프라인을 구축하고,
파이프라인 구축할 때의 예외처리를 다룬 뒤 프로세서를 완성시킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;451-seq-계산-단계들을-재배치하기&quot;&gt;4.5.1 SEQ+: 계산 단계들을 재배치하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;PC 갱신 단계가 클럭 사이클의 마지막이 아니라 맨 처음에 오도록 한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 단계에서의 순차적인 동작을 더 잘 수행할 수 있다.&lt;/li&gt;
      &lt;li&gt;수정된 설계를 “SEQ+”라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PC 계산 타이밍의 변경이다.
    &lt;ul&gt;
      &lt;li&gt;SEQ+에서 인스트럭션 실행의 첫 단계로 현재 상태에 대한 프로그램 카운터 값을 계산한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;452-파이프라인-레지스터의-삽입&quot;&gt;4.5.2 파이프라인 레지스터의 삽입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ+의 단계들간에 파이프라인 레지스터들을 삽입하였으며 신호들을 재배치해서 PIPE- 프로세서를 만들었다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터들은 다음과 같이 명명하였다
    &lt;ul&gt;
      &lt;li&gt;F : 프로그램 카운터의 예측 값을 저장한다.&lt;/li&gt;
      &lt;li&gt;D : 선입과 해동 단계 사이에 위치한다. 해독 단계가 처리하기 위해서 가장 최근에 선입한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;E : 해독과 실행 단계 사이에 위치한다. 실행 단계가 처리하기 위해서 레지스터 파일로부터 읽어들인 값과 가장 최근에 해독한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;M : 실행과 메모리 단계 사이에 위치한다. 메모리 단계가 처리하기 위한 가장 최근에 실행 인스트럭션 결과와 조건부에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;W : 레지스터 파일에 기록을 위한 결과, 리턴주소, PC 선택 로직을 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_1.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 SEQ+ 하드웨어 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_2.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE- 의 하드웨어 구조, 초기 파이프라인 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 코드 배열이 어떻게 5단계 파이프라인을 통해 흘러가는지를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;453-신호의-재배치와-재명명&quot;&gt;4.5.3 신호의 재배치와 재명명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ에서는 한 번에 한 개의 인스트럭션만을 처리했지만, 파이프라인 설계에서는 인스트럭션에 연계된 여러 버전의 값이 존재한다.&lt;/li&gt;
  &lt;li&gt;PIPE-의 상세 설계에서 네 개의 서로 다른 인스트럭션을 위한 상태코드를 저장하는 “Stat”이 있다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터의 이름은 대문자를 사용한다. D_stat, E_stat, M_stat, W_stat&lt;/li&gt;
  &lt;li&gt;계산된 일부 신호의 이름은 소문자를 사용한다 f_stat, m_stat&lt;/li&gt;
  &lt;li&gt;전체 프로세서의 실제 상태 Stat이 파이프라인 레지스터 W에 기록된 상태값에 따라 재기록 단계에서 계산된다.&lt;/li&gt;
  &lt;li&gt;일반적인 원칙으로 특정 인스트럭션에 관한 모든 정보를 한 개의 파이프라인 단계 내에 유지하는 것을 원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;454-다음-pc-값의-추정&quot;&gt;4.5.4 다음 PC 값의 추정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이며, 새 인스트럭션이 실행 단계로 진행해서 궁극적으로는 완료되는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;리턴이나 조건부 점프 인스트럭션은 선입 단계에 계산된 정보를 사용해서 다음 인스트럭션의 주소를 결정할 수 없다.&lt;/li&gt;
  &lt;li&gt;따라서 매 클럭 사이클마다 하나의 새 인스트럭션을 실행하려는 우리의 목표를 달성하기 위해서 대부분의 경우에 PC의 새로운 값을 예측해야 한다.
    &lt;blockquote&gt;
      &lt;p&gt;이부분이 처음에 조금 이해가 안됐지만, 파이프라인 해저드를 공부하고 이해가 됐다. 해저드를 통해 이러한 분기예측을 제어한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;분기의 방향을 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술을 분기예측branch prediction 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;455-파이프라인-해저드&quot;&gt;4.5.5 파이프라인 해저드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;피드백이 있는 시스템에 파이프라인을 도입하면 연속되는 인스트럭션들 간에 의존성이 존재할 때 문제가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존성은 두 가지 형태를 띈다.
    &lt;ul&gt;
      &lt;li&gt;데이터 의존성: 한개의 인스트럭션이 계산한 결과가 다음에 오는 인스트럭션을 위한 데이터로 사용되는 경우&lt;/li&gt;
      &lt;li&gt;제어 의존성: jump, call, ret와 같이 한 개의 인스트럭션이 다음에 따라오는 인스트럭션의 위치를 결정하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성들이 파이프라인으로 인해 잘못된 계산을 야기할 가능서이 있을 때 해저드라고 부른다.&lt;/li&gt;
  &lt;li&gt;해저드 또한 데이터 해저드, 제어 해저드로 구분할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러x&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러X)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러o&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러O)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스톨을-사용한-데이터-해저드의-회피&quot;&gt;스톨을 사용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해저드를 회피하는 매우 일반적인 기술은 프로세서가 하나 또는 여러 인스트럭션을 해저드 조건이 사라질 때까지 파이프라인 내에 유지하는 스톨과 관련된다.&lt;/li&gt;
  &lt;li&gt;해독 단계에서 인스트럭션을 소스 오퍼랜드를 생성하는 인스트럭션들이 재기록 단계를 통과할 때까지 스톨시키는 방법으로 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;스톨링은 한 그룹의 인스트럭션들을 이들의 단계에 붙잡아두지만, 다른 인스트럭션들은 파이프라인을 계속 흘러가도록 한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션을 해독단계에 붙잡아 놓을 때마다 실행 단계에 버블을 삽입하는 방식으로 처리한다.&lt;/li&gt;
  &lt;li&gt;버블은 동적으로 생성된 nop 인스트럭션과 비슷하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포워딩forwarding을-이용한-데이터-해저드의-회피&quot;&gt;포워딩Forwarding을 이용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재기록 단계에서 이들 소스 레지스터 중의 하나에 대기하고 있는 쓰기 작업이 존재할 수 있다.&lt;/li&gt;
  &lt;li&gt;쓰기 작업이 완료될 때까지 스톨하기보다는 소스 오퍼랜드로 파이프라인 레지스터 E에 기록될 값을 단순히 전달할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터 포워딩은 메모리 단계에서 대기하고 있는 레지스터 쓰기 작업이 있을 때에도 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;위 그림은 해독 단계 로직이 레지스터 파일에서 온 값을 사용할지, 포워딩된 값을 사용할지 여부를 어떻게 결정할 수 있는지 보여준다.
    &lt;ul&gt;
      &lt;li&gt;레지스터 파일에 재기록되는 모든 값과 관련된 것은 목적지 레지스터 ID이다.&lt;/li&gt;
      &lt;li&gt;이 로직은 이 ID들을 소스 레지스터 ID인 srcA, srcB와 비교해서 포워딩을 위한 경우를 검출할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다섯개의 포워딩 소스가 해독 단계에 “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로드사용-데이터-해저드&quot;&gt;로드/사용 데이터 해저드&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_10.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 데이터 해저드는 순수하게 포워딩만 가지고는 처리할 수 없다.&lt;/li&gt;
  &lt;li&gt;해당 경우는 스톨링과 포워딩을 함께 사용해서 로드/사용 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것을 로드 인터록load interlock이라고 부른다.&lt;/li&gt;
  &lt;li&gt;포워딩과 결합된 로드 인터록은 가능한 모든 형태의 데이터 해저드를 충분히 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-해저드의-회피&quot;&gt;제어 해저드의 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제어 해저드는 프로세서가 선입 단계에서 현재 인스트럭션에 기초하여 다음 인스트럭션의 주소를 안정적으로 결정할 수 없을 때 발생한다.&lt;/li&gt;
  &lt;li&gt;제어 해저드는 ret와 점프 인스트럭션에 대해서만 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_11.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 ret가 해독, 실행, 메모리 단계를 통과하며 세개의 버블을 삽입하는 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;PC 선택 로직은 ret가 재기록 단계에 도착하면(사이클 7) 인스트럭션 선입 주소로 리턴주소를 선택하게 된다.
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_12.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 잘못 예측한 분기 인스트럭션의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 분기를 할 것이라고 예측하고, 따라서 점프 목적지에서 인스트럭션 선입을 시작한다.&lt;/li&gt;
      &lt;li&gt;점프 인스트럭션이 실행 단계를 통해 흘러갈 때 두 인스트럭션은 사이클 4에서 예측오류가 검출되기 전에 선입된다.&lt;/li&gt;
      &lt;li&gt;사이클 5에서 파이프라인은 해독과 실행단계에 버블을 삽입해서 두 목적지 인스트럭션을 취소하고, 점프 다음에 오는 인스트럭션을 선입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;간단히 두 개의 잘못 선입한 인스트럭션을 취소할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 스쿼싱squashing이라고 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;programmers-visible state에는 아무런 영향을 주지 않지만 단점은 두 클럭 사이클 만큼의 인스트럭션 처리 능력이 낭비된다는 점이다.&lt;/li&gt;
  &lt;li&gt;스톨링과 파이프라인에 버블을 삽입하는 기술들은 특수한 상황이 발생할 때 파이프라인의 흐름을 동적으로 조절한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;456-예외처리&quot;&gt;4.5.6 예외처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서의 다양한 동작은 예외적인 제어흐름을 발생시키며, 이 경우 정상적인 프로그램 실행의 연결은 끊어진다.&lt;/li&gt;
  &lt;li&gt;예외들은 프로그램 실행에 의해 내부적으로 발생하거나 외부 신호에 의해 외부적으로 생성될 수 있다.&lt;/li&gt;
  &lt;li&gt;세 가지 서로 다른 내부 생성 예외
    &lt;ol&gt;
      &lt;li&gt;halt 인스트럭션에 의한 예외&lt;/li&gt;
      &lt;li&gt;인스트럭션과 함수코드의 잘못된 조합을 갖는 인스트럭션&lt;/li&gt;
      &lt;li&gt;인스트럭션 선입 또는 데이터 읽기나 쓰기를 위해 유효하지 않은 주소에 접근하려 하는 경우&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세서가 예외를 만나면 정지하고 적절한 생태코드를 설정한다.&lt;/li&gt;
  &lt;li&gt;프로세서는 운영체제의 일부인 예외핸들러라는 프로시저를 계속 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인과-예외처리&quot;&gt;파이프라인과 예외처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인을 사용한 시스템에서 예외처리는 여러 가지 미묘한 부분들이 관계되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;예외상황이 다수의 인스트럭션들에 의해 동시에 발생할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;기본 규칙은 파이프라인에서 가장 멀리 있는 인스트럭션이 유발한 예외상황에 우선순위를 둔다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어떤 인스트럭션이 선입되고, 실행을 시작해서 예외를 발생시키고, 나중에 잘못 예측한 분기명령으로 인해 취소할 때 발생한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 제어로직은 인스트럭션을 취소한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라인 프로세서가 서로 다른 단계에서 시스템 상태의 서로 다른 부분을 갱신하기 때문에 발생한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 제어로직은 메모리나 재기록 단계의 인스트럭션이 예외를 발생시켰을 때 데이터 메모리나 조건코드 레지스터를 갱신하는 것을 김지한다.&lt;/li&gt;
  &lt;li&gt;파이프라인의 하나 이상의 단계에서 예외가 발생할 때 정보는 단순히 파이프라인 레지스터의 상태 필드에 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;457-pipe-단계의-구현&quot;&gt;4.5.7 PIPE 단계의 구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 레지스터, 재구성 가능한 로직 블록, 추가적인 파이프라인 제어로직을 추가하고, 이전의 순차적 설계 같은 하드웨어 유닛들을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pc-선택과-선입-단계&quot;&gt;PC 선택과 선입 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_13.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 카운터의 현재 값을 선택해야하며, 다음 PC 값을 예측해야 한다.&lt;/li&gt;
  &lt;li&gt;메모리에서 인스트럭션을 읽고 여러 가지 인스트럭션 필드들을 추출하기 위한 하드웨어 유닛들은 SEQ를 위해 고려한 것과 동일하다.&lt;/li&gt;
  &lt;li&gt;하나의 사이클 시간의 범위 내에 프로세서는 다음 인스트럭션의 주소를 예측만 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해독-및-재기록-단계&quot;&gt;해독 및 재기록 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_14.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;valP와 레지스터 포트 A로부터 읽은 값을 동시에 요구하는 인스트럭션은 없으며 따라서 이들은 다음 단계를 위한 신호 valA를 구성하기 위해 통합할 수 있따.
    &lt;ul&gt;
      &lt;li&gt;“Sel+FwdA” 블록이 해당 일을 수행하고 valA를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
      &lt;li&gt;“FwdB” 블록은 소스 오퍼랜드 valB를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 쓰기 위치는 해독 단계보다는 재기록 단계에서 가져온 dstE와 dstM으로 나타낸다.
    &lt;ul&gt;
      &lt;li&gt;해독 단계가 현재 재기록 단계에 있는 인스트럭션의 결과를 기록하고 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_15.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 HCL 코드에서 다섯 개의 포워딩 소스에 주어진 우선순위는 매우 종요하다.&lt;/li&gt;
  &lt;li&gt;우선순위는 HCL코드에서 다섯 개의 목적지 레지스터 ID가 시험되는 순서에 의해 결정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실행-단계&quot;&gt;실행 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_16.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 실행 단계 로직이다. 이 부분의 설계는 SEQ의 로직과 매우 유사하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-단계&quot;&gt;메모리 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_17.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 메모리 단계 로직이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 레지스터 M, W의 많은 신호들이 앞 단계들로 전달되어 재기록한 결과, 인스트럭션 주소, 포워드된 값들을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;458-파이프라인-제어로직&quot;&gt;4.5.8 파이프라인 제어로직&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 포워딩과 분기예측과 같이 다른 방법들로는 처리할 수 없는 다음과 같은 네 개의 제어 경우를 처리해야 한다.
    &lt;ul&gt;
      &lt;li&gt;로드/사용 해저드 : 메모리에서 값을 읽은 인스트럭션과 이 값을 사용하는 인스트럭션 사이에 한 사이클 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;잘못 예측한 분기 : 예측으로 인해 잘못 선입된 인스트럭션들은 취소되어야 하며, 선입 단계는 점프 인스트럭션 다음의 인스트럭션에서 시작해야한다.&lt;/li&gt;
      &lt;li&gt;예외 : 어떤 인스트럭션이 예외를 발생시키면 programmer-visible state가 갱신되는 것을 막아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수한-제어-상황들의-바람직한-처리&quot;&gt;특수한 제어 상황들의 바람직한 처리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_18.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션의 상세한 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;선입 단계는 ret 인스트럭션 다음의 rrmovq 인스트럭션을 반복적으로 선입하지만, 파이프라인 제어회로는 rrmovq 인스트럭션이 진행하는 것을 허용하는 대신에 해독 단계에 한 개의 버블을 삽입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_19.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 유효하지 않은 메모리 참조 예외의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;사이클 6에서 pushq 인스트럭션으로 인한 유효하지 않은 메모리 차몾는 조건코드 갱신을 금지시킨다.&lt;/li&gt;
      &lt;li&gt;파이프라인은 메모리 단계에 버블을 삽입하기 시작하고 재기록 단계에 있는 예외 인스트럭션을 스톨시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수-제어-조건의-감지&quot;&gt;특수 제어 조건의 감지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ret 인스트럭션이 파이프라인을 통과해 갈 때 검출하려면 해독, 실행, 메모리 단계에 있는 인스트럭션들의 인스트럭션 코드를 단순히 체크하면 된다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 검출하려면 실행 단계에 있는 인스트럭션의 종류(mrmovq, popq)를 체크해야 하고, 해독 단계에 있는 인스트럭션의 소스 레지스터들과 목적지 레지스터들을 비교해야 한다.&lt;/li&gt;
  &lt;li&gt;파이프라인 제어로직은 인스트럭션이 해독 단계에 있는 동안 잘못 예측한 분기를 검출해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인-제어-과정&quot;&gt;파이프라인 제어 과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_20.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 파이프라인 레지스터 동작이다.
    &lt;ul&gt;
      &lt;li&gt;a. 정상 조건 시 레지스터의 상태와 출력은 클럭이 상승할 때 입력 값으로 설정된다.&lt;/li&gt;
      &lt;li&gt;b. 스톨 모드에서 동작할 때, 상태는 이전 값으로 고정된다.&lt;/li&gt;
      &lt;li&gt;c. 버블 모드에서 동작할 때 상태는 연산의 결과로 기록된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-조건들의-조합&quot;&gt;제어 조건들의 조합&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_21.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 특수한 제어 조건들에 대한 파이프라인 상태이다.
    &lt;ul&gt;
      &lt;li&gt;표시한 두 쌍은 동시에 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-로직의-구현&quot;&gt;제어 로직의 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_22.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE 파이프라인 제어로직이다.
    &lt;ul&gt;
      &lt;li&gt;이 로직은 프로시저 리턴, 잘못 예측한 분기, 로드/사용 해저드, 프로그램 예외 같은 특수한 조건들을 처리하기 위해서 정상적인 인스트럭션 흐름이 파이프라인을 통과하는 것을 정지시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;459-성능-분석&quot;&gt;4.5.9 성능 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스트럭션마다 걸리는 평균 클럭 사이클 수는 CPIcycles per instruction라는 단위로 추정값을 계산한다.
    &lt;ul&gt;
      &lt;li&gt;Ci 인스트르럭션, Cb 버블을 처리한다면, 프로세서는 Ci + Cb개의 클럭 사이클을 필요로한다.&lt;/li&gt;
      &lt;li&gt;CPI = 1.0 + Cb/Ci 이다.&lt;/li&gt;
      &lt;li&gt;오직 세개의 인스트럭션 타입만이 버블을 추가하기 때문에
        &lt;ul&gt;
          &lt;li&gt;CPI = 1.0 lr(load penalty) + mp(mispredicted branch penalty) + rp(return penalty)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4510-남아-있는-작업&quot;&gt;4.5.10 남아 있는 작업&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중 사이클 인스트럭션
    &lt;ul&gt;
      &lt;li&gt;다중 인스트럭션을 구현하는 한 가지 간단한 방법은 실행 단계 로직의 성능을 정수와 부동 소수점 산술연산 유닛들을 포함하도록 단순히 확장하는 것이다.
        &lt;ul&gt;
          &lt;li&gt;한 개의 인스트럭션이 해독 단계에 들어갈 때 특수 유닛으로 보낸다.(ex. 부동소수점 유닛)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 시스템과의 인터페이스&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;46-요약&quot;&gt;4.6 요약&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;해당 장을 통해 인스트럭션 집합 아키텍처 ISA는 프로세서의 동작과 프로세서가 어떻게 구현되는지 간에 추상화 계층을 제공한다는 것을 알 수 있었다.&lt;/li&gt;
  &lt;li&gt;ISA는 프로그램 실행을 하나의 인스트럭션이 다음 인스트럭션이 시작되기 전에 실행되어 종료되는 순차적인 프로그램 실행의 모습을 제공한다.&lt;/li&gt;
  &lt;li&gt;여러 가지 인스트럭션들이 요구하는 처리작업을 5단계로 구성하였으며, 전체 인스트럭션이 다섯 단계를 통해 들어가서 매 클럭 사이클마다 실행된다.&lt;/li&gt;
  &lt;li&gt;파이프라인은 여러 단계들이 동시에 동작하도록 하여 시스템의 처리량 성능을 개선한다.&lt;/li&gt;
  &lt;li&gt;예외를 적절히 처리하는 것은 높은 파이프라인 단계와 병렬성을 사용하는 시스템에서 보다 복잡해진다.&lt;/li&gt;
  &lt;li&gt;교훈
    &lt;ul&gt;
      &lt;li&gt;복잡성을 관리하는 것이 최우선순위를 갖는다.
        &lt;ul&gt;
          &lt;li&gt;모든 인스트럭션 타입을 처리하기 위한 매우 간단하고 통일된 프레임워크를 만들어서 구현하였다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ISA를 직접 구현할 필요는 없다.
        &lt;ul&gt;
          &lt;li&gt;파이프라인 설계를 사용하였고 파이프라인 해저드를 처리할 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하드웨어 설계자는 꼼꼼해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2장부터 4장이 하드웨어까지의 모든 부분들을 살펴본 것 같다. 4장은 꼭 한번 더 읽어보자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 18</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)</title><link href="http://localhost:4000/csapp/csapp_17/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_17</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_17/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;44-파이프라이닝의-일반-원리&quot;&gt;4.4 파이프라이닝의 일반 원리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 시스템의 일반적인 특징과 원리들을 생각해보자.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 시스템에서 수행해야 할 일은 여러 개의 일련의 단계뜰로 나누어진다.&lt;/li&gt;
      &lt;li&gt;식당의 예를들면, 샐러드를 먼저 제공하고, 메인 음식, 디저트 그리고 음료의 순으로 제공하는 것과 비슷하다.&lt;/li&gt;
      &lt;li&gt;컨베이어 벨트와 비슷하게 여러 고객이 동시에 시스템을 진행하도록 한다.&lt;/li&gt;
      &lt;li&gt;비록 어떤 사람은 일부 음식만을 원할지라도 모든 단계를 통과해 간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라이닝의 주요 특징
    &lt;ul&gt;
      &lt;li&gt;시스템 처리량(단위시간당 처리하는 고객의 수)을 증가시킨다.&lt;/li&gt;
      &lt;li&gt;지연시간(고객을 지원하는 데 걸리는 시간)을 증가시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;441-계산용-파이프라인&quot;&gt;4.4.1 계산용 파이프라인&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;위의 식당의 예를 계산용 파이프라인으로 초점을 옮기면
    &lt;ul&gt;
      &lt;li&gt;“고객들”은 인스트럭션&lt;/li&gt;
      &lt;li&gt;단계들은 인스트럭션 실행의 일부분을 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 간단한 비파이프라인 하드웨어 시스템의 예이다.
    &lt;ul&gt;
      &lt;li&gt;계산을 수행하는 일부 로직으로 이루어진다.&lt;/li&gt;
      &lt;li&gt;계산 결과를 저장하는 레지스터가 따라온다.&lt;/li&gt;
      &lt;li&gt;클럭 신호는 규칙적인 시간간격으로 레지스터에 로딩되는 것을 제어한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 조합로직은 300ps를 필요로하고 레지스터 로딩은 20ps를 필요로 한다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/320 * 1,000 = 3.12&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 320ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 3단계 파이프라인 계산 하드웨어이다.
    &lt;ul&gt;
      &lt;li&gt;시스템에서 수행하는 계산을 세 단계 A,B,C로 나눌 수 있다고 가정한다.&lt;/li&gt;
      &lt;li&gt;파이프라인 레지스터들을 단계 사이에 배치해서 각 인스트럭션이 3단계로 시스템을 통해 이동한다.&lt;/li&gt;
      &lt;li&gt;시작부토 종료할 때까지 세 개의 클럭 사이클이 소요된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 클럭을 매 100+20=120ps이고 한 개의 인스트럭션을 처리하는 데 3클럭 사이클이 필요하다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/120 * 1,000 = 8.33&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 360ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비파이프라인 보다 처리량은 빠르지만 지연시간이 증가한 이유는 추가된 파이프라인 레지스터에 의한 오버헤드 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;442-파이프라인-연산의-상세한-고찰&quot;&gt;4.4.2 파이프라인 연산의 상세한 고찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 단계들 간에 인스트럭션의 이동은 위의 파이프라인 다이어그램에 나타낸 것과 같이 클럭 신호에 의해 제어된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 한 사이클 동안의 파이프라인 동작이다.
    &lt;ul&gt;
      &lt;li&gt;신호들은 파이프라인 레지스터 입력들로 전달되지만, 클럭이 상승할 때까지 레지스터의 상태는 바뀌지 않는다.&lt;/li&gt;
      &lt;li&gt;클럭을 늦추는 것이 파이프라인의 동작을 변화시키지 않는다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;443-파이프라이닝의-한계&quot;&gt;4.4.3 파이프라이닝의 한계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인의 효과를 축소시키는 여러 요소들이 종종 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비균일-분리-nonuniform-partitioning&quot;&gt;비균일 분리 Nonuniform Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 이전처럼 세 단계로 나눈 시스템이지만 각 단계에서 발생하는 지연시간은 50에서 150 ps까지 변화한다.&lt;/li&gt;
  &lt;li&gt;우리가 구동할 수 있는 클럭의 속도는 가장 늦은 단계의 시간지연 값에 의해 결정된다.&lt;/li&gt;
  &lt;li&gt;실제 시스템 설계에서는 타이밍을 최적화하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;줄어드는-깊은-파이프라이닝의-효과&quot;&gt;줄어드는 깊은 파이프라이닝의 효과&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 여섯 단계로 나누었고, 각각은 50ps를 소모한다.&lt;/li&gt;
  &lt;li&gt;이 시스템의 클럭 주기는 50+20=70ps, 처리량은 14.29, 지연시간은 480이다.&lt;/li&gt;
  &lt;li&gt;각 계산 블록에서 소요되는 시간을 2분의 1로 줄였지만 파이프라인 레지스터를 통과하는 시간지연으로 인해 처리량은 두 배를 얻지 못했다.&lt;/li&gt;
  &lt;li&gt;이 지연시간은 파이프라인의 처리량에 있어서 제한요소가 된다.&lt;/li&gt;
  &lt;li&gt;최신 프로세서들은 프로세서의 클럭속도를 최대로 올리기 위해 매우 깊은(15단계 이상) 파이프라인을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;444-피드백을-갖는-파이프라인-시스템&quot;&gt;4.4.4 피드백을 갖는 파이프라인 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기계어 프로그램을 실행하는 시스템에서는 연속적인 인스트럭션들 간에는 잠재적인 의존성이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_5.png&quot; width=&quot;30%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;예를들어 위의 코드 배열은 각각의 연속되는 인스트럭션들 간에 원으로 표시한 레지스터 이름에 데이터 의존성이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_6.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 피드백을 갖는 시스템에 파이프라인을 추가할 때의 위험을 보여준다.
    &lt;ul&gt;
      &lt;li&gt;피드백이 있는 파이프라인을 사용하지 않는 시스템(a)에서 파이프라인 시스템(c)으로 전환하기 위해서 두 파이프라인 다이어그램에서 보는 바와 같이 계산적인 동작을 변경한다(b와d)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 17</summary></entry></feed>