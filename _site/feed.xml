<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-03-19T17:27:06+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">[CS:APP] Chapter 05 프로그램 성능 최적화하기</title><link href="http://localhost:4000/cs:app/csapp_19/" rel="alternate" type="text/html" title="[CS:APP] Chapter 05 프로그램 성능 최적화하기" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_19</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_19/"></content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 19</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)</title><link href="http://localhost:4000/cs:app/csapp_17/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.4 파이프라이닝의 일반 원리)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_17</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_17/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;44-파이프라이닝의-일반-원리&quot;&gt;4.4 파이프라이닝의 일반 원리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 시스템의 일반적인 특징과 원리들을 생각해보자.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 시스템에서 수행해야 할 일은 여러 개의 일련의 단계뜰로 나누어진다.&lt;/li&gt;
      &lt;li&gt;식당의 예를들면, 샐러드를 먼저 제공하고, 메인 음식, 디저트 그리고 음료의 순으로 제공하는 것과 비슷하다.&lt;/li&gt;
      &lt;li&gt;컨베이어 벨트와 비슷하게 여러 고객이 동시에 시스템을 진행하도록 한다.&lt;/li&gt;
      &lt;li&gt;비록 어떤 사람은 일부 음식만을 원할지라도 모든 단계를 통과해 간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라이닝의 주요 특징
    &lt;ul&gt;
      &lt;li&gt;시스템 처리량(단위시간당 처리하는 고객의 수)을 증가시킨다.&lt;/li&gt;
      &lt;li&gt;지연시간(고객을 지원하는 데 걸리는 시간)을 증가시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;441-계산용-파이프라인&quot;&gt;4.4.1 계산용 파이프라인&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;위의 식당의 예를 계산용 파이프라인으로 초점을 옮기면
    &lt;ul&gt;
      &lt;li&gt;“고객들”은 인스트럭션&lt;/li&gt;
      &lt;li&gt;단계들은 인스트럭션 실행의 일부분을 수행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 간단한 비파이프라인 하드웨어 시스템의 예이다.
    &lt;ul&gt;
      &lt;li&gt;계산을 수행하는 일부 로직으로 이루어진다.&lt;/li&gt;
      &lt;li&gt;계산 결과를 저장하는 레지스터가 따라온다.&lt;/li&gt;
      &lt;li&gt;클럭 신호는 규칙적인 시간간격으로 레지스터에 로딩되는 것을 제어한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 조합로직은 300ps를 필요로하고 레지스터 로딩은 20ps를 필요로 한다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/320 * 1,000 = 3.12&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 320ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 3단계 파이프라인 계산 하드웨어이다.
    &lt;ul&gt;
      &lt;li&gt;시스템에서 수행하는 계산을 세 단계 A,B,C로 나눌 수 있다고 가정한다.&lt;/li&gt;
      &lt;li&gt;파이프라인 레지스터들을 단계 사이에 배치해서 각 인스트럭션이 3단계로 시스템을 통해 이동한다.&lt;/li&gt;
      &lt;li&gt;시작부토 종료할 때까지 세 개의 클럭 사이클이 소요된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 예제에서는 클럭을 매 100+20=120ps이고 한 개의 인스트럭션을 처리하는 데 3클럭 사이클이 필요하다.
    &lt;ul&gt;
      &lt;li&gt;이 시스템에서 처리량은 1/120 * 1,000 = 8.33&lt;/li&gt;
      &lt;li&gt;이 시스템에서 지연시간은 360ps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비파이프라인 보다 처리량은 빠르지만 지연시간이 증가한 이유는 추가된 파이프라인 레지스터에 의한 오버헤드 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;442-파이프라인-연산의-상세한-고찰&quot;&gt;4.4.2 파이프라인 연산의 상세한 고찰&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 단계들 간에 인스트럭션의 이동은 위의 파이프라인 다이어그램에 나타낸 것과 같이 클럭 신호에 의해 제어된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 한 사이클 동안의 파이프라인 동작이다.
    &lt;ul&gt;
      &lt;li&gt;신호들은 파이프라인 레지스터 입력들로 전달되지만, 클럭이 상승할 때까지 레지스터의 상태는 바뀌지 않는다.&lt;/li&gt;
      &lt;li&gt;클럭을 늦추는 것이 파이프라인의 동작을 변화시키지 않는다는 것을 알 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;443-파이프라이닝의-한계&quot;&gt;4.4.3 파이프라이닝의 한계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인의 효과를 축소시키는 여러 요소들이 종종 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비균일-분리-nonuniform-partitioning&quot;&gt;비균일 분리 Nonuniform Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 이전처럼 세 단계로 나눈 시스템이지만 각 단계에서 발생하는 지연시간은 50에서 150 ps까지 변화한다.&lt;/li&gt;
  &lt;li&gt;우리가 구동할 수 있는 클럭의 속도는 가장 늦은 단계의 시간지연 값에 의해 결정된다.&lt;/li&gt;
  &lt;li&gt;실제 시스템 설계에서는 타이밍을 최적화하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;줄어드는-깊은-파이프라이닝의-효과&quot;&gt;줄어드는 깊은 파이프라이닝의 효과&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 계산을 여섯 단계로 나누었고, 각각은 50ps를 소모한다.&lt;/li&gt;
  &lt;li&gt;이 시스템의 클럭 주기는 50+20=70ps, 처리량은 14.29, 지연시간은 480이다.&lt;/li&gt;
  &lt;li&gt;각 계산 블록에서 소요되는 시간을 2분의 1로 줄였지만 파이프라인 레지스터를 통과하는 시간지연으로 인해 처리량은 두 배를 얻지 못했다.&lt;/li&gt;
  &lt;li&gt;이 지연시간은 파이프라인의 처리량에 있어서 제한요소가 된다.&lt;/li&gt;
  &lt;li&gt;최신 프로세서들은 프로세서의 클럭속도를 최대로 올리기 위해 매우 깊은(15단계 이상) 파이프라인을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;444-피드백을-갖는-파이프라인-시스템&quot;&gt;4.4.4 피드백을 갖는 파이프라인 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기계어 프로그램을 실행하는 시스템에서는 연속적인 인스트럭션들 간에는 잠재적인 의존성이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/17/img_5.png&quot; width=&quot;30%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;예를들어 위의 코드 배열은 각각의 연속되는 인스트럭션들 간에 원으로 표시한 레지스터 이름에 데이터 의존성이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/17/img_6.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 피드백을 갖는 시스템에 파이프라인을 추가할 때의 위험을 보여준다.
    &lt;ul&gt;
      &lt;li&gt;피드백이 있는 파이프라인을 사용하지 않는 시스템(a)에서 파이프라인 시스템(c)으로 전환하기 위해서 두 파이프라인 다이어그램에서 보는 바와 같이 계산적인 동작을 변경한다(b와d)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 17</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)</title><link href="http://localhost:4000/cs:app/csapp_18/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.5 파이프라인형 Y86-64의 구현)" /><published>2022-03-19T00:00:00+09:00</published><updated>2022-03-19T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_18</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_18/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
  &lt;li&gt;4.4 파이프라이닝의 일반 원리&lt;/li&gt;
  &lt;li&gt;4.5 파이프라인형 Y86-64의 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;45-파이프라인형-y86-64의-구현&quot;&gt;4.5 파이프라인형 Y86-64의 구현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;순차적 프로세서 SEQ를 약간 변형해서 PC의 계산을 선입 단계로 이동하는 것으로 프로세서를 변경한다.&lt;/li&gt;
  &lt;li&gt;이후 파이프라인 레지스터들을 단계별로 추가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;결국은 이 파이프라인형 Y86-64 “PIPE”를 만들기 위해 2장부터 4장까지 달려온 것이다.&lt;br /&gt;
우선 컴퓨터가 해석할 수 있는 정수와 부동소수점 표현과 기본 산술에 대해서 2장에서 배웠고,&lt;br /&gt;
3장에서는 프로그래머가 작성한 코드를 컴퓨터가가 해석할 수 있는 기계어로 변경하는 것을 배웠고,&lt;br /&gt;
4장 초반에서는 해당 기계어를 컴퓨터가 해석할 수 있도록 인스트럭션 집합으로 변경하는 것을 배웠고,&lt;br /&gt;
4장 후반 SEQ 구현에서는 해당 인스트럭션을 컴퓨터가 어떻게 해석하는지를 배웠고,&lt;br /&gt;
4장 후반 파이프라인 구현에서는 인스트럭션을 해석하는데에 있어 속도를 증가시키기 위해서 SEQ에 파이프라인을 구축하고,
파이프라인 구축할 때의 예외처리를 다룬 뒤 프로세서를 완성시킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;451-seq-계산-단계들을-재배치하기&quot;&gt;4.5.1 SEQ+: 계산 단계들을 재배치하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;PC 갱신 단계가 클럭 사이클의 마지막이 아니라 맨 처음에 오도록 한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 단계에서의 순차적인 동작을 더 잘 수행할 수 있다.&lt;/li&gt;
      &lt;li&gt;수정된 설계를 “SEQ+”라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PC 계산 타이밍의 변경이다.
    &lt;ul&gt;
      &lt;li&gt;SEQ+에서 인스트럭션 실행의 첫 단계로 현재 상태에 대한 프로그램 카운터 값을 계산한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;452-파이프라인-레지스터의-삽입&quot;&gt;4.5.2 파이프라인 레지스터의 삽입&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ+의 단계들간에 파이프라인 레지스터들을 삽입하였으며 신호들을 재배치해서 PIPE- 프로세서를 만들었다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터들은 다음과 같이 명명하였다
    &lt;ul&gt;
      &lt;li&gt;F : 프로그램 카운터의 예측 값을 저장한다.&lt;/li&gt;
      &lt;li&gt;D : 선입과 해동 단계 사이에 위치한다. 해독 단계가 처리하기 위해서 가장 최근에 선입한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;E : 해독과 실행 단계 사이에 위치한다. 실행 단계가 처리하기 위해서 레지스터 파일로부터 읽어들인 값과 가장 최근에 해독한 인스트럭션에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;M : 실행과 메모리 단계 사이에 위치한다. 메모리 단계가 처리하기 위한 가장 최근에 실행 인스트럭션 결과와 조건부에 관한 정보를 저장한다.&lt;/li&gt;
      &lt;li&gt;W : 레지스터 파일에 기록을 위한 결과, 리턴주소, PC 선택 로직을 저장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_1.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 SEQ+ 하드웨어 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_2.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE- 의 하드웨어 구조, 초기 파이프라인 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 코드 배열이 어떻게 5단계 파이프라인을 통해 흘러가는지를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;453-신호의-재배치와-재명명&quot;&gt;4.5.3 신호의 재배치와 재명명&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ에서는 한 번에 한 개의 인스트럭션만을 처리했지만, 파이프라인 설계에서는 인스트럭션에 연계된 여러 버전의 값이 존재한다.&lt;/li&gt;
  &lt;li&gt;PIPE-의 상세 설계에서 네 개의 서로 다른 인스트럭션을 위한 상태코드를 저장하는 “Stat”이 있다.&lt;/li&gt;
  &lt;li&gt;파이프라인 레지스터의 이름은 대문자를 사용한다. D_stat, E_stat, M_stat, W_stat&lt;/li&gt;
  &lt;li&gt;계산된 일부 신호의 이름은 소문자를 사용한다 f_stat, m_stat&lt;/li&gt;
  &lt;li&gt;전체 프로세서의 실제 상태 Stat이 파이프라인 레지스터 W에 기록된 상태값에 따라 재기록 단계에서 계산된다.&lt;/li&gt;
  &lt;li&gt;일반적인 원칙으로 특정 인스트럭션에 관한 모든 정보를 한 개의 파이프라인 단계 내에 유지하는 것을 원한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;454-다음-pc-값의-추정&quot;&gt;4.5.4 다음 PC 값의 추정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 설계의 목표는 매 클럭 사이클마다 새로운 인스트럭션을 실행하는 것이며, 새 인스트럭션이 실행 단계로 진행해서 궁극적으로는 완료되는 것을 의미한다.&lt;/li&gt;
  &lt;li&gt;리턴이나 조건부 점프 인스트럭션은 선입 단계에 계산된 정보를 사용해서 다음 인스트럭션의 주소를 결정할 수 없다.&lt;/li&gt;
  &lt;li&gt;따라서 매 클럭 사이클마다 하나의 새 인스트럭션을 실행하려는 우리의 목표를 달성하기 위해서 대부분의 경우에 PC의 새로운 값을 예측해야 한다.
    &lt;blockquote&gt;
      &lt;p&gt;이부분이 처음에 조금 이해가 안됐지만, 파이프라인 해저드를 공부하고 이해가 됐다. 해저드를 통해 이러한 분기예측을 제어한다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;분기의 방향을 추측하고 추측 결과에 따라 인스트럭션을 선입하는 기술을 분기예측branch prediction 이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;455-파이프라인-해저드&quot;&gt;4.5.5 파이프라인 해저드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;피드백이 있는 시스템에 파이프라인을 도입하면 연속되는 인스트럭션들 간에 의존성이 존재할 때 문제가 발생할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존성은 두 가지 형태를 띈다.
    &lt;ul&gt;
      &lt;li&gt;데이터 의존성: 한개의 인스트럭션이 계산한 결과가 다음에 오는 인스트럭션을 위한 데이터로 사용되는 경우&lt;/li&gt;
      &lt;li&gt;제어 의존성: jump, call, ret와 같이 한 개의 인스트럭션이 다음에 따라오는 인스트럭션의 위치를 결정하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;의존성들이 파이프라인으로 인해 잘못된 계산을 야기할 가능서이 있을 때 해저드라고 부른다.&lt;/li&gt;
  &lt;li&gt;해저드 또한 데이터 해저드, 제어 해저드로 구분할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러x&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러X)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;특별한-파이프라인-제어-없는-경우의-파이프라인-실행에러o&quot;&gt;특별한 파이프라인 제어 없는 경우의 파이프라인 실행(에러O)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;스톨을-사용한-데이터-해저드의-회피&quot;&gt;스톨을 사용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;해저드를 회피하는 매우 일반적인 기술은 프로세서가 하나 또는 여러 인스트럭션을 해저드 조건이 사라질 때까지 파이프라인 내에 유지하는 스톨과 관련된다.&lt;/li&gt;
  &lt;li&gt;해독 단계에서 인스트럭션을 소스 오퍼랜드를 생성하는 인스트럭션들이 재기록 단계를 통과할 때까지 스톨시키는 방법으로 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;스톨링은 한 그룹의 인스트럭션들을 이들의 단계에 붙잡아두지만, 다른 인스트럭션들은 파이프라인을 계속 흘러가도록 한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션을 해독단계에 붙잡아 놓을 때마다 실행 단계에 버블을 삽입하는 방식으로 처리한다.&lt;/li&gt;
  &lt;li&gt;버블은 동적으로 생성된 nop 인스트럭션과 비슷하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;포워딩forwarding을-이용한-데이터-해저드의-회피&quot;&gt;포워딩Forwarding을 이용한 데이터 해저드의 회피&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재기록 단계에서 이들 소스 레지스터 중의 하나에 대기하고 있는 쓰기 작업이 존재할 수 있다.&lt;/li&gt;
  &lt;li&gt;쓰기 작업이 완료될 때까지 스톨하기보다는 소스 오퍼랜드로 파이프라인 레지스터 E에 기록될 값을 단순히 전달할 수 있다.&lt;/li&gt;
  &lt;li&gt;데이터 포워딩은 메모리 단계에서 대기하고 있는 레지스터 쓰기 작업이 있을 때에도 사용될 수 있다.&lt;/li&gt;
  &lt;li&gt;위 그림은 해독 단계 로직이 레지스터 파일에서 온 값을 사용할지, 포워딩된 값을 사용할지 여부를 어떻게 결정할 수 있는지 보여준다.
    &lt;ul&gt;
      &lt;li&gt;레지스터 파일에 재기록되는 모든 값과 관련된 것은 목적지 레지스터 ID이다.&lt;/li&gt;
      &lt;li&gt;이 로직은 이 ID들을 소스 레지스터 ID인 srcA, srcB와 비교해서 포워딩을 위한 경우를 검출할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다섯개의 포워딩 소스가 해독 단계에 “Sel+Fwd A”와 “Fwd B” 두 블록으로 피드백 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로드사용-데이터-해저드&quot;&gt;로드/사용 데이터 해저드&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_10.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 읽기가 파이프라인의 뒷부분에서 일어나기 때문에 데이터 해저드는 순수하게 포워딩만 가지고는 처리할 수 없다.&lt;/li&gt;
  &lt;li&gt;해당 경우는 스톨링과 포워딩을 함께 사용해서 로드/사용 데이터 해저드를 회피할 수 있다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 처리하기 위해 스톨을 사용하는 것을 로드 인터록load interlock이라고 부른다.&lt;/li&gt;
  &lt;li&gt;포워딩과 결합된 로드 인터록은 가능한 모든 형태의 데이터 해저드를 충분히 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-해저드의-회피&quot;&gt;제어 해저드의 회피&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제어 해저드는 프로세서가 선입 단계에서 현재 인스트럭션에 기초하여 다음 인스트럭션의 주소를 안정적으로 결정할 수 없을 때 발생한다.&lt;/li&gt;
  &lt;li&gt;제어 해저드는 ret와 점프 인스트럭션에 대해서만 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_11.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 ret가 해독, 실행, 메모리 단계를 통과하며 세개의 버블을 삽입하는 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;PC 선택 로직은 ret가 재기록 단계에 도착하면(사이클 7) 인스트럭션 선입 주소로 리턴주소를 선택하게 된다.
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_12.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 잘못 예측한 분기 인스트럭션의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인은 분기를 할 것이라고 예측하고, 따라서 점프 목적지에서 인스트럭션 선입을 시작한다.&lt;/li&gt;
      &lt;li&gt;점프 인스트럭션이 실행 단계를 통해 흘러갈 때 두 인스트럭션은 사이클 4에서 예측오류가 검출되기 전에 선입된다.&lt;/li&gt;
      &lt;li&gt;사이클 5에서 파이프라인은 해독과 실행단계에 버블을 삽입해서 두 목적지 인스트럭션을 취소하고, 점프 다음에 오는 인스트럭션을 선입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;간단히 두 개의 잘못 선입한 인스트럭션을 취소할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 스쿼싱squashing이라고 불린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;programmers-visible state에는 아무런 영향을 주지 않지만 단점은 두 클럭 사이클 만큼의 인스트럭션 처리 능력이 낭비된다는 점이다.&lt;/li&gt;
  &lt;li&gt;스톨링과 파이프라인에 버블을 삽입하는 기술들은 특수한 상황이 발생할 때 파이프라인의 흐름을 동적으로 조절한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;456-예외처리&quot;&gt;4.5.6 예외처리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서의 다양한 동작은 예외적인 제어흐름을 발생시키며, 이 경우 정상적인 프로그램 실행의 연결은 끊어진다.&lt;/li&gt;
  &lt;li&gt;예외들은 프로그램 실행에 의해 내부적으로 발생하거나 외부 신호에 의해 외부적으로 생성될 수 있다.&lt;/li&gt;
  &lt;li&gt;세 가지 서로 다른 내부 생성 예외
    &lt;ol&gt;
      &lt;li&gt;halt 인스트럭션에 의한 예외&lt;/li&gt;
      &lt;li&gt;인스트럭션과 함수코드의 잘못된 조합을 갖는 인스트럭션&lt;/li&gt;
      &lt;li&gt;인스트럭션 선입 또는 데이터 읽기나 쓰기를 위해 유효하지 않은 주소에 접근하려 하는 경우&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세서가 예외를 만나면 정지하고 적절한 생태코드를 설정한다.&lt;/li&gt;
  &lt;li&gt;프로세서는 운영체제의 일부인 예외핸들러라는 프로시저를 계속 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인과-예외처리&quot;&gt;파이프라인과 예외처리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인을 사용한 시스템에서 예외처리는 여러 가지 미묘한 부분들이 관계되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;예외상황이 다수의 인스트럭션들에 의해 동시에 발생할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;기본 규칙은 파이프라인에서 가장 멀리 있는 인스트럭션이 유발한 예외상황에 우선순위를 둔다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어떤 인스트럭션이 선입되고, 실행을 시작해서 예외를 발생시키고, 나중에 잘못 예측한 분기명령으로 인해 취소할 때 발생한다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 제어로직은 인스트럭션을 취소한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프라인 프로세서가 서로 다른 단계에서 시스템 상태의 서로 다른 부분을 갱신하기 때문에 발생한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 제어로직은 메모리나 재기록 단계의 인스트럭션이 예외를 발생시켰을 때 데이터 메모리나 조건코드 레지스터를 갱신하는 것을 김지한다.&lt;/li&gt;
  &lt;li&gt;파이프라인의 하나 이상의 단계에서 예외가 발생할 때 정보는 단순히 파이프라인 레지스터의 상태 필드에 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;457-pipe-단계의-구현&quot;&gt;4.5.7 PIPE 단계의 구현&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 레지스터, 재구성 가능한 로직 블록, 추가적인 파이프라인 제어로직을 추가하고, 이전의 순차적 설계 같은 하드웨어 유닛들을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pc-선택과-선입-단계&quot;&gt;PC 선택과 선입 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_13.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 카운터의 현재 값을 선택해야하며, 다음 PC 값을 예측해야 한다.&lt;/li&gt;
  &lt;li&gt;메모리에서 인스트럭션을 읽고 여러 가지 인스트럭션 필드들을 추출하기 위한 하드웨어 유닛들은 SEQ를 위해 고려한 것과 동일하다.&lt;/li&gt;
  &lt;li&gt;하나의 사이클 시간의 범위 내에 프로세서는 다음 인스트럭션의 주소를 예측만 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해독-및-재기록-단계&quot;&gt;해독 및 재기록 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_14.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;valP와 레지스터 포트 A로부터 읽은 값을 동시에 요구하는 인스트럭션은 없으며 따라서 이들은 다음 단계를 위한 신호 valA를 구성하기 위해 통합할 수 있따.
    &lt;ul&gt;
      &lt;li&gt;“Sel+FwdA” 블록이 해당 일을 수행하고 valA를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
      &lt;li&gt;“FwdB” 블록은 소스 오퍼랜드 valB를 위한 포워딩 로직을 구현한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 쓰기 위치는 해독 단계보다는 재기록 단계에서 가져온 dstE와 dstM으로 나타낸다.
    &lt;ul&gt;
      &lt;li&gt;해독 단계가 현재 재기록 단계에 있는 인스트럭션의 결과를 기록하고 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_15.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 HCL 코드에서 다섯 개의 포워딩 소스에 주어진 우선순위는 매우 종요하다.&lt;/li&gt;
  &lt;li&gt;우선순위는 HCL코드에서 다섯 개의 목적지 레지스터 ID가 시험되는 순서에 의해 결정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실행-단계&quot;&gt;실행 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_16.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 실행 단계 로직이다. 이 부분의 설계는 SEQ의 로직과 매우 유사하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-단계&quot;&gt;메모리 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_17.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PIPE 메모리 단계 로직이다.
    &lt;ul&gt;
      &lt;li&gt;파이프라인 레지스터 M, W의 많은 신호들이 앞 단계들로 전달되어 재기록한 결과, 인스트럭션 주소, 포워드된 값들을 제공한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;458-파이프라인-제어로직&quot;&gt;4.5.8 파이프라인 제어로직&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 포워딩과 분기예측과 같이 다른 방법들로는 처리할 수 없는 다음과 같은 네 개의 제어 경우를 처리해야 한다.
    &lt;ul&gt;
      &lt;li&gt;로드/사용 해저드 : 메모리에서 값을 읽은 인스트럭션과 이 값을 사용하는 인스트럭션 사이에 한 사이클 동안 스톨해야한다.&lt;/li&gt;
      &lt;li&gt;잘못 예측한 분기 : 예측으로 인해 잘못 선입된 인스트럭션들은 취소되어야 하며, 선입 단계는 점프 인스트럭션 다음의 인스트럭션에서 시작해야한다.&lt;/li&gt;
      &lt;li&gt;예외 : 어떤 인스트럭션이 예외를 발생시키면 programmer-visible state가 갱신되는 것을 막아야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수한-제어-상황들의-바람직한-처리&quot;&gt;특수한 제어 상황들의 바람직한 처리&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_18.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 ret 인스트럭션의 상세한 처리과정이다.
    &lt;ul&gt;
      &lt;li&gt;선입 단계는 ret 인스트럭션 다음의 rrmovq 인스트럭션을 반복적으로 선입하지만, 파이프라인 제어회로는 rrmovq 인스트럭션이 진행하는 것을 허용하는 대신에 해독 단계에 한 개의 버블을 삽입한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/18/img_19.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 유효하지 않은 메모리 참조 예외의 처리이다.
    &lt;ul&gt;
      &lt;li&gt;사이클 6에서 pushq 인스트럭션으로 인한 유효하지 않은 메모리 차몾는 조건코드 갱신을 금지시킨다.&lt;/li&gt;
      &lt;li&gt;파이프라인은 메모리 단계에 버블을 삽입하기 시작하고 재기록 단계에 있는 예외 인스트럭션을 스톨시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특수-제어-조건의-감지&quot;&gt;특수 제어 조건의 감지&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ret 인스트럭션이 파이프라인을 통과해 갈 때 검출하려면 해독, 실행, 메모리 단계에 있는 인스트럭션들의 인스트럭션 코드를 단순히 체크하면 된다.&lt;/li&gt;
  &lt;li&gt;로드/사용 해저드를 검출하려면 실행 단계에 있는 인스트럭션의 종류(mrmovq, popq)를 체크해야 하고, 해독 단계에 있는 인스트럭션의 소스 레지스터들과 목적지 레지스터들을 비교해야 한다.&lt;/li&gt;
  &lt;li&gt;파이프라인 제어로직은 인스트럭션이 해독 단계에 있는 동안 잘못 예측한 분기를 검출해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파이프라인-제어-과정&quot;&gt;파이프라인 제어 과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_20.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 파이프라인 레지스터 동작이다.
    &lt;ul&gt;
      &lt;li&gt;a. 정상 조건 시 레지스터의 상태와 출력은 클럭이 상승할 때 입력 값으로 설정된다.&lt;/li&gt;
      &lt;li&gt;b. 스톨 모드에서 동작할 때, 상태는 이전 값으로 고정된다.&lt;/li&gt;
      &lt;li&gt;c. 버블 모드에서 동작할 때 상태는 연산의 결과로 기록된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-조건들의-조합&quot;&gt;제어 조건들의 조합&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_21.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 특수한 제어 조건들에 대한 파이프라인 상태이다.
    &lt;ul&gt;
      &lt;li&gt;표시한 두 쌍은 동시에 발생할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-로직의-구현&quot;&gt;제어 로직의 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/18/img_22.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 PIPE 파이프라인 제어로직이다.
    &lt;ul&gt;
      &lt;li&gt;이 로직은 프로시저 리턴, 잘못 예측한 분기, 로드/사용 해저드, 프로그램 예외 같은 특수한 조건들을 처리하기 위해서 정상적인 인스트럭션 흐름이 파이프라인을 통과하는 것을 정지시킨다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;459-성능-분석&quot;&gt;4.5.9 성능 분석&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스트럭션마다 걸리는 평균 클럭 사이클 수는 CPIcycles per instruction라는 단위로 추정값을 계산한다.
    &lt;ul&gt;
      &lt;li&gt;Ci 인스트르럭션, Cb 버블을 처리한다면, 프로세서는 Ci + Cb개의 클럭 사이클을 필요로한다.&lt;/li&gt;
      &lt;li&gt;CPI = 1.0 + Cb/Ci 이다.&lt;/li&gt;
      &lt;li&gt;오직 세개의 인스트럭션 타입만이 버블을 추가하기 때문에
        &lt;ul&gt;
          &lt;li&gt;CPI = 1.0 lr(load penalty) + mp(mispredicted branch penalty) + rp(return penalty)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4510-남아-있는-작업&quot;&gt;4.5.10 남아 있는 작업&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중 사이클 인스트럭션
    &lt;ul&gt;
      &lt;li&gt;다중 인스트럭션을 구현하는 한 가지 간단한 방법은 실행 단계 로직의 성능을 정수와 부동 소수점 산술연산 유닛들을 포함하도록 단순히 확장하는 것이다.
        &lt;ul&gt;
          &lt;li&gt;한 개의 인스트럭션이 해독 단계에 들어갈 때 특수 유닛으로 보낸다.(ex. 부동소수점 유닛)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 시스템과의 인터페이스&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;46-요약&quot;&gt;4.6 요약&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;해당 장을 통해 인스트럭션 집합 아키텍처 ISA는 프로세서의 동작과 프로세서가 어떻게 구현되는지 간에 추상화 계층을 제공한다는 것을 알 수 있었다.&lt;/li&gt;
  &lt;li&gt;ISA는 프로그램 실행을 하나의 인스트럭션이 다음 인스트럭션이 시작되기 전에 실행되어 종료되는 순차적인 프로그램 실행의 모습을 제공한다.&lt;/li&gt;
  &lt;li&gt;여러 가지 인스트럭션들이 요구하는 처리작업을 5단계로 구성하였으며, 전체 인스트럭션이 다섯 단계를 통해 들어가서 매 클럭 사이클마다 실행된다.&lt;/li&gt;
  &lt;li&gt;파이프라인은 여러 단계들이 동시에 동작하도록 하여 시스템의 처리량 성능을 개선한다.&lt;/li&gt;
  &lt;li&gt;예외를 적절히 처리하는 것은 높은 파이프라인 단계와 병렬성을 사용하는 시스템에서 보다 복잡해진다.&lt;/li&gt;
  &lt;li&gt;교훈
    &lt;ul&gt;
      &lt;li&gt;복잡성을 관리하는 것이 최우선순위를 갖는다.
        &lt;ul&gt;
          &lt;li&gt;모든 인스트럭션 타입을 처리하기 위한 매우 간단하고 통일된 프레임워크를 만들어서 구현하였다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ISA를 직접 구현할 필요는 없다.
        &lt;ul&gt;
          &lt;li&gt;파이프라인 설계를 사용하였고 파이프라인 해저드를 처리할 수 있었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하드웨어 설계자는 꼼꼼해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2장부터 4장이 하드웨어까지의 모든 부분들을 살펴본 것 같다. 4장은 꼭 한번 더 읽어보자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 18</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)</title><link href="http://localhost:4000/cs:app/csapp_16/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.4 SEQ 단계의 구현)" /><published>2022-03-17T00:00:00+09:00</published><updated>2022-03-17T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_16</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_16/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;434-seq-단계의-구현&quot;&gt;4.3.4 SEQ 단계의 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ를 구현하는 데 필요한 제어로직 블록을 위한 HCL작성방법을 설명한다.&lt;/li&gt;
  &lt;li&gt;여러가지 인스트럭션 코드, 함수코드, 레지스트 이름, ALU 연산, 상태코드 등을 위한 상수 값뿐만 아니라 여러가지 하드웨어 신호의 이름이 포함된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 표는 HCL 문장에 사용된 상수 값들이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선입-단계&quot;&gt;선입 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선입 단계는 인스트럭션 메모리 하드웨어 유닛을 포함한다.&lt;/li&gt;
  &lt;li&gt;유닛은 PC를 첫 바이트(0번 바이트)의 주소로 사용해서 메모리로부터 한 번에 10바이트를 읽어들인다.&lt;/li&gt;
  &lt;li&gt;이 바이트는 인스트럭션 바이트로 해석되고, 두 개의 4비트 값으로 나누어진다.(“Split”이라고 표시된 유닛에 의해 icode와 ifun으로 나뉜다.)&lt;/li&gt;
  &lt;li&gt;icode 값에 따라 세 개의 1비트 신호를 계산할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;instr_valid: 이 신호는 부정 인스트럭션을 검출하기 위해 사용된다.&lt;/li&gt;
      &lt;li&gt;need_regids: 레지스터 지정 바이트를 포함하는가&lt;/li&gt;
      &lt;li&gt;need_valC: 상수 워드를 포함하는가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;instr_valid, imem_error 신호(인스트럭션 주소가 범위를 벗어날 때 만들어지는)는 메모리 단계에서 상태코드를 만들기 위해 사용된다.&lt;/li&gt;
  &lt;li&gt;need_regids를 위한 HCL 표현은 icode 값이 레지스터 지정자 바이트를 갖는 인스트럭션인지를 결정한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;  &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;need_regids&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;icode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IRRMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IOPQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IPUSHQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IPOPQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;no&quot;&gt;IIRMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IRMMOVQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;IMRMOVQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;인스트럭션 메모리에서 읽은 나머지 바이트는 레지스터 지정자와 상수 워드들이다.
    &lt;ul&gt;
      &lt;li&gt;Align 이라고 이름 붙인 하드웨어 유닛이 레지스터 필드들과 상수 워드에 대해 처리작업을 수행한다.&lt;/li&gt;
      &lt;li&gt;계산된 need_regids가 1이면, 레지스터 지정자 rA와 rB로 나누어진다.&lt;/li&gt;
      &lt;li&gt;상수 워드 valC도 만든다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PC 증가 하드웨어 유닛은 현재의 PC 값, need_regids, need_ValC에 따라 valP를 만든다. (p+1+r+8i)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;해동과-재기록-단계&quot;&gt;해동과 재기록 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ에서 해독과 재기록 단계 모두를 구현하는 로직의 상세한 모습을 보여준다.
    &lt;ul&gt;
      &lt;li&gt;해동과 재기록 단계 모두 레지스터 파일에 접근하기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레지스터 파일은 네 개의 포트를 가지고 있다.
    &lt;ul&gt;
      &lt;li&gt;두 개의 동시 읽기(포트 A와 B), 두 개의 동시 쓰기(포트 E와 M)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 포트는 한 개의 주소 연결과 데이터 연결을 모두 갖는다.
    &lt;ul&gt;
      &lt;li&gt;주소 연결은 레지스터 ID, 데이터 연결은 레지스터 파일의 출력 워드 이거나 입력워드로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 개의 읽기 포트는 주소 입력 srcA와 srcB를 가진다.&lt;/li&gt;
  &lt;li&gt;두 개의 쓰기 포트는 dstE와 dstM을 주소 입력으로 갖느다.&lt;/li&gt;
  &lt;li&gt;네 개의 블록은 인스트럭션 코드 icode, 레지스터 지정자 rA, rB, 실행 단계에서 계산된 조건신호 Cnd에 기초하여 네 개의 레지스터 ID를 만들어 낸다.&lt;/li&gt;
  &lt;li&gt;레지스터 ID dstE는 쓰기 포트 E를 위한 목적지 레지스터를 나타내며 계싼된 valE가 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;실행-단계&quot;&gt;실행 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;실행 단계는 산술/논리 유닛(ALU)을 포함한다.&lt;/li&gt;
  &lt;li&gt;이 유닛은 ADD, SUBTRACT, AND, EXCLUSIVE-OR를 입력 aluA, aluB에 alufun 신호의 설정에 따라 실행한다.&lt;/li&gt;
  &lt;li&gt;ALU가 대부분의 경우에 덧셈기로 사용된다.
    &lt;ul&gt;
      &lt;li&gt;OPq 인스트럭션에 대해서는 인스트럭션의 ifun 필드에 인코딩된 연산을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 단계는 조건코드 레지스터를 포함한다.
    &lt;ul&gt;
      &lt;li&gt;조건코드 레지스터가 갱신되어야 할지 여부는 제어하는 set_cc 신호를 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;“cond”로 명명된 하드웨어 유닛은 조건부 분기나 데이터 이동이 일어나야 할지를 결정하기 위한 조건코드들과 함수코드의 조합을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-단계&quot;&gt;메모리 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 단계는 프로그램 데이터를 읽거나 쓰는 일을 수행한다.&lt;/li&gt;
  &lt;li&gt;두 개의 제어 블록이 메모리주소와 메모리 입력 데이터(쓰기 연산을 위한)를 위한 값을 만들어낸다.&lt;/li&gt;
  &lt;li&gt;메모리 단계에서 마지막 기능은 icode, imem_error, 선입 단계에서 만들어진 instr_valid, 데이터 메모리에서 만든 dmem_error 신호에 따라 인스트럭션 실행에서 결정되는 상태코드 Stat을 계산하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pc-갱신-단계&quot;&gt;PC 갱신 단계&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/16/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SEQ의 최종 단계는 새로운 프로그램 카운터 값을 생성하는 것이다.&lt;/li&gt;
  &lt;li&gt;새로운 PC 값은 인스트럭션 타입과 분기를 택할지 여부에 따라 valC, valM, valP가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;seq-현황-조사&quot;&gt;SEQ 현황 조사&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 인스트럭션을 통일된 흐름으로 실행하기 위해 필요한 단계를 구성하면서 프로세서 전체를 적은 수의 여러 하드웨어 유닛들과 계산을 순서화하기 위한 한 개이의 클럭으로 구현할 수 있다.&lt;/li&gt;
  &lt;li&gt;SEQ에서 유일한 문제는 매우 느리다.
    &lt;ul&gt;
      &lt;li&gt;그 이유는 각 유닛들이 전체 클럭 사이클의 일부 동안만 사용되기 때문이다.&lt;/li&gt;
      &lt;li&gt;그렇기 때문에 파이프라인을 사용해서 보다 좋은 성능을 얻을 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세서의 구조를 자세히 살펴보았는데, 굉장히 이해하기 어려운 부분이 많았다. 이번 챕터는 자주 보고 다른 자료도 더 찾아봐야겠다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 16</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)</title><link href="http://localhost:4000/cs:app/csapp_15/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.2 SEQ 하드웨어 구조)" /><published>2022-03-17T00:00:00+09:00</published><updated>2022-03-17T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_15</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_15/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;432-seq-하드웨어-구조&quot;&gt;4.3.2 SEQ 하드웨어 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인스트럭션을 구현하는 데 필요한 계산들은 여섯 개의 순차적인 기본 단계로 구성될 수 있다.
    &lt;ol&gt;
      &lt;li&gt;선입&lt;/li&gt;
      &lt;li&gt;해독&lt;/li&gt;
      &lt;li&gt;실행&lt;/li&gt;
      &lt;li&gt;메모리&lt;/li&gt;
      &lt;li&gt;재기록&lt;/li&gt;
      &lt;li&gt;PC 갱신&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;SEQ에서는 하드웨어 유닛에 처리되는 모든 일들은 하나의 클럭 사이클 내에서 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/15/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 순차적인 구현인 SEQ의 추상적인 모습이다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션을 실행하는 동안 처리된 정보는 그림의 좌측 하단 구석에 있는 PC를 사용해서 인스트럭션 선입으로 시작해서 시계방향을 따라 진행한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드웨어 유닛들은 여러가지 처리 단계들과 연계되어있다.
    &lt;ul&gt;
      &lt;li&gt;선입
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터 레지스터를 주소로 사용해서 인스트럭션 메모리는 인스트럭션의 바이트들을 읽어들인다.&lt;/li&gt;
          &lt;li&gt;PC 가산기는 valP, 증가된 프로그램 카운터를 계산한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;해독
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일은 두 개의 읽기 포트 A,B를 가지고 있다.&lt;/li&gt;
          &lt;li&gt;이를 통해서 레지스터 값 valA, valB를 동시에 읽어들일 수 있다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실행
        &lt;ul&gt;
          &lt;li&gt;인스트럭션의 종류에 따라 여러 가지 목적을 위해 산술/유닛 유닛(ALU)을 사용한다.&lt;/li&gt;
          &lt;li&gt;조건코드 레지스터(CC)는 세 개의 조건코드 비트를 저장한다. 목적지 레지스터를 갱신할지 여부를 결정하는 조건코드와 이동 조건에 의해 계산된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리
        &lt;ul&gt;
          &lt;li&gt;메모리 인스트럭션을 실행할 때 메모리 워드를 읽거나 쓴다.&lt;/li&gt;
          &lt;li&gt;인스트럭션과 데이터 메모리는 같은 메모리 위치에 접근하지만, 목적은 서로 다르다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;재기록
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일은 두 개의 쓰기 포트를 가지고 있다.&lt;/li&gt;
          &lt;li&gt;E 포트는 ALU가 계산한 값을 기록하기 위해 사용된다.&lt;/li&gt;
          &lt;li&gt;M 포트는 데이터 메모리에서 읽어온 값을 기록할 때 사용한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PC 갱신
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터의 새로운 값은 다음 인스트럭션의 주소 valP, call이나 점프 인스트럭션에 의해 지정된 목적지 주소, 또는 메모리에서 읽어온 리턴주소 valM 중에서 선택된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/15/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 SEQ, 순차적 구현의 하드웨어 구조이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/15/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 표는 순차적 구현에서 여러가지 계산 단계 식별 표이다.
    &lt;ul&gt;
      &lt;li&gt;두번째 열은 SEQ의 단계에서 계산되는 값 또는 수행되는 연산을 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;433-seq-타이밍&quot;&gt;4.3.3 SEQ 타이밍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ는 조합논리회로와 두 가지 형태의 메모리 장치로 이루어진다.
    &lt;ul&gt;
      &lt;li&gt;레지스터(프로그램 카운터와 조건코드 레지스터)&lt;/li&gt;
      &lt;li&gt;랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조합논리회로는 순차처리나 제어를 필요로 하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;입력이 바뀔 때마다 논리 게이트의 네트워크를 통해 값들이 전파된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;랜덤 액세스 메모리를 읽는 것은 출력 워드가 주소 입력에 따라 생성되는 방식으로 조합논리회로와 매우 유사하게 동작한다.&lt;/li&gt;
  &lt;li&gt;순차실행을 위해 명시적인 제어를 필요로 하는 네 개의 하드웨어 유닛
    &lt;ul&gt;
      &lt;li&gt;프로그램 카운터, 조건코드 레지스터, 데이터 메모리, 레지스터 파일&lt;/li&gt;
      &lt;li&gt;이들은 새로운 값을 레지스터에 로딩하는 것과 값들을 랜덤 액세스 메모리에 기록하는 작업을 만드는 한 개의 클럭 신호를 통해서 제어된다.&lt;/li&gt;
      &lt;li&gt;프로그램 카운터 : 매 클럭 사이클마다 새로운 인스트럭션 주소를 적재한다.&lt;/li&gt;
      &lt;li&gt;조건코드 레지스터 : 정수연산 인스트럭션이 실행될 때에만 값이 적재된다.&lt;/li&gt;
      &lt;li&gt;데이터 메모리 : rmmovq, pushq, call 인스트럭션이 실행될 때에만 값이 기록된다.&lt;/li&gt;
      &lt;li&gt;레지스터 파일 : 두 개의 쓰기 포트를 통해서 두 개의 프로그램 레지스터가 매 사이클마다 갱신될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위와 같이 레지스터들과 메모리에 클럭을 공급하는 것은 프로세서에서 여러 동작들을 순서대로 제어하기 위해 필요한 모든 거싱다.&lt;/li&gt;
  &lt;li&gt;프로세서는 인스트럭션의 처리를 완료하기 위해 어떤 인스트럭션에 의해 갱신된 상태를 다시 읽을 필요는 절대 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/15/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 SEQ의 두 실행 사이클 추적이다.
    &lt;ul&gt;
      &lt;li&gt;각 사이클은 이전 인스트럭션에 의해 설정된 상태 원소들(프로그램 카운터, 조건코드 레지스터, 레지스터 파일, 데이터 메모리)을 가지고 시작된다.&lt;/li&gt;
      &lt;li&gt;신호들은 이 상태 원소들을 위한 새로운 값을 만들면서 조합회로를 지나면서 전파된다.&lt;/li&gt;
      &lt;li&gt;이 값들은 다음 사이클을 시작하기 위해 상태 원소들에 적재된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태 원소들의 갱신을 제어하기 위해서 조합회로를 통한 값들의 전파와 함께 클럭을 사용하면 SEQ에서 각 인스트럭션을 위해 수행한 계산들을 충분히 제어할 수 있다.&lt;/li&gt;
  &lt;li&gt;클럭이 low에서 high로 전환이 이루어지는 매 시점마다 프로세서는 새 인스트럭션의 실행을 시작한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 15</summary></entry><entry><title type="html">[NLP/CS224n]CS224n Lecture 17: Multitask Learning</title><link href="http://localhost:4000/nlp/NLP_06/" rel="alternate" type="text/html" title="[NLP/CS224n]CS224n Lecture 17: Multitask Learning" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_06</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_06/">&lt;blockquote&gt;
  &lt;p&gt;lecture 5, 7, 13 ,17 을 리뷰 했는데,,, 17강 밖에 안남아있다…T.T&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;the-limits-of-single-task-learning&quot;&gt;The Limits of Single-task Learning&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Great performance improvements in recent years given
    &lt;ul&gt;
      &lt;li&gt;dataset&lt;/li&gt;
      &lt;li&gt;task&lt;/li&gt;
      &lt;li&gt;model&lt;/li&gt;
      &lt;li&gt;metric&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Models typically start from ranbdom or are only partly pre-trained&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;pre-training-and-sharing-knowledge-is-great&quot;&gt;Pre-training and sharing knowledge is great!&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Computer Vision
    &lt;ul&gt;
      &lt;li&gt;ImageNet + CNN이 큰 성공을 거두었음&lt;/li&gt;
      &lt;li&gt;Classification task가 과거에 큰 장벽이었음&lt;/li&gt;
      &lt;li&gt;이 문제가 해결되고 많은 문제들을 푸는 것이 가능해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Natural Language Processing
    &lt;ul&gt;
      &lt;li&gt;Word2Vec, Glove&lt;/li&gt;
      &lt;li&gt;최근 CoVe, ELMo, BERT 성공을 거두기 시작함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;why-has-weightmodel-sharing-not-happened-as-much-in-nlp&quot;&gt;Why has weight&amp;amp;model sharing not happened as much in NLP?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;NLP는 많은 종류의 추론이 요구됨
    &lt;ul&gt;
      &lt;li&gt;logical, linguistic, emotional, visual&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Short and long term memory가 요구됨&lt;/li&gt;
  &lt;li&gt;NLP는 중간 단계 또는 분리된 Task로 많이 나누어져 있음&lt;/li&gt;
  &lt;li&gt;하나의 Unsupervised Task가 전체 문제를 해결할 수 없음&lt;/li&gt;
  &lt;li&gt;언어는 현실적으로 분명한 Supervision이 필요함&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;why-a-unified-multi-task-model-for-nlp&quot;&gt;Why a unified multi-task model for NLP&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Multi-task learning은 General NLP system이 넘어야할 장벽임&lt;/li&gt;
  &lt;li&gt;하나의 통합된 모델은 지식을 어떻게 전달할지 결정 가능
    &lt;ul&gt;
      &lt;li&gt;Domain adaptation, weight sharing, transfer and zero shot learning&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 통합된 Multi-task 모델은
    &lt;ul&gt;
      &lt;li&gt;새로운 task가 주어졌을 때 쉽게 적응할 수 있음&lt;/li&gt;
      &lt;li&gt;실제 production을 위해 deploy하는 것이 매우 간단해짐&lt;/li&gt;
      &lt;li&gt;더 많은 사람들이 새로운 task를 해결할 수 있도록 도와줌&lt;/li&gt;
      &lt;li&gt;잠재적으로 Continual learning으로 나아갈 수 있음&lt;/li&gt;
      &lt;li&gt;모든 프로젝트를 계속 다시 시작하게 된다면 자연 언어의 복잡성을 점점 더 많이 포함하는 하나의 모델에 도달하지 못함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인공지능이 대화를 가능하게 하는 task를 진행할 때 사람의 언어처럼 순차적으로 처리하는 것 만큼 비효율적인 것은 없음. 컴퓨터가 인간의 언어를 supervision하지 않다면 훨씬 더많은 언어로 의사소통 가능.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-to-express-many-nlp-tasks-in-the-same-framework&quot;&gt;How to express many NLP tasks in the same framework?&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Sequence tagging
    &lt;ul&gt;
      &lt;li&gt;Named Entity Recognition, aspect specific sentiment&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Text classification
    &lt;ul&gt;
      &lt;li&gt;Dialogue state tracking, sentiment classification&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Seq2seq
    &lt;ul&gt;
      &lt;li&gt;Machine Translation, Summarization, Question Answering&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;three-equivalent-supertasks-of-nlp&quot;&gt;Three equivalent Supertasks of NLP&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Language Modeling
    &lt;ul&gt;
      &lt;li&gt;다음 단어를 예측하는 것은 질문의 일종이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Question Answering
    &lt;ul&gt;
      &lt;li&gt;말 그대로 Question &amp;amp; Answering 이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dialogue System
    &lt;ul&gt;
      &lt;li&gt;질문 답변, 답변에 대한 답변 형태이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img.png&quot; width=&quot;40%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-natural-language-decathlondecanlp&quot;&gt;The Natural Language Decathlon(decaNLP)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;The Natural Language Decathlon : Multitask Learning as Question Answering
    &lt;ul&gt;
      &lt;li&gt;10개의 NLP Task를 하나의 Question Answering모델 학습만으로 풀 수 있도록 디자인&lt;/li&gt;
      &lt;li&gt;이를 위해 모든 데이터 셋에 대하여 question, context, answer 형태로 전처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;multitask-question-answering-networkmqan&quot;&gt;Multitask Question Answering Network(MQAN)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fixed Glove+Character n-gram embeddings -&amp;gt; Linear -&amp;gt; Shared BiLSTM with skip connection&lt;/li&gt;
  &lt;li&gt;Attention summations from one sequence to the other and back again with skip connections&lt;/li&gt;
  &lt;li&gt;Separate BiLSTMs to reduce dimensionality, two transformer layers, another BiLSTM&lt;/li&gt;
  &lt;li&gt;Auto-regressive decoder :
    &lt;ul&gt;
      &lt;li&gt;Fixed GloVe, character n-gram embeddings&lt;/li&gt;
      &lt;li&gt;Two transformer layers&lt;/li&gt;
      &lt;li&gt;LSTM Layers (attend last 3 layers of encoder)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_6.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_7.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_8.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_9.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_10.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;training-strategies-fully-joint&quot;&gt;Training Strategies: Fully Joint&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_11.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Curriculum learning : 모델 학습시 전체 데이터를 한번에 학습시키지 않고 쉬운것-&amp;gt;어려운 것 순서로 학습함&lt;/li&gt;
  &lt;li&gt;Batch를 Sampling할 때, Fixed order로 계속 Round Robin하여 수집함&lt;/li&gt;
  &lt;li&gt;많은 양이 돌아 Converge되는 Task들은 잘 동작하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;training-strategies-anti-curriculum-pre-training&quot;&gt;Training Strategies: Anti-Curriculum Pre-training&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_12.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_13.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;training-strategies-cove&quot;&gt;Training Strategies: CoVe&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_14.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;whats-next-for-nlp&quot;&gt;What’s next for NLP?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/06/img_15.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="cs224n" /><category term="nlp" /><summary type="html">NLP 랩실에서의 CS224n 강의 리뷰이었던 것...</summary></entry><entry><title type="html">[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리</title><link href="http://localhost:4000/dataengineering/de_01/" rel="alternate" type="text/html" title="[DataEngineering]DataEngineer가 되기 위한 기술 스택 정리" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/dataengineering/de_01</id><content type="html" xml:base="http://localhost:4000/dataengineering/de_01/">&lt;h1 id=&quot;data-development&quot;&gt;Data Development&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Crawler&lt;/li&gt;
  &lt;li&gt;ETL&lt;/li&gt;
  &lt;li&gt;Docker&lt;/li&gt;
  &lt;li&gt;k8s&lt;/li&gt;
  &lt;li&gt;airflow
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;data-platform&quot;&gt;Data Platform&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Data Orchestration&lt;/li&gt;
  &lt;li&gt;Data Storage
    &lt;ul&gt;
      &lt;li&gt;Data Lake&lt;/li&gt;
      &lt;li&gt;Data Warehouse&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Catalog&lt;/li&gt;
  &lt;li&gt;Data Monitoring
    &lt;ul&gt;
      &lt;li&gt;Data Validation&lt;/li&gt;
      &lt;li&gt;Data Notification
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;data-governance&quot;&gt;Data Governance&lt;/h1&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;하둡 스파크 카프카 스칼라…? 알아야할게 산더미군..!!!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="DataEngineering" /><category term="DataEngineering" /><summary type="html">인턴 하면서 끄적였던 것들...4</summary></entry><entry><title type="html">[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)</title><link href="http://localhost:4000/cs:app/csapp_14/" rel="alternate" type="text/html" title="[CS:APP] Chapter 04. 프로세서 구조 (4.3 순차적 Y86-64 구현 - 4.3.1 작업을 단계로 구성하기)" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_14</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_14/">&lt;h1 id=&quot;chapter-04-프로세서-구조&quot;&gt;Chapter 04. 프로세서 구조&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;4.1 Y86-64 인스트럭션 집합 구조&lt;/li&gt;
  &lt;li&gt;4.2 논리 설계와 하드웨어 제어 언어 HCL&lt;/li&gt;
  &lt;li&gt;4.3 순차적sequential Y86-64 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;43-순차적sequential-y86-64-구현&quot;&gt;4.3 순차적sequential Y86-64 구현&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;SEQ : sequential 프로세서를 의미&lt;/li&gt;
  &lt;li&gt;매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.&lt;/li&gt;
  &lt;li&gt;SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;431-작업을-단계로-구성하기&quot;&gt;4.3.1 작업을 단계로 구성하기&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;인스트럭션을 처리하는 데는 다수의 연산이 관련되어 있다.&lt;/li&gt;
  &lt;li&gt;이들은 특정한 단계들Stages로 구성해서 비록 인스트럭션들의 동작은 다를지라도 모든 인스트럭션들이 일정한 순서를 따르도록 한다.&lt;/li&gt;
  &lt;li&gt;각 단계에서의 세부 처리내용은 실행하는 인스트럭션에 따라 달라진다.
    &lt;ul&gt;
      &lt;li&gt;선입 fetch
        &lt;ul&gt;
          &lt;li&gt;프로그램 카운터 PC를 메모리주소로 사용해서 메모리로부터 인스트럭션 바이트들을 읽어들인다.&lt;/li&gt;
          &lt;li&gt;icode(인스트럭션 코드)와 ifun(instruction function)을 추출한다.&lt;/li&gt;
          &lt;li&gt;한 개의 레지스터 지시자 바이트를 선입해서 한 개 또는 두 개의 레지스터 오퍼랜드 지시자 rA와 rB를 얻어내는 경우도 있다. 또한 8바이트 상수 워드 valC를 선입할 수도 있다.&lt;/li&gt;
          &lt;li&gt;이것은 지금 실행 중인 인스트럭션의 순차적인 다음 인시트럭션의 주소가 되는 valP를 계산한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;해독 decode
        &lt;ul&gt;
          &lt;li&gt;레지스터 파일에서 최대 두 개의 오퍼랜드를 읽어서 valA, valB를 얻어온다.&lt;/li&gt;
          &lt;li&gt;일부 인스트럭션에 대해서는 레지스터 %rsp를 읽어온다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실행 excution
        &lt;ul&gt;
          &lt;li&gt;산술/논리 연산 유닛(ALU)이 인스트럭션이 지시하는 연산을 수행하거나(ifun 값에 따라), 메모리 참조 시 유효주소를 계산하거나, 스택 포인터 값을 변경한다. 이 결과를 valE라고 부른다.&lt;/li&gt;
          &lt;li&gt;조건 코드들은 이 경우에 설정될 수 있다. 조건부 이동 인스트럭션에 대해서 조건코드와 분기 조건(ifun에서 주어진)을 평가하고 조건이 참이 되는 경우에만 목적지 레지스터를 갱신한다. 점프 인스트럭션도 마찬가지이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리
        &lt;ul&gt;
          &lt;li&gt;데이터를 메모리에 쓰거나 메모리에서 데이터를 읽어올 수 있다. 이 값을 valM이라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;재기록 write back
        &lt;ul&gt;
          &lt;li&gt;두 결과를 레지스터 파일에 기록한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PC 갱신
        &lt;ul&gt;
          &lt;li&gt;PC는 다음 인스트럭션의 주소로 설정된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세서는 위의 사항들을 무한히 반복하면서 이 단계들을 실행한다.&lt;/li&gt;
  &lt;li&gt;한 개의 인스트럭션을 실행하는 데는 놀라운 양의 작업을 요구한다.
    &lt;ul&gt;
      &lt;li&gt;각 인스트럭션에 대해 기술한 연산을 싫애해야하고&lt;/li&gt;
      &lt;li&gt;주소를 계산하고&lt;/li&gt;
      &lt;li&gt;스택 포인터를 갱신하고&lt;/li&gt;
      &lt;li&gt;다음 인스트럭션을 결정해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;y86-64-인스트럭션-처리과정&quot;&gt;Y86-64 인스트럭션 처리과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/14/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 Y86-64 인스트럭션 예제이다. 해당 코드를 사용해서 여러가지 Y86-64 인스트럭션들의 처리과정을 그림으로 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OPq 인스트럭션 타입(정수와 논리연산), rrmovq(레지스터-레지스터 이동), irmovq(상수-레지스터 이동)에 대해 요구되는 작업을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;선입 단계에서 상수 워드는 필요하지 않기 때문에 valP는 PC+2로 계산된다.&lt;/li&gt;
  &lt;li&gt;해석 단계에서 두 개의 오퍼랜드를 읽어들인다.&lt;/li&gt;
  &lt;li&gt;실행단계에서 함수 지시자 ifun과 함께 ALU에 제공된다.&lt;/li&gt;
  &lt;li&gt;valE는 인스트럭션 결과가 된다.&lt;/li&gt;
  &lt;li&gt;rrmovq인스트럭션을 실행하면 산술연산과 매우 비슷하게 진행한다.&lt;/li&gt;
  &lt;li&gt;irmovq의 경우에도 첫 번째 ALU 입력 대신에 상수 값 valC를 사용한다는 점을 제외하고는 유사한 처리가 발생한다.
    &lt;ul&gt;
      &lt;li&gt;프로그램 카운터를 10 증가시켜야 하는데, 그 이유는 irmovq가 긴 인스트럭션 형식을 가지기 때문이다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/14/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;메모리 쓰기와 읽기 인스트럭션인 rmmovq와 mrmovq를 위해 필요한 처리작업을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;valC를 valB에 더하기 위해 ALU를 사용해서 메모리 연산을 위한 유효주소를 만들어 낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;pushq와 popq 인스트럭션을 처리하기 위해 요구되는 단계들을 보여준다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;메모리에 접근 하면서 동시에 스택 포인터를 변경한다.&lt;/li&gt;
  &lt;li&gt;pushq 인스트럭션은 해석단계에서 %rsp를 두 번째 레지스터 오퍼랜드의 식별자로 사용해서 스택 포인터를 valB로 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;img src=&quot;../../assets/img/csapp/14/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;세 개의 제어 전환 인스트럭션에서의 처리과정을 나타낸다: jump, call, ret&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;정수연산에서처럼 분기를 할지 말지 결정할 때에만 이들이 다르기 때문에 모든 점프를 통합된 방법으로 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;점프 인스트럭션은 선입에서 해독까지는 레지스터 명시자를 필요로 하지 않는다.&lt;/li&gt;
  &lt;li&gt;실행단계에서 조건코드와 점프 조건을 체크해서 분기를 할지 말지 결정하고, 1비트 신호 Cnd를 만든다.&lt;/li&gt;
  &lt;li&gt;PC갱신단계 동안에 이 플래그를 시험하고, 만일 플래그가 1이면 PC를 valC(점프 목적지)로 설정하고, 만일 0이면 valP(다음 인스트럭션의 주소)로 설정한다.&lt;/li&gt;
  &lt;li&gt;인스트럭션 call과 ret은 프로그램 카운터 값을 push, pop한다는점 외에는 pushq, popq와 약간의 유사성을 갖는다.&lt;/li&gt;
  &lt;li&gt;call할 때는 call 인스트럭션의 다음 인스트럭션의 주소인 valP를 push한다.&lt;/li&gt;
  &lt;li&gt;PC 갱신 단계 동안에 PC를 call 목적지인 valC로 설정한다.&lt;/li&gt;
  &lt;li&gt;ret 인스트럭션에서 스택에서 pop한 값인 valM을 PC 갱신 단계에서 PC에 저장한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 14</summary></entry><entry><title type="html">[NLP/Paper]Deep contextualized word representations 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_05/" rel="alternate" type="text/html" title="[NLP/Paper]Deep contextualized word representations 논문 리뷰" /><published>2022-03-03T00:00:00+09:00</published><updated>2022-03-03T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_05</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_05/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-trained word representations are a key component in many neural language understanding models.&lt;/li&gt;
  &lt;li&gt;Our representations differ from traditional word type embeddings in that each token is assigned a representation that is a function of the entire input sentence.&lt;/li&gt;
  &lt;li&gt;We use vectors derived from a bidirectional LSTM that is trained with a coupled language model (LM) objective on a large text corpus.&lt;/li&gt;
  &lt;li&gt;In many experiments, the ELMo representation has been shown to be very excellent, and the error rate is relatively reduced by 20%&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;related-work&quot;&gt;Related Work&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pretrained word vector의 활용이 표준화 되었지만, 하나의 단어에 하나의 벡터를 부여하다보니 context-independent한 문제가 있었다.&lt;/li&gt;
  &lt;li&gt;워드 임베딩을 풍부하게 하기 위해, subword information을 활용하거나 다의어의 경우 의미별로 다른 벡터를 학습시키는 방법이 등장하였다.
    &lt;ul&gt;
      &lt;li&gt;context2vec&lt;/li&gt;
      &lt;li&gt;CoVe&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이전 연구에 의하면 biRNN의 서로 다른 레이어가 다른 형태의 정보를 인코딩하는데, 본 연구에서도 유사한 효과가 나타났다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;model&quot;&gt;Model&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ELMo
    &lt;ul&gt;
      &lt;li&gt;ELMo word representations are functions of the entire input sentence.&lt;/li&gt;
      &lt;li&gt;They are computed on top of two-layer biLMs with character convolutions, as a linear function of the internal network states.&lt;/li&gt;
      &lt;li&gt;This setup allows us to do semi-supervised learning, where the biLM is pre-trained at a large scale and easily incorporated into a wide range of existing neural NLP architectures.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pretrained BiLM&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Task-specific ELMo Embedding&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_3.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_4.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Using biLMs for supervised NLP tasks
    &lt;ul&gt;
      &lt;li&gt;기존의 임베딩 벡터와 함께 사용된다.&lt;/li&gt;
      &lt;li&gt;ELMo 표현을 만드는데 사용된 사전 훈련된 언어 모델의 가중치는 고정시키고, 각 층의 가중치와 스칼라 파라미터는 훈련 과정에서 학습된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_5.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_6.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;6개의 NLP task에서 에러율을 6~20% 줄였다.&lt;/li&gt;
  &lt;li&gt;6개의 NLP task에서 높은 점수를 기록했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;analysis&quot;&gt;Analysis&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_7.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;일부 task(SNLI, SQuAD) 에서는 ELMo 벡터를 Output에 다시 concat 시키는 것이 효과가 있다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_8.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GloVe 단어 벡터에서 ‘play’와 비슷한 단어는 품사를 변형한 것 또는 스포츠에 관한 유사 단어만 뜬다.&lt;/li&gt;
  &lt;li&gt;biLM에서는 문맥을 고려한다는 것을 알 수 있다.
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_9.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;biLM의 첫 번째 레이어는 syntactic 정보를, 두 번째 레이어는 semantic 정보를 더 잘 인코딩 하는 것으로 나타난다.&lt;/li&gt;
  &lt;li&gt;이는 biLM의 모든 레이어를 사용하는 것이 성능향상에 도움이 된다는 것을 증명한다
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/05/img_9.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ELMo를 활용하면 같은 성능을 내는 데에 있어 훨씬 학습이 효율적임을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;We have introduced a general approach for learning high-quality deep context-dependent representations from biLMs, and shown large improvements when applying ELMo to a broad range of NLP tasks.&lt;/li&gt;
  &lt;li&gt;Through ablations and other controlled experiments, we have also confirmed that the biLM layers efficiently encode different types of syntactic and semantic information about words in-context, and that using all layers improves overall task performance.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...5</summary></entry><entry><title type="html">[Python/Pandas] Python Pandas Cheat Sheet!을 한번 만들어 보겠습니다.</title><link href="http://localhost:4000/python/python_01/" rel="alternate" type="text/html" title="[Python/Pandas] Python Pandas Cheat Sheet!을 한번 만들어 보겠습니다." /><published>2022-03-02T00:00:00+09:00</published><updated>2022-03-02T00:00:00+09:00</updated><id>http://localhost:4000/python/python_01</id><content type="html" xml:base="http://localhost:4000/python/python_01/">&lt;h1 id=&quot;cheat-sheet-왜-필요할까&quot;&gt;Cheat Sheet! 왜 필요할까?&lt;/h1&gt;

&lt;p&gt;Data Engineering 인턴을 경험하면서 나는 ETL 작성을 주업무로 맡게 되었다. R 코드로 작성된 레거시 파일을 Python 코드로 마이그레이션 하는 업무인데, 가끔씩
data 요청사항이 있으면 직접 로직을 구현하는 경우도 있었다. 보통 data 가공을 DataFrame으로 만들어 Pandas 문법을 사용하는데, 자주 사용했던 문법도 기억이 안나서
구글링으로 시간을 낭비했던 경험이 꽤 있다. 그래서! “구글링의 속도를 높여줄 혹은 구글링이 필요 없을 정도의 Cheat Sheet을 만들어두면 굉장히 편할 것 같다!” 라고 생각한다.
약 8개월간의 인턴생활중 자주 사용했던 Pandas 문법을 정리해보겠다.&lt;/p&gt;

&lt;p&gt;우선 Pandas 문법을 크게 세가지로 분류하겠다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Input/output
    &lt;ul&gt;
      &lt;li&gt;pandas의 input output 관련 문법&lt;/li&gt;
      &lt;li&gt;ex) read_csv,to_json…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;General functions
    &lt;ul&gt;
      &lt;li&gt;DataFrame 자체를 가공하는 문법..?&lt;/li&gt;
      &lt;li&gt;ex) pd.merge(), pd.concat()…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DataFrame
    &lt;ul&gt;
      &lt;li&gt;DataFrame 이 갖고있는 메소드..?&lt;/li&gt;
      &lt;li&gt;ex) DataFrame.astype, DataFrame.pop…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;inputoutput&quot;&gt;Input/output&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;read_csv&lt;/li&gt;
  &lt;li&gt;to_csv&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;general-functinons&quot;&gt;General functinons&lt;/h2&gt;

&lt;h3 id=&quot;dataframe-합치기-관련&quot;&gt;DataFrame 합치기 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasmerge&quot;&gt;pandas.merge&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;n개의 dataframe을 merge 또는 join&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasconcat&quot;&gt;pandas.concat&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;n개의 dataframe을 단순히 합침&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-중복제거-관련&quot;&gt;DataFrame 중복제거 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasunique&quot;&gt;pandas.unique&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;중복된 값을 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-nan값-관련&quot;&gt;DataFrame Nan값 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasisna&quot;&gt;pandas.isna&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;Nan인 값 True&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasnotna&quot;&gt;pandas.notna&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;Nan이 아닌 값 True
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;isnull, notnull 도 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dataframe&quot;&gt;DataFrame&lt;/h2&gt;

&lt;h3 id=&quot;dataframe-info-관련&quot;&gt;DataFrame Info 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframedtypes&quot;&gt;pandas.DataFrame.dtypes&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;column들의 type 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeshape&quot;&gt;pandas.DataFrame.shape&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 column과 row수 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframehead&quot;&gt;pandas.DataFrame.head&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 상위 n개의 정보 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-value-관련&quot;&gt;DataFrame value 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframevalues&quot;&gt;pandas.DataFrame.values&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 value들을 출력&lt;/li&gt;
      &lt;li&gt;ex) df[“A”].values.to_list() -&amp;gt; A컬럼의 value들을 list로 변경함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframevalue_counts&quot;&gt;pandas.DataFrame.value_counts&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 value 수 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframesort_values&quot;&gt;pandas.DataFrame.sort_values&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 값을 df의 X column value 기준으로 정렬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-index-관련&quot;&gt;DataFrame index 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframereset_index&quot;&gt;pandas.DataFrame.reset_index&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 index를 reset&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeset_index&quot;&gt;pandas.DataFrame.set_index&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;df의 X column으로 index 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-column-관련&quot;&gt;DataFrame column 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframerename&quot;&gt;pandas.DataFrame.rename&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;column 명을 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeastype&quot;&gt;pandas.DataFrame.astype&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;column의 type 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-조건-추출-관련&quot;&gt;DataFrame 조건 추출 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframewhere&quot;&gt;pandas.DataFrame.where&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 조건을 만족하지 않은 값, False인 값을 특정 값으로 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframemask&quot;&gt;pandas.DataFrame.mask&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 조건을 만족하는 값, True인 값을 특정 값으로 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeequals&quot;&gt;pandas.DataFrame.equals&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;DataFrame과 DataFrame을 비교하여 True of False 추출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-nan-관련&quot;&gt;DataFrame Nan 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframedropna&quot;&gt;pandas.DataFrame.dropna&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;Nan값 drop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-중복제거-관련-1&quot;&gt;DataFrame 중복제거 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframedrop_duplicates&quot;&gt;pandas.DataFrame.drop_duplicates&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;중복된 값 drop&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-groupby-관련&quot;&gt;DataFrame groupby 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframegroupby&quot;&gt;pandas.DataFrame.groupby&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 컬럼으로 groupby 후 min(),max() 등의 함수 적용하여 새로운 DataFrame 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeagg&quot;&gt;pandas.DataFrame.agg&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;특정 컬럼으로 groupby 후 커스텀 함수 적용하여 새로운 DataFrame 생성
  &lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;groupby에는 추가 메소드가 존재함!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-특정-함수-적용-관련&quot;&gt;DataFrame 특정 함수 적용 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframeapply&quot;&gt;pandas.DataFrame.apply&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;axis 기준으로 row 또는 column의 value들이 인자 값으로 넘어가는데, 해당 인자 값을 커스텀 함수로 변경 후 return 가능.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dataframe-col---row-변형-관련&quot;&gt;DataFrame col &amp;lt;-&amp;gt; row 변형 관련&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframestack&quot;&gt;pandas.DataFrame.stack&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;pandasdataframet&quot;&gt;pandas.DataFrame.T&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;etc&quot;&gt;ETC…&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;dataframe의-간단한-조건-추출&quot;&gt;DataFrame의 간단한 조건 추출&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;A라는 Data Frame이 있다고 가정해보자&lt;/li&gt;
      &lt;li&gt;A[A[“pnu”]==”123”] -&amp;gt; pnu가 123인 값들로 새로운 df를 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;dataframe과-series의-차이&quot;&gt;DataFrame과 Series의 차이&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;Series는 contains나 .str을 적용할 수 없다.&lt;/li&gt;
      &lt;li&gt;DataFrame은 df.str.contains(“x”) 사용 가능하지만, Series는 pd.Series([1,2]) in [1] 로 사용해야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;dataframestr&quot;&gt;DataFrame.str&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;python string 관련 메소드를 df에 적용하고 싶을 때 사용, df에 적용하면 vector값으로 계산이 가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;사용하기-어려운-문법&quot;&gt;사용하기 어려운 문법&lt;/h2&gt;
&lt;p&gt;사용하기 어려운 문법은, 다음에 더 자세히 정리해서 포스팅하겠다.
우선 갑자기 어떤 문법을 사용해야하는데 생각이 안난다! 싶으면 해당 문법이 어떤 카테고리인지 생각해보고 Cheat Sheet에 와서 ctrl+F를 해보자!
Cheat Sheet에 각각의 문법에 해시태그를 추가해서 키워드로 검색이 가능해서 구글링의 편의성을 늘려보자!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pandas.pydata.org/docs/reference/index.html&quot;&gt;pandas doumentation API reference&lt;/a&gt; &amp;lt;- 여기에 다~~ 있다!&lt;/p&gt;

&lt;p&gt;이제부터 공식문서를 보는 힘을 기르자! 아자아자 화이팅!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="Python" /><category term="Python" /><category term="Pandas" /><category term="DataEngineering" /><summary type="html">인턴을 하며 끄적였던 것들...3(이거 한장이면 data 가공은 끝!)</summary></entry></feed>