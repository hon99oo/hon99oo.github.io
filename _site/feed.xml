<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-01-23T00:45:55+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰</title><link href="http://localhost:4000/nlp/NLP_02/" rel="alternate" type="text/html" title="MASS:Masked Sequence to Sequence pre-training for Language Generation 논문 리뷰" /><published>2022-01-23T00:00:00+09:00</published><updated>2022-01-23T00:00:00+09:00</updated><id>http://localhost:4000/nlp/NLP_02</id><content type="html" xml:base="http://localhost:4000/nlp/NLP_02/">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-training은 최근 NLP 분야에서 활발한 연구가 이루어지는 주제 중 하나&lt;/li&gt;
  &lt;li&gt;Google의 Bert와 XLNet은 자연어 이해(NLU) Task에서 큰 성공을 거둔 모델&lt;/li&gt;
  &lt;li&gt;NLU Task 외에 Sequence to Sequence를 기반으로 하는 자연어 생성 Task가 있음
    &lt;ul&gt;
      &lt;li&gt;Machine Translation, Abstract Text Summarization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자연어 생성 Task는 Encoder - Attention - Decoder 구조의 모델들이 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;encoder-attention-decoder&quot;&gt;Encoder-Attention-Decoder&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Encoder는 Source sequence X를 input으로 받은 후, 이를 hidden representations sequence로 변형&lt;/li&gt;
  &lt;li&gt;Decoder는 Encoder로부터 hidden representations sequence를 전달 받아 Target Sequence Y를 생성하며, 이 때 Attention mechanism이 학습한 Input에 대한 정보를 함께 참조&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;related-works&quot;&gt;Related Works&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_1.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Bert와 XLNet은 Language Understanding을 위해 Encoder를 Pre-train&lt;/li&gt;
  &lt;li&gt;GPT는 Language Modeling을 위해 Decoder를 Pre-train&lt;/li&gt;
  &lt;li&gt;이전 모델들은 Encoder, Attention, Decoder를 함께 Pre-train하지 못했음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;massmasked-sequence-to-sequence-pre-training&quot;&gt;MASS:Masked Sequence to Sequence Pre-training&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_2.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;새로운 모델 MASS는 Masked Sequence to Sequence Pre-training의 약자&lt;/li&gt;
  &lt;li&gt;Input에서 K개의 토큰 Fragment를 임의로 지정해 Masking&lt;/li&gt;
  &lt;li&gt;마스킹 된 Fragment를 Encoder-Attention-Decoder를 거쳐 예측하도록 훈련시킴&lt;/li&gt;
  &lt;li&gt;Encoder에서 Masking되지 않은 토큰들이 Decoder에서 Masking됨에 따라, Decoder는 Encoder가 제공한 hidden representation과 Attention 정보만을 참고하여 Masking된 토큰들을 예측해야함, 이를 통해 Encoder-Attention-Decoder가 함께 Pre-train될 수 있는 환경을 제공&lt;/li&gt;
  &lt;li&gt;Encoder는 Encoder에서 Masking되지 않은 토큰들의 정보를 잘 추출할 수 있도록 학습, 이를 통해 Language Understanding 능력 개선&lt;/li&gt;
  &lt;li&gt;Decoder는 Encoder에서 Maksing된 토큰들에 대한 예측을 연속적으로 수행해야 하기 때문에 Language Modeling 능력을 학습하게 됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_3.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;K는 Encoder에서 Masking되는 토큰 개수를 결정하는 하이퍼 파라미터&lt;/li&gt;
  &lt;li&gt;하이퍼 파라미터 K를 조정함으로써 MASS는 BERT의 Masked LM과 GPT의 Standard LM을 모두 구현 가능&lt;/li&gt;
  &lt;li&gt;BERT Masked LM
    &lt;ul&gt;
      &lt;li&gt;K=1일 때, Encoder에서는 하나의 토큰이 Masking되고, Decoder는 Masking된 하나의 토큰을 예측해야 하므로 BERT의 Masked LM과 같아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;GPT Standard LM
    &lt;ul&gt;
      &lt;li&gt;하이퍼 파라미터 K가 Input 문장의 전체 길이인 m과 같을 때 Encoder의 모든 토큰들이 Masking됨&lt;/li&gt;
      &lt;li&gt;Decoder는 Encoder로부터 어떠한 정보도 부여 받지 않은 채 모든 토큰을 예측해야 하므로, GPT의 Standard LM과 같아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_4.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;m - Input sequence의 전체길이&lt;/li&gt;
  &lt;li&gt;u - Maskinge된 Fragment의 시작점&lt;/li&gt;
  &lt;li&gt;v - Masking된 Fragment의 끝점&lt;/li&gt;
  &lt;li&gt;X^u - u부터 v까지의 fragment&lt;/li&gt;
  &lt;li&gt;X^\u:v - u부터 v까지 Making된 Input Sequence&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;experiments&quot;&gt;Experiments&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Model Configuration
    &lt;ul&gt;
      &lt;li&gt;1024 embeding/hidden size, 4096 feed-forward filter size를 가진 6-layer encoder, 6-layer decoder로 구성된 기본 모델 구조 Transformer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datasets
    &lt;ul&gt;
      &lt;li&gt;2007 - 2017 WMT News Crawl datasets 190M English, 62M French, German 270M&lt;/li&gt;
      &lt;li&gt;MASS의 효과 검증을 위한 low-resource language Romanian&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pre-training Details
    &lt;ul&gt;
      &lt;li&gt;Fragment length K의 길이를 문장에 있는 총 토큰 수의 약 50%로 설정하고 정확성의 변화를 비교하기 위하여 K를 바꿔가며 실험&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;experimentunsupervised-machine-translation&quot;&gt;Experiment:Unsupervised Machine Translation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_5.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unsupervised Machine Translation Task에 있어 이전 모델들, 최근까지 SOTA였던 Facebook의 XLM모델과 MASS의 성능 비교를 수행&lt;/li&gt;
  &lt;li&gt;Facebook의 XLM은 Encoder와 Decoder를 각각 Bert의 Masked LM과 standard LM으로 Pre-train 시킨 모델&lt;/li&gt;
  &lt;li&gt;MASS는 6개의 Machine Translation Task에 있어 XLM을 능가하는 성능, SOTA 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentlow-resource-translation&quot;&gt;Experiment:Low-resource Translation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_6.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Low-resource Machine Translation : bilingual 트레이닝 데이터셋이 부족한 환경에서의 기계번역&lt;/li&gt;
  &lt;li&gt;Englisgh-Fench, English-German, English-Romanian 데이터 셋을 10K, 100K, 1M의 사이즈로 늘려가며 Low-resource 환경에서의 Machine Translation 테스트&lt;/li&gt;
  &lt;li&gt;MASS는 모든 스케일에서 Low-resource MT의 baseline 성능을 능가&lt;/li&gt;
  &lt;li&gt;데이터셋의 사이즈가 작을수록 더욱 두드러지게 나타남&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentabstractive-summarization&quot;&gt;Experiment:Abstractive Summarization&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_7.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-trained Bert를 인코더로 Pre-trained Language Model을 Decoder로 사용한 BERT+LM 모델과 DAE(Denoising Auto-Encoder), MASS의 Abstractive Summarization 성능을 Gigaword Corpus에 대해 비교&lt;/li&gt;
  &lt;li&gt;MASS는 BERT+LM과 DAE 두 모델의 Abstractive Summarization 성능을 모두 능가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;experimentconversational-response-generation&quot;&gt;Experiment:Conversational Response Generation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_8.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstractive Summarization 성능 비교에 사용되었던 BERT+LM 모델과 Baseline, MASS의 Conversational Response Generation 성능을 Cornell Movie Dialog Corpus에 대해 비교&lt;/li&gt;
  &lt;li&gt;MASS가 BERT+LM 모델과 Baseline 보다 낮은 Perplexity를 기록하며 더 좋은 성능을 보여줌&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;the-probability-formulation&quot;&gt;The probability formulation&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/img/nlp/02/img_9.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(a) 영어-프랑스 번역의 영어, (b) 영어-프랑스 번역의 프랑스어, (c) 영어-프랑스 번역의 BLUE score (d) Text Summarization의 ROUGE score, (e) conversational response generation의 PPL&lt;/li&gt;
  &lt;li&gt;하이퍼 파라미터 K를 다르게 설정해가며, MASS의 성능에 대한 다양한 실험 결과&lt;/li&gt;
  &lt;li&gt;실험을 통해 K가 문장의 절반 정도 크기에 해당할 때, downstream task에서 가장 좋은 성능을 보임을 알게 됨
    &lt;ul&gt;
      &lt;li&gt;문장 내 절반의 토큰을 Masking하는 것이 Encoder와 Decoder의 Pre-training에 있어 적절한 균형을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;K가 1(BERT), K가 m(GPT) 이었을 때는 downstream task에서 좋은 성능이 나오지 않음 이 이유는 MASS가 Sequence to Sequence 기반의 Language Generation Task에 이점을 지니고 있음을 반증&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;couclusion&quot;&gt;Couclusion&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;MASS는 Sequence to Sequence 기반의 다양한 Language generation Task에 있어 좋은 성능 기록&lt;/li&gt;
  &lt;li&gt;Language generation에서 좋은 성능을 기록한 MASS가 BERT와 XLnet이 뛰어난 결과를 기록한 Natural Language Understanding Task에서도 좋은 성능을 보일 것인지 차후 실험해볼 예정&lt;/li&gt;
  &lt;li&gt;또한 MASS 모델이 Image와 Video와 같은 NLP와 다른 도메인에서도 Sequence to Sequence 기반의 생성 Task를 수행해낼 수 있을지에 대한 추가 실험도 해볼 예정&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="NLP" /><category term="paper review" /><category term="nlp" /><summary type="html">NLP 랩실에서의 논문 리딩이었던 것...2</summary></entry><entry><title type="html">[Java/프로그래머스] Part4 배열</title><link href="http://localhost:4000/java/java_04/" rel="alternate" type="text/html" title="[Java/프로그래머스] Part4 배열" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_04</id><content type="html" xml:base="http://localhost:4000/java/java_04/">&lt;h1 id=&quot;part4-배열&quot;&gt;Part4 배열&lt;/h1&gt;

&lt;h2 id=&quot;배열-만들기&quot;&gt;배열 만들기&lt;/h2&gt;
&lt;h2 id=&quot;배열-사용하기&quot;&gt;배열 사용하기&lt;/h2&gt;
&lt;h2 id=&quot;2차원-배열&quot;&gt;2차원 배열&lt;/h2&gt;
&lt;h2 id=&quot;for-each&quot;&gt;for each&lt;/h2&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="프로그래머스 자바 입문" /><summary type="html">프로그래머스 자바 입문 강의 - 03</summary></entry><entry><title type="html">[Java/프로그래머스] Part3 제어문</title><link href="http://localhost:4000/java/java_03/" rel="alternate" type="text/html" title="[Java/프로그래머스] Part3 제어문" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_03</id><content type="html" xml:base="http://localhost:4000/java/java_03/">&lt;h1 id=&quot;part3-제어문&quot;&gt;Part3 제어문&lt;/h1&gt;

&lt;h2 id=&quot;if-조건문&quot;&gt;if 조건문&lt;/h2&gt;
&lt;p&gt;조건식의 연산 결과에 따라 블록 내부 문장의 실해 여부를 결정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;if 문&lt;/li&gt;
  &lt;li&gt;if - else 문&lt;/li&gt;
  &lt;li&gt;if - else if - else 문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;논리-연산자&quot;&gt;논리 연산자&lt;/h2&gt;
&lt;p&gt;논리 연산자의 피연산자는 블린 타입만 사용할 수 있다. 결과는 불린값이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;OR :&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;AND : &amp;amp;&amp;amp;&lt;/li&gt;
  &lt;li&gt;NOT : !&lt;/li&gt;
  &lt;li&gt;EXCLUSIVE-Or : ^&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;삼항-연산자&quot;&gt;삼항 연산자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;조건식 ? 피연산자1 : 피연산자2
    &lt;ul&gt;
      &lt;li&gt;조건식의 결과가 true 라면 결과는 피연산자1&lt;/li&gt;
      &lt;li&gt;조건식의 결과가 false 라면 결과는 피연산자2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;switch문&quot;&gt;switch문&lt;/h2&gt;
&lt;p&gt;switch문은 어떤 변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문이다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;변수&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
            &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; 
            &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;break를 쓰지 않으면 value값이 값1일 경우 값1, 값2, default를 모두 실행한다.&lt;/li&gt;
  &lt;li&gt;JDK7 이후에는 문자열 타입의 변수도 가능함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;while문&quot;&gt;while문&lt;/h2&gt;
&lt;p&gt;조건문의 실행 결과가 true일 동안 반복해서 실행한다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조건문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;do-while문&quot;&gt;do while문&lt;/h2&gt;
&lt;p&gt;while 문의 경우 조건이 만족되지 않을 때 실행되지 않지만, do while 문은 무조건 한번은 수행 된다.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;   &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;조건문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;실행문을 한번은 실행하고 싶을 경우에 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;for-반복문&quot;&gt;for 반복문&lt;/h2&gt;
&lt;p&gt;for 구문 자체에 변수 초기화, 조건식, 증감식이 한줄로 표현됨&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;초기화식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;증감식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="프로그래머스 자바 입문" /><summary type="html">프로그래머스 자바 입문 강의 - 02</summary></entry><entry><title type="html">[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산</title><link href="http://localhost:4000/java/java_02/" rel="alternate" type="text/html" title="[Java/프로그래머스] Part1 자바 시작하기, Part2 변수와 계산" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_02</id><content type="html" xml:base="http://localhost:4000/java/java_02/">&lt;h1 id=&quot;part1-자바-시작하기&quot;&gt;Part1 자바 시작하기&lt;/h1&gt;
&lt;h2 id=&quot;java&quot;&gt;Java&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향언어&lt;/li&gt;
  &lt;li&gt;C,C++ 문법을 기본으로 개발
    &lt;ul&gt;
      &lt;li&gt;C언어에 객체지향 특성 확장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;플랫폼에 독립적임
    &lt;ul&gt;
      &lt;li&gt;JVM으로 인해서 어떤 플랫폼에서도 실행 가능함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Garbage Collector로 사용되지 않는 메모리 자동적으로 정리해줌&lt;/li&gt;
  &lt;li&gt;JDK : Java Development Kit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;java-개발순서&quot;&gt;JAVA 개발순서&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;코드 작성&lt;/li&gt;
  &lt;li&gt;코드 컴파일&lt;/li&gt;
  &lt;li&gt;컴파일한 소스를 JVM을 이용하여 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;주석문&quot;&gt;주석문&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//&lt;/code&gt; : 행단위 주석&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/* */&lt;/code&gt; : 블럭단위 주석&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/** ..*.. */&lt;/code&gt; : 문서화 주석&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;part2-변수와-계산&quot;&gt;Part2 변수와 계산&lt;/h1&gt;

&lt;h2 id=&quot;변수&quot;&gt;변수&lt;/h2&gt;
&lt;p&gt;변수 값(Data)을 저장할 수 있는 메모리 공간&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;java는 강형 언어로써 모든 변수의 타입이 컴파일 시에 결정됨&lt;/li&gt;
  &lt;li&gt;java 식별자 명명 규칙
    &lt;ul&gt;
      &lt;li&gt;첫 번째 글자는 문자 이거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 이어야 함&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; 이외의 특수문자는 사용 불가능&lt;/li&gt;
      &lt;li&gt;키워드는 식별자로 사용할 수 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;java 변수 명명 관례
    &lt;ul&gt;
      &lt;li&gt;첫 번째 문자가 소문자인 명사로 정함&lt;/li&gt;
      &lt;li&gt;여러 단어로 구서된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함 (카멜 표기법)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;를 쓰지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;상수&quot;&gt;상수&lt;/h2&gt;
&lt;p&gt;상수란 수식에서 변하지 않는 값을 의미&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;상수의 선언
    &lt;ul&gt;
      &lt;li&gt;final 상수타입 상수명;
        &lt;ul&gt;
          &lt;li&gt;eg) final int J;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상수 명명 관례
    &lt;ul&gt;
      &lt;li&gt;대문자로만 구성된 명사로 정함&lt;/li&gt;
      &lt;li&gt;여러 단어로 구성된 이릠의 경우 단어 사이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt;을 써서 구분함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상수를 사용해야 하는 경우
    &lt;ul&gt;
      &lt;li&gt;값이 변하면 위험한 경우에 상수 사용&lt;/li&gt;
      &lt;li&gt;값만 봤을 때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;기본형-타입&quot;&gt;기본형 타입&lt;/h2&gt;
&lt;p&gt;기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형,실수형,문자형,불린형을 의미한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;논리형
    &lt;ul&gt;
      &lt;li&gt;boolean 1byte 크기, true와 false 중 한 가지 값을 가질 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문자형
    &lt;ul&gt;
      &lt;li&gt;char 2byte 크기, 작은따옴표를 이용하여 한 글자 표현 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정수형
    &lt;ul&gt;
      &lt;li&gt;int 4byte, long 8byte&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실수형
    &lt;ul&gt;
      &lt;li&gt;float 4byte, double 9byte&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리터럴
    &lt;ul&gt;
      &lt;li&gt;CS 분야에서 리터럴이란, 소스 코드의 고정된 값을 대표하는 용어&lt;/li&gt;
      &lt;li&gt;리터럴은 일종의 값이다. true, false, 10, 11.1, ‘a’등 이런 값 자체를 리터럴이라고 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용 방법
    &lt;ul&gt;
      &lt;li&gt;long : 값을 적을 때 뒤에 l이나 L 적어야함&lt;/li&gt;
      &lt;li&gt;float : 값을 적을 때 뒤에 f나 F를 적어야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;기본형-타입변환&quot;&gt;기본형 타입변환&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;묵시적 형변환
    &lt;ul&gt;
      &lt;li&gt;크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때에는 묵시적으로 형을 바꾸어 줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명시적 형변환
    &lt;ul&gt;
      &lt;li&gt;크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환 해주어야 함&lt;/li&gt;
      &lt;li&gt;eg) long x = 20; int y = (int) x;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;연산자-우선순위&quot;&gt;연산자 우선순위&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;최우선연산자 ( ., [], () )&lt;/li&gt;
  &lt;li&gt;단항연산자 ( ++,–,!,~,+/-   : 부정, bit변환&amp;gt;부호&amp;gt;증감)
    &lt;ul&gt;
      &lt;li&gt;단, 후위연산자(a++)은 우선순위가 낮음&lt;/li&gt;
      &lt;li&gt;eg) a=5, x = a++ - 5 라면 x는 0, a는6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;산술연산자 ( *,/,%,+,-,shift) &amp;lt; 시프트연산자 ( »,«,»&amp;gt; ) &amp;gt;&lt;/li&gt;
  &lt;li&gt;비교연산자 ( &amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=,==,!= )&lt;/li&gt;
  &lt;li&gt;비트연산자 ( &amp;amp;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;,,~ )&lt;/li&gt;
  &lt;li&gt;논리연산자 (&amp;amp;&amp;amp; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;||&lt;/code&gt; , !)&lt;/li&gt;
  &lt;li&gt;삼항연산자 (조건식) ? :&lt;/li&gt;
  &lt;li&gt;대입연산자 =,*=,/=,%=,+=,-=&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="프로그래머스 자바 입문" /><summary type="html">프로그래머스 자바 입문 강의 - 01</summary></entry><entry><title type="html">[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성</title><link href="http://localhost:4000/java/java_01/" rel="alternate" type="text/html" title="[Java/IntelliJ] IntelliJ 설치 및 Hello world 작성" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/java/java_01</id><content type="html" xml:base="http://localhost:4000/java/java_01/">&lt;h1 id=&quot;intellij&quot;&gt;IntelliJ&lt;/h1&gt;
&lt;p&gt;학교에서는 java를 배울 때 이클립스(Eclipse)를 사용했다. 하지만 python을 주로 다루면서 파이참(Pycharm)에 익숙해졌다. 
java 공부를 하면서 좀 더 친숙한 JetBrains 회사의 개발도구를 사용하려고 한다. 정보를 조금 찾아보니 IntelliJ가 현재 내가 사용하고 있는 환경인
Mac Os에서 이클립스보다 오류가 덜 발생한다고 한다. 통합 개발 환경도 제공한다고 하니 이보다 더 좋을 수가 없다!&lt;br /&gt;
&lt;br /&gt;
해당 포스트는 Mac Os 환경에서 진행되었다.&lt;/p&gt;

&lt;h3 id=&quot;1-intellij-설치&quot;&gt;1. IntelliJ 설치&lt;/h3&gt;
&lt;p&gt;우선 IntelliJ Mac Os 버전을 설치하려면 
&lt;a href=&quot;https://www.jetbrains.com/ko-kr/idea/download/#section=mac&quot;&gt;IntelliJ 설치 링크&lt;/a&gt;
에 접속한다.&lt;br /&gt;
각자 Mac 환경에 맞는 파일을 다운로드한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
java 학습을 위해선 Community Edition으로도 충분하다고 한다. 하지만 본인이 학생 신분이라면 학생 라이센스를 이용한
Ultimate 버전을 추천한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
아래와 같은 창이 뜨면 설치 성공!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_2.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-java-project-만들기&quot;&gt;2. Java Project 만들기&lt;/h3&gt;
&lt;p&gt;위의 창에서 Create New Project를 누르면 아래와 같은 창이 열린다. &lt;br /&gt;
왼쪽의 리스트에서는 Java 선택, 오른쪽 리스트에서는 아무것도 선택하지 않고, 오른쪽 아래의 “Next” 버튼을 누른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_3.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
Java 프로젝트를 생성할 때 샘플코드를 생성할지 여부. &lt;br /&gt;
본인이 직접 생성할 것이기 때문에 아무것도 선택하지 않고 “Next” 버튼을 누른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_4.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
프로젝트 이름을 정하고 “Next” 버튼을 누른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_5.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-hello-world-출력하기&quot;&gt;3. Hello World 출력하기&lt;/h3&gt;
&lt;p&gt;프로젝트 생성이 완료되면, main 메소드가 있는 새로운 Java 클래스를 생성하기 위해 src 폴더를 우클릭한다.&lt;br /&gt;
New &amp;gt; Java Class 를 선택한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_7.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
새로 생성할 Java Class 이름을 설정하고 Enter를 친다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_8.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
Hello World 출력 코드를 작성한다.&lt;br /&gt;
상단의 망치 버튼을 클릭하여 빌드하거나 “control + option + R”키를 눌러 빌드한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_10.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
혹은 out &amp;gt; production &amp;gt; “project_name” &amp;gt; “Class_name” 우클릭 후 Run을 선택해도 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/java/01/img_11.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
이제 IntelliJ와 함께 Java 공부를 시작해보자,,,!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="Java" /><category term="Java" /><category term="IntelliJ" /><summary type="html">java 공부를 시작해보자!</summary></entry><entry><title type="html">[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산 ~ 2.4 부동소수점)</title><link href="http://localhost:4000/cs:app/csapp_03/" rel="alternate" type="text/html" title="[CS:APP] Chapter 02. 정보의 표현과 처리 (2.3 정수의 산술연산 ~ 2.4 부동소수점)" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_03</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_03/">&lt;h1 id=&quot;chapter-02-정보의-표현과-처리&quot;&gt;Chapter 02. 정보의 표현과 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;2.1 정보의 저장
    &lt;ul&gt;
      &lt;li&gt;컴퓨터는 데이터, 인스트럭션등을 어떻게 저장하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.2 정수의 표시
    &lt;ul&gt;
      &lt;li&gt;인코딩, 비부호형 및 2의보수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-정수의-산술연산&quot;&gt;2.3 정수의 산술연산&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개의 양수를 더해서 음수가 나오는 경우, x&amp;lt;y와 x-y&amp;lt;0이 다른 결과를 보일 때 초보 프로그래머(나포함 ㅋ..)들은 놀라게 된다,
    &lt;ul&gt;
      &lt;li&gt;그렇다면 컴퓨터 산술연산의 미묘한 느낌을 이해해보자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;231-비부호형-덧셈&quot;&gt;2.3.1 비부호형 덧셈&lt;/h3&gt;

&lt;h3 id=&quot;232-2의-보수의-덧셈&quot;&gt;2.3.2 2의 보수의 덧셈&lt;/h3&gt;

&lt;h3 id=&quot;233-2의-보수에서의-비트반전-negation&quot;&gt;2.3.3 2의 보수에서의 비트반전 Negation&lt;/h3&gt;

&lt;h3 id=&quot;234-비부호형-곱셈&quot;&gt;2.3.4 비부호형 곱셈&lt;/h3&gt;

&lt;h3 id=&quot;235-2의-보수-곱셈&quot;&gt;2.3.5 2의 보수 곱셈&lt;/h3&gt;

&lt;h3 id=&quot;236-상수를-사용한-곱셈&quot;&gt;2.3.6 상수를 사용한 곱셈&lt;/h3&gt;

&lt;h3 id=&quot;237-2의-제곱으로-나눗셈하기&quot;&gt;2.3.7 2의 제곱으로 나눗셈하기&lt;/h3&gt;

&lt;h3 id=&quot;238-정수-산술연산에-대한-마지막-고찰&quot;&gt;2.3.8 정수 산술연산에 대한 마지막 고찰&lt;/h3&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 03</summary></entry><entry><title type="html">[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)</title><link href="http://localhost:4000/cs:app/csapp_02/" rel="alternate" type="text/html" title="[CS:APP] Chapter 02. 정보의 표현과 처리 (2.1 정보의 저장 ~ 2.2 정수의 표시)" /><published>2022-01-22T00:00:00+09:00</published><updated>2022-01-22T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_02</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_02/">&lt;h1 id=&quot;chapter-02-정보의-표현과-처리&quot;&gt;Chapter 02. 정보의 표현과 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터는 두 개의 값을 갖는 신호로 표현되는 정보를 저장하고 처리한다.&lt;/li&gt;
  &lt;li&gt;비트 패턴
    &lt;ul&gt;
      &lt;li&gt;이진수 체계를 사용하여 여러 비트를 묶어서 양수들을 인코딩하기 위해 사용한다.&lt;/li&gt;
      &lt;li&gt;표준 문자코드를 사용해서 문서의 글자와 기호를 인코딩할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인코딩
    &lt;ul&gt;
      &lt;li&gt;비부호형 : 전통적인 이진수 표시 사용&lt;/li&gt;
      &lt;li&gt;부호형(2의 보수) : 양수 또는 음수 값을 갖는 부호형 정수를 표시하는 가장 일반적인 방법&lt;/li&gt;
      &lt;li&gt;부동소수점 : 2진수 버전의 소수 표시방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 장을 통해 표시 가능한 숫자의 범위, 비트수준 표시, 산술연산 성질 같은 특성을 도출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-정보의-저장&quot;&gt;2.1 정보의 저장&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기계수준의 프로그램은 메모리를 ‘가상메모리’라고 하는 거대한 바이트의 배열로 취급&lt;/li&gt;
  &lt;li&gt;메모리의 각 바이트는 주소라고 하는 고유한 숫자로 식별할 수 있음&lt;/li&gt;
  &lt;li&gt;모든 가능한 주소들의 집합을 ‘가상 주소공간’이라고 부름&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;211-16진수-표시&quot;&gt;2.1.1 16진수 표시&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1바이트는 8비트로 이루어짐&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이진수 표시와 십진수 표시는 비트 패턴을 표시하는 데 매우 불편함 -&amp;gt; 16진수 사용&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;16진수 &amp;lt;-&amp;gt; 10진수 &amp;lt;-&amp;gt; 2진수 변환을 잘 할 수 있어야 이후 내용이 헷갈리지 않음&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;212-데이터의-크기&quot;&gt;2.1.2 데이터의 크기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 컴퓨터는 워드 크기(word size)를 규격으로 가지게 됨
    &lt;ul&gt;
      &lt;li&gt;w비트 워드 크기를 갖는 컴퓨터에서 가상주소는 0에서 2^w - 1 범위를 가짐&lt;/li&gt;
      &lt;li&gt;프로그램은 최대 2^w 바이트에 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최근에는 32비트 워드 크기를 갖는 컴퓨터에서 64비트 워드 크기를 갖는 컴퓨터로 전환이 보편적임&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/01.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;213-주소지정과-바이트-순서&quot;&gt;2.1.3 주소지정과 바이트 순서&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 바이트에 걸쳐 있는 프로그램 객체들에 있어 두 개의 관습 설정
    &lt;ul&gt;
      &lt;li&gt;객체의 주소가 무엇이 되어야 하는지&lt;/li&gt;
      &lt;li&gt;메모리에 바이트들을 어떻게 정렬해야 하는지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비트 표시 [xw−1, xw−2, . . . , x1, x0]를 갖는 w-비트 정수가 있다.
    &lt;ul&gt;
      &lt;li&gt;가장 중요한 바이트 : [xw−1, xw−2, . . . , xw−8]&lt;/li&gt;
      &lt;li&gt;가장 덜 중요한 바이트 : [x7, x6, . . . , x0]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바이트 저장 방법
    &lt;ul&gt;
      &lt;li&gt;리틀 엔디안 : 가장 덜 중요한 바이트가 먼저 오는&lt;/li&gt;
      &lt;li&gt;빅 엔디안 : 가장 중요한 바이트가 먼저 오는&lt;/li&gt;
      &lt;li&gt;대부분의 인텔 호환 머신들은 리틀 엔디안 방식으로 동작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;바이트 순서가 이슈가 되는 경우
    &lt;ul&gt;
      &lt;li&gt;이진 데이터가 네트워크를 통해 다른 컴퓨터로 전송될 때
        &lt;ul&gt;
          &lt;li&gt;리틀 엔디안과 빅 엔디안과의 통신에 있어 바이트 순서가 뒤바뀜&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정수 데이터를 나타내는 바이트들을 살펴볼 때&lt;/li&gt;
      &lt;li&gt;프로그램이 정상적인 타입 체계를 회피하도록 작성되었을 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;214-스트링의-표시&quot;&gt;2.1.4 스트링의 표시&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;그냥 ASCII를 사용한다는 내용,,,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;215-코드의-표현&quot;&gt;2.1.5 코드의 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;인스트럭션들의 인코딩이 컴퓨터 타입마다 모두 다름&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img02.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터 시스템에서 근본 개념은 컴퓨터의 관점에서 볼 때 프로그램이라는 것은 단순히 바이트의 연속이라는 것&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;216-부울-boolean-대수&quot;&gt;2.1.6 부울 Boolean 대수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;NOT : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;AND : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;OR : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EXCLUSIVE-OR : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;217-c에서의-비트수준-연산&quot;&gt;2.1.7 C에서의 비트수준 연산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;C에서는 비트들 간의 부울 연산을 지원&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_1.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비트수준 연산은 일반적으로 마스크 연산을 구현할 때 사용한다.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;마스크: 비트 연산에 사용되는 데이터&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;219-c에서의-쉬프트-연산&quot;&gt;2.1.9 C에서의 쉬프트 연산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비트 패턴을 좌우로 이동시키는 쉬프트 연산 집합 제공&lt;/li&gt;
  &lt;li&gt;x « k
    &lt;ul&gt;
      &lt;li&gt;x는 좌측으로 k비트 이동하고, 중요한 좌측의 k비트가 밀려서 삭제되며, 우측에는 k개의 0으로 채워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;x » k
    &lt;ul&gt;
      &lt;li&gt;좌측 쉬프트와 비슷하지만 미묘한 차이가 있다.&lt;/li&gt;
      &lt;li&gt;논리 우측 쉬프트 : 좌측 끝을 k개의 0들로 채움&lt;/li&gt;
      &lt;li&gt;산술 우측 쉬프트 : 좌측 끝을 가장 중요한 비트를 K개 반복해서 채움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부호형 데이터는 산술 우측 쉬프트, 비부호형 데이터는 논리 우측 쉬프트 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-정수의-표시&quot;&gt;2.2 정수의 표시&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컴퓨터가 어떻게 정수를 인코딩하고 사용하는지, 아래 그림은 수학적 용어들로 나열한 것&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;221-정수형-데이터-타입&quot;&gt;2.2.1 정수형 데이터 타입&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;서로 다른 크기에 할당된 바이트 수는 컴퓨터의 워드 크기와 컴파일러에 따라 달라진다.&lt;/li&gt;
  &lt;li&gt;64비트 프로그램에서의 C 정수형 자료형의 일반적인 범위
    &lt;ul&gt;
      &lt;li&gt;음수의 범위가 양의 범위보다 1 더 넓은 것에 주목&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;222-비부호형의-인코딩&quot;&gt;2.2.2 비부호형의 인코딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;음수 값을 포함하지 않음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B2U는 Binary 에서 Unsigned의 줄임말&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;
&lt;img src=&quot;../../assets/img/csapp/02/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;223-2의-보수-twos-complement-인코딩&quot;&gt;2.2.3 2의 보수 two’s complement 인코딩&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;음수 값을 포함&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B2T는 Binary 에서 Two’s complement의 줄임말&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;
&lt;img src=&quot;../../assets/img/csapp/02/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든 머신들에서의 호환성을 극대화하는 것을 고려하는 프로그래머라면 자료형들의 보장된 범위를 넘어가는 표현 가능한 값의 특정 범위를 가정해서는 안되며, 
부호형 수에 대해서 특정 표시를 가정해서도 안된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;224-비부호형과-부호형-간의-변환&quot;&gt;2.2.4 비부호형과 부호형 간의 변환&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;C는 서로 다른 숫자 데이터 타입들 간에 캐스팅을 허용한다.&lt;/li&gt;
  &lt;li&gt;2의 보수에서 비부호형으로의 변환
    &lt;ul&gt;
      &lt;li&gt;TMin ≤ x ≤ TMax를 만족하는 x에 대해&lt;br /&gt; x가 0보다 크거나 같으면 x&lt;br /&gt;x가 0보다 작으면 x+2^w&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;이유는 2의 보수는 가장 중요한 바트 위치에 부호를 표현하는 비트를 사용하는데 Unsigned에서는 부호비트를 사용하지 않기 때문이다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;비부호형에서 2의 보수로의 변환
    &lt;ul&gt;
      &lt;li&gt;0 ≤ u ≤ UMax를 만족하는 u에 대해&lt;br /&gt;u가 TMax보다 작거나 같으면 u&lt;br /&gt;u가 TMax보다 크면 u-2^w&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;이유는 T2U의 이유와 동일하다.&lt;br /&gt;
이러한 특성이 산술연산에서 오버플로우를 일으킨다. 2.3장에서 해당 내용이 나올 예정이다.(이해하는데 살짝 오래걸려씀 ㅜㅜ..)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;225-c에서-부호형과-비부호형의-비교&quot;&gt;2.2.5 C에서 부호형과 비부호형의 비교&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;C에서는 부호형과 비부호형 산술연산을 지원한다.
    &lt;ul&gt;
      &lt;li&gt;C는 묵시적으로 부호형 인자를 비부호형으로 변환하고, 숫자들이 비음수라고 가정하고 계산을 수행한다.
&lt;img src=&quot;../../assets/img/csapp/02/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;226-수의-비트-표시를-확장하기&quot;&gt;2.2.6 수의 비트 표시를 확장하기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비부호형 수를 길이가 긴 데이터 타입으로 변환하기 위해서 단순히 앞에 0들을 추가할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;영의 확장 zero extension 이라고 알려짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 보수를 보다 긴 데이터 타입으로 변환하려면 앞에 가장 중요한 비트를 복사해서 추가한다.
    &lt;ul&gt;
      &lt;li&gt;부호 확장 sign extension 이라고 알려짐&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/02/img_9.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;227-숫자의-절삭&quot;&gt;2.2.7 숫자의 절삭&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;진짜 진짜 너무 어려웠다… mod가 뭔지 몰랐는데 mod는 나머지 구하기를 뜻하고 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비트의 개수를 줄이는 경우이다.
    &lt;ul&gt;
      &lt;li&gt;eg1) int type을 short type으로 캐스팅할 때. 32비트 int를 16비트 short로 절삭한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비부호형 수의 절삭
    &lt;ul&gt;
      &lt;li&gt;x’ = x mod 2^k 이다.
        &lt;ul&gt;
          &lt;li&gt;삭제되는 모든 비트들은 i ≥ k인 2^i의 자리값을 가진다.&lt;/li&gt;
          &lt;li&gt;자리값들은 모듈(mod) 계산으로 모두 0이 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2의 보수 숫자의 절삭
    &lt;ul&gt;
      &lt;li&gt;x’ = U2T(x mod 2^k) 이다.
        &lt;ul&gt;
          &lt;li&gt;가장 중요한 비트인 x_k-1이 자리값 2^(k-1) 대신 -2^(k-1)을 갖는 효과를 가진다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;228-signed와-unsigned에-관한-조언&quot;&gt;2.2.8 Signed와 Unsigned에 관한 조언&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부호형을 비부호형으로 묵시적인 타입 변환을 하면 다소 직관적이지 않은 동작을 보인다.&lt;/li&gt;
  &lt;li&gt;비부호형 값들은 워드 길이 데이터를 숫자 값으로 해석하지 않고 단지 비트들의 집합으로 생각하려는 경우에 매우 유용하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.2 정수의 표현 챕터에서 나온 Signed와 Unsigned의 인코딩, 변환, 비교 그리고 비트 확장 및 절삭은 다음 챕터인 산술연산에서 모두 사용된다.
위의 내용들을 정확히 숙지하지 않고 산술연산을 공부하게 되면 많은 어려움을 겪을 수 있다. 이번 챕터를 확실하게 이해하고 다음 챕터로 넘어가자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 02</summary></entry><entry><title type="html">[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행</title><link href="http://localhost:4000/cs:app/csapp_01/" rel="alternate" type="text/html" title="[CS:APP] Chapter 01. 컴퓨터 시스템으로의 여행" /><published>2022-01-21T00:00:00+09:00</published><updated>2022-01-21T00:00:00+09:00</updated><id>http://localhost:4000/cs:app/csapp_01</id><content type="html" xml:base="http://localhost:4000/cs:app/csapp_01/">&lt;h1 id=&quot;csapp&quot;&gt;CS:APP&lt;/h1&gt;
&lt;p&gt;Computer Systems A Programmer’s Perspective, CSAPP로도 잘 알려져있는 컴퓨터 구조론의 바이블이다. 이 책을 통해서 컴퓨터구조론을 다시 공부해볼 생각이다.
군대 전역 직후 2학년 2학기로 복학해서 컴퓨터 구조론 전공 수업을 들었지만 학점을 위한 공부만 해서 남아있는게 없는 것 같다. 인턴 생활을 하면서 다양한 부분에서 어려움을 겪었는데
기초를 몰라서 헤메고 있다는 느낌을 굉장히 많이 받았다.&lt;/p&gt;

&lt;p&gt;첫 페이지를 읽었을 때 이 책으로 정하길 정말 잘했다는 생각이 들었다. 전공 수업때 사용했던 컴퓨터구조론 책은 제작자의 관점에서 기술 되었다는 느낌을 강하게 받았었다.
하지만, CSAPP는 프로그래머의 관점에서 기술하였고, 컴퓨터구조론의 시스템들을 어떻게 사용해서 좋은 프로그램을 개발할 수 있는지를 배울 수 있다고 한다. 
인턴 생활을 하면서 실제 현업을 겪고 느꼇던 강한 의문들을 해결할 수 있을 것 같은 느낌이다.&lt;/p&gt;

&lt;p&gt;책의 목차는 정보의 표현과 처리로 시작하여 프로그램의 기계어 표현, 프로세서 구조, 프로그램 성능 최적화, 메모리 계층구조, 링커, 예외적인 제어흐름, 가상메모리, 시스템 수준 입출력, 네트워크 프로그래밍, 동시성 프로그래밍 
순서로 이어져 있다. 많은 사람들은 6장 메모리 계층구조, 7장 링커의 전까지 읽어도 좋다고 하지만, 가능하다면 12장 동시성 프로그래밍까지 읽어볼 생각이다.&lt;/p&gt;

&lt;h1 id=&quot;chapter-01-컴퓨터-시스템으로의-여행&quot;&gt;Chapter 01. 컴퓨터 시스템으로의 여행&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 구현방식은 변하지만 근본적인 개념들은 변하지 않는다.&lt;/li&gt;
  &lt;li&gt;프로그래머들로 하여금 컴포넌트들이 어떻게 동작하고 프로그램 성능과 정확성에 어떤 영향을 주는지 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;11-정보는-비트와-컨텍스트로-이루어진다&quot;&gt;1.1 정보는 비트와 컨텍스트로 이루어진다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;텍스트 문자 -&amp;gt; 아스키(ASCII) 표준 사용하여 표현 -&amp;gt; 각 문자를 바이트 길이의 정수 값으로 표현 -&amp;gt; 연속된 바이트 파일 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-프로그램은-다른-프로그램에-의해-다른-형태로-번역된다&quot;&gt;1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;hello.c 실행 -&amp;gt; 저급 기계어 인스트럭션들로 번역 -&amp;gt; (실행가능 목적 프로그램)으로 합쳐져 바이너리 디스크 파일로 저장 
-&amp;gt; 컴파일러 드라이브는 유닉스 시스템에서 소스파일에서 오브젝트 파일로 변경 -&amp;gt; 4개의 단계를 거쳐서 실행
    &lt;ul&gt;
      &lt;li&gt;4개의 단계:
        &lt;ol&gt;
          &lt;li&gt;전처리기&lt;/li&gt;
          &lt;li&gt;컴파일러&lt;/li&gt;
          &lt;li&gt;어셈블러&lt;/li&gt;
          &lt;li&gt;링커&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13-컴파일-시스템이-어떻게-동작하는지-이해하는-것은-중요하다&quot;&gt;1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 성능 최적화하기
    &lt;ul&gt;
      &lt;li&gt;eg1) switch문은 if-else문을 연속해서 사용하는 것보다 효율적인가?&lt;/li&gt;
      &lt;li&gt;eg2) while 루프는 for 루프보다 더 효율적일까?&lt;/li&gt;
      &lt;li&gt;eg3) 포인터 참조가 배열 인덱스보다 더 효율적인가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링크 에러 이해하기
    &lt;ul&gt;
      &lt;li&gt;eg1) 정적변수와 전역변수의 차이는 무엇인가?&lt;/li&gt;
      &lt;li&gt;eg2) 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨 일이 일어나는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보안 약점 피하기
    &lt;ul&gt;
      &lt;li&gt;eg1) 프로그램 스택에 데이터와 제어 정보가 저장되는 방식은 무엇인가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14-프로세서는-메모리에-저장된-인스트럭션을-읽고-해석한다&quot;&gt;1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;인스트럭션이란 : 컴퓨터에게 일을 시키는 단위(기계어)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;시스템의 하드웨어 조직
    &lt;ul&gt;
      &lt;li&gt;버스 : 시스템 내를 관통하는 전기적 배선군&lt;/li&gt;
      &lt;li&gt;입출력 장치 : 시스템과 외부세계외의 연결 담당&lt;/li&gt;
      &lt;li&gt;메인 메모리 : 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치&lt;/li&gt;
      &lt;li&gt;프로세서 : 인스트럭션들을 해독(실행)하는 엔진
        &lt;ul&gt;
          &lt;li&gt;인스트럭션의 요청에 의해 CPU(프로세서)가 실행하는 단순한 작업의 예
            &lt;ul&gt;
              &lt;li&gt;적재(load), 저장(store), 작업(operate), 점프(jump)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램의 실행
(그림 추가 예정 ㅎㅎ..)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15-캐시가-중요하다&quot;&gt;1.5 캐시가 중요하다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;hello 프로그램의 기계어 인스트럭션들은 본래 하드디스크에 저장되어 있다.&lt;/li&gt;
  &lt;li&gt;프로그램이 로딩될 때 이들은 메인 메모리로 복사된다.&lt;/li&gt;
  &lt;li&gt;이 작업이 시간이 너무 오래 걸려서 “단기간에 필요로 할 가능성이 높은 정보를 임시로 저장하는” 캐시 메모리가 설계 되었다.&lt;/li&gt;
  &lt;li&gt;캐시 시스템의 이면에 깔려 있는 아이디어는 프로그램이 지엽적인 영역의 코드와 데이터를 액세스하는 경향인 지역성을 활용하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;16-저장장치들은-계층구조를-이룬다&quot;&gt;1.6 저장장치들은 계층구조를 이룬다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 컴퓨터 시스템의 저장장치즈들은 메모리 계층구조로 구성되어 있다.&lt;/li&gt;
  &lt;li&gt;(그림 추가 예정 ㅎㅎ..)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;17-운영체제는-하드웨어를-관리한다&quot;&gt;1.7 운영체제는 하드웨어를 관리한다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제는 두 가지 주요 목적을 가지고 있다.
    &lt;ol&gt;
      &lt;li&gt;제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못 사용하는 것을 막기 위해&lt;/li&gt;
      &lt;li&gt;응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기 위해&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;위 두가지 목표를 위해 근본적인 추상화를 통해 달성하고 있다.&lt;/li&gt;
  &lt;li&gt;추상화 결과
    &lt;ul&gt;
      &lt;li&gt;프로세스 : 프로세서, 메인 메모리, 입출력장치 모두의 추상화 결과&lt;/li&gt;
      &lt;li&gt;가상 메모리 : 메인 메모리와 디스크 입출력 장치의 추상화&lt;/li&gt;
      &lt;li&gt;파일 : 입출력장치의 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;18-시스템은-네트워크를-사용하여-다른-시스템과-통신한다&quot;&gt;1.8 시스템은 네트워크를 사용하여 다른 시스템과 통신한다.&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;네트워크는 또 다른 입력장치로 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;시스템이 메인 메모리로부터 네트워크 어댑터로 일련의 바이트를 복사할 때, 데이터는 로컬디스크 드라이브 대신에 네트워크를 통해서 다른 컴퓨터로 이동된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;19-중요한-주제들&quot;&gt;1.9 중요한 주제들&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Amdahl의 법칙
    &lt;ul&gt;
      &lt;li&gt;우리가 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 구 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동시성과 병렬성
    &lt;ul&gt;
      &lt;li&gt;동시성 : 다수의 동시에 벌어지는 일을 갖는 시스템에 관한 일반적인 개념&lt;/li&gt;
      &lt;li&gt;병렬성 : 동시성을 사용해서 시스템을 보다 더 빠르게 동작하도록 하는 것&lt;/li&gt;
      &lt;li&gt;쓰레드 수준 동시성
        &lt;ul&gt;
          &lt;li&gt;쓰레드를 이용하면 한 개의 프로세스 내에서 실행되는 다수의 제어흐름을 가질 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인스트럭션 수준 병렬성
        &lt;ul&gt;
          &lt;li&gt;프로세서들은 훨씬 낮은 수준에서의 추상화로 여러 개의 인스트럭션을 한 번에 실행할 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템에서 추상화의 중요성
    &lt;ul&gt;
      &lt;li&gt;추상화의 사용은 전산학에서 가장 중요한 개념!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;110-요약&quot;&gt;1.10 요약&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;컴퓨터 내의 정보는 비트들의 그룹으로 표시&lt;/li&gt;
  &lt;li&gt;컴파일러와 링커에 의해 바이너리 실행파일들로 번역&lt;/li&gt;
  &lt;li&gt;프로세서는 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석&lt;/li&gt;
  &lt;li&gt;컴퓨터는 대부분의 시간을 메모리, 입출력장치, CPU 레지스터 간에 데이터를 복사하고 쓰는 데 사용&lt;/li&gt;
  &lt;li&gt;위와 같은 이유로 시스템의 저장장치들은 계층구조 형성&lt;/li&gt;
  &lt;li&gt;운영체제 커널은 응용프로그램과 하드웨어 사이에서 중간자 역할 수행&lt;/li&gt;
  &lt;li&gt;네트워크는 컴퓨터 시스템이 서로 통신할 수 있는 방법 제공&lt;/li&gt;
&lt;/ol&gt;</content><author><name>honggoo</name></author><category term="CS:APP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 01</summary></entry><entry><title type="html">TDD와 each map</title><link href="http://localhost:4000/docker/doodle_03/" rel="alternate" type="text/html" title="TDD와 each map" /><published>2022-01-11T00:00:00+09:00</published><updated>2022-01-11T00:00:00+09:00</updated><id>http://localhost:4000/docker/doodle_03</id><content type="html" xml:base="http://localhost:4000/docker/doodle_03/">&lt;h1 id=&quot;tdd&quot;&gt;TDD&lt;/h1&gt;

&lt;p&gt;TDD(Test Driven Development)란 본격적인 개발에 들어가기 전에 테스트
계획 및 코드를 작성하는 것을 의미한다. 테스트가 개발을 이끌어 나가는 것이다.
예를들어, 개발 중 에러가 발생했을 때 소규모 개발에서는 큰 문제가 되지는 않지만,
대규모의 개발 상황에서는 수 많은 모듈과 함수간 종속성들이 굉장히 많은 시간을 괴롭히게 된다.
이러한 문제점을 해결하기 위해서 테스트 주도 개발이 등장했다.&lt;/p&gt;

&lt;p&gt;나는 pytest를 사용할 것이다.
https://binux.tistory.com/47&lt;/p&gt;

&lt;p&gt;일단, monkeypatch.setattr 살펴보자. 
이것은 어떤것을 하냐면, mocking이다. Mocking은 실제 값이 아닌 가짜 값을 만들어내는 것이다.&lt;/p&gt;

&lt;p&gt;음 예를들면 Upload 클래스가 있다.&lt;/p&gt;

&lt;p&gt;Class Upload  &lt;br /&gt;
|_ Def Extract &lt;br /&gt;
|_ Def Transform &lt;br /&gt;
|_ Def Load&lt;/p&gt;

&lt;p&gt;이렇게 되어있을 때 나는 Transform 부분만 테스트하고 싶다. 하지만 함수의 종속성으로 인하여
Transform에서 사용되는 data는 Extract로 부터 참조되며 Extract에서 추출되는 data는 
특정 라이브러리의 기능을 참조한다. 나는 Transform 부분만 테스트하고 싶지만 이런 경우에 Extract부터
특정 라이브러리으 기능까지 테스트해야되는 상황에 처한 것이다. 이런 경우에 이제 Mocking이라는 기술을 쓴다.
pytest에서도 제공하는 function이 있지만, 단순한 예를 하나 들자면 정답과 인풋값을 csv파일이나 등등으로 미리 만들어서
로컬에서 참조하도록 코드를 작성하면 된다.&lt;/p&gt;

&lt;p&gt;하지만 이때, 테스트 코드에서 원코드를 실행할 때 원코드의 Extract가 실행 되기 때문에
monkeypatch.setattr 같은 기능으로 해당 function을 사용하지 않고 넘겨주는 기능을 넣어줘야한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;each-map&quot;&gt;each map&lt;/h1&gt;
&lt;p&gt;each map을 알아야한다. 
음 지금 내가 하는 것은 DB -&amp;gt; transform -&amp;gt; DB 적재이다.
transform에서 전처리 및 parsing을 해주는데, transform에서 이뤄지는 작업은
모든 Dataframe이 메모리 상으로 올라가게 된다. 작은 task면 문제없이 실행 되겠지만,
큰 규모의 task는 메모리를 많이 차지하게 되어 에러가 날 수 있다.
이럴 때 사용 하는 것이 each map이다.
each map은 dataframe에서 row 별로 메모리 상으로 올린다.
이후 해당 row에서 특정 처리를 진행 후에 buffer로 옮긴 뒤 DB로 적재를 한다.
이 때 조심해야 하는 부분은 seperate다. row에서 컬럼으로 구분하는 seperate값을 잘 이용해야지 에러가 나지 않을 것이다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;즉! pytest 부분을 더 공부하고 적절한 testset을 생각해보고, testcode를 작성해보자!&lt;/p&gt;</content><author><name>honggoo</name></author><category term="Docker" /><category term="Docker" /><summary type="html">인턴 하면서 끄적였던 것들...2</summary></entry><entry><title type="html">Docker는 대충 이런 느낌인가?</title><link href="http://localhost:4000/docker/docker_01/" rel="alternate" type="text/html" title="Docker는 대충 이런 느낌인가?" /><published>2022-01-10T00:00:00+09:00</published><updated>2022-01-10T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker_01</id><content type="html" xml:base="http://localhost:4000/docker/docker_01/">&lt;h1 id=&quot;docker&quot;&gt;Docker&lt;/h1&gt;

&lt;p&gt;내가 느낀 전체적인 도커의 메커니즘 : 어떠어떠한 것을 빌드해서 이미지를 만들고 
-&amp;gt; 이미지를 도커로 띄운 뒤 -&amp;gt; 이미지를 받아서 로컬에서 개발작업을 진행&lt;/p&gt;

&lt;p&gt;!!많은 시행착오를 거쳐 도커의 메커니즘에 대해 이해가 조금 되었다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Dockerfile을 만든다.&lt;/li&gt;
  &lt;li&gt;해당 디렉토리 위치에서 docker build를 한다.&lt;/li&gt;
  &lt;li&gt;docker build을 하면 이미지가 생성된다.&lt;/li&gt;
  &lt;li&gt;이미지가 생성됐으면, 해당 이미지로 docker run을 한다.&lt;/li&gt;
  &lt;li&gt;docker run을 하면 컨테이너가 만들어지고 해당 이미지를 컨테이너 안으로 넣는다?띄운다?&lt;/li&gt;
  &lt;li&gt;그럼 환경셋팅이 된다…?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;틀린 부분도 있겠지만 아주 조오금 조오오오오금 메커니즘이 이해가 됐다. &lt;br /&gt;
앗 참고로 음… 저런 run이니 이미지 파일들이니 어떤 컨테이너가 실행중인지를 GUI로 확인할 수 있는 프로그램이 Docker Desktop 같다 ㅎㅎ..&lt;/p&gt;

&lt;p&gt;추가적으로 환경세팅을 완료한 것 같다. 음… 위의 6번까지 진행한 후에&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;컨테이너를 만들면 어떠한 가상환경이 만들어지는 것 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 그 컨테이너에가 파이썬 환경으로 이루어져있고 추가로 다양한 패키지들이 들어있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그럼 그 환경을 내가 사용하고 있는 Pycharm과 연동을 하는 거다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;어떻게 하냐면 파이참 프로젝트의 인터프리터를 해당 컨테이너에 있는 파이썬path로 설정해주는거다.
*https://i-am-eden.tistory.com/13&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그리고 코딩하면 된다 ㅎㅎ
***&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커엔진 - 도커를 실행하면 Dockered라는 데몬 프로그램이 서버로 실행. &lt;br /&gt;
**여기서 잠깐! 데몬 프로그램이 뭘까? &lt;br /&gt;
https://blogger.pe.kr/770  (포그라운드, 백그라운드, 데몬 프로세스)  &lt;br /&gt;
https://haruhiism.tistory.com/9&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커실행 : 도커 이미지를 받아서 컨테이너로 실행 &lt;br /&gt;
** -it 라는 명령어는 -i와 -t 옵션이 합쳐진 옵션, -i는 호스트와 컨테이너 상호 입출력을 맞추고,
-t는 TTY를 활성화해서 컨테이너에 터미널로 입력이 가능하게 한다. &lt;br /&gt;
** TTY가 뭐지?! &lt;br /&gt;
https://cosmosproject2015.tistory.com/143 (TTY, PTS, PTY)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커 volume : 데이터를 컨테이너에 저장하지 않고 호스트에 저장하는 방식 &lt;br /&gt;
https://www.daleseo.com/docker-volumes-bind-mounts/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;도커빌드 : Dockerfile로 사용자 정의 이미지를 만듬&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;*공부하기 : 도커 아키텍쳐, 컨테이너-OS 간의 통신 구조 &lt;br /&gt;
**&lt;/em&gt;
Docker의 개념 및 핵심 설명 : 
https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Docker 예제 실습중 갱장히 이상한 오류가 발생했다.&lt;/p&gt;

&lt;p&gt;failed to solve with frontend dockerfile.v0: failed to read dockerfile: open /var/lib/docker/tmp/buildkit-mount174403522/Dockerfile: no such file or directory&lt;/p&gt;

&lt;p&gt;구글링을 계속 해봤지만 dockerfile -&amp;gt; Dockerfile 로 이름을 바꾸라는 답변밖에 없었다. &lt;br /&gt;
하지만, 오류가 고쳐지지 않았고 터미널을 Open한 디렉토리 경로를 상위 폴더 위치로 open을 해서 났던 오류였다 ㅎㅎ&lt;/p&gt;</content><author><name>honggoo</name></author><category term="Docker" /><category term="Docker" /><summary type="html">인턴 하면서 끄적였던 것들...</summary></entry></feed>