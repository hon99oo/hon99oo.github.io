<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-05-11T14:29:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">홍구의 개발 블로그</title><subtitle>본격적인 개발 블로그를 시작해볼까!</subtitle><author><name>honggoo</name></author><entry><title type="html">[CS:APP] Chapter 10 시스템 수준 입출력</title><link href="http://localhost:4000/csapp/csapp_27/" rel="alternate" type="text/html" title="[CS:APP] Chapter 10 시스템 수준 입출력" /><published>2022-05-11T00:00:00+09:00</published><updated>2022-05-11T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_27</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_27/"></content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 26</summary></entry><entry><title type="html">[CS:APP] Chapter 09 가상메모리 (9.8 메모리 매핑 ~ 9.12 요약)</title><link href="http://localhost:4000/csapp/csapp_26/" rel="alternate" type="text/html" title="[CS:APP] Chapter 09 가상메모리 (9.8 메모리 매핑 ~ 9.12 요약)" /><published>2022-05-10T00:00:00+09:00</published><updated>2022-05-10T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_26</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_26/">&lt;h1 id=&quot;chapter-09-가상메모리&quot;&gt;Chapter 09 가상메모리&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;물리 및 가상주소 방식&lt;/li&gt;
  &lt;li&gt;주소공간&lt;/li&gt;
  &lt;li&gt;캐싱 도구로서의 VM&lt;/li&gt;
  &lt;li&gt;메모리 관리를 위한 도구로서의 VM&lt;/li&gt;
  &lt;li&gt;메모리 보호를 위한 도구로서의 VM&lt;/li&gt;
  &lt;li&gt;주소의 번역&lt;/li&gt;
  &lt;li&gt;사례 연구: 인텔 코어 i7/리눅스 메모리 시스템&lt;/li&gt;
  &lt;li&gt;메모리 매핑&lt;/li&gt;
  &lt;li&gt;동적 메모리 할당&lt;/li&gt;
  &lt;li&gt;가비지 컬렉션&lt;/li&gt;
  &lt;li&gt;C 프로그램에서의 공통된 메모리 관련 버그&lt;/li&gt;
  &lt;li&gt;요약&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;98-메모리-매핑&quot;&gt;9.8 메모리 매핑&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;매핑: 리눅스는 가상메모리 영역의 내용을 디스크의 객체에 연결해서 초기화한다.&lt;/li&gt;
  &lt;li&gt;영역들은 다음 두 종류의 객체 중의 하나로 매핑될 수 있다.
    &lt;ol&gt;
      &lt;li&gt;리눅스 파일 시스템 내의 일반 파일: 한 영역은 실행가능 목적파일과 같은 일반 디스크 파일의 연속적인 섹션으로 매핑될 수 있다.&lt;/li&gt;
      &lt;li&gt;무기명 파일: 한 영역은 또한 무기명 파일로 매핑될 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;가상페이지가 초기화된 후에는 커널이 관리하는 특별한 &lt;strong&gt;스왑 파일&lt;/strong&gt; 사이에서 스왑 인되었다가 아웃되었다가 한다.
    &lt;ul&gt;
      &lt;li&gt;스왑 파일은 스왑 공간 또는 스왑 영역이라고도 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;981-다시-보는-공유-객체&quot;&gt;9.8.1 다시 보는 공유 객체&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 매핑에 대한 아이디어는 만일 가상메모리 시스템이 보통의 파일 시스템과 통합될 수 있다면, 단순하고 효과적으로 프로그램과 데이터를 메모리에 로드할 수 있을 것이라는 기발한 
생각에서 생겨났다.&lt;/li&gt;
  &lt;li&gt;프로세스 개념은 각 프로세스에 자신만의 가상 주소공간을 제공하며, 이것은 다른 프로세스들에 의해 잘못된 쓰기와 읽기 작업이 발생하는 것을 막아준다.&lt;/li&gt;
  &lt;li&gt;객체는 공유 가상메모리 영역으로 공유 객체 또는 사적private 개체로 매핑될 수 있따.
    &lt;ul&gt;
      &lt;li&gt;공유 객체에 매핑: 프로세스가 해당 영역에 쓰는 모든 내용은 자신의 공유 메모리 내로 객체를 매핑한 다른 프로세스들도 볼 수 있게 한다. 변경된 내용은 디스크 상의 원래의 객체에도 반영된다.&lt;/li&gt;
      &lt;li&gt;사적 객체에 매핑: 해당 영역에 가한 수정사항들은 다른 프로세스들은 볼 수 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img.png&quot; width=&quot;40%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 공유 객체이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_1.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 사적 copy-on-write 객체이다.
    &lt;ul&gt;
      &lt;li&gt;사적 객체들은 &lt;strong&gt;copy-on-write&lt;/strong&gt;라고 알려진 기법을 사용해서 가상메모리에 매핑된다.&lt;/li&gt;
      &lt;li&gt;공유된 객체에 다른 프로세스가 쓰기 작업을 하게 되면 새로운 사본을 물리페이지 내에 만들고 해 사본을 가르키게 한다.&lt;/li&gt;
      &lt;li&gt;copy-on-write는 마지막 가능한 순간까지 사적 객체 내에서 페이지를 복사하는 것을 지연시켜서 부족한 물리 메모리를 가장 효율적으로 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;982-다시-보는-fork-함수&quot;&gt;9.8.2 다시 보는 fork 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 프로세스가 fork 함수를 호출하면, 커널은 새로운 프로세스를 위한 여러가지 자료 구조를 생성하고, 여기에 고유한 PID를 부여한다.&lt;/li&gt;
  &lt;li&gt;새 프로세스를 위한 가상메모리를 생성하기 위해 현재 프로세스의 mm_struct, 영역 구조체, 페이지 테이블과 동일한 사본을 만든다.&lt;/li&gt;
  &lt;li&gt;두 프로세스의 모든 페이지들을 읽기-허용으로 표시하고, 두 프로세스의 영역 구조체들을 사적 copy-on-write로 표시한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;983-다시-보는-execve-함수&quot;&gt;9.8.3 다시 보는 execve 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가상메모리와 메모리 매핑은 또한 프로그램을 메모리로 로딩하는 과정에서 중요한 역할을 한다.&lt;/li&gt;
  &lt;li&gt;execve 함수는 현재 프로세스 내에서 현재 프로그램을 효과적으로 교체하면서 실행 목적파일에 포함된 프로그램을 실행하고 로드한다.
    &lt;ol&gt;
      &lt;li&gt;기존 사용자 영역을 제거한다.&lt;/li&gt;
      &lt;li&gt;사적 영역을 매핑한다. copy-on-write형식을 사용한다.&lt;/li&gt;
      &lt;li&gt;공유 영역을 매핑한다.&lt;/li&gt;
      &lt;li&gt;프로그램 카운터를 설정한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;984-함수를-이용한-사용자수준-메모리-매핑&quot;&gt;9.8.4 함수를 이용한 사용자수준 메모리 매핑&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리눅스 프로세스들은 함수를 이용해서 가상메모리의 새로운 영역들을 만들 수 있으며, 객체들을 이 영역으로 매핑할 수 있다.&lt;/li&gt;
  &lt;li&gt;mmap 함수: 커널에 새 가상메모리 영역을 생성해 줄 것을 요청&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_2.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 mmap 인자의 시각적 해석&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nunmap 함수: 가상메모리의 영역들을 삭제한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;99-동적-메모리-할당&quot;&gt;9.9 동적 메모리 할당&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동적 메모리 할당기&lt;/strong&gt;을 사용하여 추가적인 가상메모리를 런타임에 획득한다.&lt;/li&gt;
  &lt;li&gt;동적 메모리 할당기는 힙heap 이라고 하는 프로세스의 가상메모리 영역을 관리한다.
    &lt;ul&gt;
      &lt;li&gt;힙은 미초기화된 데이터 영역 직후에 시작해서 위쪽(높은 주소 방향)으로 커지는 무요구 메모리 영역이라고 가정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_3.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 힙heap 이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;할당기는 힙을 다양한 크기의 블록들의 집합으로 관리한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;명시적 할당기: application이 명시적으로 할당된 블록을 반환해 줄 것을 요구한다. malloc 패키지.&lt;/li&gt;
      &lt;li&gt;묵시적 할당기: 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구한다. 가비지 컬렉터garbage collector.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;991-malloc과-free함수&quot;&gt;9.9.1 malloc과 free함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;malloc 함수: 힙으로부터 블록들을 할당받는다.&lt;/li&gt;
  &lt;li&gt;sbrk 함수: brk 포인터에 인자값(incr)을 더해서 힙을 늘리거나 줄인다.&lt;/li&gt;
  &lt;li&gt;free 함수: 할당된 힙 블록을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_4.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 malloc과 free를 사용해서 블록을 할당하고 반환시키는 모습을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;992-왜-동적-메모리-할당인가&quot;&gt;9.9.2 왜 동적 메모리 할당인가?&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램을 실제 실행시키기 전에는 자료 구조의 크기를 알 수 없는 경우들이 있기 때문이다.
    &lt;ul&gt;
      &lt;li&gt;예를들어 n만큼의 배열 길이를 초기화 해줘야 하는데, n은 프로그램 실행 후에 입력받는다면, 배열의 길이를 n만큼 동적 할당해줘야한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;993-할당기-요구사항과-목표&quot;&gt;9.9.3 할당기 요구사항과 목표&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;명시적 할당기들은 다소 엄격한 제한사항 내에서 동작해야 한다.
    &lt;ul&gt;
      &lt;li&gt;임의의 요청 순서 처리하기: application은 각각의 가용 블록이 이전의 할당 요청에의해 현재 할당된 블록에 대응되어야 한다는 제한사항을 만족해야한다.&lt;/li&gt;
      &lt;li&gt;요청에 즉시 응답하기&lt;/li&gt;
      &lt;li&gt;힙만 사용하기: 비확장성 자료 구조들은 힙 자체에 저장되어야 한다.&lt;/li&gt;
      &lt;li&gt;블록 정렬하기(정렬 요건) : 어떤 종류의 데이터 객체라도 저장할 수 있도록 정렬해야한다.&lt;/li&gt;
      &lt;li&gt;할당된 블록을 수정하지 않기: 할당기는 가용 블록을 조작하거나 변경할 수만 있다. 할당된 블록은 수정하거나 이동하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;할당기는 두가지 목표를 달성하기 위해 노력한다.
    &lt;ol&gt;
      &lt;li&gt;처리량 극대화하기&lt;/li&gt;
      &lt;li&gt;메모리 이용도를 최대화하기&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;994-단편화&quot;&gt;9.9.4 단편화&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단편화: 가용 메모리가 할당 요청을 만족시킬 수 없는 상태 일어난다.
    &lt;ol&gt;
      &lt;li&gt;내부 단편화: 할당된 블록이 데이터 자체보다 더 클 때 일어난다. 사용하지 않는 블록이 낭비된다.&lt;/li&gt;
      &lt;li&gt;외부 단편화: 요청을 처리할 수 있는 단일한 가용블록이 없는 경우 발생한다. (가용 가능한 블록을 모두 모으면 충분한 크기가 존재하지만 단일 블록들이 만족할 수 없어서)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_5.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;외부 단편화를 위의 그림을 예로 든다면, 8워드 블록의 할당을 요청하면, 가용 블록들을 모두 모으면 가능하지만, 6워드 블록과, 2워드 블록으로 나뉘어져 있기 때문에 외부 단편화가 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;995-구현-이슈&quot;&gt;9.9.5 구현 이슈&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가용 블록 구성: 어떻게 가용 블록을 지속적으로 추적하는가?&lt;/li&gt;
  &lt;li&gt;배치: 새롭게 할당된 블록을 배치하기 위한 가용 블록을 어떻게 선택하는가?&lt;/li&gt;
  &lt;li&gt;분할: 블록을 새롭게 할당 후 가용 블록의 나머지 부분들로 무엇을 할 것인가?&lt;/li&gt;
  &lt;li&gt;연결: 방금 반환된 블록으로 무엇을 할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;996-묵시적-가용-리스트implict-free-list&quot;&gt;9.9.6 묵시적 가용 리스트(implict free list)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 힙 블록의 포맷이다.
    &lt;ul&gt;
      &lt;li&gt;한 블록은 1워드 헤더, 데이터, 추가적인 패딩으로 구성된다.&lt;/li&gt;
      &lt;li&gt;헤더: 블록 크기와 블록이 할당되었는지 가용 상태인지를 인코딩한다. 블록 크기는 정렬 기준의 배수이다.&lt;/li&gt;
      &lt;li&gt;데이터: 헤더 다음에는 malloc을 불렀을 때 요구한 데이터가 따라온다.&lt;/li&gt;
      &lt;li&gt;패딩: 패딩의 크기는 가변적이다. 패딩을 해야하는 이유는 1)외부 단편화를 극복하기 위해, 2)정렬 요구사항을 만족하기 위해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_6.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 묵시적 가용 리스트를 사용해서 구현한 힙이다.
    &lt;ul&gt;
      &lt;li&gt;8byte 더블 워드 정렬을 기준으로 구현했기 때문에 블록의 크기는 항상 8의 배수이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 구조를 &lt;strong&gt;묵시적 리스트&lt;/strong&gt;라고 부르는데, 가용 블록이 헤더 내 필드에 의해서 묵시적으로 연결되기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;997-할당한-블록의-배치&quot;&gt;9.9.7 할당한 블록의 배치&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;application이 메모리 할당을 요청할 때 요청한 블록을 저장하기에 충분히 큰 가용 블록을 리스트에서 검색한다. 할당기가 검색을 수행하는 방법은 &lt;strong&gt;배치 정책&lt;/strong&gt;에 의해서 결정된다.
    &lt;ul&gt;
      &lt;li&gt;First fit: 가용 리스트를 처음부터 검색한다.&lt;/li&gt;
      &lt;li&gt;Next fit: 이전 검색이 종료된 지점에서 검색을 시작한다.&lt;/li&gt;
      &lt;li&gt;Best fit: 모든 가용 블록을 검사하며 크기가 맞는 가장 작은 블록을 선택한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;998-가용-블록의-분할&quot;&gt;9.9.8 가용 블록의 분할&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;할당기는 가용 블록을 두 부분으로 나눈다.&lt;/li&gt;
  &lt;li&gt;예를들어 8워드 크기의 가용 블록중 2워드 크기를 할당하면 나머지 6워드 크기의 내부 단편화가 생긴다. 이를 분할해서 6워드 크기의 가용 블록을 새로 만든다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;999-추가적인-힙-메모리-획득하기&quot;&gt;9.9.9 추가적인 힙 메모리 획득하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가용 블록이 부족하다면 할당기는 커널에게 sork 함수를 호출해서 추가적인 힙 메모리를 요청한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9910-가용-블록-연결하기&quot;&gt;9.9.10 가용 블록 연결하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_8.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 가용할 수 있는 블록이 16/0 으로 두개로 나뉘어져 있다. 이는 &lt;strong&gt;오류 단편화false fragmentation&lt;/strong&gt;라고 한다.
    &lt;ul&gt;
      &lt;li&gt;이를 극복하기 위해서 16/0으로 나뉘어져 있는 가용블록을 32/0으로 연결한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_9.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림처럼 연결 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;즉시 연결: 할당기는 블록이 반환될 때마다 인접 블록을 통합한다.&lt;/li&gt;
  &lt;li&gt;지연 연결: 일정 시간 후에 가용 블록들을 연결하기 요청이 들어오면 블록들을 통합한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9911-경계-태그로-연결하기&quot;&gt;9.9.11 경계 태그로 연결하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;현재 블록(반환하려고 하는 블록)의 헤더는 다음 블록의 헤더를 가리키고 있으며, 이것은 다음 블록이 가용한지 결정하기 위해 체크될 수 있다. 하지만 이전 블록을 체크 할 수 
있는 방법은 없다. 해당 문제점을 해결하기 위해서 &lt;strong&gt;경계 태그&lt;/strong&gt; 기법을 만들었다.&lt;/li&gt;
  &lt;li&gt;경계태그: 각 블록의 끝 부분에 &lt;strong&gt;풋터footer(경계 태그)&lt;/strong&gt;을 추가하고 이 풋터는 이전 블록의 헤더를 복사한 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9912-종합설계-간단한-할당기의-구현&quot;&gt;9.9.12 종합설계: 간단한 할당기의 구현&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;현재 실력으로 구현은 조금 힘든 것 같아서 지식을 조금 더 쌓고 꼭 구현해보도록 하겠다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;9913-명시적-가용-리스트explicit-free-list&quot;&gt;9.9.13 명시적 가용 리스트(explicit free list)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;묵시적 가용 리스트는 블록 할당 시간이 전체 힙 블록의 수에 비례하기 때문에 범용 할당기에는 적합하지 않다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명시적 가용 리스트&lt;/strong&gt;는 가용 블록들을 일종의 명시적 자료구조로 구성하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;가용 블록들을 연결리스트로 모두 쭈르륵 연결한거라고 생각하면 된다! 반면에 묵시적 가용 리스트는 모든 블록을 연결한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_10.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 이중 연결 가용 리스트를 사용하는 힙 블록의 포맷이다.
-가용 블록 내에 pred와 succ 포인터를 포함하는 이중 연결 리스트로 구성된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;명시적 가용 리스트의 접근법
    &lt;ul&gt;
      &lt;li&gt;후입선출(LIFO): 리스트를 새롭게 반환한 블록들을 리스트의 시작 부분에 삽입해서 후입선출 순으로 유지 하는 것이다. LIFO 순서와 first fit 배치 정책을 사용하면, 할당기는 대부분의 최근에 사용된 블록들을 먼저 조사한다.&lt;/li&gt;
      &lt;li&gt;주소 순으로 정렬: 리스트를 주소 순으로 정렬해 리스트 내 각 블록의 주소가 다음 블록의 주소보다 작도록 한다. 후입선출 방식보다 좀 더 좋은 메모리 이용도를 가진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명시적 리스트의 단점은 가용 블록들이 header와 footer 뿐만 아니라 필요한 포인터까지 포함해야한다는 것이다. 그래서 최소 블록 크기가 커지고 내부 단편화 가능성이 증가한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9914-분리-가용-리스트&quot;&gt;9.9.14 분리 가용 리스트&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단일 연결 가용 블록 리스트를 사용하는 할당기는 한 개의 블록을 할당하는 데 가용 블록의 수에 비례하는 시간이 필요하다.&lt;/li&gt;
  &lt;li&gt;할당 시간을 줄이기 위해 &lt;strong&gt;분리 저장장치segregated storage&lt;/strong&gt;는 다수의 가용 리스트를 유지하며, 각 리스트는 거의 동일한 블록들을 저장한다.&lt;/li&gt;
  &lt;li&gt;모든 가능한 블록 크기를 크기 클래스size class라고 하는 동일 클래스의 집합들로 분리하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;910-가비지-컬렉션&quot;&gt;9.10 가비지 컬렉션&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;가비지 컬렉터garbage collector: 더 이상 프로그램에서 사용하지 않는 블록들을 자동으로 반환하는 동적 저장장치 할당기다.&lt;/li&gt;
  &lt;li&gt;가비지garbage: 사용하지 않는 블록들&lt;/li&gt;
  &lt;li&gt;가비지 컬렉션: 자동으로 힙 저장장치를 반납하는 과정&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;많은 가비지 컬렉션이 있지만, 우리는 논의를 가비지 컬렉션을 처음 개발한 McCarthy의 오리지널 Mark&amp;amp;Sweep 알고리즘에 국한할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;9101-가비지-컬렉터-기초&quot;&gt;9.10.1 가비지 컬렉터 기초&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/26/img_11.png&quot; width=&quot;100%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;가비지 컬렉터는 위의 그림과 같이 방향성 도달 그래프로 메모리를 고려한다.
    &lt;ul&gt;
      &lt;li&gt;그래프의 노드들은 루트 노드들과 힙 노드들로 나눈다.&lt;/li&gt;
      &lt;li&gt;각 힙 노드는 힙 내 한 개의 할당된 블록에 대응된다.&lt;/li&gt;
      &lt;li&gt;방향성 에지egde p -&amp;gt; q는 블록 p 내부의 위치가 블록 q 내부의 위치를 가리킨다는 것을 의미한다.&lt;/li&gt;
      &lt;li&gt;루트노드들은 가상메모리의 읽기-쓰기 데이터 영역 내 레지스터, 스택변수, 전역변수가 될 수 있따.&lt;/li&gt;
      &lt;li&gt;어떤 루트 노드에서 p로 방향성 경로가 존재한다면, p는 도달할 수 있다고 말한다.&lt;/li&gt;
      &lt;li&gt;application은 어떤 시점에서든 도달할 수 없는 노드를 다시는 사용할 수 없는 가비지에 대응시킨다.&lt;/li&gt;
      &lt;li&gt;가비지 컬렉터의 역할은 이 도달성 그래프의 표시를 관리하는 것과 도달 불가 노드들을 free시키는 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컬렉터들은 자신의 서비스를 요청에 의해서 제공하거나, application과 병렬로 별도의 쓰레드로서 실행되어 도달성 그래프를 지속적으로 갱신하고 가비지를 회수한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;911-c-프로그램에서의-공통된-메모리-관련-버그&quot;&gt;9.11 C 프로그램에서의 공통된 메모리 관련 버그&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 관련 버그들은 위험하다, 그 이유는 이들이 종종 시간과 공간적으로 버그의 원인으로부터 멀리 떨어진 곳에서 자신을 드러내기 때문인다.&lt;/li&gt;
  &lt;li&gt;메모리 관련 버그
    &lt;ul&gt;
      &lt;li&gt;잘못된 포인터 역참조&lt;/li&gt;
      &lt;li&gt;초기화되지 않은 메모리를 읽는 경우: bss 메모리 위치들은 0으로 초기화, 하지만 힙 메모리는 그렇지 않다.&lt;/li&gt;
      &lt;li&gt;스택 버퍼 오버플로우 허용하기: 배열의 범위를 벗어나면 버퍼 오버플로우를 갖는다.&lt;/li&gt;
      &lt;li&gt;Off-by-One 에러 만들기: 덮어쓰기 버그&lt;/li&gt;
      &lt;li&gt;포인터가 가리키는 객체 대신에 포인터 참조하기&lt;/li&gt;
      &lt;li&gt;존재하지 않는 변수 참조하기&lt;/li&gt;
      &lt;li&gt;가용 힙 블록 내 데이터 참조하기&lt;/li&gt;
      &lt;li&gt;메모리 누수leak 유발: 블록을 할당하고 반환을 하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;912-요약&quot;&gt;9.12 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;가상 메모리는 메인 메모리를 추상화한 것이다.
    &lt;ul&gt;
      &lt;li&gt;가상메모리를 지원하는 프로세서는 가상주소지정이라고 하는 간접화의 형태로 메인 메모리를 참조한다.&lt;/li&gt;
      &lt;li&gt;프로세서는 가상주소를 생성하고, 이것은 메인 메모리로 보내지기 전에 물리 주소로 번역된다.&lt;/li&gt;
      &lt;li&gt;페이지 테이블을 사용해서 번역한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가상 메모리는 세 가지 중요한 기능을 제공한다.
    &lt;ol&gt;
      &lt;li&gt;자동으로 최근에 사용한 디스크상의 가상 주소공간의 내용을 메모리로 캐시한다.
        &lt;ul&gt;
          &lt;li&gt;페이지: 가상 메모리 캐시에서 블록&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;가상메모리는 메모리 관리를 단순화해 주고, 링킹, 프로세스들 간의 데이터 공유, 프로세스를 위한 메모리 할당, 프로그램 로딩을 단순화해 준다.&lt;/li&gt;
      &lt;li&gt;가상메모리는 매 페이지 테이블 엔트리 내 보호 비트를 사용해서 메모리 보호를 단순화해 준다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;TLB를 사용해서 캐시의 동작과 통합&lt;/li&gt;
  &lt;li&gt;메모리 매핑: 가상메모리 블록을 디스크 상의 파일 묶음에 이들을 연계해서 초기화하는 과정
    &lt;ul&gt;
      &lt;li&gt;메모리 매핑은 데이터의 공유, 새로운 프로세스의 생성, 프로그램의 로딩을 위한 효율적인 메커니즘을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 할당기
    &lt;ul&gt;
      &lt;li&gt;힙이라고 부르는 가상의 주소공간 영역에 블록 할당&lt;/li&gt;
      &lt;li&gt;명시적 할당기: malloc (동적 메모리 할당기)&lt;/li&gt;
      &lt;li&gt;묵시적 할당기: 가비지 컬렉터 (자동으로 미사용 블록들 반환)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 26</summary></entry><entry><title type="html">[CS:APP] Chapter 09 가상메모리 (9.1물리 및 가상주소 방식 ~ 9.6주소의 번역)</title><link href="http://localhost:4000/csapp/csapp_25/" rel="alternate" type="text/html" title="[CS:APP] Chapter 09 가상메모리 (9.1물리 및 가상주소 방식 ~ 9.6주소의 번역)" /><published>2022-05-09T00:00:00+09:00</published><updated>2022-05-09T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_25</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_25/">&lt;h1 id=&quot;chapter-09-가상메모리&quot;&gt;Chapter 09. 가상메모리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;시스템의 프로세스들은 CPU와 메인 메모리를 다른 프로세스들과 공유한다.&lt;/li&gt;
  &lt;li&gt;메모리를 보다 효율적이고 더 적은 에러를 갖도록 관리하기 위해서 현대의 시스템은 가상메모리 virtual memory VM 이라고 알려진 메인 메모리의 추상화를 제공한다.&lt;/li&gt;
  &lt;li&gt;가상메모리는 각 프로세스에 하나의 크고 통합된, 사적 주소공간을 제공한다.&lt;/li&gt;
  &lt;li&gt;가상 메모리의 중요한 세가지 기능
    &lt;ol&gt;
      &lt;li&gt;메인 메모리를 디스크에 저장된 주소공간에 대한 캐시로 취급해서 메인 메모리 내 활성화 영역만 유지하고, 데이터를 디스크와 메모리 간에 필요에 따라 전송하는 방법으로 메인 메모리를 효율적을 ㅗ사용&lt;/li&gt;
      &lt;li&gt;각 프로세스에 주소공간을 제공함으로써 메모리 관리를 단순화한다.&lt;/li&gt;
      &lt;li&gt;각 프로세스의 주소공간을 다른 프로세스에 의한 손상으로부터 보호한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;가상 메모리를 이해하면 어떻게 시스템이 일반적으로 동작하는지 더 잘 이해할 수 있으며, 가상메모리의 강력한 성능을 응용프로그램에 적용할 수 있다. 또한 가상메모리는 
치명적인 에러를 발생시키는데 이를 방지할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;91-물리-및-가상주소-방식&quot;&gt;9.1 물리 및 가상주소 방식&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 시스템의 메인 메모리는 M개의 연속적인 바이트 크기 셀의 배열로 구성된다.&lt;/li&gt;
  &lt;li&gt;각 바이트는 고유의 물리 주소(PA physical address)를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 &lt;strong&gt;물리 주소 방식&lt;/strong&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_1.png&quot; width=&quot;80%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 &lt;strong&gt;가상주소방식&lt;/strong&gt;이다.
    &lt;ul&gt;
      &lt;li&gt;CPU는 가상주소지정으로 가상주소(VA virtual address)를 생성해서 메인 메모리에 접근하다.&lt;/li&gt;
      &lt;li&gt;가상주소를 물리 주소로 변환 하는 작업은 &lt;strong&gt;주소 번역&lt;/strong&gt;이다.&lt;/li&gt;
      &lt;li&gt;CPU 칩 내에 &lt;strong&gt;메모리 관리 유닛(MMU)&lt;/strong&gt;를 사용해서 가상주소로 번역한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;92-주소공간&quot;&gt;9.2 주소공간&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;메인 메모리의 각 바이트는 가상 주소공간으로부터 선택된 가상주소를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;93-캐싱-도구로서의-vm&quot;&gt;9.3 캐싱 도구로서의 VM&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;가상메모리는 디스크에 저장된 N개의 바이트 크기의 셀 배열로 구성된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VM system&lt;/strong&gt;은 가상메모리를 규정된 사이즈 블록 단위로 분할하여 관리한다.
    &lt;ul&gt;
      &lt;li&gt;분할된 블록들은 &lt;strong&gt;가상페이지&lt;/strong&gt;라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가상페이지의 집합은 세 개의 중첩되지 않는 부분집합으로 나누어진다.
    &lt;ul&gt;
      &lt;li&gt;Unallocated: VM 시스템에 의해 아직까지 할당되지 않은 페이지들&lt;/li&gt;
      &lt;li&gt;Cached: 현재 물리 메모리에 캐시되어 할당된 페이지들&lt;/li&gt;
      &lt;li&gt;Uncached: 물리 메모리에 캐시되지 않은 할당된 페이지들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 여덟 개의 가상페이지를 갖는 작은 가상메모리를 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;931-dram-캐시의-구성&quot;&gt;9.3.1 DRAM 캐시의 구성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM 캐시의 미스 비용과 첫 번째 바이트를 접근하는 데 드는 비용은 크기 때문에 가상페이지 또한 커지고 있다.&lt;/li&gt;
  &lt;li&gt;DRAM 캐시는 완전 결합성이기 때문에 모든 가상페이지는 물리페이지에 둘 수 있다.&lt;/li&gt;
  &lt;li&gt;디스크의 큰 접근 시간 때문에 DRAM은 항상 write-through 대신에 write-back을 사용하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 결합성은 하나의 집합에 모든 라인이 들어있는 캐시 구조를 말한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;932-페이지-테이블&quot;&gt;9.3.2 페이지 테이블&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 캐시에서처럼 VM 시스템은 가상페이지가 DRAM 어딘가에 캐시되었는지 결정하기 위한 방법을 갖고 있어야 한다.&lt;/li&gt;
  &lt;li&gt;이러한 기능은 &lt;strong&gt;운영체제 소프트웨어&lt;/strong&gt;와 &lt;strong&gt;MMU 내의 주소 번역 하드웨어&lt;/strong&gt;와 &lt;strong&gt;페이지 테이블&lt;/strong&gt;의 조합으로 제공된다.
    &lt;ul&gt;
      &lt;li&gt;페이지 테이블: 가상페이지를 물리페이지로 매핑하는 역할&lt;/li&gt;
      &lt;li&gt;주소 번역 하드웨어: 가상주소를 물리 주소로 변환할 때마다 페이지 테이블을 읽는다.&lt;/li&gt;
      &lt;li&gt;운영체제: 페이지 테이블의 콘텐츠 관리와 페이지들을 디스크와 DRAM 사이에서 왔다 갔다 하는 것을 관장한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_3.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 페이지 테이블의 기분 구조를 보여준다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DRAM 캐시가 완전 결합성이므로 물리페이지가 모든 가상페이지를 포함할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;933-페이지-적중&quot;&gt;9.3.3 페이지 적중&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;PTE 내의 물리 메모리 주소를 사용해서 해당 워드의 물리 주소를 구성한다.을 관장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_4.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;934-페이지-오류&quot;&gt;9.3.4 페이지 오류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가상메모리 용어에서 DRAM 캐시 미스는 페이지 오류page fault라고 알려져 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_5.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;VP3 내의 워드에 대한 참조는 미스가 되고 페이지 오류를 발생시킨다.
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_6.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;페이지 오류 핸들러는 VP4를 희생시키고 디스크로부터 VP3의 사본으로 교체한 뒤 정상적으로 읽는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지: 가상메모리 용어에서의 블록&lt;/li&gt;
  &lt;li&gt;스와핑(페이징): 디스크와 메모리 사이에 페이지를 전송하는 동작&lt;/li&gt;
  &lt;li&gt;요구 페이징 demand paging: 미스가 발생할 때, 하나의 페이지로 스와핑되어 들어오는 마지막 순간까지 기다리는 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;935-페이지의-할당&quot;&gt;9.3.5 페이지의 할당&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제가 가상메모리의 새로운 페이지를 할당할 때 디스크 상에 공간을 만들고 임의의 PTE를 디스크에 새롭게 만든 페이지를 가리키도록 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;936-문제해결을-위한-또-한-번의-지역성의-등장&quot;&gt;9.3.6 문제해결을 위한 또 한 번의 지역성의 등장&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;가상메모리의 개념을 공부하면 비효율적인 것을 느낄 수 있다 하지만 실제로 가상메모리는 잘 동작하는데, 주로 &lt;strong&gt;지역성&lt;/strong&gt; 문제 때문이다.&lt;/li&gt;
  &lt;li&gt;지역성의 원리는 시간상의 어느 시점에서라도 이들이 동작 집합working set 또는 거주 집합resident set이라고 알려진 보다 작은 활성화된 페이지 집합에서 동작하는 
경향을 보일 것이라는 점을 약속해준다.&lt;/li&gt;
  &lt;li&gt;쓰레싱thrashing: 동작 집합 크기가 물리 메모리보다 더 크면, 페이지들이 연속적으로 스왑을 반복하게 되는 불행한 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;94-메모리-관리를-위한-도구로서의-vm&quot;&gt;9.4 메모리 관리를 위한 도구로서의 VM&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;다수의 가상페이지들이 동일한 공유된 물리페이지에 매핑될 수 있다.&lt;/li&gt;
  &lt;li&gt;요구 페이징과 분리된 가상 주소공간의 조합은 메모리가 시스템에서 사용되고 관리되는 방식에 중요한 영향을 미친다.&lt;/li&gt;
  &lt;li&gt;특히 VM은 링킹과정과 로딩, 코드와 데이터의 공유, application으로의 메모리 할당을 단순화 해준다.
    &lt;ul&gt;
      &lt;li&gt;링킹을 단순화한다: 별도의 주소공간은 각 프로세스들이 각 메모리 이미지에 대해서 코드와 데이터가 실제로 물리 메모리 내 어디에 위치하는지에 상관 없이 동일한 기본 포맷을 사용하도록 해준다. 이러한 통일성은 링커의 설계와 구현을 매우 단순화해준다.&lt;/li&gt;
      &lt;li&gt;로딩을 단순화한다: 가상메모리는 실행파일과 공유 목적파일들을 메모리에 로드하기 쉽게 해준다.&lt;/li&gt;
      &lt;li&gt;공유를 단순화한다: 운영체제는 다수의 프로세스가 서로 다른 프로세스에 들어 있는 가상페이지들을 동일한 물리페이지들로 적절하게 매핑해서 한 개의 사본을 공유하도록 할 수 있다.&lt;/li&gt;
      &lt;li&gt;메모리 할당을 단순화한다: 운영체제는 적당한 수의 연속적인 가상메모리 페이지를 할당하고 이들을 물리 메모리 내에 위치한 k개의 임의의 물리페이지로 매핑한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;95-메모리-보호를-위한-도구로서의-vm&quot;&gt;9.5 메모리 보호를 위한 도구로서의 VM&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 시스템은 운영체제가 메모리 시스템에 접근하는 것을 제어할 수 있는 수단을 제공한다.&lt;/li&gt;
  &lt;li&gt;별도의 가상 주소공간을 제공하면 사적 메모리를 다른 프로세스로부터 분리하는 것이 쉬워진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림에서 SUP는 커널 모드(수퍼바이저)로 돌고 있는지를 나타내는 비트다.
    &lt;ul&gt;
      &lt;li&gt;만약 사용자모드에서 VP2에 접근하려 한다면 CPU는 일반 보호 오류를 발생해서 SIGSEGV 시그널을 위반한 프로세스로 보내 커널 내의 예외 핸들러로 제어를 이동시킨다.&lt;/li&gt;
      &lt;li&gt;위와 같은 예외를 “세그먼트 오류segmentation fault”라고 보고한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;96-주소의-번역&quot;&gt;9.6 주소의 번역&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;용어설명&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;VA: virtual address&lt;/li&gt;
    &lt;li&gt;PETA: page table entry address&lt;/li&gt;
    &lt;li&gt;PTE: page table entry&lt;/li&gt;
    &lt;li&gt;PA: physical address&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_8.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;페이지 적중이 일어났을 때
    &lt;ol&gt;
      &lt;li&gt;프로세서는 가상주소를 생성하고 이것을 MMU로 보낸다.&lt;/li&gt;
      &lt;li&gt;MMU는 PTE 주소를 생성하고 이것을 캐시/메인 메모리에 요청한다.&lt;/li&gt;
      &lt;li&gt;캐시/메인 메모리는 PTE를 MMU로 리턴한다.&lt;/li&gt;
      &lt;li&gt;MMU는 물리 주소를 구성하고 이것을 캐시/메인 메모리로 보낸다.&lt;/li&gt;
      &lt;li&gt;캐시/메인 메모리는 요청한 데이터 워드를 프로세서로 보낸다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_9.png&quot; width=&quot;75%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;페이지 오류를 처리할 때
    &lt;ol&gt;
      &lt;li&gt;페이지 적중과 동일&lt;/li&gt;
      &lt;li&gt;페이지 적중과 동일&lt;/li&gt;
      &lt;li&gt;페이지 적중과 동일&lt;/li&gt;
      &lt;li&gt;PTE의 유효비트는 0이므로 MMU는 예외를 발생시키고, CPU 내의 제어를 운영체제 커널의 페이지 오류 예외 핸들러로 이동시킨다.&lt;/li&gt;
      &lt;li&gt;오류 핸들러는 물리 메모리 내의 희생자 페이지를 결정하고, 만일 이 페이지가 수정되었다면 디스크로 페이지를 이동한다.&lt;/li&gt;
      &lt;li&gt;오류 핸들러는 새 페이지를 페이지 이동해서 들여오고, 메모리 내의 PTE를 갱신하다.&lt;/li&gt;
      &lt;li&gt;오류 핸들러는 처음의 프로세스로 돌아가고 오류 인스트럭션은 재시작된다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;961-캐시와-vm의-통합&quot;&gt;9.6.1 캐시와 VM의 통합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;대부분의 시스템은 SRAM 캐시에 물리 주소지정을 선택한다.&lt;/li&gt;
  &lt;li&gt;물리 주소를 사용하면 다중 프로세스들이 캐시에서 블록을 갖는 것과 마찬가지로 가상페이지로부터 블록을 공유하는 것이 단순해진다.&lt;/li&gt;
  &lt;li&gt;물리 주소를 사용하는 캐시가 가상메모리와 통합될 수 있는 이유는 &lt;strong&gt;주소 번역이 캐시 참조 이전에 일어나기 때문이다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;TLB를 사용하면 캐시 참조 이전에 주소 번역이 일어남&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;962-tlb를-사용한-주소-번역-속도의-개선&quot;&gt;9.6.2 TLB를 사용한 주소 번역 속도의 개선&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주소 번역의 비용을 줄이기 위해 MMU 내에 &lt;strong&gt;번역 참조 버퍼translation lookaside buffer(TLB)&lt;/strong&gt;라고 부르는 작은 캐시를 포함한다.&lt;/li&gt;
  &lt;li&gt;TLB는 작은 가상주소지정 캐시로, 각 라인은 하나의 PTE로 구성된 하나의 블록을 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_10.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TLB 적중이 발생할 때
    &lt;ol&gt;
      &lt;li&gt;CPU는 가상주소를 생성한다.&lt;/li&gt;
      &lt;li&gt;MMU는 적당한 PTE를 TLB로부터 선입한다.&lt;/li&gt;
      &lt;li&gt;MMU는 적당한 PTE를 TLB로부터 선입한다.&lt;/li&gt;
      &lt;li&gt;MMU는 가상주소를 물리 주소로 번역하고, 그것을 캐시/메인 메모리로 전송한다.&lt;/li&gt;
      &lt;li&gt;캐시/메인 메모리는 요청한 데이터 워드를 CPU로 리턴한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_11.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TLB 미스가 발생하면, MMU는 PTE를 L1캐시에서 선입해야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;963-다중-레벨-페이지-테이블&quot;&gt;9.6.3 다중 레벨 페이지 테이블&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;주소를 번역하기 위해서 한 개의 페이지 테이블을 사용하면 낭비가 매우 심하기 때문에 페이지 테이블의 계층구조를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_16.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 2단계 페이지 테이블 계층구조이다.&lt;/li&gt;
  &lt;li&gt;위와 같은 기법은 메모리 요구량을 두 가지 방법으로 줄여준다.
    &lt;ol&gt;
      &lt;li&gt;만일 1단계 PTE가 널이면, 해당 2단계 페이지 테이블이 존재할 필요가 없어진다. -&amp;gt; 절약&lt;/li&gt;
      &lt;li&gt;1단계 테이블만이 항상 메인 메모리에 있고 2단계 페이지 테이블은 필요로 할 때마다 페이지 인 또는 아웃이 되므로 메인 메모리로의 압박을 줄일 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/25/img_17.png&quot; width=&quot;60%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 K단계 페이지 테이블을 사용한 주소 번역이다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 25</summary></entry><entry><title type="html">[CS:APP] Chapter 07 링커</title><link href="http://localhost:4000/csapp/csapp_23/" rel="alternate" type="text/html" title="[CS:APP] Chapter 07 링커" /><published>2022-05-03T00:00:00+09:00</published><updated>2022-05-03T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_23</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_23/">&lt;h1 id=&quot;chapter-07-링커&quot;&gt;Chapter 07. 링커&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;링킹은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파이로 만드는 작업이다.
    &lt;ul&gt;
      &lt;li&gt;링킹은 컴파일 시에 수행할 수 있다.&lt;/li&gt;
      &lt;li&gt;로더에 의해 로드 타임에, 응용프로그램에 의해 실행 시에도 수행될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링커는 소프트웨어 개발 시에 중요한 역할: 독립적인 컴파일을 가능하게 하기 때문이다.&lt;/li&gt;
  &lt;li&gt;링커를 배우는 이유
    &lt;ul&gt;
      &lt;li&gt;큰 프로그램을 작성하는 데 도움이 된다.&lt;/li&gt;
      &lt;li&gt;위험한 프로그래밍 에러를 피할 수 있다.&lt;/li&gt;
      &lt;li&gt;어떻게 언어의 변수 영역 규칙이 구현되었는지 이해하는 데 도움이 된다.&lt;/li&gt;
      &lt;li&gt;다른 중요한 시스템 개념을 이해할 수 있게 된다.&lt;/li&gt;
      &lt;li&gt;공유 라이브러리에 대해 이해할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;71-컴파일러-드라이버&quot;&gt;7.1 컴파일러 드라이버&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;대부분의 컴파일 시스템은 사용자를 대신해서 언어 전처리기, 컴파일러, 어셈블러, 링커를 필요에 따라 호출하는 컴파일러 드라이버를 제공한다.&lt;/li&gt;
  &lt;li&gt;컴파일 순서
    &lt;ol&gt;
      &lt;li&gt;C 전처리기(cpp)로 main.c -&amp;gt; ASCII 중간 파일인 main.i로 번역&lt;/li&gt;
      &lt;li&gt;C 컴파일러(cc1)로 main.i -&amp;gt; ASCII 어셈블리 언어 파일인 main.s로 번역&lt;/li&gt;
      &lt;li&gt;어셈블러(as)로 main.s -&amp;gt; 재배치 가능한 바이너리 목적파일인 main.o로 번역&lt;/li&gt;
      &lt;li&gt;링커(ld)로 main.o &amp;amp; sum.o 두개를 연결 -&amp;gt; 실행 가능 목적파일 prog 생성&lt;/li&gt;
      &lt;li&gt;로더라고 부르는 운영체제 내의 함수를 호출 -&amp;gt; 로더는 실행파일 prog의 코드와 데이터를 메모리로 복사하고, 제어를 프로그램의 시작 부분으로 전환한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;72-정적연결&quot;&gt;7.2 정적연결&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정적 링커는 재배치 가능한 목적파일들과 명령줄 인자들을 받아들여 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 생성한다.&lt;/li&gt;
  &lt;li&gt;실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행한다.
    &lt;ol&gt;
      &lt;li&gt;심볼 해석 symbol resolutions: 각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결하는 것이다.&lt;/li&gt;
      &lt;li&gt;재배치 Relocation: 링커는 섹션들을 각 심볼 정의와 연결시켜 재배치한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;73-목적파일&quot;&gt;7.3 목적파일&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;세가지 목적파일이 있다.
    &lt;ul&gt;
      &lt;li&gt;재배치 가능 목적파일 Relocatable object file: 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함&lt;/li&gt;
      &lt;li&gt;실행 가능 목적파일 Executable object file: 메모리에 직접 복사될 수 있고 실행될 수 있음&lt;/li&gt;
      &lt;li&gt;공유 목적파일 Shared object file: 로드타임 또는 런타임 시에 동적으로 링크되고 로드될 수 있는 목적파일&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일러와 어셈블러는 재배치 가능 목적파일을 생성, 링커는 실행 가능한 목적파일을 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;74-재배치-가능-목적파일&quot;&gt;7.4 재배치 가능 목적파일&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_1.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 전형적인 ELF(Executable and Linkable Format) 재배치 가능 목적파일의 포맷이다.
    &lt;ul&gt;
      &lt;li&gt;.text: 컴파일된 프로그램의 머신 코드&lt;/li&gt;
      &lt;li&gt;.rodata: printf 문장의 포맷 스트링&lt;/li&gt;
      &lt;li&gt;.data: 초기화된 전역변수 및 정적변수&lt;/li&gt;
      &lt;li&gt;.bss: 초기화되지 않은 또는 0으로 초기화된 전역변수 및 정적변수&lt;/li&gt;
      &lt;li&gt;.symtab: 프로그램에서 정의되고 참조되는 전역변수들과 함수에 대한 정보를 가지고 있는 심볼 테이블&lt;/li&gt;
      &lt;li&gt;.rel.text: 다른 목적 파일들과 연결할 때 링커가 수정해야하는 .text 섹션 내 위치들의 리스트&lt;/li&gt;
      &lt;li&gt;.rel.data: 전역변수들에 대한 재배치 정보&lt;/li&gt;
      &lt;li&gt;.debug: 프로그램 내에서 정의된 지역변수들과 typedef&lt;/li&gt;
      &lt;li&gt;.line: 최초 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑&lt;/li&gt;
      &lt;li&gt;.strtab: 섹션 이름들을 위한 스트링 테이블&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;75-심볼과-심볼-테이블&quot;&gt;7.5 심볼과 심볼 테이블&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;재배치 가능 목적 모듈 m은 m에 의해서 정의되고 참조되는 심볼들에 대한 정보를 포함하는 심볼 테이블을 가지고 있다.
    &lt;ul&gt;
      &lt;li&gt;m에 의해 정의되고 다른 모든 모듈들에 의해서 참조될 수 있는 전역 심볼
        &lt;ul&gt;
          &lt;li&gt;전역&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;m에 의해 참조되지만 다른 모듈에 의해 정의된 전역 심볼
        &lt;ul&gt;
          &lt;li&gt;external&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;m에 의해서 배타적으로 참조되고 정의된 지역 심볼
        &lt;ul&gt;
          &lt;li&gt;static&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;지역 변수는 런타임에 스택에 의해서 관리되며 링커에는 관심거리가 아니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;.symtab 섹션의 ELF 심볼 테이블은 엔트리들의 배열을 포함하고 있다.
&lt;img src=&quot;../../assets/img/csapp/23/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테이블 엔트리가 없는 의사 섹션pseudo section 이 존재한다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;ABS: 재배치해서는 안 되는 심볼&lt;/li&gt;
      &lt;li&gt;UNDEF: 정의되지 않은 심볼, 해당 모듈에서는 참조만 되고 다른 곳에서 정의된 심볼들을 위함&lt;/li&gt;
      &lt;li&gt;COMMON: 아직 할당되거나 초기화되지 않은 데이터 객체를 위함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;COMMON: 초기화하지 않은 전역변수들, .bss: 초기화하지 않은 정적변수들과 0으로 초기화된 전역변수나 정적변수들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;76-심볼-해석&quot;&gt;7.6 심볼 해석&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;링커는 자신의 입력 재배치 가능 목적파일들의 심볼 테이블로부터 정확히 한 개의 심볼 정의에 각 참조를 연결시켜서 심볼 참조를 해석한다.&lt;/li&gt;
  &lt;li&gt;컴파일러가 현재 모듈에서 정의되지 않은 심볼을 만나면, 다른 모듈에서 정의되어 있다고 가정하고 링커 심볼 테이블 엔트리를 생성하며, 링커가 이것을 처리하도록 남겨둔다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;761-링커가-중복으로-정의된-전역-심볼을-해결하는-방법&quot;&gt;7.6.1 링커가 중복으로 정의된 전역 심볼을 해결하는 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링커의 입력은 여러 개의 재배치 가능한 오브젝트 모듈들이다.
    &lt;ul&gt;
      &lt;li&gt;일부는 지역적이다(정의된 모듈 내에서만 볼 수 있는).&lt;/li&gt;
      &lt;li&gt;일부는 전역적이다(다른 모듈에서도 볼 수 있는).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일러는 각 전역 심볼을 어셈블러로 강하게 또는 약하게 보내 심볼 테이블에 묵시적으로 인코딩하게 한다.
    &lt;ul&gt;
      &lt;li&gt;함수들과 초기화된 전역변수들은 강한 심볼&lt;/li&gt;
      &lt;li&gt;비초기화된 전역변수들은 약한 심볼이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링커는 중복된 심볼 이름을 처리하기 위해서 다음과 같은 규칙을 사용한다.
    &lt;ol&gt;
      &lt;li&gt;동일한 이름을 갖는 복수의 강한 심불은 허용 X&lt;/li&gt;
      &lt;li&gt;동일한 이름의 강한 심볼과 다수의 약한 심볼들이 있으면 강한 심볼 선택&lt;/li&gt;
      &lt;li&gt;동일한 이름의 여러 개의 약한 심볼이 있으면 어떤 약한 심볼을 선택해도 관계 X&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;762-정적-라이브러리와-링크하기&quot;&gt;7.6.2 정적 라이브러리와 링크하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;모든 컴파일 시스템은 관련된 객체 모듈들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적 라이브러리&lt;/code&gt;라고 부르는 한 개의 파일로 패키징하는 매커니즘을 제공한다.
    &lt;ul&gt;
      &lt;li&gt;이 라이브러리는 다음에 링커의 입력으로 제공될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일러 개발자들이 라이브러리의 다양한 함수들을 정적 라이브러리의 혜택 없이 사용자들에게 재공하려면 컴파일러가 직접 함수의 코드를 생성하거나 한 개의 재배치 가능 목적 모듈에
저장하거나 해야한다. 하지만 이런 방법들은 상당한 복잡성을 더하거나 디스크 공간을 극도로 낭비한다. 위와 같은 접근 방법의 단점들을 해겨하기 위해 정적 라이브러리 개념이 개발되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_3.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위 그림은 정적 라이브러리 연결 시 링커의 동작을 요약한 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;763-링커가-참조를-해석하기-위해-정적-라이브러리를-사용하는-방법&quot;&gt;7.6.3 링커가 참조를 해석하기 위해 정적 라이브러리를 사용하는 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;링커는 실행파일을 구성하기 위해 합쳐질 재배치 가능 목적파일들의 집합 E, 미해석 집합 U, 이전 입력파일에서 정의된 심볼 집합 D를 유지한다.
    &lt;ol&gt;
      &lt;li&gt;입력파일 f에 대해서 링커는 f가 목적파일 또는 아카이브인지 결정한다.&lt;/li&gt;
      &lt;li&gt;f가 목적파일이면 f를 E에 추가하고 U와 D를 갱신한다.&lt;/li&gt;
      &lt;li&gt;f가 아카이브라면, 링커는 U 안의 미해석 심볼들을 아카이브의 멤버들에 의해 정의된 심볼들과 매칭하려고 시도한다.&lt;/li&gt;
      &lt;li&gt;심볼을 정의한다면 m은 E에 추가되고 U와 D를 갱신한다.&lt;/li&gt;
      &lt;li&gt;위 과정을 U와 D가 더 이상 바뀌지 않는 일정 지점까지 반복 실행한다.&lt;/li&gt;
      &lt;li&gt;스캔을 끝마칠 때 U가 비어있지 않다면 에러 출력, 그렇지 않다면 E에 있는 목적파일들을 합치고 재배치해서 출력 실행파일을 만든다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;위의 알고리즘은 명령줄의 라이브러리와 목적파일의 순서가 중요한 이유가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;77-재배치&quot;&gt;7.7 재배치&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;링커가 심볼 해석 단계를 완료하면, 코드 내 각 심볼 참조는 정확히 한 개의 심볼 정의에 연결된다.(입력 모듈 중 하나의 심볼 테이블 엔트리로 연결됨)&lt;/li&gt;
  &lt;li&gt;이후 재배치를 하게 된다. 재배치는 두 단계로 구성된다.
    &lt;ol&gt;
      &lt;li&gt;섹션과 심볼 정의를 재배치한다.&lt;/li&gt;
      &lt;li&gt;섹션 내 심볼 참조를 재배치한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;771-재배치-엔트리&quot;&gt;7.7.1 재배치 엔트리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어셈블러가 목적 모듈을 생성할 때, 어셈블러는 코드와 데이터가 궁극적으로 메모리 어디에 저장될지 알지 못한다.
    &lt;ul&gt;
      &lt;li&gt;어셈블러가 위치를 알지 못하는 객체로의 참조를 만나면, 링커에게 이 참조를 어떻게 수정하는지 알려주는 재배치 엔트리를 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;재배치 타입
    &lt;ul&gt;
      &lt;li&gt;R_X86_64_PC32: 32비트 PC-상대주소를 사용하는 참조를 재배치한다.&lt;/li&gt;
      &lt;li&gt;R_X86_64_32: 32비트 절대주소를 사용하는 참조를 재배치한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;772-심볼-참조의-재배치&quot;&gt;7.7.2 심볼 참조의 재배치&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 링커의 재배치 알고리즘을 위한 의사코드이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;78-실행-가능한-목적파일&quot;&gt;7.8 실행 가능한 목적파일&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_6.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행 가능 목적파일의 포맷은 재배치 가능한 목적파일의 포맷과 유사하다.
    &lt;ul&gt;
      &lt;li&gt;.text, .rodata, .data 섹션들이 각자의 최종 런타임 메모리 주소로 재배치되었다.&lt;/li&gt;
      &lt;li&gt;_init는 프로그램의 초기화 코드에서 호출한다.&lt;/li&gt;
      &lt;li&gt;실행파일이 완전히 링크(재배치) 되었기 때문에, .rel 섹션을 필요로 하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ELF 실행파일들은 연속적인 메모리 세그멘트에 매핑된 연속적인 실행 가능 파일들의 덩어리로 메모리에 로드하기 쉽도록 설계되었다.
    &lt;ul&gt;
      &lt;li&gt;이 매핑은 프로그램 헤더 테이블에 설명되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 세그먼트 s에 대해, 링커는 다음과 같이 시작주소를 선택해야 한다.
    &lt;ul&gt;
      &lt;li&gt;vaddr mod align = off mod align&lt;/li&gt;
      &lt;li&gt;align은 프로그램 헤더에 명시된 정렬(2^21 = 0x2000000)이다.&lt;/li&gt;
      &lt;li&gt;이러한 정렬 요구사항은 프로그램이 실행될 때 목적파일의 세그먼트들이 메모리로 효과적으로 전송될 수 있도록 하는 최적화의 결과다.
        &lt;ul&gt;
          &lt;li&gt;가상메모리가 크기가 큰 연속된 2의 제곱 크기의 바이트 묶음으로 구성되어 있는 방식이기 때문이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;79-실행-가능-목적파일의-로딩&quot;&gt;7.9 실행 가능 목적파일의 로딩&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;실행 가능 목적파일 prog를 실행한다.&lt;/li&gt;
  &lt;li&gt;쉘은 로더loader 라고 알려진 메모리 상주 운영체제 코드를 호출해서 prog를 실행한다.&lt;/li&gt;
  &lt;li&gt;로더는 디스크로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사한다.&lt;/li&gt;
  &lt;li&gt;해당 프로그램의 첫 번째 인스트럭션, 즉 엔트리 포인트로 점프해서 프로그램을 실행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_7.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 실행 중인 리눅스 프로그램은 위의 그림과 유사한 런타임 메모리 이미지를 가진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;710-공유-라이브러리로-동적-링크하기&quot;&gt;7.10 공유 라이브러리로 동적 링크하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정적 라이브러리들은 다른 모든 소프트웨어처럼 관리해야 하고 주기적으로 갱신해야한다.&lt;/li&gt;
  &lt;li&gt;공유 라이브러리들은 정적 라이브러리의 단점들을 극복한다.
    &lt;ul&gt;
      &lt;li&gt;공유 라이브러리는 런타임이나 로드타임에 임의의 메모리 주소에서 로드되고, 메모리에서 프로그램으로 연결될 수 있는 목적 모듈이다.&lt;/li&gt;
      &lt;li&gt;해당 과정을 동적 링킹이라고 한다.&lt;/li&gt;
      &lt;li&gt;리눅스 시스템에서 .so 확장자, 윈도우 시스템에서 DLL(dynamic link libraries)이라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 라이브러리들은 두 가지 다른 방법으로 “공유”된다.
    &lt;ol&gt;
      &lt;li&gt;어떤 주어진 파일 시스템에서, 특정 라이브러리에 대해 정확히 한 개의 .so 파일만이 존재한다.
        &lt;ul&gt;
          &lt;li&gt;.so 파일 내의 코드와 데이터는 이 라이브러리를 참조하는 모든 실행 가능한 목적파일들에 의해 공유된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리에 있는 공유 라이브러리의 .text 섹션은 서로 다른 실행중의 프로세스들에 의해 공유될 수 있다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/23/img_8.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 공유 라이브러리로 동적 링크 과정을 요약한 것이다.&lt;/li&gt;
  &lt;li&gt;기본 아이디어는 링킹의 일부는 실행 가능 파일이 생성될 때 정적으로 수행하고, 프로그램이 로드될 때 링킹 작업을 동적으로 완료하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;711-applications-으로부터-공유-라이브러리를-로드하고-링크하기&quot;&gt;7.11 Applications 으로부터 공유 라이브러리를 로드하고 링크하기&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;응용프로그램이 돌고 있는 동안에 동적 링커에게 응용프로그램을 컴파일 시에 라이브러리와 링크할 필요 없이 임의의 공유 라이브러리를 로드하고 링크할 것을 요청할 수도 있다.&lt;/li&gt;
  &lt;li&gt;기본 아이디어는 공유 라이브러리에서 동적 콘텐츠를 생성하는 각 함수들을 패키지 하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;서버는 동적으로 적당한 함수를 로드하고 링크한 뒤에 직접 호출한다.&lt;/li&gt;
      &lt;li&gt;함수는 서버의 주소공간에 캐시된 상태로 남으며, 후속 요청들은 간단한 함수 호출하는 비용만으로 처리될 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;712-위치-독립성-코드pic&quot;&gt;7.12 위치-독립성 코드(PIC)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;공유 라이브러리를 사용하는 주목적은 다수의 실행되고 있는 프로세스들이 메모리 내에서 동일한 라이브러리 코드를 공유하도록 하는 것이며, 귀중한 메모리 자원을 절약하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;한 가지 접근 방법은 공유 라이브러리를 사전에 정해진 주소공간 블록에 할당 하는 것이다.
        &lt;ul&gt;
          &lt;li&gt;단점 : 사용하지 않을 때도 할당, 메모리 블록들이 중첩되지 않도록 보장해줘야 함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위의 문제점을 피하기 위해 공유 모듈들의 코드 일부분을 컴파일해서 링커에 의해 수정되지 않고도 이들이 메모리 어디든지 로드될 수 있도록 한다.
    &lt;ul&gt;
      &lt;li&gt;어떠한 재배치 작업 없이 로드될 수 있는 코드는 위치-독립성코드라고 한다.(PIC)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;PIC와 GOT, PLT는 아직 이해를 하지 못해 좀 더 찾아보고 공부해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;713-라이브러리-삽입&quot;&gt;7.13 라이브러리 삽입&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일 삽입&lt;/li&gt;
  &lt;li&gt;링크 삽입&lt;/li&gt;
  &lt;li&gt;런타임 삽입&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;714-요약&quot;&gt;7.14 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;링킹은 컴파일 시에 정적 링커에 의해 수행될 수 있으며, 로드타임과 런타임에는 동적 링커에 의해 수행된다.&lt;/li&gt;
  &lt;li&gt;목적 파일들은 세 가지 형태로 나타난다.
    &lt;ul&gt;
      &lt;li&gt;재배치 가능: 정적 링커에 의해 실행 가능 목적파일로 연결&lt;/li&gt;
      &lt;li&gt;실행 가능: 메모리에 로드되고 실행&lt;/li&gt;
      &lt;li&gt;공유: 공유 라이브러리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링커의 두 가지 주요 임무
    &lt;ul&gt;
      &lt;li&gt;전역 심볼들이 유일한 정의에 연결되는 경우 심볼 해석&lt;/li&gt;
      &lt;li&gt;재배치 작업&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로더는 실행파일의 내용을 메모리로 매핑하고 프로그램을 실행한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 23</summary></entry><entry><title type="html">[CS:APP] Chapter 08 예외적인 제어흐름</title><link href="http://localhost:4000/csapp/csapp_24/" rel="alternate" type="text/html" title="[CS:APP] Chapter 08 예외적인 제어흐름" /><published>2022-05-03T00:00:00+09:00</published><updated>2022-05-03T00:00:00+09:00</updated><id>http://localhost:4000/csapp/csapp_24</id><content type="html" xml:base="http://localhost:4000/csapp/csapp_24/">&lt;h1 id=&quot;chapter-08-예외적인-제어흐름&quot;&gt;Chapter 08. 예외적인 제어흐름&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서에서 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터는 연속된 값들을 가정한다.
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 I에 대응되는 주소가 ak -&amp;gt; ak+1 로의 전환은 제어이동이라고 부른다.&lt;/li&gt;
      &lt;li&gt;이러한 제어이동의 배열은 &lt;strong&gt;제어흐름 또는 프로세서의 제어흐름&lt;/strong&gt;이라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램의 실행과는 반드시 관련되어 있지 않은 시스템 상태의 변화에도 반응할 수 있어야 한다.
    &lt;ul&gt;
      &lt;li&gt;현대의 시스템들은 갑작스런 변화를 만드는 방법으로 이러한 상황에 반응한다.&lt;/li&gt;
      &lt;li&gt;일반적으로 이와 같은 급격한 변화를 &lt;strong&gt;예외적인 제어흐름exceptional control flow(ECF)&lt;/strong&gt;라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ECF의 중요성
    &lt;ul&gt;
      &lt;li&gt;ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.&lt;/li&gt;
      &lt;li&gt;ECF를 이해하면 어떻게 application들이 운영체제와 상호작용하는지를 이해할 수 있다.&lt;/li&gt;
      &lt;li&gt;ECF는 컴퓨터 시스템에서 동시성을 구현하는 기본 메커니즘이다.&lt;/li&gt;
      &lt;li&gt;ECF를 이해하면소프트웨어적인 예외상황이 어떻게 동작하는지 이해할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;7장까지는 시스템에 대한 application이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다. 98장은 application이 운영체제와 어떻게
상호작용하는지 배우게 되는 측면에서 전환점이라고 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터 수준에 존재하는 ECF의 다양한 형태
    &lt;ol&gt;
      &lt;li&gt;하드웨어와 운영체제의 교차점에 놓인 예외&lt;/li&gt;
      &lt;li&gt;application에게 운영체제 내부로 엔트리 포인트를 제공하는 예외인 시스템콜&lt;/li&gt;
      &lt;li&gt;application과 운영체제의 교차점에 위치한 프로세스와 시그널&lt;/li&gt;
      &lt;li&gt;비지역성 점프 - ECF의 응용수준&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;81-예외상황&quot;&gt;8.1 예외상황&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;예외상황은 부분적으로는 하드웨어와 운영체제에 의해서 구현된 예외적인 제어흐름의 한가지 형태다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 예외상황의 기본 아이디어다.&lt;/li&gt;
  &lt;li&gt;프로세서가 이벤트(상태 변화)가 발생했다는 것을 감지하면, 예외 테이블이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 간접 프로시저 콜을 하게 된다.&lt;/li&gt;
  &lt;li&gt;예외처리 핸들러가 처리를 끝마치면, 다음 세 가지 중의 한 가지 일을 발생한다.
    &lt;ol&gt;
      &lt;li&gt;핸들러는 제어를 현재 인스트럭션으로 돌려준다.&lt;/li&gt;
      &lt;li&gt;핸들러는 제어를 다음 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션으로 돌려준다.&lt;/li&gt;
      &lt;li&gt;핸들러는 중단된 프로그램을 종료한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;811-예외처리&quot;&gt;8.1.1 예외처리&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;한 시스템 내에서 가능한 예외상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다.&lt;/li&gt;
  &lt;li&gt;시스템 부팅 시, 운영체제는 예외 테이블이라고 하는 점프 테이블을 할당하고 초기화해서 엔트리 k가 예외상황 k에 대한 핸들러의 주소를 갖는다.&lt;/li&gt;
  &lt;li&gt;런타임에 프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다.&lt;/li&gt;
  &lt;li&gt;k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다.&lt;/li&gt;
  &lt;li&gt;예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작 주소는 ‘예외 테이블 베이스 레지스터’라는 특별한 CPU 레지스터에 저장되어 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_1.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 예외테이블이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예외상황과 프로시저 콜의 차이점&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;프로시저 콜: 스택에 리턴주소 푸시, 예외상황: 현재 또는 다음 인스트럭션&lt;/li&gt;
      &lt;li&gt;핸들러가 리턴할 때 중단된 프로그램을 다시 시작하기 위해 스택 상에 추가적인 프로세서 상태를 푸시한다.&lt;/li&gt;
      &lt;li&gt;모든 아이템들은 사용자 스택 위가 아니라 커널 스택 상에 푸시된다.&lt;/li&gt;
      &lt;li&gt;예외 핸들러는 ‘커널 모드’에서 돌아간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;812-예외의-종류&quot;&gt;8.1.2 예외의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;예외상황은 네 가지 종류를 구분할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;인터럽트&lt;/li&gt;
      &lt;li&gt;트랩&lt;/li&gt;
      &lt;li&gt;오류fault&lt;/li&gt;
      &lt;li&gt;중단abort&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트&quot;&gt;인터럽트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 비동기적으로 발생한다.(특정 인스트럭션을 싫애해서 발생한 것이 아니라는 의미)&lt;/li&gt;
  &lt;li&gt;핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터럽트를 제외한 나머지 예외의 종류들은 동기적으로 일어난다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;트랩과-시스템-콜&quot;&gt;트랩과 시스템 콜&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;의도적인 예외상황으로, 어떤 인스트럭션을 실행한 결과로 발생한다.&lt;/li&gt;
  &lt;li&gt;트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다.&lt;/li&gt;
  &lt;li&gt;트랩의 가장 중요한 사용은 &lt;strong&gt;시스템콜&lt;/strong&gt;이라고 알려진 사용자 프로그램과 커널 사이의 프로시저와 유사한 인터페이스를 제공하는 것이다.&lt;/li&gt;
  &lt;li&gt;시스템 콜은 ‘커널 모드’에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;오류fault는-error와-다르다&quot;&gt;오류(fault는 error와 다르다.)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;오류는 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생한다.&lt;/li&gt;
  &lt;li&gt;핸들러가 에러 조건을 정정한다면, 제어를 오류를 발생시킨 인스트럭션으로 돌려주어 거기서부터 재실행한다.&lt;/li&gt;
  &lt;li&gt;정정하지 못한다면, 커널 내부의 abort 루틴으로 리턴해서 프로그램을 종료한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;중단-abort&quot;&gt;중단 abort&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;중단 핸들러는 절대로 응용프로그램으로 제어를 리턴하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;813-리눅스x86-64-시스템에서의-예외상황&quot;&gt;8.1.3 리눅스/x86-64 시스템에서의 예외상황&lt;/h2&gt;

&lt;h3 id=&quot;오류와-중단&quot;&gt;오류와 중단&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;나누기 에러: 0으로 나누려할 때&lt;/li&gt;
  &lt;li&gt;일반 보호 오류: 프로그램이 가상메모리의 정의되지 않은 영역을 참조하거나 read-only를 쓰려고 하기 때문에 발생&lt;/li&gt;
  &lt;li&gt;페이지 오류: 가상메모리 페이지 오류&lt;/li&gt;
  &lt;li&gt;머신 체크: 오류 인스트럭션을 실행하는 동안에 검출된 치명적인 하드웨 에러의 결과로 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-콜&quot;&gt;시스템 콜&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;리눅스는 파일을 읽거나 쓸 때, 또는 새로운 프로세스를 만들 때 응용프로그램이 사용할 수 있는 수백 개의 시스템 콜을 제공한다.&lt;/li&gt;
  &lt;li&gt;x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해서 제공된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_2.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 리눅스 x86-64 시스템의 주요 시스템 콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;82-프로세스&quot;&gt;8.2 프로세스&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;예외상황은 &lt;strong&gt;프로세스&lt;/strong&gt; 개념을 운영체제 커널이 제공할 수 있게 하는 기본 구성 블록이다.&lt;/li&gt;
  &lt;li&gt;프로세스의 고전적인 정의는 &lt;strong&gt;실행 프로그램의 인스턴스이다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;시스템 내의 각 프로그램은 어떤 프로세스의 &lt;strong&gt;문맥context&lt;/strong&gt;에서 돌아간다.&lt;/li&gt;
  &lt;li&gt;사용자가 실행 목적파일의 이름을 쉘에 입력해서 프로그램을 돌릴 때마다 쉘은 새로운 프로세스를 생성하고, 실행 목적파일을 이 새로운 프로세스의 문맥에서 실행한다.&lt;/li&gt;
  &lt;li&gt;프로세스가 application에 제공하는 주요 추상화
    &lt;ul&gt;
      &lt;li&gt;프로세서를 혼자서 사용한다는 착각을 제공하는 독립적 논리 제어 흐름&lt;/li&gt;
      &lt;li&gt;혼자서 메모리 시스템을 가진다는 착각을 제공하는 사적 주소공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;821-논리적인-제어흐름&quot;&gt;8.2.1 논리적인 제어흐름&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;논리흐름
    &lt;ul&gt;
      &lt;li&gt;프로그램과 동적으로 런타임에 링크된 공유 객체 내의 인스트럭션들에게 일련의 프로그램 카운터 PC 값들이 대응된다는 것을 관찰할 수 있다.&lt;/li&gt;
      &lt;li&gt;이러한 PC 값들의 배열을 논리적 제어흐름 또는 논리흐름이라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_3.png&quot; width=&quot;50%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 논리적 제어흐름이다.
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세서를 사용해서 여러 프로세스들이 교대로 돌아간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;822-동시성-흐름&quot;&gt;8.2.2 동시성 흐름&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;논리흐름은 컴퓨터 시스템 내에서 여러 가지 다른 형태를 갖는다.
    &lt;ul&gt;
      &lt;li&gt;예외 핸들러, 프로세스, 시그널 핸들러, 쓰레드, 자바 프로세스는 모두 논리흐름의 예다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자신의 실행시간이 다른 흐름과 겹치는 논리흐름을 &lt;strong&gt;동시성 흐름&lt;/strong&gt;이라고 부른다.&lt;/li&gt;
  &lt;li&gt;동시성: 공동으로 실행되는 흐름의 일반적인 현상&lt;/li&gt;
  &lt;li&gt;멀티태스킹: 프로세스가 다른 프로세스들과 교대로 실행된다는 개념&lt;/li&gt;
  &lt;li&gt;타임 슬라이스: 프로세스가 자신의 흐름 일부를 실행하는 매 시간 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 개의 흐름이 서로 다른 프로세서 코어나 컴퓨터에서 동시에 돌아간다면, 이것은 &lt;strong&gt;병렬 흐름&lt;/strong&gt; 이라고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;823-사적-주소공간&quot;&gt;8.2.3 사적 주소공간&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 각 프로그램에 자신이 시스템의 주소공간을 혼자서 사용한다는 착각을 불러일으킨다.&lt;/li&gt;
  &lt;li&gt;프로세스는 각 프로그램에 자신만의 &lt;strong&gt;사적 주소공간&lt;/strong&gt;을 제공한다.
    &lt;ul&gt;
      &lt;li&gt;이 공간의 특정 주소에 연결된 메모리의 한 개의 바이트가 일반적으로 다른 프로세스에 의해서 읽히거나 쓰일 수 없다는 의미로 이 공간은 사적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_4.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 프로세스 주소공간이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;824-사용자-및-커널-모드&quot;&gt;8.2.4 사용자 및 커널 모드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제가 완벽한 프로세스 추상화를 제공하기 위해서 프로세서는 응용프로그램이 접근할 수 있는 주소공간 뿐만 아니라 응용프로그램이 실행할 수 있는 인스트럭션들을 제한하는 메커니즘을 제공해야한다.&lt;/li&gt;
  &lt;li&gt;커널 모드에서 돌고 있는 프로세스는 인스트럭션 집합의 어떤 인스트럭션도 실행할 수 있으며, 시스템 내의 어떤 메모리 위치도 접근할 수 있다.&lt;/li&gt;
  &lt;li&gt;예외가 발생해서 제어가 예외 핸들러로 넘어가면, 프로세서는 사용자 모드에서 커널 모드로 변경한다.
    &lt;ul&gt;
      &lt;li&gt;핸들러는 커널 모드에서 돌아간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;825-문맥-전환&quot;&gt;8.2.5 문맥 전환&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제 커널은 &lt;strong&gt;문맥 전환context switch&lt;/strong&gt; 이라고 알려진 예외적인 제어흐름의 상위수준 형태를 사용해서 멀티태스킹을 구현하고 있다.&lt;/li&gt;
  &lt;li&gt;커널은 각 프로세스마다 컨텍스트를 유지한다. 컨텍스트는 커널이 선점된 프로세스를 다시 시작하기 위해서 필요로 하는 상태다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_5.png&quot; width=&quot;70%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위의 그림은 프로세스 문맥 전환의 분석이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;스케줄링
    &lt;ul&gt;
      &lt;li&gt;커널은 프로세서가 실행되는 동안의 어떤 시점에 현재 프로세스를 선점하고 이전에 선점된 프로세스를 다시 시작할 것을 결정한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스케줄러&lt;/strong&gt;라고 불리는 커널 내부의 코드에 의해 처리된다.&lt;/li&gt;
      &lt;li&gt;커널이 실행할 새 프로세스를 선택할 때 커널이 그 프로세스를 &lt;strong&gt;스케줄&lt;/strong&gt; 했다고 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문맥 전환
    &lt;ul&gt;
      &lt;li&gt;커널이 실행할 새 프로세스를 스케줄한 후에 현재 프로세스를 선점하는 것을 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문맥 전환의 수행 절차
    &lt;ol&gt;
      &lt;li&gt;현재 프로세스의 컨텍스트를 저장한다.&lt;/li&gt;
      &lt;li&gt;이전에 선점된(일시적으로 정지된) 프로세스의 저장된 컨텍스트를 복원한다.&lt;/li&gt;
      &lt;li&gt;제어를 이 새롭게 복원된 프로세스로 전달한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;83-시스템-콜의-에러-처리&quot;&gt;8.3 시스템 콜의 에러 처리&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Unix의 시스템 수준 함수가 에러를 만날 때 이들은 대개 -1을 리턴하고, 전역 정수 변수인 errno를 세팅해서 무엇이 잘못되었는지를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;84-프로세스의-제어&quot;&gt;8.4 프로세스의 제어&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Unix는 C 프로그램으로부터 프로세스를 제어하기 위한 많은 시스템 콜을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;841-프로세스-id-가져오기&quot;&gt;8.4.1 프로세스 ID 가져오기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;각각의 프로세스는 고유의 양수 프로세스 ID(PID)를 가진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;getpid 함수는 호출하는 함수의 PID를 리턴한다.&lt;/li&gt;
  &lt;li&gt;getppid 함수는 자신의 부모의 PID를 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;842-프로세스의-생성과-종료&quot;&gt;8.4.2 프로세스의 생성과 종료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머의 관점에서 프로세느는 세 가지 상태가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;실행중 running: 프로세스는 CPU에서 실행하고 있거나 실행을 기다리고 있다. 궁극적으로 커널에 의해서 스케줄될 것이다.&lt;/li&gt;
      &lt;li&gt;정지 stopped: 프로세스의 실행은 정지한 상태이고 스케줄되지 않는다.&lt;/li&gt;
      &lt;li&gt;종료 terminated: 프로세스는 영구적으로 정지된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;exit 함수는 종료 상태 status로 프로세스를 종료한다.&lt;/li&gt;
  &lt;li&gt;fork 함수는 부모 프로세스가 자식 프로세스를 생성한다.
    &lt;ul&gt;
      &lt;li&gt;한 번 호출하고 두 번 리턴한다.(한 번은 부모가, 다른 한 번은 자식이)&lt;/li&gt;
      &lt;li&gt;동시 실행한다.(부모와 자식은 동시에 돌아가는 별도의 프로세스)&lt;/li&gt;
      &lt;li&gt;중복되었지만 별도의 주소공간이다.&lt;/li&gt;
      &lt;li&gt;파일을 공유한다.(자식이 부모가 오픈한 모든 파일들을 상속받음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;843-자식-프로세스의-청소&quot;&gt;8.4.3 자식 프로세스의 청소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스가 어떤 이유로 종료할 때, 커널은 시스템에서 즉시 제거하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;부모가 청소할 때까지 종료된 상태로 남아 있는다.&lt;/li&gt;
      &lt;li&gt;부모가 종료된 자식을 청소할 때 커널은 자식의 exit 상태를 부모에게 전달 후 종료된 프로세스를 없앤다. 이 때 프로세스가 사라진다.&lt;/li&gt;
      &lt;li&gt;종료되었지만 아직 청소되지 않은 프로세스를 좀비라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;waitpid 함수는 자신의 자식들이 종료되거나 정지되기를 기다린다.&lt;/li&gt;
  &lt;li&gt;wait 함수는 waitpid의 단순화된 버전이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;844-프로세스-재우기&quot;&gt;8.4.4 프로세스 재우기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;sleep 함수는 일정 기간 동안 프로세스를 정지시킨다.&lt;/li&gt;
  &lt;li&gt;pause 함수는 호출하는 함수를 시그널이 프로세스에 의해 수신될 때까지 잠을 재운다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;845-프로그램의-로딩과-실행&quot;&gt;8.4.5 프로그램의 로딩과 실행&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;execve 함수는 현재 프로그램의 컨텍스트 내에서 새로운 프로그램을 로드하고 실행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;85-시그널&quot;&gt;8.5 시그널&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;리눅스 시그널이라고 알려진 상위수준의 소프트웨어 형태의 예외적 제어흐름을 배운다.
    &lt;ul&gt;
      &lt;li&gt;해당 시그널은 프로세스와 커널이 다른 프로세스를 중단하도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시그널
    &lt;ul&gt;
      &lt;li&gt;작은 메시지 형태로, 프로세스에게 시스템 내에 어떤 종류의 이벤트가 일어났다는 것을 알려준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/img/csapp/24/img_6.png&quot; width=&quot;90%&quot; height=&quot;100%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;위의 그림은 리눅스 시스템에서 지원되는 30개의 서로 다른 종류의 시그널을 보여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;851-시그널-용어&quot;&gt;8.5.1 시그널 용어&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;시그널을 목적지 프로세스로 전달하는 것은 두 단계로 이루어진다:
    &lt;ol&gt;
      &lt;li&gt;시그널 보내기: 커널은 목적지 프로세스의 컨텍스트 내에 있는 일부 상태를 갱신해서 시그널을 목적지 프로세스로 보낸다(배달한다).&lt;/li&gt;
      &lt;li&gt;시그널 받기: 목적지 프로세스는 배달된 신호에 대해서 커널이 어떤 방식으로 반응해야 할 때 목적지 프로세스는 시그널을 받는다.ㅜ&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;펜딩pending 시그널: 보내졌지만 아직 받지 않은 시그널&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;852-시그널-보내기&quot;&gt;8.5.2 시그널 보내기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Unix 시스템은 시그널을 프로세스로 보내는 여러가지 메커니즘을 제공한다.
    &lt;ul&gt;
      &lt;li&gt;모든 메커니즘은 프로세스 그룹 개념을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로세스-그룹&quot;&gt;프로세스 그룹&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모든 프로세스는 정확히 한 개의 프로세스 그룹에 속한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;getpgrp 함수는 현재 프로세스의 프로세스 그룹 ID를 리턴한다.&lt;/li&gt;
  &lt;li&gt;setpgid 함수는 프로세스 pid의 프로세스 그룹을 pgid로 변경한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시그널을-binkill-프로그램을-사용해서-보내기&quot;&gt;시그널을 /bin/kill 프로그램을 사용해서 보내기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;/bin/kill -9 15213: 시그널 9번(SIGKILL)을 프로세스 15213에 보낸다.&lt;/li&gt;
  &lt;li&gt;/bin/kill -9 -15213: SIGKILL 시그널이 프로세스 그룹 15213 내의 모든 프로세스에게 보내지도록 한다. (음수 PID는 전체에게 보냄)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;키보드에서-시그널-보내기&quot;&gt;키보드에서 시그널 보내기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Ctrl+C를 입력하면 커널은 SIGINT 시그널을 포그라운드 프로세스 그룹에 속한 모든 프로세스에게 보낸다.&lt;/li&gt;
  &lt;li&gt;Ctrl+Z를 입력하면 마찬가지로 모든 프로세스에 SIGSTP 시그널을 보낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kill-함수로-시그널-보내기&quot;&gt;kill 함수로 시그널 보내기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 kill 함수를 호출해서 시그널을 다른 프로세스로 보낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;alarm-함수로-시그널-보내기&quot;&gt;alarm 함수로 시그널 보내기&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 SIGALRM 시그널을 alarm 함수를 호출해서 자기 자신에게 보낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;853-시그널의-수신&quot;&gt;8.5.3 시그널의 수신&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;커널이 프로세스 p를 커널 모드에서 사용자모드로 전환할 때, 커널은 프로세스 p에 대한 블록되지 않은 펜딩 시그널의 집합을 체크한다.
    &lt;ul&gt;
      &lt;li&gt;만일 이 집합이 비어 있다면, 커널은 제어를 p의 논리 제어흐름 내의 다음 인스트럭션으로 전달한다.&lt;/li&gt;
      &lt;li&gt;집합이 비어 있지 않다면, 커널은 집합 내 어떤 시그널 k를 선택해서 p가 시그널 k를 수신하도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;854-시그널-블록하기와-블록-해제하기&quot;&gt;8.5.4 시그널 블록하기와 블록 해제하기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;묵시적 블록 방법
    &lt;ul&gt;
      &lt;li&gt;기본적으로, 커널은 핸들러에 의해 처리되고 있는 유형의 모든 대기 시그널들의 처리를 막는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명시적 블록 방법
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램들은 sigprocmak 함수와 이들의 도움함수를 이용해서 시그널들을 명시적으로 블록하거나 해제할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;86-비지역성-점프&quot;&gt;8.6 비지역성 점프&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;C는 &lt;strong&gt;비지역성 점프&lt;/strong&gt;라고 부르는 사용자 수준의 예외적 제어흐름의 형태를 제공한다.
    &lt;ul&gt;
      &lt;li&gt;이것은 보통의 콜-리턴 순서를 통할 필요 없이 하나의 함수에서 현재 실행하고 있는 다른 함수로 제어를 이동한다.&lt;/li&gt;
      &lt;li&gt;setjmp와 longjmp 함수로 제공된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비지역성 점프의 중요한 응용은 심하게 중첩된 함 수콜에서, 어떤 에러 조건을 검출한 결과 즉시 리턴을 허용하는 것이다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 에러 조건이 중첩된 함수 호출의 깊은 곳에서 발견되면, 콜 스택을 거꾸로 돌아가는 대신 공통의 지역적인 에러 핸들러로 직접 리턴하기 위해 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;87-요약&quot;&gt;8.7 요약&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;예외적 제어흐름 ECF는 컴퓨터 시스템의 모든 수준에서 일어나며, 컴퓨터 시스템에 동시성을 제공하는 기본 메커니즘이다.&lt;/li&gt;
  &lt;li&gt;운영체제 수준에서, 커널은 ECF를 사용해서 프로세스의 근본적인 개념을 제공한다.&lt;/li&gt;
  &lt;li&gt;프로세스는 응용프로그램에 두 개의 추상화를 제공한다:
    &lt;ol&gt;
      &lt;li&gt;각 프로그램에 자신이 프로세서를 혼자서 사용하고 있다는 착각을 느끼게 하는 논리적 제어흐름.&lt;/li&gt;
      &lt;li&gt;각 프로그램이 메인 메모리를 혼자서 사용하는 착각을 제공하는 사적 주소공간.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;8.4 프로세스의 제어, 8.5.5 시그널 핸들러 작성하기 8.6 비지역성 점프 부분은 한번 더 꼭 읽어보자.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>honggoo</name></author><category term="CSAPP" /><category term="CS:APP" /><category term="CS" /><summary type="html">CS:APP - 24</summary></entry><entry><title type="html">[DataEngineering] 첫 번째 데이터엔지니어 인턴 회고</title><link href="http://localhost:4000/dataengineering/de_02/" rel="alternate" type="text/html" title="[DataEngineering] 첫 번째 데이터엔지니어 인턴 회고" /><published>2022-05-02T00:00:00+09:00</published><updated>2022-05-02T00:00:00+09:00</updated><id>http://localhost:4000/dataengineering/de_02</id><content type="html" xml:base="http://localhost:4000/dataengineering/de_02/">&lt;h1 id=&quot;첫-회사-생활&quot;&gt;첫 회사 생활&lt;/h1&gt;
&lt;p&gt;4학년 1학기에 졸업작품을 마치고 현업을 경험하고 싶어 인턴을 지원했다. 그 때 당시에는 아직 세세한 직무를 정하지 않아서, 평소에 관심 있던 백엔드와 데이터엔지니어
두 분야에 지원했다. 둘 중 더 좋은 조건의 인턴을 붙게 된다면 해당 직무를 경험해보자는 생각이였다. 지원은 많이 했지만, 코테 준비가 미흡해서 면접까지 간 회사는 거의 없었다.
코테를 보지 않는 회사 중 두 곳을 면접을 보게 되었는데, 첫 번째 회사의 면접 경험은 정말 최악이었다. 두 번째 회사의 면접은 정말 마음에 들었다. 내가 했던 프로젝트에 대해서
상세하게 질문이 들어왔고, 꼬리에 꼬리를 무는 질문이 많았다. 면접을 하면서도 내가 부족한 부분이 무엇인지 더 공부해야할 부분들을 알게 되는 신기한 경험을 하게 되었다.
면접을 진행하면서 모르겠다고 답변했던 것들 투성이여서 그 때 당시 내 현주소도 알게 되면서 조금 부끄러웠던 것 같다. (졸업작품을 막 끝내고 더닝크루거의 우매한 봉우리에 위치 해 
있었던 것 같다…)&lt;/p&gt;

&lt;p&gt;1주일 뒤에 합격 통지를 받았고, 데이터엔지니어 챕터의 인턴으로 합류하게 되었다. 굉장히 설레면서도 무서웠다. 할 수 있는 것은 야매로 프로젝트를 했던 경험이 전부인데, 
현업에 뛰어들어 내가 1인분 역할을 할 수 있을지 정말 미지수였다. 하지만, 평소에 궁금했던, 현업에서는 코딩을 어떻게 하는지, 어떤 프로젝트들을 맡아 진행하는지, 
팀원들간의 의사소통은 어떻게 하는지 등등… 을 해결할 수 있어서 신나기도 했다.&lt;/p&gt;

&lt;h1 id=&quot;좌절의-연속&quot;&gt;좌절의 연속&lt;/h1&gt;
&lt;p&gt;인턴 생활을 하면서 내 자신이 프로그래머로서 너무나도 부족한 사람이구나를 여러번 깨달았다.&lt;/p&gt;

&lt;p&gt;첫번째, 업무를 진행하기 위해서 환경세팅을 하는 모든 것이 어려웠다. 나는 R로 작성되어 있는 ETL 레거시 파일들을 python 으로 migration 하는 업무를 맡았다. 
Docker를 사용해서 python 개발 환경을 구축해야 했고, git-secret 등록, git-secret을 등록하기 위해서 GPG Key 생성, SSH Key 생성, AWS MFA 설정 등등…
사용 방법이 작성되어 있는 문서를 봐도 쉽게 따라할 수 없는 것들이였다.&lt;/p&gt;

&lt;p&gt;두번째, 챕터내의 전반적인 개발 프로세스를 따라하는 것이 어려웠다. 개발자들은 소통을 위한 tool을 굉장히 많이 사용하고 있었다. Slack 부터 사용해서 Notion, Jira,
Ally, Github 등등… Slack을 통한 간단한 메세지와 Notion을 통한 문서화는 어렵지 않았지만, 새로운 task를 부여 받았을 때 Jira로 관리하는 것이 뭔가 어색하기도 해서 
어렵게 느껴졌다. Jira를 사용할 때 문서를 작성하는 것도 어색했던 것 같다. 그리고 이러한 소통을 하면서 사용하는 단어들(예를들어 에픽, man month, OKR 등등…) 또한
처음 들어본 단어들이 많아서 의사소통을 하면서 처음에 적응하기 쉽지 않았다.&lt;/p&gt;

&lt;p&gt;세번째, 사내에 다양한 세미나에 참여했는데, 반 이상은 이해하지 못했다. 가장 크게 좌절했던 부분이다. 다른 팀원들은 세미나 주제에 대해서 일정 시간동안 문서를 읽고 
다양한 의견들을 서로 주고 받는데, 나는 문서를 읽으면서도 이해하지 못하는 것들이 태반이였고, 당연하지만 여러 의견들도 나누지 못했다. 여기서 나는 이론적으로도 실무적으로도
너무나도 부족한 개발자라는 것을 뼈저리게 느꼈다. 예를들어 우리 DE 챕터에서는 PostgreSQL을 사용했는데, 세미나 주제가 PostgreSQL의 인덱싱 알고리즘이였다. PostgreSQL
에서 인덱싱에 사용되는 여러 알고리즘들을 소개하고, 해당 방법들이 어떤 데이터에서 유용한지에 대한 공식 도큐멘테이션을 읽고 서로 의견을 나누는 세미나다. 하지만 나는 
‘인덱싱’ 이라는 개념 조차도 정확히 알고있지 못하는 상태였다.&lt;/p&gt;

&lt;p&gt;마지막은 코딩이다. ETL을 작성하면서 python pandas를 가장 많이 사용하였는데, 코드 리뷰를 받으면서 내가 알지 못하는 문법들이 굉장히 많았고, 프로그램의 속도에 관해서 
처음으로 고민을 시작하게 됐던 것 같다. Unittest를 작성하면서도 모르는 개념들 투성이였다. R로 작성되어 있는 코드를 실행하면서 실행결과를 비교해가면서 migration 했는데,
코딩 속도도 굉장히 만족스럽지 못했고, Terminal 안에서 파일들을 열고 수정하는 부분들도 부족함을 많이 느꼈다. &amp;lt;- 이 부분에 대해서 얘기하고 싶은 것이 하나 있는데,
같은 팀원이 했던 얘기가 굉장히 인상 깊었다. “GUI 툴로는 사용자가 원하는 만큼 접근할 수 없다. 프로그램에 컨트롤 당하면 안되고 프로그램 위에서 컨트롤 할 줄 알아야 한다.” 
GUI 툴에서 지원하는 기능에 너무 기대지 않고 직접 해당 기능들을 만질 수 있어야 된다는 의미 같다.&lt;/p&gt;

&lt;h1 id=&quot;어깨-너머로-배운-것들&quot;&gt;어깨 너머로 배운 것들&lt;/h1&gt;
&lt;p&gt;좌절도 많이 했지만, 독학으로는 배우지 못했던 것들을 어깨 너머로 많이 배운 것 같다. 내가 맡았던 업무에 대한 프로세스를 간단히 얘기해보자면, 
레포 세팅을 하면서 webhook과 git-secret, AWS, GPG 를 secret action에 등록해준다.
Docker로 해당 task의 환경을 세팅해주고, Dockerfile을 빌드하기 전에 AWS ECR 레포와 DB 환경 변수를 추가해주고 빌드를 진행한다.
ETL과 Unittest를 모두 작성하면 해당 파일에 lint를 적용해 일정 점수 이상을 받게 되면 black 과 isort로 한번 더 파일을 정리해준다.
이후에 work branch 에서 test branch로 merge하게 되면, Git Action에서 CI/CD가 자동으로 돌고 AWS ECR에 생성했둔 레포에 해당 ETL 파일의 이미지가 저장된다.
해당 이미지를 가지고 Airflow에 Dag를 작성해 배포해준다.&lt;/p&gt;

&lt;p&gt;ETL 프로세스에 대해 전반적으로 배울 수 있었던 것 같다. 추가적으로 공부하고 싶은 부분이 있다면, ETL과 unittest 작성 부분을 제외하고 나머지 모두 다이다.
나 혼자서 CI/CD를 자동으로 구축해보고 싶고, Airflow를 구축해서 자동으로 배포도 해보고 싶다. 또한 Dockerfile을 만들어 python 개발 환경을 구축해보고 싶다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;위의 것들은 개인 프로젝트로 진행해볼 예정이다! 위의 것들을 적용시키기 위한 좋은 아이디어를 생각중이다…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또한 팀내 다양한 문서와 세미나를 통해 데이터엔지니어가 알고 있어야할 개념들을 많이 알게 되었다. 입사하기 전에는 데이터웨어하우스의 개념조차도 몰랐었던걸 비교하면 
굉장히 다양한 개념(딱 개념 수준정도만…)을 알게 된 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;앞으로의-방향성&quot;&gt;앞으로의 방향성&lt;/h1&gt;
&lt;p&gt;어쩌다보니 다음 목적지도 데이터엔지니어로 정하게 됐다. 인턴을 하면서 부족했던 CS 지식들은 독학으로 채워가고 있다. 어느정도 CS 공부가 마무리 되면(공부에 마무리는 없지만…)
개인 프로젝트를 진행하면서 인턴 생활을 하면서 직간접적으로 배웠던 것들을 직접 적용해볼 생각이다. 또한 데이터엔지니어 과정의 국비교육도 수강할 계획에 있다.
앞으로 신입 데이터엔지니어가 되기 위해 필요한 지식들을 하나씩 쌓아가면서 든든한 데이터엔지니어가 되어보겠다.&lt;/p&gt;</content><author><name>honggoo</name></author><category term="DataEngineering" /><category term="DataEngineering" /><summary type="html">길면 길었고 짧으면 짧았던 9개월간의 기록</summary></entry><entry><title type="html">[이코테/Python] 이진 탐색 - 부품 찾기</title><link href="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_09/" rel="alternate" type="text/html" title="[이코테/Python] 이진 탐색 - 부품 찾기" /><published>2022-04-08T00:00:00+09:00</published><updated>2022-04-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_09</id><content type="html" xml:base="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_09/">&lt;h1 id=&quot;이코테&quot;&gt;이코테&lt;/h1&gt;

&lt;h2 id=&quot;이진탐색-부품-찾기python&quot;&gt;이진탐색 부품 찾기(Python)&lt;/h2&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;

&lt;p&gt;전자 매장에는 부품이 N개 있다. &lt;br /&gt;
어느날 손님이 M개 종류의 부품을 구매하려고 한다. &lt;br /&gt;
이 때 매장에서 손님이 사려고 하는 부품이 있는지 yes와 no 형태로 구하라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예시&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;입력 : &lt;br /&gt;
        array = [9, 3, 7, 9, 2] &lt;br /&gt;
        target = [5, 7, 9] &lt;br /&gt;
결과 : no yes yes&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;탐색시간을 줄이기 위해서는 array를 정렬하고 이진 탐색으로 target에 저장된 배열의 인자를 하나씩 탐색해나가면 쉽게 풀 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;array를 내림차순으로 정렬&lt;/li&gt;
  &lt;li&gt;target 배열의 인자를 하나씩 꺼내서 target으로 설정&lt;/li&gt;
  &lt;li&gt;array의 end가 start보다 크거나 같을 동안 while문 반복&lt;/li&gt;
  &lt;li&gt;이진탐색 알고리즘을 사용하여 탐색이 완료되면 Yes, 탐색이 되지 않으면 while 문 밖에서 No(No 저장 때 array[mid]가 t가 아닐 때의 조건을 걸어 둔 이유는 무차별적으로 No가 저장되는 것을 방지하기 위함)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;다른-풀이&quot;&gt;다른 풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;이진탐색 뿐만 아니라, count sorting, set 자료형을 사용하여 풀 수 있다.
set 자료형은 {} &amp;lt;- 로 array를 묶어 target in {} 문법을 사용하여 쉽게 풀 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                   &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Yes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
    
        &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Yes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="이코테" /><category term="Algorithm" /><category term="Python" /><category term="이코테" /><summary type="html">이코테 알고리즘 - 09</summary></entry><entry><title type="html">[이코테/Python] DFS/BFS - 미로 탈출</title><link href="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_08/" rel="alternate" type="text/html" title="[이코테/Python] DFS/BFS - 미로 탈출" /><published>2022-04-08T00:00:00+09:00</published><updated>2022-04-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_08</id><content type="html" xml:base="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_08/">&lt;h1 id=&quot;이코테&quot;&gt;이코테&lt;/h1&gt;

&lt;h2 id=&quot;dfsbfs-미로-탈출python&quot;&gt;DFS/BFS 미로 탈출(Python)&lt;/h2&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;

&lt;p&gt;N x M 크기의 미로가 있다.&lt;br /&gt;
몬스터가 있는 곳은 0, 몬스터가 없는 곳은 1로 표시된다.&lt;br /&gt;
몬스터를 피해서 (0,0) 좌표에서 (N,M) 좌표까지 탈출해야한다.&lt;br /&gt;
이때 탈출까지의 최단 거리를 구하여라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예시&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;입력 : &lt;br /&gt;
    [1,0,1,0,1,0]&lt;br /&gt;
    [1,0,1,1,1,1]&lt;br /&gt;
    [1,0,1,1,1,0]&lt;br /&gt;
    [1,0,1,0,1,0]&lt;br /&gt;
    [1,1,1,0,1,1]&lt;br /&gt;
결과 : 14&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 문제는 1이 연결된 길을 찾으면 되는 문제이다. 최단 거리를 구하기 위해서 현재 위치에서 근접한 1의 위치를 찾으면 된다. 그렇기 때문에 BFS로 접근하였다.
하지만, 관건은 근접한 1의 위치를 찾고 최단거리를 계산하는 방법이다.
1을 만나게 되면, 이전 노드의 정보를 더해주는 방식으로 (1,1) 좌표에서 특정 노드까지의 최단거리를 모두 저장해주면 된다.
이후 (N,M)에 저장되어 있는 정보를 출력하면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;solution1&quot;&gt;solution1&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;탐색하기 위해 노드를 저장하는 deque 변수를 선언한다.
    &lt;ul&gt;
      &lt;li&gt;deque는 (x좌표,y좌표,해당노드까지의 최단 거리) 가 tuple 형식으로 저장된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;deque가 비게 되면 탈출하게 되는 while문을 선언한다.&lt;/li&gt;
  &lt;li&gt;반복문을 돌며 첫번째로 deque를 pop하여 각각 x,y,v에 저장한다.&lt;/li&gt;
  &lt;li&gt;x와 y가 0보다 작거나 graph의 크기를 벗어나면 continue 해준다.&lt;/li&gt;
  &lt;li&gt;graph의 x, y좌표가 1이라면, 해당 노드에 v 값을 더해준다.&lt;/li&gt;
  &lt;li&gt;이후 deque에 해당 좌표 기준 상,하,좌,우 값을 추가하여 탐색할 수 있게 설정한다.&lt;/li&gt;
  &lt;li&gt;반복문이 끝나면 graph의 N,M 좌표에 해당하는 value를 return한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;solution2&quot;&gt;solution2&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;solution1과 로직은 같지만, solution2는 상하좌우를 배열에 저장하였고,
큐에는 x와 y좌표만 저장해두었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;collections&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# 이동할 네 방향 정의(상, 하, 좌, 우)
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;# graph 크기 정의
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;# BFS 소스코드 구현
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    
            &lt;span class=&quot;c1&quot;&gt;# 큐(Queue) 구현을 위해 deque 라이브러리 사용
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;deque&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    
            &lt;span class=&quot;c1&quot;&gt;# 큐가 빌 때까지 반복
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popleft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 현재 위치에서 네 방향으로의 위치 확인
&lt;/span&gt;                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;# 미로 찾기 공간을 벗어난 경우 무시
&lt;/span&gt;                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;# 벽인 경우 무시
&lt;/span&gt;                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;# 해당 노드를 처음 방문하는 경우에만 최단 거리 기록
&lt;/span&gt;                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ny&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    
            &lt;span class=&quot;c1&quot;&gt;# 가장 오른쪽 아래까지의 최단 거리 반환
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="이코테" /><category term="Algorithm" /><category term="Python" /><category term="이코테" /><summary type="html">이코테 알고리즘 - 08</summary></entry><entry><title type="html">[이코테/Python] 이진 탐색 - 나무 자르기</title><link href="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_10/" rel="alternate" type="text/html" title="[이코테/Python] 이진 탐색 - 나무 자르기" /><published>2022-04-08T00:00:00+09:00</published><updated>2022-04-08T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_10</id><content type="html" xml:base="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_10/">&lt;h1 id=&quot;이코테&quot;&gt;이코테&lt;/h1&gt;

&lt;h2 id=&quot;이진탐색-나무-자르기python&quot;&gt;이진탐색 나무 자르기(Python)&lt;/h2&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2805&quot;&gt;문제로 이동!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;나무를 자를 수 있는 길이는 0부터 가장 긴 나무의 길이다. 0~가장 긴 나무 길이를 이진 탐색을 하며 잘려진 나무의 합이 목표 길이보다 크다면 자른 길이를 저장한다.
최대값을 구하기 위해서 탐색이 종료될 때까지 조건에 맞는 길이를 찾아간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;나무 길이의 최대 값을 찾는다.&lt;/li&gt;
  &lt;li&gt;start는 0, end는 나무 길이의 최대 값으로 설정한다.&lt;/li&gt;
  &lt;li&gt;중간 값을 찾고, 나무 길이 - 중간 값을 리스트 컴프리헨션으로 음수가 되는 값은 0으로 변경하여 전체 합을 구한다.&lt;/li&gt;
  &lt;li&gt;전체합과 target을 비교하여 전체합 보다 target이 작거나 같으면 결과에 중간값을 저장한다.&lt;/li&gt;
  &lt;li&gt;탐색이 끝날 때 까지 반복하며 최대 값을 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;추가-설명&quot;&gt;추가 설명&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;해당 문제는 전형적인 이진 탐색 문제이자, 파라메트릭 서치parametric search 유형의 문제라고 한다. “원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제”에 주로 사용한다.
예를 들어 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진 탐색으로 결정 문제를 해결하며 범위를 좁혀갈 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="이코테" /><category term="Algorithm" /><category term="Python" /><category term="이코테" /><summary type="html">이코테 알고리즘 - 10</summary></entry><entry><title type="html">[이코테/Python] DFS/BFS - 음료수 얼려 먹기</title><link href="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_07/" rel="alternate" type="text/html" title="[이코테/Python] DFS/BFS - 음료수 얼려 먹기" /><published>2022-04-07T00:00:00+09:00</published><updated>2022-04-07T00:00:00+09:00</updated><id>http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_07</id><content type="html" xml:base="http://localhost:4000/%EC%9D%B4%EC%BD%94%ED%85%8C/this_07/">&lt;h1 id=&quot;이코테&quot;&gt;이코테&lt;/h1&gt;

&lt;h2 id=&quot;dfsbfs-음료수-얼려-먹기python&quot;&gt;DFS/BFS 음료수 얼려 먹기(Python)&lt;/h2&gt;

&lt;h2 id=&quot;문제&quot;&gt;문제&lt;/h2&gt;

&lt;p&gt;N x M 크기의 얼음 틀이 있다.&lt;br /&gt;
구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.&lt;br /&gt;
구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있을 경우 서로 연결되어 있는 것으로 간주한다.&lt;br /&gt;
이때 생성할 수 있는 총 얼음의 개수를 구하라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;예시&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;입력 : &lt;br /&gt;
        [0,0,1,1,0]&lt;br /&gt;
        [0,0,0,1,1]&lt;br /&gt;
        [1,1,1,1,1]&lt;br /&gt;
        [0,0,0,0,0]&lt;br /&gt;
결과 : 3&lt;/p&gt;

&lt;h2 id=&quot;풀이&quot;&gt;풀이&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;이 문제는 0이 연결되어 있는 부분들을 모두 찾아야된다. 그렇기 때문에 하나에서 연결된 부분의 끝까지 탐색하는 DFS(깊이우선탐색) 방법으로 접근하면 쉽게 풀 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 입력으로 주어진 그래프를 2중 반복문을 사용하여 모든 인자값을 탐색한다.&lt;/li&gt;
  &lt;li&gt;dfs 함수를 호출하여 해당 인자값으로부터 시작해서 얼음틀이 어디까지 연결되어 있는지를 체크한 후 1로 변경한뒤 전체 결과값에서 +1을 해준다.&lt;/li&gt;
  &lt;li&gt;dfs 함수는 재귀함수 형식으로 호출되며, 탐색을 시작한 값에서 상,하,좌,우 를 탐색하는 방식으로 dfs 함수를 재귀로 호출하여 체크해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;새로-알게된-문법&quot;&gt;새로 알게된 문법&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;새로 알게된 ‘문법’ 까지는 아니지만, DFS/BFS를 배울 때 해당 예시로 그려진 그래프와 같은 그래프에만 적용되는 줄 알았다. 하지만 해당 문제 처럼
상하좌우를 강제적으로(ex.[x-1,y],[x,y+1]) 형식으로 조회하여 찾을 수 있다는 것을 알게 되었다. 하지만 이렇게 풀 경우 반복문을 세번이나 돌게 되면서 n^3인데
시간초과가 나지 않는 것이 조금 신기하다… 해당 부분은 조금 더 공부가 필요해보인다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;코드&quot;&gt;코드&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])):&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# 현재 위치에서 DFS 수행
&lt;/span&gt;                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;# 주어진 범위를 벗어나는 경우에는 즉시 종료
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
    
        &lt;span class=&quot;c1&quot;&gt;# 현재 노드를 아직 방문하지 않았다면
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
    
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
    
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;__main__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    
        &lt;span class=&quot;n&quot;&gt;solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name>honggoo</name></author><category term="이코테" /><category term="Algorithm" /><category term="Python" /><category term="이코테" /><summary type="html">이코테 알고리즘 - 07</summary></entry></feed>