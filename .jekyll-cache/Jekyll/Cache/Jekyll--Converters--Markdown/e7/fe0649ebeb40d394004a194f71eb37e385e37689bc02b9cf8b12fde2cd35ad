I"<h1 id="1-파일과-디렉터리">1. 파일과 디렉터리</h1>
<ul>
  <li>지금까지 운영체제를 구성하는 두 개의 핵심 개념을 살펴보았다.
    <ul>
      <li>CPU를 가상화한 “프로세스”와 메모리를 가상화한 “주소 공간”이다.</li>
      <li>이 개념들은 서로 협력하여 응용 프로그램들이 서로 독립된 세계에서 실행될 수 있도록 한다.</li>
      <li>자신만의 프로세서와 자신만의 메모리가 있는 것처럼 만들어 준다.</li>
    </ul>
  </li>
  <li>이번 장에서는 <strong>영속 저장 장치(persistent storage)</strong>라고 하는 가상화에 있어서 또 하나의 핵심적인 개념을 다룬다.
    <ul>
      <li><strong>하드 디스크 드라이브</strong> 또는 좀 더 최근의 <strong>솔리드스테이트 드라이브(Solid-state storage, SSD)</strong>와 같은 저장 장치는 영구적으로 정보를 저장한다.</li>
    </ul>
  </li>
  <li>어떻게 영속 장치를 관리하는가
    <ul>
      <li>운영체제가 영속 장치를 어떻게 관리해야 할까?</li>
      <li>API들은 어떤 것이 있는가?</li>
      <li>구현의 중요한 측면은 무엇인가?</li>
    </ul>
  </li>
  <li>영속 데이터를 관리하는 핵심 기술들을 살펴볼 것이며 성능과 신뢰성을 향상시키는 기법들을 중점으로 알아보자</li>
</ul>

<h2 id="11-파일과-디렉터리">1.1 파일과 디렉터리</h2>
<p>저장 장치의 가상화에 대한 두 가지 주요 개념이 개발되었다.</p>

<ol>
  <li><strong>파일</strong>
    <ul>
      <li>파일은 단순히 읽거나 쓸 수 있는 순차적인 바이트의 배열이다.</li>
      <li>각 파일은 <strong>저수준 이름(low-level name)</strong>을 가지고 있으며 보통은 숫자로 표현되지만 사용자는 그 이름에 대해서 알지 못한다.</li>
      <li>이 저수준의 이름을 <strong>아이노드 번호(inode number)</strong>라고 부른다.</li>
      <li>각 파일은 아이노드 번호와 연결되어 있다.</li>
      <li>시스템에서 운영체제는 파일의 구조를 모른다. 파일 시스템의 역할은 그러한 데이터를 디스크에 안전히 저장하고, 데이터가 요청되면 처음 저장했떤 데이터를 돌려주는 것이다.</li>
    </ul>
  </li>
  <li><strong>디렉터리</strong>
    <ul>
      <li>파일과 마찬가지로 디렉터리도 저수준의 이름(아이노드 번호)을 갖는다.</li>
      <li>파일과는 달리 내용은 구체적으로 정해져 있다.</li>
      <li>디렉터리는 &lt;사용자가 읽을 수 있는 이름, 저수준의 이름&gt; 쌍으로 이루어진 목록을 갖고 있다.</li>
      <li>디렉터리의 각 항목은 파일 또는 다른 디렉터리를 가리킨다.</li>
      <li>디렉터리 내에 다른 디렉터리를 포함함으로써 사용자는 모든 파일들과 디렉터리들이 저장되어 있는 임의의 <strong>디렉터리 트리(directory tree), 디렉터리 계층(directory hierarchy)</strong>을 구성할 수 있다.</li>
      <li>디렉터리의 계층은 <strong>루트 디렉터리(root directory)</strong>부터 시작하며 원하는 파일이나 디렉터리의 이름을 표현할 때 까지 <strong>구분자(separator)</strong>를 사용하여 <strong>하위 디렉터리</strong>를 명시할 수 있다.</li>
    </ul>
  </li>
</ol>

<h2 id="12-공유하는-파일-테이블의-요소들-fork와-dup">1.2 공유하는 파일 테이블의 요소들: fork()와 dup()</h2>
<blockquote>
  <p><strong>파일 디스크립터</strong></p>

  <p>파일 디스크립터는 프로세스마다 존재하는 정수로서 Unix 시스템에서 파일을 접근하는 데 사용된다. 열린 파일을 읽고 쓰는 데도 사용된다. 해당 파일에 대한 권한을 갖고 있어야 한다.                   <br />
파일 디스크립터를 파일 객체를 가리키는 포인터로 볼 수도 있다.</p>
</blockquote>

<blockquote>
  <p><strong>자료구조 - open file table</strong></p>

  <p>각 프로세스는 파일 디스크립터 배열을 갖고 있따. 각 파일 디스크립터는 시스템이 관리하는 <strong>열린 파일 테이블(open file table)</strong>의 요소를 가리킨다. 이 테이블의 각 요소는 디스크립터가
가리키는 파일과 현재 오프셋 그리고 읽기 쓰기 여부와 같은 다른 관련 정보를 담고 있다.</p>
</blockquote>

<ul>
  <li>열린 파일 테이블의 요소와 파일 디스크립터를 연결하는 것은 일대일 매핑으로 이루어 진다.
    <ul>
      <li>다른 프로세스가 같은 파일을 동시에 읽는다 하더라도 각 프로세스는 개별적인 열린 파일 테이블의 요소를 다룬다.</li>
      <li>같은 파일에 대한 논리적 읽기와 쓰기는 독립적이며 각각이 개별적인 현재 오프셋을 관리한다.</li>
    </ul>
  </li>
  <li>프로세스들이 열린 파일 테이블을 공유하는 경우가 있다.
    <ul>
      <li>부모 프로세스가 fork()를 사용하여 자식 프로세스를 생성하는 경우이다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/17/img.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 열린 파일 테이블의 요소를 공유하는 프로세스들이다.</li>
</ul>
:ET