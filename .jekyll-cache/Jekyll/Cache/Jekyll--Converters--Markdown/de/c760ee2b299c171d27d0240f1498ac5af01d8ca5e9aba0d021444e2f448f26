I"#<h1 id="chapter-08-예외적인-제어흐름">Chapter 08. 예외적인 제어흐름</h1>
<ul>
  <li>프로세서에서 전원을 처음 공급하는 시점부터 전원을 끌 때까지 프로그램 카운터는 연속된 값들을 가정한다.
    <ul>
      <li>인스트럭션 I에 대응되는 주소가 ak -&gt; ak+1 로의 전환은 제어이동이라고 부른다.</li>
      <li>이러한 제어이동의 배열은 <strong>제어흐름 또는 프로세서의 제어흐름</strong>이라고 부른다.</li>
    </ul>
  </li>
  <li>프로그램의 실행과는 반드시 관련되어 있지 않은 시스템 상태의 변화에도 반응할 수 있어야 한다.
    <ul>
      <li>현대의 시스템들은 갑작스런 변화를 만드는 방법으로 이러한 상황에 반응한다.</li>
      <li>일반적으로 이와 같은 급격한 변화를 <strong>예외적인 제어흐름exceptional control flow(ECF)</strong>라고 한다.</li>
    </ul>
  </li>
  <li>ECF의 중요성
    <ul>
      <li>ECF는 운영체제가 입출력, 프로세스, 가상메모리를 구현하기 위해 사용하는 기본 메커니즘이다.</li>
      <li>ECF를 이해하면 어떻게 application들이 운영체제와 상호작용하는지를 이해할 수 있다.</li>
      <li>ECF는 컴퓨터 시스템에서 동시성을 구현하는 기본 메커니즘이다.</li>
      <li>ECF를 이해하면소프트웨어적인 예외상황이 어떻게 동작하는지 이해할 수 있다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>7장까지는 시스템에 대한 application이 하드웨어와 어떻게 상호작용하는지에 관한 것이었다. 98장은 application이 운영체제와 어떻게
상호작용하는지 배우게 되는 측면에서 전환점이라고 볼 수 있다.</p>
</blockquote>

<ul>
  <li>컴퓨터 수준에 존재하는 ECF의 다양한 형태
    <ol>
      <li>하드웨어와 운영체제의 교차점에 놓인 예외</li>
      <li>application에게 운영체제 내부로 엔트리 포인트를 제공하는 예외인 시스템콜</li>
      <li>application과 운영체제의 교차점에 위치한 프로세스와 시그널</li>
      <li>비지역성 점프 - ECF의 응용수준</li>
    </ol>
  </li>
</ul>

<h1 id="81-예외상황">8.1 예외상황</h1>
<ul>
  <li>예외상황은 부분적으로는 하드웨어와 운영체제에 의해서 구현된 예외적인 제어흐름의 한가지 형태다.</li>
</ul>

<p><img src="../../assets/img/csapp/24/img.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 예외상황의 기본 아이디어다.</li>
  <li>프로세서가 이벤트(상태 변화)가 발생했다는 것을 감지하면, 예외 테이블이라고 하는 점프 테이블을 통해서 이 특정 종류의 이벤트를 처리하기 위해 특별히 설계된 운영체제 서브루틴(예외처리 핸들러)으로 간접 프로시저 콜을 하게 된다.</li>
  <li>예외처리 핸들러가 처리를 끝마치면, 다음 세 가지 중의 한 가지 일을 발생한다.
    <ol>
      <li>핸들러는 제어를 현재 인스트럭션으로 돌려준다.</li>
      <li>핸들러는 제어를 다음 예외상황이 발생하지 않았더라면 다음에 실행되었을 인스트럭션으로 돌려준다.</li>
      <li>핸들러는 중단된 프로그램을 종료한다.</li>
    </ol>
  </li>
</ul>

<h2 id="811-예외처리">8.1.1 예외처리</h2>
<ol>
  <li>한 시스템 내에서 가능한 예외상황의 종류마다 중복되지 않는 양의 정수를 예외번호로 할당하고 있다.</li>
  <li>시스템 부팅 시, 운영체제는 예외 테이블이라고 하는 점프 테이블을 할당하고 초기화해서 엔트리 k가 예외상황 k에 대한 핸들러의 주소를 갖는다.</li>
  <li>런타임에 프로세서는 이벤트가 발생했다는 것을 감지하고, 대응되는 예외번호 k를 결정한다.</li>
  <li>k를 통해서 간접 프로시저 콜을 하는 방법으로 예외상황을 발생시킨다.</li>
  <li>예외번호는 예외 테이블에서 인덱스이며, 이 테이블의 시작 주소는 ‘예외 테이블 베이스 레지스터’라는 특별한 CPU 레지스터에 저장되어 있다.</li>
</ol>

<p><img src="../../assets/img/csapp/24/img_1.png" width="50%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 예외테이블이다.</p>
  </li>
  <li>
    <p>예외상황과 프로시저 콜의 차이점</p>
    <ul>
      <li>프로시저 콜: 스택에 리턴주소 푸시, 예외상황: 현재 또는 다음 인스트럭션</li>
      <li>핸들러가 리턴할 때 중단된 프로그램을 다시 시작하기 위해 스택 상에 추가적인 프로세서 상태를 푸시한다.</li>
      <li>모든 아이템들은 사용자 스택 위가 아니라 커널 스택 상에 푸시된다.</li>
      <li>예외 핸들러는 ‘커널 모드’에서 돌아간다.</li>
    </ul>
  </li>
</ul>

<h2 id="812-예외의-종류">8.1.2 예외의 종류</h2>
<ul>
  <li>예외상황은 네 가지 종류를 구분할 수 있다.
    <ul>
      <li>인터럽트</li>
      <li>트랩</li>
      <li>오류fault</li>
      <li>중단abort</li>
    </ul>
  </li>
</ul>

<h3 id="인터럽트">인터럽트</h3>
<ul>
  <li>프로세서 외부에 있는 입출력 디바이스로부터의 시그널의 결과로 비동기적으로 발생한다.(특정 인스트럭션을 싫애해서 발생한 것이 아니라는 의미)</li>
  <li>핸들러가 리턴할 때, 제어를 다음 인스트럭션으로 돌려준다.</li>
</ul>

<blockquote>
  <p>인터럽트를 제외한 나머지 예외의 종류들은 동기적으로 일어난다.</p>
</blockquote>

<h3 id="트랩과-시스템-콜">트랩과 시스템 콜</h3>
<ul>
  <li>의도적인 예외상황으로, 어떤 인스트럭션을 실행한 결과로 발생한다.</li>
  <li>트랩 핸들러는 제어를 다음 인스트럭션으로 리턴한다.</li>
  <li>트랩의 가장 중요한 사용은 <strong>시스템콜</strong>이라고 알려진 사용자 프로그램과 커널 사이의 프로시저와 유사한 인터페이스를 제공하는 것이다.</li>
  <li>시스템 콜은 ‘커널 모드’에서 돌아가며, 이로 인해 커널 내에서 정의된 스택에 접근하며, 특권을 가진 인스트럭션을 실행할 수 있도록 해준다.</li>
</ul>

<h3 id="오류fault는-error와-다르다">오류(fault는 error와 다르다.)</h3>
<ul>
  <li>오류는 핸들러가 정정할 수 있을 가능성이 있는 에러 조건으로부터 발생한다.</li>
  <li>핸들러가 에러 조건을 정정한다면, 제어를 오류를 발생시킨 인스트럭션으로 돌려주어 거기서부터 재실행한다.</li>
  <li>정정하지 못한다면, 커널 내부의 abort 루틴으로 리턴해서 프로그램을 종료한다.</li>
</ul>

<h3 id="중단-abort">중단 abort</h3>
<ul>
  <li>중단 핸들러는 절대로 응용프로그램으로 제어를 리턴하지 않는다.</li>
</ul>

<h2 id="813-리눅스x86-64-시스템에서의-예외상황">8.1.3 리눅스/x86-64 시스템에서의 예외상황</h2>

<h3 id="오류와-중단">오류와 중단</h3>
<ul>
  <li>나누기 에러: 0으로 나누려할 때</li>
  <li>일반 보호 오류: 프로그램이 가상메모리의 정의되지 않은 영역을 참조하거나 read-only를 쓰려고 하기 때문에 발생</li>
  <li>페이지 오류: 가상메모리 페이지 오류</li>
  <li>머신 체크: 오류 인스트럭션을 실행하는 동안에 검출된 치명적인 하드웨 에러의 결과로 발생</li>
</ul>

<h2 id="시스템-콜">시스템 콜</h2>
<ul>
  <li>리눅스는 파일을 읽거나 쓸 때, 또는 새로운 프로세스를 만들 때 응용프로그램이 사용할 수 있는 수백 개의 시스템 콜을 제공한다.</li>
  <li>x86-64 시스템에서 시스템 콜은 syscall이라고 부르는 트랩 인스트럭션을 통해서 제공된다.</li>
</ul>

<p><img src="../../assets/img/csapp/24/img_2.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 리눅스 x86-64 시스템의 주요 시스템 콜</li>
</ul>

<h1 id="82-프로세스">8.2 프로세스</h1>
<ul>
  <li>예외상황은 <strong>프로세스</strong> 개념을 운영체제 커널이 제공할 수 있게 하는 기본 구성 블록이다.</li>
  <li>프로세스의 고전적인 정의는 <strong>실행 프로그램의 인스턴스이다.</strong></li>
  <li>시스템 내의 각 프로그램은 어떤 프로세스의 <strong>문맥context</strong>에서 돌아간다.</li>
  <li>사용자가 실행 목적파일의 이름을 쉘에 입력해서 프로그램을 돌릴 때마다 쉘은 새로운 프로세스를 생성하고, 실행 목적파일을 이 새로운 프로세스의 문맥에서 실행한다.</li>
  <li>프로세스가 application에 제공하는 주요 추상화
    <ul>
      <li>프로세서를 혼자서 사용한다는 착각을 제공하는 독립적 논리 제어 흐름</li>
      <li>혼자서 메모리 시스템을 가진다는 착각을 제공하는 사적 주소공간</li>
    </ul>
  </li>
</ul>

<h2 id="821-논리적인-제어흐름">8.2.1 논리적인 제어흐름</h2>
:ET