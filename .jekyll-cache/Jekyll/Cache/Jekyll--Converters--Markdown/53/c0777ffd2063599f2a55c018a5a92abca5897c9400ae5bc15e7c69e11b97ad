I"'<h1 id="chapter-06-메모리-계층구조">Chapter 06. 메모리 계층구조</h1>
<ul>
  <li>메모리 시스템은 용량, 비용, 접근시간을 갖는 저장장치들의 계층구조다.
    <ul>
      <li>캐시메모리는 CPU 부근에서 비교적 느린 메인메모리에 대한 준비장소</li>
      <li>메인메모리는 크고 느린 디스크들에 대한 준비장소</li>
      <li>디스크들은 네트워크로 연결된 다른 머신들의 준비장소</li>
    </ul>
  </li>
  <li>메모리의 계층별로 접근 속도가 상이하다.
    <ul>
      <li>레지스터가 가장 빠르고, 그 다음은 메인메모리, 그 다음은 디스크이다.</li>
    </ul>
  </li>
  <li>데이터를 계층의 상부에 저장시켜서 CPU가 보다 빨리 접근할 수 있도록 프로그램을 작성해야한다.
    <ul>
      <li>이 개념은 지역성locality라고 알려진 컴퓨터 프로그램의 근본특징에 근거를 두고 있다.</li>
    </ul>
  </li>
</ul>

<h1 id="61-저장장치-기술">6.1 저장장치 기술</h1>

<h2 id="611-랜덤-접근-메모리">6.1.1 랜덤-접근 메모리</h2>
<ul>
  <li>랜덤-접근 메모리(RAM)은 두 종류를 가진다.
    <ul>
      <li>정적 SRAM : 동적램 DRAM 보다 더 빠르고 훨 씬 비싸다. 캐시메모리로 사용된다.</li>
      <li>동적 DRAM : 메인메모리와 그래픽 시스템의 프레임 버퍼로도 사용된다.</li>
    </ul>
  </li>
</ul>

<h3 id="정적-sram">정적 SRAM</h3>
<ul>
  <li>SRAM은 각 비트를 이중안정bistable 메모리 셀cell에 저장한다.</li>
  <li>SRAM은 전원이 공급되는 한 지속성을 갖는다.</li>
  <li>리프레시가 필요없다.</li>
  <li>DRAM보다 트랜지스터를 더 많이 사용하여 밀도가 낮으며 비싸고 전력을 많이 사용한다.</li>
</ul>

<h3 id="동적-dram">동적 DRAM</h3>
<ul>
  <li>DRAM은 각 비트를 전하로 캐패시터에 저장한다.</li>
  <li>리프레시가 필요하다.
    <ul>
      <li>메모리 시스템은 주기적으로 메모리의 모든 비트를 읽었다가 다시 써 주는 방식</li>
    </ul>
  </li>
</ul>

<h3 id="일반-dram">일반 DRAM</h3>
<p><img src="../../assets/img/csapp/20/img_3.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 DRAM 칩의 구조이다.</li>
  <li>DRAM 칩 내의 셀들은 d 슈퍼셀들로 나누어지며, 각각은 w DRAM 셀들로 이루어진다.</li>
  <li>슈퍼셀 (i,j)의 내용을 읽으려면 메모리 컨트롤러는 행 주소 i를 DRAM에 보내고, 다음에 열 주소 j를 보낸다.</li>
</ul>

<p><img src="../../assets/img/csapp/20/img_1.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 DRAM 슈퍼셀의 내용을 읽는 과정이다.</li>
</ul>

<h3 id="메모리-모듈">메모리 모듈</h3>
<ul>
  <li>DRAM 칩은 메인 시스템(머더보드)의 확상슬롯에 꽂을 수 있는 메모리 모듈 형태로 패키징 된다.</li>
  <li>DRAM을 여러개 추가하여 바이트를 순서대로 저장한다.</li>
</ul>

<h3 id="비휘발성-메모리">비휘발성 메모리</h3>
<ul>
  <li>DRAM과 SRAM은 전원이 꺼지면 정보도 잃어버리기 때문에 휘발성이다.</li>
  <li>비휘발성 메모리는 이들의 전원 꺼져도 정보를 유지한다.</li>
  <li>Read-only memory : ROM 이라고 부른다.</li>
  <li>ROM 디바이스에 저장된 프로그램들은 종종 펌웨어firmware라고 부른다.</li>
</ul>

<h3 id="메모리에-접근하기">메모리에 접근하기</h3>
<ul>
  <li>데이터는 ‘버스’라고 하는 공유된 전기회로를 통해서 프로세서와 DRAM메인메모리간에 앞뒤로 교환한다.</li>
  <li>CPU와 메모리 간의 매 전송은 버스 트랜잭션bus transaction이라고 부르는 일련의 단계들을 통해 이뤄진다.</li>
</ul>

<p><img src="../../assets/img/csapp/20/img_2.png" width="60%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 CPU와 메인메모리를 연결하는 버스 구조다.</p>
  </li>
  <li>읽기 트랜잭션(movq A,%rax)
    <ol>
      <li>CPU는 주소 A를 시스템 버스에 보낸다. I/O브릿지는 신호를 메모리 버스를 따라 보낸다.</li>
      <li>메인메모리는 메모리 버스에서 주소 신호를 감지하고, 메모리 버스로부터 주소를 읽고 DRAM에서 데이터 워드를 선입, 데이터를 메모리 버스에 쓴다.</li>
      <li>I/O 브릿지는 신호를 시스템 버스 신호로 변환해서 시스템 버스를 따라 보낸다. CPU는 시스템 버스에서 데이터를 감지하고 %rax에 복사한다.</li>
    </ol>
  </li>
  <li>쓰기 트랜잭션(movq %rax,A)
    <ol>
      <li>CPU는 주소를 시스템 버스에 보낸다. 메모리는 메모리 버스에서 주소를 읽고 데이터가 도착하기를 기다린다.</li>
      <li>CPU는 %rax에 있는 데이터를 시스템 버스에 복사한다.</li>
      <li>메인메모리는 데이터를 메모리 버스에서 읽고 비트들을 저장한다.</li>
    </ol>
  </li>
</ul>

<h2 id="612-디스크-저장장치">6.1.2 디스크 저장장치</h2>
<ul>
  <li>디스크는 RAM 메모리의 수천 메가바이트 단위에 비해 수백에서 수천 기가비이트 단위의 엄청난 양의 데이터를 저장하는 대표적인 저장장치다.</li>
  <li>디스크 용량
    <ul>
      <li>기록밀도: 1인치의 트랙에 집어넣을 수 있는 비트의 수</li>
      <li>트랙밀도: 원판 중심에서 반지름의 1인치 길이에 넣을 수 있는 트랙의 수</li>
      <li>면적밀도: 기록밀도와 트랙밀도의 곱</li>
    </ul>
  </li>
  <li>디스크의 동작
    <ul>
      <li>탐색시간: 섹터의 내용을 읽기위해 헤드를 타깃 섹터를 보유한 트랙 위로 위치시키는 시간</li>
      <li>회전 지연시간: 헤드가 트랙 위에 위치하면 타깃 섹터의 첫번째 비트가 헤드 아래로 지나가는 것을 기다리는 시간.(헤드의 위치와 디스크의 회전 속도 모두 관련됨)</li>
      <li>전송시간: 하나의 섹터를 전송하는 시간(회전속도와 트랙당 섹터 수에 관련됨)</li>
    </ul>
  </li>
  <li>디스크 접근하기(디스크 섹터 읽기)
    <ol>
      <li>CPU는 명령어, 논리블록 번호, 목적지 메모리 주소를 디스크와 관련된 메모리 매핑한 주소에 써주어서 디스크 읽기를 개시한다.</li>
      <li>디스크 컨트롤러는 이 섹터를 읽고 메인메모리로 DMA 전송을 수행한다.</li>
      <li>DMA 전송이 완료될 때, 디스크 컨트롤러는 CPU에 인터럽트로 알려준다.</li>
    </ol>
  </li>
</ul>

<h1 id="62-지역성">6.2 지역성</h1>
<ul>
  <li>잘 작성한 컴퓨터 프로그램은 좋은 지역성locality를 보여준다.
    <ul>
      <li>최근에 참조했던 데이터 아이템 근처의 데이터 아이템이나 최근에 자신을 참조했던 데이터 아이템을 참조하려는 경향이 있다.</li>
    </ul>
  </li>
  <li>지역성은 두가지 형태가 있다.
    <ul>
      <li>시간 지역성 : 한번 참조된 메모리 위치는 여러 번 참조될 가능성이 높다.</li>
      <li>공간 지역성 : 한번 참조된 메모리는 근처의 메모리 위치를 참조할 가능성이 높다.</li>
    </ul>
  </li>
  <li>캐시 메모리 : 가장 최근에 참조한 인스트럭션과 데이터 아이템의 블록을 저장
    <ul>
      <li>캐시 메모리라는 작고 빠른 메모리를 도입하여 메인메모리를 빠르게 돌릴 수 있게 됐다.</li>
    </ul>
  </li>
</ul>

<h2 id="611-프로그램-데이터-참조의-지역성">6.1.1 프로그램 데이터 참조의 지역성</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="63-메모리-계층구조">6.3 메모리 계층구조</h1>
:ET