I"E&<h1 id="2-정보의-표현과-처리">2 정보의 표현과 처리</h1>
<blockquote>
  <p>컴퓨터가 실제로 해석하는 비트들과 연산들이 무엇이 있는지 배운다.</p>
</blockquote>

<ul>
  <li>컴퓨터는 두 개의 값을 갖는 신호로 정보를 처리한다.</li>
  <li>이러한 비트를 이진수 체계를 사용해서 양수들로 인코딩하여 사용한다.
    <ul>
      <li>비부호형</li>
      <li>부호형(2의 보수)</li>
      <li>부동소수점</li>
    </ul>
  </li>
</ul>

<h2 id="정보의-저장">정보의 저장</h2>
<ul>
  <li>2진수: 컴퓨터의 비트 표현</li>
  <li>16진수: 비트 패턴을 표시하는데 사용됨(2진수와 10진수는 불편함)</li>
  <li>비트 표시 방법(xw-1,xw-2,…,x1,x0)
    <ul>
      <li>리틀 엔디안: 가장 덜 중요한 바이트가 먼저 온다.(x0,x1…)</li>
      <li>빅 엔디안: 가장 중요한 바이트가 먼저 온다.(xw-1,xw-2…)</li>
    </ul>
  </li>
  <li>비트 수준 연산
    <ul>
      <li>부울 대수: <code class="language-plaintext highlighter-rouge">~</code>(not),<code class="language-plaintext highlighter-rouge">&amp;</code>(and),<code class="language-plaintext highlighter-rouge">|</code>(or),<code class="language-plaintext highlighter-rouge">^</code>(exclusive-or)</li>
      <li>쉬프트
        <ul>
          <li>좌측 쉬프트: « 우측에는 k개의 0 채워짐</li>
          <li>논리 우측 쉬프트 » 좌측에는 k개의 0 채워짐</li>
          <li>산술 우측 쉬프트 » 좌측에는 k개의 중요한 비트들이 채워짐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="정수의-표시">정수의 표시</h2>
<blockquote>
  <p>비부호형과 부호형(2의보수)의 표현 방법에 차이점에 포인트를 두어야 한다.</p>
</blockquote>

<ul>
  <li>부호형(2의 보수) : 맨 앞자리의 비트가 0이면 양수, 1이면 음수로 표현한다.
    <ul>
      <li>ex) 1101 -&gt; 앞자리가 1이므로 -8, 앞자리를 제외한 값이 5 -&gt; -8+5=-3 이렇게 계산한다.</li>
    </ul>
  </li>
  <li>비부호형과 부호형 간의 변환과 확장, 절삭에서 부호형의 오버플로우가 발생한다.</li>
</ul>

<h2 id="정수의-계산">정수의 계산</h2>
<ul>
  <li>부호형의 덧셈, 곱셈에서 음의 오버플로우와 양의 오버플로우가 발생한다.</li>
  <li>쉬프트를 사용해서 곱셈이 가능하다.(비용이 훨씬 적게 듬)
    <ul>
      <li>ex) 11(1011[2])*4 = 44(101100[2])</li>
    </ul>
  </li>
</ul>

<h2 id="부동소수점">부동소수점</h2>
<ul>
  <li>부동소수점 V = x*2^y 형태로 인코딩한다. y는 1/2, 1/4… 와 같은 값</li>
  <li>근사법 rounding
    <ul>
      <li>부동소수점은 정확한 값을 얻을 수 없다. 그렇기 때문에 근사 연산을 한다.
        <ul>
          <li>짝수근사법, 영방향근사, 하향근사, 상향근사 모드가 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="3-프로그램의-기계수준-표현">3 프로그램의 기계수준 표현</h1>
<blockquote>
  <p>우리가 코드를 작성하면 컴파일러는 소스파일의 어셈블러 버전을 생성한다. 어셈블러는 해당 어셈블리 코드를 바이너리 목적코드로 변환한다. 이후 목적코드를 컴퓨터가 해석한다.
이번 챕터에서는 어셈블리 코드에 대해 배운다. 이것을 배우게 되면 컴파일러의 최적화 방법을 알 수 있고 코드의 비효율성을 분석할 수 있게된다.</p>
</blockquote>

<h2 id="프로그램의-인코딩">프로그램의 인코딩</h2>
<ul>
  <li>프로그램 호출방법(c언어 기)
    <ol>
      <li>C 전처리가 #include와 #define을 확장해준다.</li>
      <li>컴파일러는 소스파일의 어셈블리 코드를 생성한다.(test.c -&gt; test.s)</li>
      <li>어셈블러는 어셈블리 코드를 바이너리 목적코드로 변환한다.(test.s -&gt; test.o)</li>
      <li>링커가 목적코드를 라이브러리 함수와 함꼐 최종 실행 파일인 test.p를 생성한다.</li>
    </ol>
  </li>
  <li>ISA(Instruction Set Architecture): 인스트럭션 집합구조, 프로세서의 상태 및 인스트럭션 형식과 영향을 정의한다.</li>
  <li>인스트럭션 특성 요약
    <ul>
      <li>오퍼랜드: 데이터와 목적지 위치를 명시한다.</li>
      <li>레지스터나 메모리로부터 읽고 저장한다.</li>
      <li>immediate(상수값), register, memory 세가지 타입이 존재한다.</li>
    </ul>
  </li>
</ul>

<h2 id="인스트럭션-종류">인스트럭션 종류</h2>
<ul>
  <li>데이터 이동: mov
    <ul>
      <li>두 개의 오퍼랜드 모두 메모리 위치에 올 수 없다.</li>
    </ul>
  </li>
  <li>스택의 저장과 추출: push, pop</li>
  <li>산술연산: add, sub, imul, idiv, sal(left shift), inc(++1), or, and…</li>
  <li>유효주소 적재: leaq
    <ul>
      <li>포인터 생성하기 위한 인스트럭션</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">조건코드</code>: CF(carry flag), ZF(zero flag), SF(sign flag), OF(overflow flag)
    <ul>
      <li>cf: 중요한 비트로부터 받아올림이 발생한 것을 표시(오버플로우 검출)</li>
    </ul>
  </li>
  <li>제어문: cmp, test, set
    <ul>
      <li>cmp는 두 오퍼랜드가 같으면 zf를 1로 설정</li>
      <li>test는 조건 코드만 설정</li>
      <li>set은 비교후 조건코드를 설정해줌</li>
    </ul>
  </li>
  <li>점프: jmp, je, jle…</li>
  <li>조건부 이동: cmove, cmovg…</li>
  <li>콜 리턴: call, ret</li>
</ul>

<h2 id="조건부-분기if-else">조건부 분기(if else)</h2>
<ul>
  <li>조건제어: cmp와 jump를 사용함</li>
  <li>조건부이동: cmove등을 사용함(더 빠름)
    <ul>
      <li>경우를 다 계산하고 이동만함</li>
    </ul>
  </li>
</ul>

<h2 id="반복문for-while">반복문(for, while)</h2>
<ul>
  <li>cmp와 jump를 사용</li>
</ul>

<h2 id="프로시저">프로시저</h2>
<ul>
  <li>call: call하게 되면 이전 주소와 함께 스택 메모리에 올라감</li>
  <li>return: 후입선출 구조이기 때문에 스택에 있던 이전 주소가 pop되며 retrun 하게됨</li>
  <li>데이터 전송: 인자는 레지스터로 전송되지만, 6개 이상의 인자를 가지면 초과되는 인자는 스택으로 전달된다.</li>
  <li>지역 변수: 지역변수 또한 스택 프레임 내에서 생성된다.</li>
  <li>레지스터: 레지스터는 프로시저 모두가 굥유함. 기존에 사용하던 레지스터를 새로 호출한 함수에서 “saved registers”라는 스택의 일부분을 할당해서 저장하고 보존한다.</li>
</ul>

<p><img src="../../assets/img/csapp/22/img_1.png" width="50%" height="100%" /></p>

<h2 id="데이터의-정렬">데이터의 정렬</h2>
<ul>
  <li>사용 가능한 주소를 k의 배수가 되도록 요구한다.</li>
</ul>

<p><img src="../../assets/img/csapp/22/img.png" width="50%" height="100%" /></p>

<h2 id="버퍼-오버플로우">버퍼 오버플로우</h2>
<ul>
  <li>스택의 saved registers와 return address 범위를 침범하면 심각한 오류를 발생시킨다.</li>
  <li>대응 방법
    <ul>
      <li>스택 랜덤화: 스택의 위치를 프로그램 실행마다 다르게 해준다.</li>
      <li>스택 손상 검출: 스택에 canary값을 추가하여 손상되는 것을 감지한다.</li>
      <li>실행코드 영역 제한</li>
    </ul>
  </li>
</ul>

<h2 id="부동소수점-1">부동소수점</h2>
<ul>
  <li>정수 연산과 유사하다.</li>
  <li>부동소수점을 위한 레지스터를 따로 사용한다.</li>
</ul>

<h1 id="4-프로세서-구조">4 프로세서 구조</h1>
<blockquote>
  <p>하드웨어 시스템이 ISA의 인스트럭션들을 어떻게 실행할 수 있는지를 학습한다. ISA인 “Y86-64”를 직접 만들어보며 학습한다.
이후 SEQ를 기초로 파이프라인형 프로세서 PIPE를 만들어본다. 프로세서는 각 인스트럭션의 실행단계를 5단계로 나누어 처리한다.</p>
</blockquote>

<ul>
  <li>프로그래머-가시성 상태(programmer-visible state) : 프로그램 레지스터, CC(조건코드), PC, 메모리, Stat(상태코드)를 포함한다.</li>
</ul>

<h2 id="인스트럭션-집합y86-64">인스트럭션 집합(Y86-64)</h2>

<p><img src="../../assets/img/csapp/22/img_2.png" width="70%" height="100%" /></p>
<ul>
  <li>위의 그림처럼 인스트럭션이 인코딩된다.
    <ul>
      <li>인코딩에 1에서 10바이트가 소요된다.</li>
      <li>OPq는 정수연산이며 ZF,SF,OF 조건코드를 결정한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/22/img_3.png" width="70%" height="100%" /></p>
<ul>
  <li>위의 그림처럼 인스트럭션에 대한 상세한 특정 인코딩으로 변환된다.</li>
</ul>

<h2 id="예외상황y86-64">예외상황(Y86-64)</h2>
<ul>
  <li>Stat(상태코드)를 나타낸다.
    <ul>
      <li>AOK: 정상 실행</li>
      <li>HLT: halt 인스트럭션 실행(정지 인스트럭션)</li>
      <li>ADR: 잘못된 메모리 주소를 읽거나 쓸 때</li>
      <li>INS: 잘못된 인스트럭션을 만났을 때</li>
    </ul>
  </li>
</ul>

<h2 id="어셈블러를-사용해-어셈블한-결과--목적코드">어셈블러를 사용해 어셈블한 결과 == 목적코드</h2>

<p><img src="../../assets/img/csapp/22/img_4.png" width="70%" height="100%" /></p>

<h2 id="seq-설계">SEQ 설계</h2>
<blockquote>
  <p>SEQ는</p>
  <h1 id="프로그램-성능-최적화하기">프로그램 성능 최적화하기</h1>
  <h1 id="메모리-계층구조">메모리 계층구조</h1>
</blockquote>
:ET