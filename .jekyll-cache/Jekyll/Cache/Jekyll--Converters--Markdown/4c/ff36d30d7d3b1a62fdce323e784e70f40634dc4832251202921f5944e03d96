I""<h1 id="1-스케줄링-개요">1. 스케줄링: 개요</h1>
<p>이전 포스트에서는 프로세스를 실행시키기 위한 문맥 교환 등의 저수준 <strong>기법</strong>에 대해서 설명하였다.
이번 포스트에서는 운영체제 스케줄러의 고수준 <strong>정책</strong>에 관한 이야기다.</p>

<h2 id="11-워크로드에-대한-가정">1.1 워크로드에 대한 가정</h2>
<ul>
  <li>프로세스가 동작하는 일련의 행위를 <strong>워크로드(workload)</strong>라 한다.
    <ul>
      <li>적절한 워크로드의 선정은 스케줄링 정책 개발에 매우 중요한 부분이다.</li>
    </ul>
  </li>
  <li>스케줄러의 종류를 임의로 세가지로 구분한다.
    <ul>
      <li>기본 스케줄러
        <ul>
          <li>선입선출(FIFO)</li>
          <li>최단 작업 우선(SJF, Shortest Job First)</li>
          <li>최소 잔여시간 우선(STCF, Shortest Time-to-Completion First)</li>
          <li>라운드 로빈(RR, Round-Robin)</li>
        </ul>
      </li>
      <li>멀티 레벨 피드백 큐(MLFQ)</li>
      <li>비례 볘분 or 공정 배분
        <ul>
          <li>추첨 스케줄링(lottery scheduling)</li>
          <li>보폭 스케줄링(stride scheduling)</li>
          <li>리눅스 CFS(Completely Fair Scheduler)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="2-기본-스케줄러">2. 기본 스케줄러</h1>

<h2 id="21-선입선출fifo">2.1 선입선출(FIFO)</h2>
<ul>
  <li>먼저 도착한 프로세스를 우선적으로 스케줄링 한다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_1.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 FIFO의 간단한 예이다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_2.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 FIFO의 단점을 보여주는 예이다.
    <ul>
      <li>긴 실행 시간을 가진 A가 먼저 도착했기 때문에 전체 평균 반환 시간이 110초로 늘어났다.</li>
      <li>만약 B, C를 먼저 해결한다면 전체 평균 반환 시간은 대폭 줄어들 것이다.</li>
      <li>해당 현상을 convoy effect 라고 부르며 CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상을 말한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>반환시간은 작업이 완료된 시각에서 작업이 도착한 시각을 뺀 시각이다.</p>
</blockquote>

<h2 id="22-최단-작업-우선sjf">2.2 최단 작업 우선(SJF)</h2>
<ul>
  <li>앞서 소개한 convoy effect는 최단 작업 우선 스케줄링으로 간단하게 해결할 수 있다.</li>
  <li>가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_3.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 SJF의 간단한 예이다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_4.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 SJ의 단점을 보여주는 예이다.
    <ul>
      <li>긴 실행 시간을 가진 A가 실행중에 B,C가 도착했기 때문에 convoy 문제가 다시 발생한다.</li>
    </ul>
  </li>
</ul>

<h2 id="23-최소-잔여시간-우선stcf">2.3 최소 잔여시간 우선(STCF)</h2>
<ul>
  <li>SJF에 선점 기능을 추가한 스케줄러다.
    <ul>
      <li>현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_5.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 STCF의 간단한 예이다.</li>
</ul>

<h2 id="24-라운드-로빈rr">2.4 라운드 로빈(RR)</h2>
<blockquote>
  <p>FIFO, SJF, STCF는 모두 평가 기준을 반환 시간인 스케줄러이다. RR은 스케줄러의 응답 시간 평가 기준을 추가한 기법이다.</p>
</blockquote>

<ul>
  <li>RR은 프로세스의 작업이 끝날 때 까지 기다리지 않는다. 대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.
    <ul>
      <li>이때 작업이 실행되는 일정 시간을 <strong>타임 슬라이스(time slice)</strong> 또는 <strong>스케줄링 퀀텀(scheduling quantum)</strong>이라 부른다.</li>
      <li>RR은 때때로 <strong>타임 슬라이싱</strong>이라고 불린다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_6.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 SJF 스케줄링이다. 응답 시간이 좋지 않다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_7.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 RR 스케줄링이다. 응답 시간이 좋다.</li>
</ul>

<blockquote>
  <p>SJF, STCF, RR 모두 프로세스의 미래 동작을 예측해야 가능한 스케줄링이다. 하지만, 실제로 프로세서가 미래동작을 예측하는데 있어 많은 어려움이 있다. 
이를 해결하기 위해 과거의 프로세스 동작 이력을 반영하는 방식으로 해결한다. 해당 스케줄러는 멀티 레벨 피드백 큐이다.</p>
</blockquote>

<h1 id="3-멀티-레벨-피드백-큐mlfq">3. 멀티 레벨 피드백 큐(MLFQ)</h1>
<ul>
  <li>MLFQ가 해결하려고 하는 기본적인 문제는 두 가지이다.
    <ol>
      <li>짧은 작업을 먼저 실행시켜 <strong>반환 시간</strong>을 최적화하고자 한다.</li>
      <li>MLFQ는 대화형 사용자를 위해 <strong>응답 시간</strong>을 최적화한다.</li>
    </ol>
  </li>
</ul>

<h2 id="31-mlfq-기본-규칙">3.1 MLFQ: 기본 규칙</h2>
<ul>
  <li>MLFQ는 여러 개의 <strong>큐</strong>로 구성되며, 각각 다른 <strong>우선순위(priority level)</strong>가 배정된다.
    <ul>
      <li>실행할 프로세스를 결정하기 위하여 우선순위를 사용한다.</li>
    </ul>
  </li>
  <li>큐에 둘 이상의 작입어 존재하면 RR 스케줄링 알고리즘이 사용된다.</li>
  <li>
    <p>고정된 우선순위를 부여하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다.</p>
  </li>
  <li>규칙
    <ol>
      <li>Priority(A) &gt; Priority(B) 이면, A가 실행된다.</li>
      <li>Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행한다.</li>
      <li>작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다.</li>
      <li>주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다.</li>
      <li>타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다.</li>
    </ol>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_8.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 규칙 4번을 보여준다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_9.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 규칙 3번을 보여준다.
    <ul>
      <li>A가 제일 낮은 우선순위에서 실행 되는 동안, B가 새로 들어옴으로써 가장 높은 우선순위에 할당된다. 이후 타임 슬라이스를 소모해가며 우선순위가 낮아진다.</li>
    </ul>
  </li>
</ul>

<h2 id="32-위의-규칙으로-인한-mlfq의-문제">3.2 위의 규칙으로 인한 MLFQ의 문제</h2>
<ul>
  <li>두가지 문제가 있다.
    <ol>
      <li>규칙 5번에 의해 기아 상태가 발생할 수 있다.</li>
      <li>타임 슬라이스의 99퍼를 사용하고 강제로 입출력을 주어서 프로세서를 악의적으로 독점할 수 있다.</li>
    </ol>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_10.png" width="50%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 기아 상태의 예이다. A(검정색)이 반복되는 입출력 작업으로 인해 실행되지 않는 모습을 보여준다.</p>
  </li>
  <li>
    <p>첫번째 문제는 <strong>상향 조정(boost)</strong>를 사용하는 것이다.</p>
    <ul>
      <li>일정 시간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_11.png" width="50%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 boost의 예이다.</p>
  </li>
  <li>
    <p>두번째 문제는 CPU 총 사용 시간을 <strong>측정</strong> 하여 일정 CPU 시간을 소진하면 다음 우선순위 큐로 강등시킨다.</p>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_12.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 CPU 사용 시간 측정의 예이다.</li>
</ul>

:ET