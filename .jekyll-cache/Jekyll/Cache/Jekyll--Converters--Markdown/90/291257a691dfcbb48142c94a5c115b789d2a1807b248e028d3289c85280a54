I"<h1 id="chapter-09-가상메모리">Chapter 09 가상메모리</h1>
<ol>
  <li>물리 및 가상주소 방식</li>
  <li>주소공간</li>
  <li>캐싱 도구로서의 VM</li>
  <li>메모리 관리를 위한 도구로서의 VM</li>
  <li>메모리 보호를 위한 도구로서의 VM</li>
  <li>주소의 번역</li>
  <li>사례 연구: 인텔 코어 i7/리눅스 메모리 시스템</li>
  <li>메모리 매핑</li>
  <li>동적 메모리 할당</li>
  <li>가비지 컬렉션</li>
  <li>C 프로그램에서의 공통된 메모리 관련 버그</li>
  <li>요약</li>
</ol>

<h1 id="98-메모리-매핑">9.8 메모리 매핑</h1>
<ul>
  <li>매핑: 리눅스는 가상메모리 영역의 내용을 디스크의 객체에 연결해서 초기화한다.</li>
  <li>영역들은 다음 두 종류의 객체 중의 하나로 매핑될 수 있다.
    <ol>
      <li>리눅스 파일 시스템 내의 일반 파일: 한 영역은 실행가능 목적파일과 같은 일반 디스크 파일의 연속적인 섹션으로 매핑될 수 있다.</li>
      <li>무기명 파일: 한 영역은 또한 무기명 파일로 매핑될 수 있다.</li>
    </ol>
  </li>
  <li>가상페이지가 초기화된 후에는 커널이 관리하는 특별한 <strong>스왑 파일</strong> 사이에서 스왑 인되었다가 아웃되었다가 한다.
    <ul>
      <li>스왑 파일은 스왑 공간 또는 스왑 영역이라고도 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="981-다시-보는-공유-객체">9.8.1 다시 보는 공유 객체</h2>
<ul>
  <li>메모리 매핑에 대한 아이디어는 만일 가상메모리 시스템이 보통의 파일 시스템과 통합될 수 있다면, 단순하고 효과적으로 프로그램과 데이터를 메모리에 로드할 수 있을 것이라는 기발한 
생각에서 생겨났다.</li>
  <li>프로세스 개념은 각 프로세스에 자신만의 가상 주소공간을 제공하며, 이것은 다른 프로세스들에 의해 잘못된 쓰기와 읽기 작업이 발생하는 것을 막아준다.</li>
  <li>객체는 공유 가상메모리 영역으로 공유 객체 또는 사적private 개체로 매핑될 수 있따.
    <ul>
      <li>공유 객체에 매핑: 프로세스가 해당 영역에 쓰는 모든 내용은 자신의 공유 메모리 내로 객체를 매핑한 다른 프로세스들도 볼 수 있게 한다. 변경된 내용은 디스크 상의 원래의 객체에도 반영된다.</li>
      <li>사적 객체에 매핑: 해당 영역에 가한 수정사항들은 다른 프로세스들은 볼 수 없다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/26/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림은 공유 객체이다.</li>
</ul>

<p><img src="../../assets/img/csapp/26/img_1.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 사적 copy-on-write 객체이다.
    <ul>
      <li>사적 객체들은 <strong>copy-on-write</strong>라고 알려진 기법을 사용해서 가상메모리에 매핑된다.</li>
      <li>공유된 객체에 다른 프로세스가 쓰기 작업을 하게 되면 새로운 사본을 물리페이지 내에 만들고 해 사본을 가르키게 한다.</li>
      <li>copy-on-write는 마지막 가능한 순간까지 사적 객체 내에서 페이지를 복사하는 것을 지연시켜서 부족한 물리 메모리를 가장 효율적으로 사용한다.</li>
    </ul>
  </li>
</ul>

<h2 id="982-다시-보는-fork-함수">9.8.2 다시 보는 fork 함수</h2>
<ul>
  <li>현재 프로세스가 fork 함수를 호출하면, 커널은 새로운 프로세스를 위한 여러가지 자료 구조를 생성하고, 여기에 고유한 PID를 부여한다.</li>
  <li>새 프로세스를 위한 가상메모리를 생성하기 위해 현재 프로세스의 mm_struct, 영역 구조체, 페이지 테이블과 동일한 사본을 만든다.</li>
  <li>두 프로세스의 모든 페이지들을 읽기-허용으로 표시하고, 두 프로세스의 영역 구조체들을 사적 copy-on-write로 표시한다.</li>
</ul>

<h2 id="983-다시-보는-execve-함수">9.8.3 다시 보는 execve 함수</h2>
<ul>
  <li>가상메모리와 메모리 매핑은 또한 프로그램을 메모리로 로딩하는 과정에서 중요한 역할을 한다.</li>
  <li>execve 함수는 현재 프로세스 내에서 현재 프로그램을 효과적으로 교체하면서 실행 목적파일에 포함된 프로그램을 실행하고 로드한다.
    <ol>
      <li>기존 사용자 영역을 제거한다.</li>
      <li>사적 영역을 매핑한다. copy-on-write형식을 사용한다.</li>
      <li>공유 영역을 매핑한다.</li>
      <li>프로그램 카운터를 설정한다.</li>
    </ol>
  </li>
</ul>

<h2 id="984-함수를-이용한-사용자수준-메모리-매핑">9.8.4 함수를 이용한 사용자수준 메모리 매핑</h2>
<ul>
  <li>리눅스 프로세스들은 함수를 이용해서 가상메모리의 새로운 영역들을 만들 수 있으며, 객체들을 이 영역으로 매핑할 수 있다.</li>
  <li>mmap 함수: 커널에 새 가상메모리 영역을 생성해 줄 것을 요청</li>
</ul>

<p><img src="../../assets/img/csapp/26/img_2.png" width="50%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 mmap 인자의 시각적 해석</p>
  </li>
  <li>nunmap 함수: 가상메모리의 영역들을 삭제한다.
    <h1 id="99-동적-메모리-할당">9.9 동적 메모리 할당</h1>
  </li>
  <li><strong>동적 메모리 할당기</strong>을 사용하여 추가적인 가상메모리를 런타임에 획득한다.</li>
  <li>동적 메모리 할당기는 힙heap 이라고 하는 프로세스의 가상메모리 영역을 관리한다.
    <ul>
      <li>힙은 미초기화된 데이터 영역 직후에 시작해서 위쪽(높은 주소 방향)으로 커지는 무요구 메모리 영역이라고 가정한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/26/img_3.png" width="50%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 힙heap 이다.</p>
  </li>
  <li>
    <p>할당기는 힙을 다양한 크기의 블록들의 집합으로 관리한다.</p>
    <ul>
      <li>명시적 할당기: application이 명시적으로 할당된 블록을 반환해 줄 것을 요구한다. malloc 패키지.</li>
      <li>묵시적 할당기: 할당된 블록이 더 이상 프로그램에 의해 사용되지 않고 블록을 반환하는지를 할당기가 검출할 수 있을 것을 요구한다. 가비지 컬렉터garbage collector.</li>
    </ul>
  </li>
</ul>

<h2 id="991-malloc과-free함수">9.9.1 malloc과 free함수</h2>
<ul>
  <li>malloc 함수: 힙으로부터 블록들을 할당받는다.</li>
  <li>sbrk 함수: brk 포인터에 인자값(incr)을 더해서 힙을 늘리거나 줄인다.</li>
  <li></li>
</ul>

:ET