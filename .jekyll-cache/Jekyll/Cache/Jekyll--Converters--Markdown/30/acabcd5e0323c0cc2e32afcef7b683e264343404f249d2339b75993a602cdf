I"R8<h1 id="이코테">이코테</h1>

<h2 id="dfsbfs-미로-탈출python">DFS/BFS 미로 탈출(Python)</h2>

<h2 id="문제">문제</h2>

<p>N x M 크기의 미로가 있다.<br />
몬스터가 있는 곳은 0, 몬스터가 없는 곳은 1로 표시된다.<br />
몬스터를 피해서 (0,0) 좌표에서 (N,M) 좌표까지 탈출해야한다.<br />
이때 탈출까지의 최단 거리를 구하여라.</p>

<ul>
  <li>예시<br /></li>
</ul>

<p>입력 : <br />
    [1,0,1,0,1,0]<br />
    [1,0,1,1,1,1]<br />
    [1,0,1,1,1,0]<br />
    [1,0,1,0,1,0]<br />
    [1,1,1,0,1,1]<br />
결과 : 14</p>

<h2 id="풀이">풀이</h2>
<blockquote>
  <p>이 문제는 1이 연결된 길을 찾으면 되는 문제이다. 최단 거리를 구하기 위해서 현재 위치에서 근접한 1의 위치를 찾으면 된다. 그렇기 때문에 BFS로 접근하였다.
하지만, 관건은 근접한 1의 위치를 찾고 최단거리를 계산하는 방법이다.
1을 만나게 되면, 이전 노드의 정보를 더해주는 방식으로 (1,1) 좌표에서 특정 노드까지의 최단거리를 모두 저장해주면 된다.
이후 (N,M)에 저장되어 있는 정보를 출력하면 된다.</p>
</blockquote>

<h3 id="solution1">solution1</h3>
<ol>
  <li>탐색하기 위해 노드를 저장하는 deque 변수를 선언한다.
    <ul>
      <li>deque는 (x좌표,y좌표,해당노드까지의 최단 거리) 가 tuple 형식으로 저장된다.</li>
    </ul>
  </li>
  <li>deque가 비게 되면 탈출하게 되는 while문을 선언한다.</li>
  <li>반복문을 돌며 첫번째로 deque를 pop하여 각각 x,y,v에 저장한다.</li>
  <li>x와 y가 0보다 작거나 graph의 크기를 벗어나면 continue 해준다.</li>
  <li>graph의 x, y좌표가 1이라면, 해당 노드에 v 값을 더해준다.</li>
  <li>이후 deque에 해당 좌표 기준 상,하,좌,우 값을 추가하여 탐색할 수 있게 설정한다.</li>
  <li>반복문이 끝나면 graph의 N,M 좌표에 해당하는 value를 return한다.</li>
</ol>

<h3 id="solution2">solution2</h3>
<blockquote>
  <p>solution1과 로직은 같지만, solution2는 상하좌우를 배열에 저장하였고,
큐에는 x와 y좌표만 저장해두었다.</p>
</blockquote>

<h2 id="코드">코드</h2>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
    
    <span class="k">def</span> <span class="nf">solution1</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">n</span> <span class="ow">or</span> <span class="n">y</span><span class="o">&gt;=</span><span class="n">m</span> <span class="ow">or</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]))</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]))</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]))</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]))</span>
    
        <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    
    <span class="k">def</span> <span class="nf">solution2</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="c1"># 이동할 네 방향 정의(상, 하, 좌, 우)
</span>        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    
        <span class="c1"># graph 크기 정의
</span>        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
        <span class="c1"># BFS 소스코드 구현
</span>        <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    
            <span class="c1"># 큐(Queue) 구현을 위해 deque 라이브러리 사용
</span>            <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
            <span class="c1"># 큐가 빌 때까지 반복
</span>            <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1"># 현재 위치에서 네 방향으로의 위치 확인
</span>                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># 미로 찾기 공간을 벗어난 경우 무시
</span>                    <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># 벽인 경우 무시
</span>                    <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># 해당 노드를 처음 방문하는 경우에만 최단 거리 기록
</span>                    <span class="k">if</span> <span class="n">graph</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">graph</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
    
            <span class="c1"># 가장 오른쪽 아래까지의 최단 거리 반환
</span>            <span class="k">return</span> <span class="n">graph</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">bfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="n">solution1</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></code></pre></figure>
:ET