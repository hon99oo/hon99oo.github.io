I"r<h1 id="1-페이징-더-빠른-변환tlb">1. 페이징: 더 빠른 변환(TLB)</h1>
<ul>
  <li>페이징은 주소 공간을 작은 크기(페이지)로 나누고 각 페이지의 실제 위치(매핑 정보)를 메모리에 저장한다. 매핑 정보를 저장하는 자료 구조를 페이지 테이블이라 한다.</li>
  <li>페이징은 성능 저하를 유발할 수 있다.
    <ul>
      <li>가상 주소에서 물리 주소로의 주소 변환을 위해 메모리에 존재하는 매핑 정보를 읽어야 한다는 사실은 페이지 테이블 접근을 위한 메모리 읽기 작업이며 이는 엄청난 성능 저하를 유발한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>주소 변환을 빠르게 하기 위해서 우리는 <strong>변환-색인 버퍼(translation-lookaside buffer)</strong> 또는 <strong>TLB</strong>를 도입한다.
    <ul>
      <li>TLB는 칩의 <strong>메모리 관리부(memory-management unit, MMU)</strong>의 일부이다.</li>
      <li>자주 참조되는 VirtualMemory-PhysicalMemory 변환 정보를 저장하는 하드웨어 캐시이다.</li>
      <li>가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인한다. 만약 있다면 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 실질적으로 TLB는 페이징 성능을 엄청나게 향상시킨다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-tlb의-기본-알고리즘">1.1 TLB의 기본 알고리즘</h2>
<ul>
  <li>주소 변환부는 단순한 <strong>선형 페이지 테이블</strong>(배열로 이루어진 페이지 테이블) 과 <strong>하드웨어로 관리되는 TLB</strong>로 구성되어 있다.</li>
  <li>하드웨어 부분의 알고리즘은 다음과 같이 동작한다. (TLB Hit 과 Miss로 나뉨)</li>
  <li>TLB Hit
    <ol>
      <li>가상주소에서 가상 페이지 번호(virtual page nubmer, <strong>VPN</strong>)을 추출한 후, 해당 VPN을 TLB 존재 여부를 검사한다.</li>
      <li>만약 존재한다면 <strong>TLB 히트</strong>이고 TLB가 변환 값을 갖고 있다는 것을 뜻한다.</li>
      <li>해당 TLB 항목에서 페이지 프레임 번호(page fame number, PFN)을 추출한다.</li>
      <li>해당 페이지에 대한 접근 권한 검사가 성공하면</li>
      <li>그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소를 구성하고 메모리에 접근한다.</li>
    </ol>
  </li>
  <li>TLB Miss
    <ol>
      <li>위의 2번에서 TLB Miss되면</li>
      <li>하드웨어가 변환 정보를 찾기 위해서 페이지 테이블에 접근한다.</li>
      <li>프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면</li>
      <li>해당 변환정보를 TLB로 읽어들인다.(시간이 많이 소요되는 작업, 테이블 접근을 위한 메모리 참조 때문)</li>
      <li>TLB가 갱신되면 하드웨어는 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 때문에, 주소 변환 작업은 그다지 부담스러운 작업이아니다.</li>
  <li>TLB 미스가 많이 발생할수록 메모리 접근 횟수가 많아진다.
    <ul>
      <li>TLB 미스가 발생하는 경우를 최대한 피해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="12-예제-배열-접근">1.2 예제: 배열 접근</h2>

<p><img src="../../assets/img/ostep/07/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림과 같이 배열의 데이터가 저장되어 있다고 가정하자.
    <ul>
      <li>index 0부터 9까지 배열을 읽으면 index0을 읽을 때 TLB는 초기화 되어있기 때문에 TLB미스가 발생하고 VPN 06번 페이지를 TLB를 가져온다.</li>
      <li>이후 1번과 2번 index를 읽을 때는 TLB히트가 발생하여 바로 가져올 수 있다.</li>
      <li>다시 3번 index를 읽을 때는 TLB미스가 발생하여 VPN 07번 페이지를 TLB로 가져온다.</li>
    </ul>
  </li>
  <li>위의 예제를 통해 배열이 처음으로 접근되었지만, TLB는 <strong>공간 지역성</strong>으로 인해서 성능을 개선할 수 있다.</li>
  <li>만약 TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면 히트, 히트, 히트, 히트, … 히트 를 얻는다.
    <ul>
      <li>이 경우에는 <strong>시간 지역성</strong>으로 인해 TLB의 히트율이 높아진다.</li>
    </ul>
  </li>
  <li>프로그램이 공간 혹은 시간 지역성을 보이는 경우, TLB 사용 효과가 더욱 두드러지게 나타날 것이다.</li>
</ul>
:ET