I"<h1 id="1-하드-디스크-드라이브">1. 하드 디스크 드라이브</h1>
<ul>
  <li><strong>하드 디스크 드라이브</strong>는 수세기 동안 컴퓨터 시스템의 영구적인 데이터 저장소였으며 파일 시스템 기술은 거의 대부분 하드 디스크 드라이브의 동작에 기반을 두고 개발되었다.</li>
</ul>

<h2 id="11-인터페이스">1.1 인터페이스</h2>
<ul>
  <li>모든 현대 드라이브의 기본적인 인터페이스는 단순하다.</li>
  <li>드라이브는 읽고 쓸 수 있는 매우 많은 수의 섹터들로 이루어져 있다.
    <ul>
      <li>그렇기 때문에 디스크를 섹터들의 배열로 볼 수 있으며 0부터 n-1이 드라이브의 <strong>주소 공간</strong>이 된다.</li>
    </ul>
  </li>
  <li>디스크 드라이브의 “계약 불문율”
    <ul>
      <li>드라이브의 주소 공간에서 가깝게 배치되어 있는 두 개의 블럭을 접근하는 것은 멀리 떨어져 있는 두 개의 블럭을 접근하는 것보다 빠르다고 가정한다.</li>
      <li>연속적인 청크의 블럭을 접근하는 것(순차 읽기 쓰기)이 가장 빠르며 어떤 랜덤 접근 패턴보다 매우 빠르다는 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="12-기본-구조">1.2 기본 구조</h2>
<ul>
  <li><strong>플래터(platter)</strong>
    <ul>
      <li>원형의 딱딱한 표면을 갖고 있는 플래터에 자기적 성질을 변형하여 데이터를 지속시킨다.</li>
      <li>디스크는 하나 또는 그 이상의 플래터를 갖고 있으며 각각은 2개의 <strong>표면(surface)</strong>을 갖고 있다.</li>
    </ul>
  </li>
  <li><strong>회전축(spindle)</strong>
    <ul>
      <li>플래터들은 회전축이라는 것으로 고정되어 있는데, 이 축은 모터와 연결 되어 있어서 플래터를 일정한 속도로 회전시킨다.</li>
      <li>회전의 속도는 <strong>분당 회전 수(rotation per minute, RPM)</strong>로 측정된다.</li>
    </ul>
  </li>
  <li><strong>트랙(track)</strong>
    <ul>
      <li>각 표면에 동심원을 따라 배치되어 있는 섹터들 위에 데이터가 부호화된다. 이 때 동심원 하나를 트랙이라고 한다.</li>
    </ul>
  </li>
  <li><strong>디스크 헤드(disk head)</strong>
    <ul>
      <li>읽기와 쓰기 동작은 디스크 헤드를 통해 할 수 있고, 각 표면마다 헤드가 하나씩 존재한다.</li>
    </ul>
  </li>
  <li><strong>디스크 암(disk arm)</strong>
    <ul>
      <li>디스크 헤드는 디스크암에 연결이 되어 있으며 이것을 통해서 헤드가 원하는 트랙 위에 위치하도록 이동시킬 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="13-간단한-디스크-드라이브">1.3 간단한 디스크 드라이브</h2>
<p><img src="../../assets/img/ostep/15/img.png" width="30%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 트랙 하나와 헤드가 있는 디스크의 모습이다.</p>
  </li>
  <li>
    <p>트랙이 하나 뿐인 간단한 디스크에서 요청이 어떻게 처리되는지 알아보자.</p>
  </li>
</ul>

<h3 id="단일-트랙-지연-시간-회전-지연">단일 트랙 지연 시간: 회전 지연</h3>
<ul>
  <li>디스크 헤드 아래에 원하는 섹터가 위치하기를 기다린다.
    <ul>
      <li>이러한 기다림은 현대 드라이브에서도 흔하게 발생하며 I/O 서비스 시간에서 중요한 요소이기 때무에 <strong>회전형 지연(rotational delay)</strong> 때로는 <strong>회전 지연(rotation delay)</strong>라고도 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="멀티-트랙-탐색-시간">멀티 트랙: 탐색 시간</h3>
<p><img src="../../assets/img/ostep/15/img_1.png" width="80%" height="100%" /></p>
<ul>
  <li>읽기 요청을 처리하기 위해서 드라이브는 디스크 암을 먼저 올바른 트랙 위에 위치시킨다.
    <ul>
      <li>이 과정을 <strong>탐색(seek)</strong>이라고 한다.</li>
      <li>회전과 더불어서 탐색은 가장 비싼 디스크 동작 중 하나다.</li>
    </ul>
  </li>
  <li>탐색은 여러 단계로 되어 있다.
    <ol>
      <li>가속 단계로 디스크 암이 움직이기 시작한다.</li>
      <li>활주 단계로 디스크 암이 최고 속도로 움직인다.</li>
      <li>감속 단계 이후에 안정화 단계에서 정확한 트랙위에 헤드가 조심스럽게 위치하게 된다.
        <ul>
          <li>드라이브가 정확한 트랙 위에 확실히 위치해야 하기 때문에 <strong>안정화 시간(settling time)</strong>은 중요하다.</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h3 id="그-외의-세부-사항">그 외의 세부 사항</h3>
<p><img src="../../assets/img/ostep/15/img_2.png" width="80%" height="100%" /></p>
<ul>
  <li>위의 그림은 <strong>트랙 비틀림(track skew)</strong>이라 불리는 기술을 채용하여 트랙의 경계를 지나서 순차적으로 존재하는 섹터들을 올바르게 읽을 수 있게 한다.</li>
</ul>

<p><br /></p>
<ul>
  <li>바깥 측에 공간이 더 많다는 구조적인 이유 때문에 바깥 측 트랙들에는 안쪽 트랙들보다 더 많은 섹터들이 있다는 것이 현실이다.
    <ul>
      <li>이러한 트랙들은 흔히 <strong>멀티 구역(multi-zoned)</strong> 디스크 드라이브라고 부른다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>마지막으로 현대 디스크 드라이브의 가장 중요한 부분은 <strong>캐시(cache)</strong>로서, <strong>트랙 버퍼(track buffer)</strong>라고도 부른다.
    <ul>
      <li>작은 크기의 메모리로 드라이브가 디스크에서 읽거나 쓴 데이터를 보관하는 데 사용한다.</li>
    </ul>
  </li>
</ul>

<h2 id="14-디스크-스케줄링">1.4 디스크 스케줄링</h2>
<ul>
  <li>I/O 비용이 크기 때문에 운영체제는 디스크에게 요청되는 I/O의 순서를 결정하는 데에 중요 역할을 담당했다.
    <ul>
      <li>I/O 요청이 주어졌을 때 <strong>디스크 스케줄러</strong>는 요청을 조사하여 다음에 어떤 I/O를 처리할지 결정한다.</li>
    </ul>
  </li>
  <li>각 작업의 길이가 얼마나 될지 알 수 없는 작업 스케줄링과 다르게 디스크 스케줄링의 경우, 디스크 요청 작업이 얼마나 길지를 꽤 정확히 예측할 수 있다.
    <ul>
      <li>디스크 스케줄러는 <strong>SJF(shortest job first)</strong>의 원칙을 따르려고 노력한다.</li>
    </ul>
  </li>
</ul>

<h3 id="sstf-최단-탐색-시간-우선">SSTF: 최단 탐색 시간 우선</h3>
:ET