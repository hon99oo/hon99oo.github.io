I"b<h1 id="1-페이징-더-빠른-변환tlb">1. 페이징: 더 빠른 변환(TLB)</h1>
<ul>
  <li>페이징은 주소 공간을 작은 크기(페이지)로 나누고 각 페이지의 실제 위치(매핑 정보)를 메모리에 저장한다. 매핑 정보를 저장하는 자료 구조를 페이지 테이블이라 한다.</li>
  <li>페이징은 성능 저하를 유발할 수 있다.
    <ul>
      <li>가상 주소에서 물리 주소로의 주소 변환을 위해 메모리에 존재하는 매핑 정보를 읽어야 한다는 사실은 페이지 테이블 접근을 위한 메모리 읽기 작업이며 이는 엄청난 성능 저하를 유발한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>주소 변환을 빠르게 하기 위해서 우리는 <strong>변환-색인 버퍼(translation-lookaside buffer)</strong> 또는 <strong>TLB</strong>를 도입한다.
    <ul>
      <li>TLB는 칩의 <strong>메모리 관리부(memory-management unit, MMU)</strong>의 일부이다.</li>
      <li>자주 참조되는 VirtualMemory-PhysicalMemory 변환 정보를 저장하는 하드웨어 캐시이다.</li>
      <li>가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인한다. 만약 있다면 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 실질적으로 TLB는 페이징 성능을 엄청나게 향상시킨다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-tlb의-기본-알고리즘">1.1 TLB의 기본 알고리즘</h2>
<ul>
  <li>주소 변환부는 단순한 <strong>선형 페이지 테이블</strong>(배열로 이루어진 페이지 테이블) 과 <strong>하드웨어로 관리되는 TLB</strong>로 구성되어 있다.</li>
  <li>하드웨어 부분의 알고리즘은 다음과 같이 동작한다. (TLB Hit 과 Miss로 나뉨)</li>
  <li>TLB Hit
    <ol>
      <li>가상주소에서 가상 페이지 번호(virtual page nubmer, <strong>VPN</strong>)을 추출한 후, 해당 VPN을 TLB 존재 여부를 검사한다.</li>
      <li>만약 존재한다면 <strong>TLB 히트</strong>이고 TLB가 변환 값을 갖고 있다는 것을 뜻한다.</li>
      <li>해당 TLB 항목에서 페이지 프레임 번호(page fame number, PFN)을 추출한다.</li>
      <li>해당 페이지에 대한 접근 권한 검사가 성공하면</li>
      <li>그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소를 구성하고 메모리에 접근한다.</li>
    </ol>
  </li>
  <li>TLB Miss
    <ol>
      <li>위의 2번에서 TLB Miss되면</li>
      <li>하드웨어가 변환 정보를 찾기 위해서 페이지 테이블에 접근한다.</li>
      <li>프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면</li>
      <li>해당 변환정보를 TLB로 읽어들인다.(시간이 많이 소요되는 작업, 테이블 접근을 위한 메모리 참조 때문)</li>
      <li>TLB가 갱신되면 하드웨어는 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 때문에, 주소 변환 작업은 그다지 부담스러운 작업이아니다.</li>
  <li>TLB 미스가 많이 발생할수록 메모리 접근 횟수가 많아진다.
    <ul>
      <li>TLB 미스가 발생하는 경우를 최대한 피해야 한다.</li>
    </ul>
  </li>
</ul>
:ET