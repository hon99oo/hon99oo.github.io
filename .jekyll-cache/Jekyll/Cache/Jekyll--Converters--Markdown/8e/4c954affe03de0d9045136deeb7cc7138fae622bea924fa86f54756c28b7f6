I"R6<h1 id="1-페이징-더-빠른-변환tlb">1. 페이징: 더 빠른 변환(TLB)</h1>
<ul>
  <li>페이징은 주소 공간을 작은 크기(페이지)로 나누고 각 페이지의 실제 위치(매핑 정보)를 메모리에 저장한다. 매핑 정보를 저장하는 자료 구조를 페이지 테이블이라 한다.</li>
  <li>페이징은 성능 저하를 유발할 수 있다.
    <ul>
      <li>가상 주소에서 물리 주소로의 주소 변환을 위해 메모리에 존재하는 매핑 정보를 읽어야 한다는 사실은 페이지 테이블 접근을 위한 메모리 읽기 작업이며 이는 엄청난 성능 저하를 유발한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>주소 변환을 빠르게 하기 위해서 우리는 <strong>변환-색인 버퍼(translation-lookaside buffer)</strong> 또는 <strong>TLB</strong>를 도입한다.
    <ul>
      <li>TLB는 칩의 <strong>메모리 관리부(memory-management unit, MMU)</strong>의 일부이다.</li>
      <li>자주 참조되는 VirtualMemory-PhysicalMemory 변환 정보를 저장하는 하드웨어 캐시이다.</li>
      <li>가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인한다. 만약 있다면 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 실질적으로 TLB는 페이징 성능을 엄청나게 향상시킨다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-tlb의-기본-알고리즘">1.1 TLB의 기본 알고리즘</h2>
<ul>
  <li>주소 변환부는 단순한 <strong>선형 페이지 테이블</strong>(배열로 이루어진 페이지 테이블) 과 <strong>하드웨어로 관리되는 TLB</strong>로 구성되어 있다.</li>
  <li>하드웨어 부분의 알고리즘은 다음과 같이 동작한다. (TLB Hit 과 Miss로 나뉨)</li>
  <li>TLB Hit
    <ol>
      <li>가상주소에서 가상 페이지 번호(virtual page nubmer, <strong>VPN</strong>)을 추출한 후, 해당 VPN을 TLB 존재 여부를 검사한다.</li>
      <li>만약 존재한다면 <strong>TLB 히트</strong>이고 TLB가 변환 값을 갖고 있다는 것을 뜻한다.</li>
      <li>해당 TLB 항목에서 페이지 프레임 번호(page fame number, PFN)을 추출한다.</li>
      <li>해당 페이지에 대한 접근 권한 검사가 성공하면</li>
      <li>그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소를 구성하고 메모리에 접근한다.</li>
    </ol>
  </li>
  <li>TLB Miss
    <ol>
      <li>위의 2번에서 TLB Miss되면</li>
      <li>하드웨어가 변환 정보를 찾기 위해서 페이지 테이블에 접근한다.</li>
      <li>프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면</li>
      <li>해당 변환정보를 TLB로 읽어들인다.(시간이 많이 소요되는 작업, 테이블 접근을 위한 메모리 참조 때문)</li>
      <li>TLB가 갱신되면 하드웨어는 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 때문에, 주소 변환 작업은 그다지 부담스러운 작업이아니다.</li>
  <li>TLB 미스가 많이 발생할수록 메모리 접근 횟수가 많아진다.
    <ul>
      <li>TLB 미스가 발생하는 경우를 최대한 피해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="12-예제-배열-접근">1.2 예제: 배열 접근</h2>

<p><img src="../../assets/img/ostep/07/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림과 같이 배열의 데이터가 저장되어 있다고 가정하자.
    <ul>
      <li>index 0부터 9까지 배열을 읽으면 index0을 읽을 때 TLB는 초기화 되어있기 때문에 TLB미스가 발생하고 VPN 06번 페이지를 TLB를 가져온다.</li>
      <li>이후 1번과 2번 index를 읽을 때는 TLB히트가 발생하여 바로 가져올 수 있다.</li>
      <li>다시 3번 index를 읽을 때는 TLB미스가 발생하여 VPN 07번 페이지를 TLB로 가져온다.</li>
    </ul>
  </li>
  <li>위의 예제를 통해 배열이 처음으로 접근되었지만, TLB는 <strong>공간 지역성</strong>으로 인해서 성능을 개선할 수 있다.</li>
  <li>만약 TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면 히트, 히트, 히트, 히트, … 히트 를 얻는다.
    <ul>
      <li>이 경우에는 <strong>시간 지역성</strong>으로 인해 TLB의 히트율이 높아진다.</li>
    </ul>
  </li>
  <li>프로그램이 공간 혹은 시간 지역성을 보이는 경우, TLB 사용 효과가 더욱 두드러지게 나타날 것이다.</li>
</ul>

<h2 id="13-tlb-미스는-누가-처리할까">1.3 TLB 미스는 누가 처리할까</h2>
<ul>
  <li>TLB 미스의 처리는 두 가지 방법이 있다.
    <ul>
      <li>하드웨어와 소프트웨어이다.</li>
    </ul>
  </li>
</ul>

<h3 id="cisccomplex-instruction-set-computers-tlb-미스를-하드웨어가-처리하도록-설계">CISC(complex-instruction set computers): TLB 미스를 하드웨어가 처리하도록 설계</h3>
<ul>
  <li>이를 위해서 하드웨어가 페이지 테이블에 대한 명확한 정보를 가지고 있어야 한다.
    <ul>
      <li>메모리 상 위치(<strong>page-table base register</strong>를 통해서)와 정확한 형식을 파악하고 있어야 한다.</li>
    </ul>
  </li>
  <li>미스 발생시 다음과 같은 일을 한다.
    <ol>
      <li>페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾고</li>
      <li>필요한 변환 정보를 추출하여</li>
      <li>TLB를 갱신한 후</li>
      <li>TLB 미스가 발생한 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>x86 CPU가 하드웨어로 관리 되는 TLB의 대표적인 예다.
    <ul>
      <li>멀티 레벨 페이지 테이블을 사용한다.</li>
    </ul>
  </li>
</ul>

<h3 id="riscreduced-instruction-set-computing-소프트웨어-관리-tlb-사용">RISC(reduced instruction set computing): 소프트웨어 관리 TLB 사용</h3>
<ul>
  <li>RISC 기반 컴퓨터에서 TLB 미스를 처리하는 과정은 다음과 같다.
    <ol>
      <li>TLB에서 주소 찾는 것이 실패하면, 하드웨어는 예외 시그널을 발생시킨다.</li>
      <li>예외 시그널을 받은 운영체제는 명령어 실행을 잠정 중지하고, 실행 모드를 커널 모드로 변경하여, 커널 코드 실행을 준비한다.
        <ul>
          <li>실행 모드를 커널 모드로 변경하는 작업의 핵심은 커널 주소 공간을 접근할 수 있또록 특권 레벨(privilege level)로 상향 조정하는 것이다.</li>
        </ul>
      </li>
      <li>커널 모드로 변경이 되면 <strong>트랩 핸들러(trap handler)</strong>를 실행한다.
        <ul>
          <li>이 때 실행되는 트랩 핸들러는 TLB 미스의 처리를 담당하는 운영체제 코드이다.</li>
        </ul>
      </li>
      <li>이 트랩 핸들러는 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 “특권” 명령어를 사용하여 TLB를 갱신한 후에 리턴한다.</li>
      <li>트랩 핸들러에서 리턴되면 하드웨어가 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와의 차이가 있다.
    <ul>
      <li>TLB 미스 처리의 경우 다음 명령어의 PC값을 트랩을 발생시킨 명령을 다시 실행해야한다.</li>
    </ul>
  </li>
  <li>
    <p>TLB 미스 핸들러를 실행할 때, TLB 미스가 무한 반복되지 않도록 주의해야 한다.</p>
  </li>
  <li>TLB를 소프트웨어로 관리하는 방식의 주된 장점은 유연성과 단순함이다.</li>
</ul>

<h2 id="14-tlb의-구성-무엇이-있나">1.4 TLB의 구성: 무엇이 있나?</h2>
<ul>
  <li>TLB는 32, 64, 또는 128개의 엔트리를 가지며, <strong>완전 연관(fully associative)</strong> 방식으로 설계된다.
    <ul>
      <li>완전 연관 방식에서 변환 정보는 TLB 내에 어디든 위치할 수 있으며, 원하는 변환 정보를 찾는 검색은 TLB 전체에서 병렬적으로 수행된다.</li>
    </ul>
  </li>
  <li>TLB의 구성: VPN \ PFN \ offset(다른 비트들)
    <ul>
      <li>하드웨어 측면에서 보자면, TLB는 <strong>완전 연관</strong> 캐시이다.</li>
    </ul>
  </li>
  <li>TLB는 일반적으로 <strong>valid bit</strong>을 갖고 있다.
    <ul>
      <li>특정 항목이 유효한 변환 정보를 갖고 있는지 여부를 나타낸다.</li>
    </ul>
  </li>
  <li><strong>보호(protection)</strong>비트라는 것도 있다.
    <ul>
      <li>보호 비트들은 페이지가 어떻게 접근될 수 있는지를 나타낸다.</li>
    </ul>
  </li>
  <li><strong>더티 비트(dirty bit)</strong>라는 것도 있다.
    <ul>
      <li>페이지가 변경되었는지에 대한 정보를 가지고 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="15-tlb의-문제-문맥-교환">1.5 TLB의 문제: 문맥 교환</h2>
<ul>
  <li>TLB에 있는 가상 주소와 실제 주소 간의 변환 정보는 그것을 탑재시킨 프로세스에서만 유효하다.
    <ul>
      <li>새로운 프로세스에서는 이전에 실행하던 프로세스의 변환 정보를 사용하지 않도록 주의해야 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/07/img_1.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림은 TLB의 예이다.(문제가 있음)
    <ul>
      <li>하지만 위의 TLB에서는 VPN이 10이 두개가 있으며(process 1과 2의 가상 주소 10) 어떤 프로세스의 가상주소인지 확인할 수 없다.</li>
    </ul>
  </li>
  <li>
    <p>TLB가 정확하고 효율적으로 멀티 프로세스 간의 가상화를 지원하기 위해서는 추가적 기능이 필요하다.</p>
  </li>
  <li>한 방법은 문맥 교환을 수행할 때 다음 프로세스가 실행되기 전에 기존 TLB 내용을 비우는 것이다.
    <ul>
      <li>하지만 TLB 내용이 비어지면 문맥 교체가 빈번히 발생되면 TLB 미스가 많아진다.</li>
    </ul>
  </li>
  <li>다른 방법은 TLB 내에 <strong>주소 공간 식별자(address space identifier, ASID)</strong> 필드를 추가하는 것이다.
    <ul>
      <li>ASID는 <strong>프로세스 식별자(process identifier, PID)</strong>와 대략적으로 유사하다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/07/img_2.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림은 ASID가 추가된 TLB의 모습이다.
    <ul>
      <li>ASID로 프로세스를 구분할 수 있게 됐다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/07/img_3.png" width="40%" height="100%" /></p>
<ul>
  <li>ASID를 사용하면 코드 페이지를 위의 그림처럼 공유하여 프로세스가 사용하는 물리 페이지의 수를 줄일 수 있다.</li>
</ul>

<h2 id="16-이슈-교체-정책">1.6 이슈: 교체 정책</h2>
<ul>
  <li>
    <p>모든 캐시가 그러하듯이 TLB에서도 <strong>캐시 교체(cache replacement)</strong> 정책이 매우 중요하다.</p>
  </li>
  <li>한 가지 흔한 방법은 가장 오래 전부터 사용되었던 <strong>최저 사용 빈도(least-recently-used, LRU)</strong> 항목을 교체하는 것이다.
    <ul>
      <li>LRU는 메모리 참조 패턴에서의 지역성을 최대한 활용하는 것이 목적이다.</li>
    </ul>
  </li>
  <li>다른 방법은 랜덤(random) 정책이다.
    <ul>
      <li>랜덤 정책에서는 교체 대상을 무작위로 정한다.</li>
      <li>랜덤 교체 정책은 구현이 간단하고 예상치 못한 예외 상황의 발생을 피할 수 있다는 장점이 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="17-요약">1.7 요약</h2>
<ul>
  <li>지금까지 주소 변환을 더 빠르게 처리하기 위한 하드웨어 기법에 대해 살펴보았따.</li>
  <li>TLB를 주소 변환 캐시로 사용하여 대부분의 메모리 참조들은 메인 메모리 상의 페이지 테이블을 읽지 않고도 처리가 가능하게 되었따.</li>
  <li>프로그램이 짧은 시간 동안 접근하는 페이지들의 수가 TLB에 들어갈 수 잇는 수보다 많다면 TLB 미스를 발생할 것이고 느리게 동작하게 될 것이다.</li>
</ul>

<h1 id="2-페이징-더-작은-테이블">2. 페이징: 더 작은 테이블</h1>
<ul>
  <li>페이징의 두 번째 문제점은 페이지 테이블의 크기이다. 페이지 테이블이 크면 많은 메모리 공간을 차지한다.
    <ul>
      <li>단순한 배열 기반의 페이지 테이블은(흔히 선형 페이지 테이블이라고 불림) 크기가 크며 일반적인 시스템에서 메모리를 과도하게 차지한다.</li>
    </ul>
  </li>
</ul>

<h2 id="21-간단한-해법-더-큰-페이지">2.1 간단한 해법: 더 큰 페이지</h2>
<ul>
  <li>페이지 테이블의 크기를 간단하게 줄일 수 있는 방법이 한 가지 있다.
    <ul>
      <li>페이지 크기를 증가시키면 된다.</li>
    </ul>
  </li>
  <li>하지만 페이지 크기의 증가는 부작용을 수반한다.
    <ul>
      <li>가장 큰 문제는 페이지 내부의 낭비 공간이 증가하는 것이다.</li>
      <li>이를 <strong>내부 단편화</strong>라 한다(할당된 페이지 <strong>내부</strong>에서 낭비가 발생하기 때문이다).</li>
    </ul>
  </li>
</ul>

<h2 id="22-하이브리드-접근-방법-페이징과-세그멘트">2.2 하이브리드 접근 방법: 페이징과 세그멘트</h2>
<ul>
  <li>페이징과 세그멘테이션을 결합하여 페이지 테이블 크기를 줄이는 아이디억 ㅏ있따.</li>
  <li></li>
</ul>
:ET