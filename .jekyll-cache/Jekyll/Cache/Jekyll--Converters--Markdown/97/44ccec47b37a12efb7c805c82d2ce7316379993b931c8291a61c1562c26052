I"<h1 id="1-병행성-관련-버그">1. 병행성 관련 버그</h1>
<ul>
  <li>핵심 질문: 일반적인 병행성 관련 오류들을 어떻게 처리하는가
    <ul>
      <li>병행성 버그는 몇 개의 전형적인 패턴을 갖고 있다.</li>
      <li>튼튼하고 올바른 병행 코드를 작성하기 위한 가장 첫 단계는 어떤 경우들을 피해야 할지 파악하는 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-오류의-종류">1.1 오류의 종류</h2>
<ul>
  <li>오류의 종류는 교착 상태 관련 오류와 비 교착 상태 관련 오류로 나뉜다.</li>
</ul>

<h2 id="12-비-교착-상태-오류">1.2 비 교착 상태 오류</h2>
<ul>
  <li>대표적인 오류는 <strong>원자성 위반(atomicity violation)</strong> 오류와 <strong>순서 위반(order violation)</strong>이다.</li>
</ul>

<h3 id="원자성-위반-오류">원자성 위반 오류</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></code></pre></figure>

<ul>
  <li>위의 코드에서 문제점을 확인해보자
    <ul>
      <li>첫 번째 쓰레드가 검사를 완료한 후 fputs를 호출하기 전에 인터럽트로 인해서 두 번째 쓰레드가 그 사이에 실행될 수가 있다.</li>
      <li>두 번째 쓰레드가 실행되면 필드이ㅡ 값을 NULL로 설정하기 때문에 fputs 함수는 NULL 포인터 역참조를 하게 되어 프로그램은 크래시될 것이다.</li>
    </ul>
  </li>
  <li>원자성 위반에 대한 정의: “다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 않았다!”</li>
  <li>해결책은 공유 변수 참조 앞뒤에 락을 추가하는 것이다.</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span></code></pre></figure>

<h3 id="순서-위반-오류">순서 위반 오류</h3>
:ET