I":<h1 id="chapter-06-메모리-계층구조">Chapter 06 메모리 계층구조</h1>
<ol>
  <li>저장장치 기술</li>
  <li>지역성</li>
  <li>메모리 계층구조</li>
  <li>캐시메모리</li>
  <li>캐시 친화적 코드 작성하기</li>
  <li>프로그램 성능에 대한 캐시의 영향</li>
  <li>요약</li>
</ol>

<h1 id="64-캐시-메모리">6.4 캐시 메모리</h1>
<ul>
  <li>CPU와 메인메모리 사이의 성능 격차가 커짐에 따라 L1 캐시 및 L2 캐시를 삽입하였다.</li>
  <li>캐시는 SRAM이다.</li>
</ul>

<p><img src="../../assets/img/csapp/21/img.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 캐시 메모리를 위한 일반적인 버스 구조이다.</li>
</ul>

<h2 id="641-기본-캐시-메모리-구조">6.4.1 기본 캐시 메모리 구조</h2>
<ul>
  <li>캐시의 구성은 순서쌍 S,E,B,m 으로 규정할 수 있다.
    <ul>
      <li>S : 2^s개의 캐시 집합</li>
      <li>E : 집합에 포함되는 캐시 라인</li>
      <li>B : 2^b 바이트의 데이터 블록</li>
      <li>m : M = 2^m 개의 교유의 주소를 구성하는 m비트</li>
      <li>C : 모든 블록의 크기 S<em>E</em>B</li>
    </ul>
  </li>
  <li>캐시는 요청된 워드를 간단히 주소비트만 조사해서 찾아ㅓ낼 수 있도록 구성되어있다.
    <ul>
      <li>해당 방식은 해시 함수를 사용하는 해시 테이블과 유사하다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/21/img_1.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 캐시의 일반적인 구조이다.</li>
</ul>

<h2 id="642-캐시-종류">6.4.2 캐시 종류</h2>
<ul>
  <li>직접매핑 캐시
    <ul>
      <li>집합당 정확히 한개의 라인을 갖는 경우</li>
    </ul>
  </li>
  <li>집합결합성 캐시
    <ul>
      <li>집합당 k개의 라인을 갖는 경우</li>
    </ul>
  </li>
  <li>완전결합성 캐시
    <ul>
      <li>모든 캐시 라인들을 갖는 하나의 집합으로 구성된 경우</li>
    </ul>
  </li>
</ul>

<h2 id="643-캐시-동작-방법">6.4.3 캐시 동작 방법</h2>
<ul>
  <li>캐시의 동작 방법은 세 단계로 이루어진다.
    <ol>
      <li>집합 선택</li>
      <li>라인 매칭</li>
      <li>워드 추출</li>
    </ol>

    <ul>
      <li>위와 같은 방법으로 캐시가 어떤 요청이 적중인지 미스인지 결정하고, 요청한 워드를 뽑아내기 위해 작업을 수행한다.</li>
    </ul>
  </li>
</ul>

<ol>
  <li>집합 선택
    <ul>
      <li>s개의 집합 인덱스 비트를 w의 주소 중에서 뽑아낸다.</li>
    </ul>
  </li>
  <li>라인 매칭
    <ul>
      <li>워드 w의 사본이 집합 i에 포함된 캐시 라인에 들어 있는지 결정한다.</li>
      <li>유효비트 valid가 1이고, 태그비트들이 일치해야한다. -&gt; 캐시 적중</li>
    </ul>
  </li>
  <li>워드 선택
    <ul>
      <li>캐시 적중이 발생하면 원하는 워드가 블록 내 어디에서 시작하는지 결정한다.</li>
    </ul>
  </li>
</ol>

<p><img src="../../assets/img/csapp/21/img_2.png" width="80%" height="100%" /></p>

<p><img src="../../assets/img/csapp/21/img_3.png" width="80%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 집합 선택과 라인 매칭 그리고 워드 선택이다.(직접매핑 캐시)</p>
  </li>
  <li>Thrashing : 캐시가 같은 집합의 캐시 블록들의 로드와 축출을 반복하는 경우
    <ul>
      <li>해결 방법 : 예를들어 x배열, y배열에서 쓰레싱이 일어나면 x배열에 패딩을 주어 x[i]와 y[i]가 서로 다른 집합에 매핑되도록 한다.</li>
    </ul>
  </li>
  <li>인덱스를 중간 비트로 사용하는 이유
    <ul>
      <li>연속적인 메모리 블록들은 동일한 캐시 집합으로 매핑된다. -&gt; 어떠한 특정 순간에 한 개의 블록 크기의 배열 묶음만을 저장하게 되며 캐시를 비효율적으로 사용하게 된다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/21/img_4.png" width="80%" height="100%" /></p>
<ul>
  <li>
    <p>위의 그림은 중간 비트로 캐시 인덱스를 사용하는 이유다.</p>
  </li>
  <li>집합결합성 캐시에서의 동작 방법
    <ul>
      <li>직접매핑 캐시와 동작이 비슷하지만,</li>
      <li>라인 매칭에서 캐시 내 태그와 주소의 태그가 일치하는 라인을 찾기위해 탐색을 한다.</li>
      <li>캐시에서 미스 발생시 : LFU(최소 빈도 사용), LRU(최소 최근 사용) 정책 활용</li>
    </ul>
  </li>
  <li>완전결합성 캐시
    <ul>
      <li>집합결합성 캐시와 동작이 비슷하지만,</li>
      <li>많은 수의 태그를 병렬로 검색해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="644-쓰기와-관련된-이슈">6.4.4 쓰기와 관련된 이슈</h2>
<ul>
  <li>Write-through</li>
</ul>

<h1 id="65-캐시-친화적-코드-작성하기">6.5 캐시 친화적 코드 작성하기</h1>

<h1 id="66-프로그램-성능에-대한-캐시의-영향">6.6 프로그램 성능에 대한 캐시의 영향</h1>

<h1 id="67-요약">6.7 요약</h1>
:ET