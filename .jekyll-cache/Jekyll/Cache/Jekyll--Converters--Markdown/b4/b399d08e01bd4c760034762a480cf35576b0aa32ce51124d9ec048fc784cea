I"+<h1 id="chapter-03-프로그램의-기계수준-표현">Chapter 03. 프로그램의 기계수준 표현</h1>
<ul>
  <li>3.1 역사적 관점</li>
  <li>3.2 프로그램의 인코딩</li>
  <li>3.3 데이터의 형식</li>
  <li>3.4 정보 접근하기</li>
  <li>3.5 산술연산과 논리연산</li>
  <li>3.6 제어문</li>
</ul>

<h1 id="35-산술연산과-논리연산">3.5 산술연산과 논리연산</h1>
<p><img src="../../assets/img/csapp/06/img.png" width="80%" height="100%" /></p>
<ul>
  <li>위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.</li>
  <li>인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.
    <ul>
      <li>addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.</li>
    </ul>
  </li>
  <li>연산들은 네 개의 그룹으로 나누어진다.
    <ul>
      <li>유효주소 적재, 단항unary, 이항binary, 쉬프트
        <ul>
          <li>이항 연산은 두 개의 오퍼랜드를 가진다.</li>
          <li>단항 연산은 한 개의 오퍼랜드를 가진다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="351-유효주소-적재-load-effective-address">3.5.1 유효주소 적재 Load Effective Address</h2>
<ul>
  <li>유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.</li>
  <li>메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.</li>
  <li>가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.</li>
  <li>이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.</li>
  <li>또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다
    <ul>
      <li>ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.</li>
    </ul>
  </li>
  <li>목적 오퍼랜드는 반드시 레지스터만 올 수 있다.</li>
</ul>

<h2 id="352-단항-및-이항-연산">3.5.2 단항 및 이항 연산</h2>
<ul>
  <li>단항 연산
    <ul>
      <li>하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.</li>
      <li>오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.</li>
      <li>ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자</li>
    </ul>
  </li>
  <li>이항 연산
    <ul>
      <li>첫 번째 오퍼랜드는 상수나 레지스터, 메모리 위치가 올 수 있고 두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.</li>
      <li>C에서 x -= y와 유사하다.</li>
      <li>두 개의 오퍼랜드가 모두 메모리 위치가 될 수 없다.</li>
      <li>두 번째 오퍼랜드가 메모리 위치일 때 프로세서가 메모리에서 값을 읽고, 연산을 하고, 그 결과를 다시 메모리에 써야 한다는 점에 유의해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="353-쉬프트-연산">3.5.3 쉬프트 연산</h2>
<ul>
  <li>쉬프트하는 크기를 먼저 주고, 쉬프트할 값을 두 번째로 준다.</li>
  <li>산술과 논리형 우측 쉬프트가 모두 가능하다.</li>
  <li>쉬프트 인스트럭션들은 쉬프트할 양을 즉시 값이나 단일 바이트 레지스터 %cl로 명시할 수 있다.</li>
  <li>좌측 쉬프트 인스트럭션에는 두 가지 이름이 있다.
    <ul>
      <li>SAR: 산술 쉬프트, 부호비트를 복사해서 채운다</li>
      <li>SHR: 논리 쉬프트, 0으로 채운다</li>
    </ul>
  </li>
  <li>쉬프트 연산의 목적 오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.</li>
</ul>

<h2 id="354-토의">3.5.4 토의</h2>
<ul>
  <li>인스트럭션들은 비부호형과 2의 보수 산술연산에 사용될 수 있다.</li>
  <li>오직 우측 쉬프트만이 부호형과 비부호형 데이터를 구분하는 인스트럭션을 요구한다.</li>
  <li>이것이 부호형 정수 산술연산을 구현하는 방식으로 2의 보수 산술연산을 선호하는 주요 특징이다.</li>
</ul>

<h2 id="355-특수-산술연산">3.5.5 특수 산술연산</h2>
<p><img src="../../assets/img/csapp/06/img_2.png" width="80%" height="100%" /></p>
<ul>
  <li>두 개의 64비트 부호형 또는 비부호형 정수들 간의 곱셈 결과값을 표시하기 위해 128비트를 필요로한다.</li>
  <li>x86064 인스트럭션 집합은 128비트 숫자와 관련된 연산에 대해서는 제한적인 지원을 제공한다.
    <ul>
      <li>워드(2바이트), 더블워드(4바이트), 쿼드워드(8바이트), 인텔은 16바이트 워드를 옥트워드oct word라고 명명한다.</li>
    </ul>
  </li>
  <li>IMUL 인스트럭션 클래스의 멤버인 형태
    <ul>
      <li>이 형식은 두 개의 64비트 오퍼랜드로부터 64비트 곱을 생성하는 “2 오퍼랜드” 곱셈 인스트럭션을 제공한다.</li>
    </ul>
  </li>
  <li>추가적으로 x86-64는 두 개의 다른 “단일 오퍼랜드” 곱셈 인스트럭션을 제공하며 64비트 값의 완전한 128비트 곱을 계산한다.
    <ul>
      <li>하나는 비부호형(mulq), 다른 하나는 2의 보수(imulq) 곱셈이다.</li>
      <li>이들 모두 한 개의 인자는 레지스터 %rax에 보관해야 하고 다른 하나는 인스트럭션 소스 오퍼랜드로 주어진다.</li>
      <li>곱은 레지스터 %rdx(상위 64비트)와  %rax(하위 64비트)에 저장된다.</li>
    </ul>
  </li>
  <li>곱을 저장하기 위해서는 아래의 그림처럼 두 개의 movq 인스트럭션이 필요하다.
<img src="../../assets/img/csapp/06/img_1.png" width="80%" height="100%" />
<br /><br /><br /></li>
  <li>단일 오퍼랜드 곱셈 인스트럭션과 비슷한 단일 오퍼랜드 나눈셈 인스트럭션으로 제공된다.</li>
  <li>나눗셈 인스트럭션 idviq은 피제수dividened를 128비트로 레지스터 %rdx(상위 64비트)와 %rax(하위 64비트)에 저장한다.</li>
  <li>제수divisor는 인스트럭션의 오퍼랜드로 주어진다.</li>
  <li>인스트럭션은 몫은 레지스터 %rax에, 나머지는 레지스터 %rdx에 저장한다.</li>
</ul>

<h1 id="36-제어문">3.6 제어문</h1>
<ul>
  <li>일부 구문인 반복문, 스위치문들은 데이터에 적용된 시험결과에 따라 일련의 연산이 실행되는 조건부 실행이 요구된다.</li>
  <li>기계어 코드에서는 조건부 동작을 구현하기 위해 두 개의 기본적인 낮은 수준의 방법을 제공한다.
    <ul>
      <li>데이터 값들을 시험해서 이 시험 결과에 따라 데이터흐름이나 제어흐름을 변경한다.</li>
    </ul>
  </li>
  <li>기계어 인스트럭션들의 실행 순서는 점프jump 인스트럭션으로 변경할 수 있다.</li>
  <li>점프 인스트럭션은 때에 따라서는 어떤 시험의 결과에 따라 프로그램의 다른 일부분으로 제어를 넘겨준다.</li>
</ul>

<h2 id="361-조건-코드">3.6.1 조건 코드</h2>
<ul>
  <li>정수 레지스터들과 함께 CPU는 가장 최근 산술 또는 논리연산의 특성을 설명하는 단일 비트 조건 코드로 구성된 레지스터들을 운영한다.</li>
  <li>이 레지스터들은 조건부 분기를 수행하기 위해서 시험될 수 있다.
    <ul>
      <li>CF: 캐리 플래그Carry flag. 가장 중요한 비트로부터 받아 올림이 발생한 것을 표시. 비부호형 연산에서 오버플로우를 검출할 때 사용</li>
      <li>ZF: 영 플래그Zero flag. 연산의 결과가 0인 것을 표시</li>
      <li>SF: 부호 플래그Sign flag. 연산이 음수를 생성한 것을 표시</li>
      <li>OF: 오버플로우 플래그Overflow flag. 양수/음수의 2의 보수 오버플로우를 발생시킨 것을 표시</li>
    </ul>
  </li>
  <li>leaq 인스트럭션은 주소계산에 사용하기 위한 것이므로 조건 코드를 변경하지 않는다.
<br /><br /></li>
</ul>

<p><img src="../../assets/img/csapp/06/img.png" width="80%" height="100%" /></p>
<ul>
  <li>반면에, 위의 그림에 나열된 모든 인스트럭션들은 조건 코드 값을 변경한다.
    <ul>
      <li>XOR 같은 논리연산에서는 캐리와 오버플로우 플래그가 0으로 세팅된다.</li>
      <li>쉬프트 연산에서는 캐리 플래그가 쉬프트되어 없어지는 마지막 비트로 설정되며, 오버플로우 플래그는 0으로 세팅된다.</li>
    </ul>
  </li>
  <li>위의 그림의 인스트럭션들에 의해 조건 코드 값이 변경될 뿐만 아니라, 다른 레지스터들은 변경시키지 않으면서 조건 코드만 변경해 주는 두 개의 인스트럭션 클래스가 있다.(아래의 그림 참조)
<img src="../../assets/img/csapp/06/img_3.png" width="80%" height="100%" /></li>
  <li>CMP 인스트럭션들은 만일 두 오퍼랜드가 같으면 영 플래그르 1로 설정한다. 다른 플래그들은 두 오퍼랜드의 순서관계를 결정하는 데 사용될 수 있다.</li>
  <li>TEST 인스트럭션은 목적지 오퍼랜드를 변경하지 않으면서 조건 코드를 설정하는 점만 제외하고는 AND 인스트럭션과 같은 방식으로 동작한다.</li>
</ul>

<h2 id="362-조건-코드-사용하기">3.6.2 조건 코드 사용하기</h2>
<ul>
  <li>조건 코드를 이용하는 보편적인 세 가지 방법이 있다.
    <ol>
      <li>조건 코드의 조합에 따라 0 또는 1을 한 개의 바이트에 기록</li>
      <li>조건에 따라 프로그램의 다른 부분으로 이동하는 방법</li>
      <li>조건에 따라 데이터를 전송하는 방법</li>
    </ol>
  </li>
</ul>

<ol>
  <li>SET 인스트럭션</li>
</ol>

<p><img src="../../assets/img/csapp/06/img_4.png" width="80%" height="100%" /></p>

<ul>
  <li>첫 번째 경우의 인스트럭션의 클래스를 SET 인스트럭션이라고 부른다.</li>
  <li>이 인스트럭션들은 접미어를 이용해서 오퍼랜드의 크기를 나타내는 것이 아니라, 조건 코드의 어떤 조합을 사용할 것인지를 나타낸다.
    <ul>
      <li>ex) setl, setb -&gt; long word와 byte를 의미하지 않고 less와 below를 의미한다.</li>
    </ul>
  </li>
  <li>SET 인스트럭션은 목적지로 하위 단일 바이트 레지스터 가운데 한 개나 단일 바이트 메모리 주소를 사용하며, 이 바이트를 0이나 1로 기록한다.
    <ul>
      <li>32비트나 64비트 결과를 만드려면, 다른 상위 비트들을 0으로 만들어줘야 한다.
<img src="../../assets/img/csapp/06/img_5.png" width="80%" height="100%" /></li>
      <li>a&lt;b를 계산하는 전형적인 인스트럭션은 위의 그림과 같이 작성된다.</li>
    </ul>
  </li>
</ul>

<h2 id="363-점프jump-인스트럭션">3.6.3 점프jump 인스트럭션</h2>
<ul>
  <li>인스트럭</li>
</ul>

:ET