I"<h1 id="chapter-04-프로세서-구조">Chapter 04. 프로세서 구조</h1>
<ul>
  <li>4.1 Y86-64 인스트럭션 집합 구조</li>
  <li>4.2 논리 설계와 하드웨어 제어 언어 HCL</li>
  <li>4.3 순차적sequential Y86-64 구현</li>
</ul>

<h1 id="43-순차적sequential-y86-64-구현">4.3 순차적sequential Y86-64 구현</h1>

<ul>
  <li>SEQ : sequential 프로세서를 의미</li>
  <li>매 클럭 사이클에 SEQ는 한 개의 완전한 인스트럭션을 처리하는 데 필요한 모든 단계를 수행한다.</li>
  <li>SEQ를 개발하는 목적은 효율적인 파이프라인 프로세서를 만들려는 우리의 최종목표로 가는 첫 단계이다.</li>
</ul>

<h2 id="432-seq-하드웨어-구조">4.3.2 SEQ 하드웨어 구조</h2>
<ul>
  <li>인스트럭션을 구현하는 데 필요한 계산들은 여섯 개의 순차적인 기본 단계로 구성될 수 있다.
    <ol>
      <li>선입</li>
      <li>해독</li>
      <li>실행</li>
      <li>메모리</li>
      <li>재기록</li>
      <li>PC 갱신</li>
    </ol>
  </li>
  <li>SEQ에서는 하드웨어 유닛에 처리되는 모든 일들은 하나의 클럭 사이클 내에서 일어난다.</li>
</ul>

<p><img src="../../assets/img/csapp/15/img.png" width="100%" height="100%" /></p>
<ul>
  <li>위 그림은 순차적인 구현인 SEQ의 추상적인 모습이다.
    <ul>
      <li>인스트럭션을 실행하는 동안 처리된 정보는 그림의 좌측 하단 구석에 있는 PC를 사용해서 인스트럭션 선입으로 시작해서 시계방향을 따라 진행한다.</li>
    </ul>
  </li>
  <li>하드웨어 유닛들은 여러가지 처리 단계들과 연계되어있다.
    <ul>
      <li>선입
        <ul>
          <li>프로그램 카운터 레지스터를 주소로 사용해서 인스트럭션 메모리는 인스트럭션의 바이트들을 읽어들인다.</li>
          <li>PC 가산기는 valP, 증가된 프로그램 카운터를 계산한다.</li>
        </ul>
      </li>
      <li>해독
        <ul>
          <li>레지스터 파일은 두 개의 읽기 포트 A,B를 가지고 있다.</li>
          <li>이를 통해서 레지스터 값 valA, valB를 동시에 읽어들일 수 있다.</li>
        </ul>
      </li>
      <li>실행
        <ul>
          <li>인스트럭션의 종류에 따라 여러 가지 목적을 위해 산술/유닛 유닛(ALU)을 사용한다.</li>
          <li>조건코드 레지스터(CC)는 세 개의 조건코드 비트를 저장한다. 목적지 레지스터를 갱신할지 여부를 결정하는 조건코드와 이동 조건에 의해 계산된다.</li>
        </ul>
      </li>
      <li>메모리
        <ul>
          <li>메모리 인스트럭션을 실행할 때 메모리 워드를 읽거나 쓴다.</li>
          <li>인스트럭션과 데이터 메모리는 같은 메모리 위치에 접근하지만, 목적은 서로 다르다.</li>
        </ul>
      </li>
      <li>재기록
        <ul>
          <li>레지스터 파일은 두 개의 쓰기 포트를 가지고 있다.</li>
          <li>E 포트는 ALU가 계산한 값을 기록하기 위해 사용된다.</li>
          <li>M 포트는 데이터 메모리에서 읽어온 값을 기록할 때 사용한다.</li>
        </ul>
      </li>
      <li>PC 갱신
        <ul>
          <li>프로그램 카운터의 새로운 값은 다음 인스트럭션의 주소 valP, call이나 점프 인스트럭션에 의해 지정된 목적지 주소, 또는 메모리에서 읽어온 리턴주소 valM 중에서 선택된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/csapp/15/img_1.png" width="100%" height="100%" /></p>
<ul>
  <li>위 그림은 SEQ, 순차적 구현의 하드웨어 구조이다. 레지스터와 제어 워드 연결뿐만 아니라 일부 제어신호들은 나타내지 않았다.</li>
</ul>

<p><br /><br />
<img src="../../assets/img/csapp/15/img_1.png" width="100%" height="100%" /></p>
<ul>
  <li>위 표는 순차적 구현에서 여러가지 계산 단계 식별 표이다.
    <ul>
      <li>두번째 열은 SEQ의 단계에서 계산되는 값 또는 수행되는 연산을 나타낸다.</li>
    </ul>
  </li>
</ul>

<h2 id="433-seq-타이밍">4.3.3 SEQ 타이밍</h2>

<ul>
  <li>SEQ는 조합논리회로와 두 가지 형태의 메모리 장치로 이루어진다.
    <ul>
      <li>레지스터(프로그램 카운터와 조건코드 레지스터)</li>
      <li>랜덤 액세스 메모리(레지스터 파일, 인스트럭션 메모리, 데이터 메모리)</li>
    </ul>
  </li>
</ul>

:ET