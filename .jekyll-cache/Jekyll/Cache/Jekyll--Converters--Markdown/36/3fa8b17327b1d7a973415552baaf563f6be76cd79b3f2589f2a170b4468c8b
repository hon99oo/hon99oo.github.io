I"	<h1 id="1-페이징-개요">1. 페이징: 개요</h1>
<ul>
  <li>세그멘테이션은 공간을 다양한 크기의 청크로 분할할 때 공간 자체가 <strong>단편화(fragmented)</strong>될 수 있고, 할당은 점점 더 어려워진다.</li>
  <li>다른 방법은 공간을 동일 크기의 조각으로 분할하는 <storng>페이징(paging)&lt;/strong&gt; 기법이다.
</storng>    <ul>
      <li>프로세스의 주소 공간을 몇개의 가변 크기의 논리 세그멘트(코드, 힙, 스택)로 나누는 것이 아니라 고정 크기의 단위로 나눈다. 이 각각의 단위를 <strong>페이지(page)</strong>라고 부른다. 상응하여 물리 메모리도 <strong>페이지 프레임(page frame)</strong>이라고 불리는 고정 크기의 슬롯의 배열이라고 생각한다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-간단한-예제-및-개요">1.1 간단한 예제 및 개요</h2>

<p><img src="../../assets/img/ostep/06/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림은 128바이트 물리 메모리에 탑재된 64바이트 주소 공간이다.
<br /><br /></li>
  <li>페이징의 가장 큰 장점은 유연성이다.
    <ul>
      <li>힙과 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도 된다.</li>
    </ul>
  </li>
  <li>페이징의 또 다른 장점은 단순함이다.
    <ul>
      <li>물리 메모리에 주소 공간을 배치하기 위해서는 운영체제는 비어 있는 네 개의 페이지만 찾으면된다. 운영체제는 모든 비어 있는 페이지의 <strong>빈 공간 리스트</strong>를 유지하고 리스트의 첫 네 개 페이지를 선택한다.
<br /><br /></li>
    </ul>
  </li>
  <li>주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위하여 운영체제는 프로세스 마다 <strong>페이지 테이블(page table)</strong>이라는 자료 구조를 유지한다.
    <ul>
      <li>페이지 테이블의 주요 역할은 주소 공간의 가상 페이지 <strong>주소 변환(address translation)</strong>정보를 저장하는 것이다.</li>
      <li>페이지 테이블은 프로세스마다 존재한다.
<br /><br /></li>
    </ul>
  </li>
  <li>프로세스가 생성한 가상 주소의 <strong>변환</strong>을 위해 먼저 가상 주소를 <strong>가상 페이지 번호(virtual page number, VPN)</strong>와 페이지 내의 <strong>오프셋</strong> 2개의 구성 요소로 분할한다.</li>
</ul>

:ET