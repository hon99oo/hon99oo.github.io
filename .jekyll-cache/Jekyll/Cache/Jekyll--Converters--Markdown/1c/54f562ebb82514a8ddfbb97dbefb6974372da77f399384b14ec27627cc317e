I"#<h1 id="1-병행성-관련-버그">1. 병행성 관련 버그</h1>
<ul>
  <li>핵심 질문: 일반적인 병행성 관련 오류들을 어떻게 처리하는가
    <ul>
      <li>병행성 버그는 몇 개의 전형적인 패턴을 갖고 있다.</li>
      <li>튼튼하고 올바른 병행 코드를 작성하기 위한 가장 첫 단계는 어떤 경우들을 피해야 할지 파악하는 것이다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-오류의-종류">1.1 오류의 종류</h2>
<ul>
  <li>오류의 종류는 교착 상태 관련 오류와 비 교착 상태 관련 오류로 나뉜다.</li>
</ul>

<h2 id="12-비-교착-상태-오류">1.2 비 교착 상태 오류</h2>
<ul>
  <li>대표적인 오류는 <strong>원자성 위반(atomicity violation)</strong> 오류와 <strong>순서 위반(order violation)</strong>이다.</li>
</ul>

<h3 id="원자성-위반-오류">원자성 위반 오류</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></code></pre></figure>

<ul>
  <li>위의 코드에서 문제점을 확인해보자
    <ul>
      <li>첫 번째 쓰레드가 검사를 완료한 후 fputs를 호출하기 전에 인터럽트로 인해서 두 번째 쓰레드가 그 사이에 실행될 수가 있다.</li>
      <li>두 번째 쓰레드가 실행되면 필드이ㅡ 값을 NULL로 설정하기 때문에 fputs 함수는 NULL 포인터 역참조를 하게 되어 프로그램은 크래시될 것이다.</li>
    </ul>
  </li>
  <li>원자성 위반에 대한 정의: “다수의 메모리 참조 연산들 간에 있어 예상했던 직렬성(serializability)이 보장되지 않았다!”</li>
  <li>해결책은 공유 변수 참조 앞뒤에 락을 추가하는 것이다.</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span>
    <span class="n">thd</span><span class="err">−</span><span class="o">&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">)</span></code></pre></figure>

<h3 id="순서-위반-오류">순서 위반 오류</h3>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mThread</span> <span class="o">=</span> <span class="n">PR_CreateThread</span><span class="p">(</span><span class="n">mMain</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="kt">void</span> <span class="nf">mMain</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">mState</span> <span class="o">=</span> <span class="n">mThread</span><span class="err">−</span><span class="o">&gt;</span><span class="n">State</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<ul>
  <li>위의 코드에서 문제점을 확인해보자
    <ul>
      <li>쓰레드 2의 코드는 mThread 변수가 이미 초기화가 된 것을 가정하고 있다.</li>
      <li>하지만, 만약 쓰레드 1이 먼저 실행되지 않았다면 쓰레드 2는 NULL 포인터를 사용하기 때문에 크래시될 것이다.</li>
    </ul>
  </li>
  <li>순서 위반의 공식 정의: “두 개의(그룹의) 메모리 참조 간의 순서가 바뀌었다.”</li>
  <li>해결책은 <strong>컨디션 변수</strong>를 사용한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">Thread</span> <span class="mi">1</span><span class="o">::</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">mThread</span> <span class="o">=</span> <span class="n">PR_CreateThread</span><span class="p">(</span><span class="n">mMain</span><span class="p">,</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">;</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
        <span class="n">mtInit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtCond</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Thread</span> <span class="mi">2</span><span class="o">::</span>
    <span class="kt">void</span> <span class="nf">mMain</span> <span class="p">(</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">mtInit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtCond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtLock</span><span class="p">);</span>
        <span class="n">mState</span> <span class="o">=</span> <span class="n">mThread</span><span class="err">−</span><span class="o">&gt;</span><span class="n">State</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<h2 id="13-교착-상태-오류">1.3 교착 상태 오류</h2>
<ul>
  <li>복잡한 락 프로토콜을 사용하는 다수의 병행 시스템에서 <strong>교착 상태(deadlock)</strong>라는 고전적 문제가 발생한다.
    <ul>
      <li>예를 들어 락 L1을 갖고 있는 쓰레드1이 또 다른 락 L2를 기다리는 상황에서 불행하게도 락 L2를 갖고 있는 쓰레드2가 락 L1이 해제되기를 기다리고 있을 때 교착 상태가 발생한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/13/img.png" width="60%" height="100%" /></p>
:ET