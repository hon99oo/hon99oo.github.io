I"F<h1 id="1-io-장치">1. I/O 장치</h1>
<p>I/O는 컴퓨터 시스템에서 상당히 중요한 부분이다.</p>
<ul>
  <li>시스템에 I/O를 어떻게 통합해야 하는가?</li>
  <li>일반적인 방법은 무엇인가?</li>
  <li>어떻게 효율적으로 통합할 수 있을까?</li>
</ul>

<h2 id="11-시스템-구조">1.1 시스템 구조</h2>
<ul>
  <li>CPU와 주메모리가 <strong>메모리 버스</strong>로 연결되어 있다.</li>
  <li>몇가지 장치들이 범용 <strong>I/O 버스</strong>에 연결이 되어 있는데, 많은 현대의 시스템에서는 <strong>PCI</strong>(또는 다른 파생된 형태의 버스)를 사용하고 있다.
    <ul>
      <li>그래픽이나 다른 고성능 I/O 장치들이 여기에 연결될 수 있다.</li>
    </ul>
  </li>
  <li>그 아래에는 <strong>SCSI</strong>나 <strong>SATA</strong> 또는 <strong>USB</strong>와 같은 <strong>주변장치용 버스</strong>가 있다.
    <ul>
      <li>이 버스들을 통해 <strong>디스크, 마우스, 키보드</strong>와 같은 느린 장치들이 연결된다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/14/img.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 시스템 구조 모형이다.</li>
</ul>

<h2 id="12-표준-장치">1.2 표준 장치</h2>
<ul>
  <li>장치를 효율적으로 활용하기 위해 필요한 것은 무엇인지 알아보자.
    <ol>
      <li>시스템의 다른 구성 요소에게 제공하는 하드웨어 <strong>인터페이스</strong>이다.
        <ul>
          <li>소프트웨어가 인터페이스를 제공하듯이 하드웨어도 인터페이스를 제공하여 시스템 소프트웨어가 동작을 제어할 수 있도록 해야 한다.</li>
        </ul>
      </li>
      <li><strong>내부 구조</strong> 또한 갖고 있어야 한다.</li>
    </ol>
  </li>
</ul>

<p><img src="../../assets/img/ostep/14/img_1.png" width="60%" height="100%" /></p>
<ul>
  <li>위의 그림은 표준 장치이다.</li>
</ul>

<h2 id="13-표준-방식">1.3 표준 방식</h2>
<ul>
  <li>위에서 봉본 그림에서 (단순화된) 장치의 인터페이스는 세 개의 레지스터로 구성되어 있다.
    <ul>
      <li><strong>상태(status)</strong> 레지스터는 장치의 현재 상태를 읽을 수 있다.</li>
      <li><strong>명령어(command)</strong> 레지스터는 장치가 특정 동작을 수행하도록 요청할 때 사용 된다.</li>
      <li><strong>데이터(data)</strong> 레지스터는 장치에 데이터를 보내거나 받거나 할 때 사용한다.</li>
      <li>이 레지스터들을 읽거나 쓰는 것을 통해 운영체제는 장치의 동작을 제어할 수 있다.</li>
    </ul>
  </li>
  <li>운영체제와 장치 간에 일어날 수 있는 상호 동작의 과정
    <ol>
      <li>먼저 반복적으로 장치의 상태 레지스터를 읽어 명령의 수신 가능 여부를 확인한다.
        <ul>
          <li>이 동작을 장치에 대해 <strong>폴링(polling)</strong> 한다고 표현한다.</li>
        </ul>
      </li>
      <li>운영체제가 데이터 레지스터에 어떤 데이터를 전달한다.
        <ul>
          <li>데이터 전송에 메인 CPU가 관여하는 경우를 <strong>programmed I/O</strong> 라고 한다.</li>
        </ul>
      </li>
      <li>운영체제가 명령 레지스터에 명령어를 기록한다.
        <ul>
          <li>이 레지스터에 명령어가 기록되면 데이터는 이미 준비되었다고 판단하고 명령어를 처리한다.</li>
        </ul>
      </li>
      <li>운영체제는 디바이스가 처리를 완료했는지를 확인하는 폴링 반복문을 돌면서 기다린다.</li>
    </ol>
  </li>
</ul>

<h2 id="14-인터럽트를-이용한-cpu-오버헤드-개선">1.4 인터럽트를 이용한 CPU 오버헤드 개선</h2>
<ul>
  <li>장치와의 상호작용을 개선하기 위해 <strong>인터럽트</strong>라는 것을 개발하였다.</li>
  <li>디바이스를 폴링하는 대신 운영체제는 입출력 작업을 요청한 프로세스를 블록 시키고 CPU를 다른 프로세스에게 양도한다.</li>
  <li>장치가 작업을 끝마치고 나면 하드웨어 인터럽트를 발생시키고 CPU는 운영체제가 미리 정의해 놓은 <strong>인터럽트 서비스 루틴(interrupt service routine, ISR)</strong> 또는 간단하게
<strong>인터럽트 핸들러(interrupt handler)</strong>를 실행한다.</li>
  <li>인터럽트 핸들러는 입출력 요청의 완료, I/O 대기 중인 프로세스 깨우기 등을 담당한다.</li>
  <li>깨어난 프로세스가 작업을 계속할 수 있도록 한다.</li>
</ul>

<p><br /></p>
<ul>
  <li>사용률을 높이기 위한 핵심 방법 중 하나는 인터럽트를 활용하여 CPU 연산과 I/O를 <strong>중첩</strong>시키는 것이다.</li>
</ul>

<p><img src="../../assets/img/ostep/14/img_2.png" width="90%" height="100%" /></p>
<ul>
  <li>위의 그림은 인터럽트가 없다면 시스템은 I/O가 완료될 때까지 반복적으로 장치의 상태를 폴링한다(p로 표현).</li>
</ul>

<p><img src="../../assets/img/ostep/14/img_3.png" width="90%" height="100%" /></p>
<ul>
  <li>인터럽트를 사용함여 연산과 I/O 작업을 중첩시킬 수 있다면 운영체제는 디스크의 응답을 기다리면서 다른 일을 할 수 있다.</li>
</ul>

<p><br /></p>
:ET