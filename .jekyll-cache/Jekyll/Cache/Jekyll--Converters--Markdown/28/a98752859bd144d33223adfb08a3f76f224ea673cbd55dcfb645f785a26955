I"<h1 id="2-정보의-표현과-처리">2 정보의 표현과 처리</h1>
<blockquote>
  <p>컴퓨터가 실제로 해석하는 비트들과 연산들이 무엇이 있는지 배운다.</p>
</blockquote>

<ul>
  <li>컴퓨터는 두 개의 값을 갖는 신호로 정보를 처리한다.</li>
  <li>이러한 비트를 이진수 체계를 사용해서 양수들로 인코딩하여 사용한다.
    <ul>
      <li>비부호형</li>
      <li>부호형(2의 보수)</li>
      <li>부동소수점</li>
    </ul>
  </li>
</ul>

<h2 id="정보의-저장">정보의 저장</h2>
<ul>
  <li>2진수: 컴퓨터의 비트 표현</li>
  <li>16진수: 비트 패턴을 표시하는데 사용됨(2진수와 10진수는 불편함)</li>
  <li>비트 표시 방법(xw-1,xw-2,…,x1,x0)
    <ul>
      <li>리틀 엔디안: 가장 덜 중요한 바이트가 먼저 온다.(x0,x1…)</li>
      <li>빅 엔디안: 가장 중요한 바이트가 먼저 온다.(xw-1,xw-2…)</li>
    </ul>
  </li>
  <li>비트 수준 연산
    <ul>
      <li>부울 대수: <code class="language-plaintext highlighter-rouge">~</code>(not),<code class="language-plaintext highlighter-rouge">&amp;</code>(and),<code class="language-plaintext highlighter-rouge">|</code>(or),<code class="language-plaintext highlighter-rouge">^</code>(exclusive-or)</li>
      <li>쉬프트
        <ul>
          <li>좌측 쉬프트: « 우측에는 k개의 0 채워짐</li>
          <li>논리 우측 쉬프트 » 좌측에는 k개의 0 채워짐</li>
          <li>산술 우측 쉬프트 » 좌측에는 k개의 중요한 비트들이 채워짐</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="정수의-표시">정수의 표시</h2>
<blockquote>
  <p>비부호형과 부호형(2의보수)의 표현 방법에 차이점에 포인트를 두어야 한다.</p>
</blockquote>

<ul>
  <li>부호형(2의 보수) : 맨 앞자리의 비트가 0이면 양수, 1이면 음수로 표현한다.
    <ul>
      <li>ex) 1101 -&gt; 앞자리가 1이므로 -8, 앞자리를 제외한 값이 5 -&gt; -8+5=-3 이렇게 계산한다.</li>
    </ul>
  </li>
  <li>비부호형과 부호형 간의 변환과 확장, 절삭에서 부호형의 오버플로우가 발생한다.</li>
</ul>

<h2 id="정수의-계산">정수의 계산</h2>
<ul>
  <li>부호형의 덧셈, 곱셈에서 음의 오버플로우와 양의 오버플로우가 발생한다.</li>
  <li>쉬프트를 사용해서 곱셈이 가능하다.(비용이 훨씬 적게 듬)
    <ul>
      <li>ex) 11(1011[2])*4 = 44(101100[2])</li>
    </ul>
  </li>
</ul>

<h1 id="3-프로그램의-기계수준-표현">3 프로그램의 기계수준 표현</h1>
<blockquote>
  <p>우리가 코드를 작성하면 컴파일러는 소스파일의 어셈블러 버전을 생성한다. 어셈블러는 해당 어셈블리 코드를 바이너리 목적코드로 변환한다. 이후 목적코드를 컴퓨터가 해석한다.
이번 챕터에서는 어셈블리 코드에 대해 배운다. 이것을 배우게 되면 컴파일러의 최적화 방법을 알 수 있고 코드의 비효율성을 분석할 수 있게된다.</p>
</blockquote>

<h2 id="프로그램의-인코딩">프로그램의 인코딩</h2>
<ul>
  <li>프로그램 호출방법(c언어 기)
    <ol>
      <li>C 전처리가 #include와 #define을 확장해준다.</li>
      <li>컴파일러는 소스파일의 어셈블리 코드를 생성한다.(test.c -&gt; test.s)</li>
      <li>어셈블러는 어셈블리 코드를 바이너리 목적코드로 변환한다.(test.s -&gt; test.o)</li>
      <li>링커가 목적코드를 라이브러리 함수와 함꼐 최종 실행 파일인 test.p를 생성한다.</li>
    </ol>
  </li>
  <li>ISA(Instruction Set Architecture): 인스트럭션 집합구조, 프로세서의 상태 및 인스트럭션 형식과 영향을 정의한다.</li>
  <li>인스트럭션 특성 요약
    <ul>
      <li>오퍼랜드: 데이터와 목적지 위치를 명시한다.</li>
      <li>레지스터나 메모리로부터 읽고 저장한다.</li>
      <li>immediate(상수값), register, memory 세가지 타입이 존재한다.</li>
    </ul>
  </li>
  <li>인스트럭션 종류
    <ul>
      <li>데이터 이동: mov
        <ul>
          <li>두 개의 오퍼랜드 모두 메모리 위치에 올 수 없다.</li>
        </ul>
      </li>
      <li>스택의 저장과 추출: push, pop</li>
      <li>산술연산: add, sub, imul, idiv, sal(left shift), inc(++1), or, and…</li>
      <li>유효주소 적재: leaq
        <ul>
          <li>포인터 생성하기 위한 인스트럭션</li>
        </ul>
      </li>
      <li>
        <ul>
          <li>조건코드: cf(carry flag), zf(zero flag), sf(sign flag), of(overflow flag)
            <ul>
              <li>cf: 중요한 비트로부터 받아올림이 발생한 것을 표시(오버플로우 검출)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>제어문: cmp, test, set
        <ul>
          <li>cmp는 두 오퍼랜드가 같으면 zf를 1로 설정</li>
          <li>test는 조건 코드만 설정</li>
          <li>set은 비교후 조건코드를 설정해줌</li>
        </ul>
      </li>
      <li>점프: jmp, je, jle…</li>
      <li>조건부 이동: cmove, cmovg…</li>
    </ul>
  </li>
  <li>조건부 분기(if else)
    <ul>
      <li>조건제어: cmp와 jump를 사용함</li>
      <li>조건부이동: cmove등을 사용함(더 빠름)
        <ul>
          <li>경우를 다 계산하고 이동만함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>반복문(for, while)
    <ul>
      <li>cmp와 jump를 사용함</li>
    </ul>
  </li>
</ul>

<h1 id="프로세서-구조">프로세서 구조</h1>
<h1 id="프로그램-성능-최적화하기">프로그램 성능 최적화하기</h1>
<h1 id="메모리-계층구조">메모리 계층구조</h1>
:ET