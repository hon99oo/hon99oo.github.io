I"{*<h1 id="1-주소-공간의-개념">1. 주소 공간의 개념</h1>

<h2 id="11-초기-시스템">1.1 초기 시스템</h2>
<ul>
  <li>메모리 관점에서 초기 컴퓨터는 많은 개념을 사용자에게 제공하지 않았다. 하지만, 시분할 시스템이 대중화 되면서 운영체제에게 새로운 요구 사항이 부과되었다. 여러 프로그램이
메모리에 동시에 존재하려면 <strong>보호(protection)</strong>가 중요한 문제가 된다.</li>
  <li>한 프로세스가 다른 프로세스의 메모리를 읽거나 혹은 더 안좋게는 쓸 수 있는 상황이 있어선 안된다.</li>
</ul>

<h2 id="12-주소-공간">1.2 주소 공간</h2>
<ul>
  <li>위 문제의 위험에 대비하기 위해 운영체제는 <strong>사용하기 쉬운(easy to use)</strong>메모리 개념을 만들어야 한다.
    <ul>
      <li>이 개념이 <strong>주소 공간(address space)</strong>이다.</li>
    </ul>
  </li>
  <li>주소 공간은 실행 프로그램의 모든 메모리 상태를 갖고 있다.
    <ul>
      <li>프로그램의 코드(code, 명령어): 메모리에 존재해야 하고 따라서 주소 공간에 존재한다.</li>
      <li>스택: 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는 데 사용된다.</li>
      <li>힙: 동적으로 할당되는 메모리를 위해 사용된다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/04/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림은 주소 공간의 예이다.
    <ul>
      <li>위의 그림처럼 실제로 프로그램이 물리 주소 0에서 16KB 사이에 존재하는 것은 아니다.실제로는 임의의 물리 주소에 탑재된다. 운영체제가 해당 일을 할 때 <strong>메모리를 가상화(virtualizing memory)</strong>한다고 말한다.</li>
      <li>즉, 메모리 가상화는 프로그램은 가상화된 주소를 사용하고 운영체제는 이 가상 주소를 실제 물리 메모리 주소로 변환하는 방식의 메커니즘을 가진다.</li>
    </ul>
  </li>
</ul>

<h2 id="13-가상-메모리-시스템vm의-목표">1.3 가상 메모리 시스템(VM)의 목표</h2>
<ul>
  <li>투명성(transparency): 운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 한다.</li>
  <li>효율성(efficiency): 운영체제는 가상화가 시간과 공간 측면에서 효율적이도록 해야 한다.</li>
  <li>보호(protection): 운영체제는 프로세스를 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호해야 한다.
    <ul>
      <li>보호 성질을 이용하여 프로세스들을 서로 <strong>격리(isolate)</strong>시킬 수 있다.</li>
    </ul>
  </li>
  <li>메모리를 가상화하기 위해 필요한 기본적인 <strong>기법</strong>과 <strong>정책</strong>이 있다.</li>
</ul>

<h1 id="2-주소-변환의-원리">2. 주소 변환의 원리</h1>
<ul>
  <li>메모리 가상화에서도 CPU 가상화 부분에서 제한적 직접 실행 기법과 비슷하게 약간의 하드웨어 지원을 받아 효율적인 가상화 제공 전략을 추구한다.</li>
  <li>메모리 가상화를 제공하는 동시에 효율성과 제어 모두를 추구한다.
    <ul>
      <li>효율성을 높이려면 하드웨어 지원을 활용할 수밖에 없다.</li>
      <li>제어는 응용 프로그램이 자기자신의 메모리 이외에는 다른 메모리에 접근하지 못한다는 것을 운영체제가 보장하는 것을 의미한다.</li>
      <li>마지막으로, 유연성(flexibility) 측면에서 VM 시스템에서 프로그래머가 원하는 대로 주소 공간을 사용하고, 프로그래밍하기 쉬운 시스템을 만들어야 한다.</li>
    </ul>
  </li>
  <li><strong>주소 변환(address translation)</strong>: 하드웨어 기반 주소 변환(hardware-based address translation)이라고도 하는 기법은 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위하여 하드웨어가 주소를 변환한다.
    <ul>
      <li>정확한 변환이 일어날 수 있도록 하드웨어를 셋업하기 위해 운영체제가 관여해야 한다. 운영체제는 메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야 하고, 메모리 사용을 제어하고 관리한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/04/img_1.png" width="30%" height="100%" /></p>
<ul>
  <li>위의 그림은 프로세스와 그 주소 공간이다.</li>
</ul>

<h2 id="21-동적하드웨어-기반-재배치-base-bound">2.1 동적(하드웨어 기반) 재배치: base-bound</h2>
<ul>
  <li><strong>베이스와 바운드(base and bound)</strong>: 이 기술은 <strong>동적 재배치(dynamic relocation)</strong>라고도 한다.</li>
  <li>이 기술은 각 CPU마다 2개의 하드웨어 레지스터가 필요하다. 하나는 <strong>베이스(base)</strong>레지스터, 다른 하나는 <strong>바운드(bound)</strong> 레지스터 혹은 <strong>한계(limit)</strong> 레지스터라고 불린다.
<br /><br /></li>
  <li><strong>베이스</strong> 레지스터 동작 방법
    <ol>
      <li>운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정한다.</li>
      <li>physical address = virtual address + base &lt;- 방법으로 프로세서에 의해 변환된다.
        <ul>
          <li>프로세스가 생성하는 메모리 참조는 <strong>가상 주소</strong>이다. 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 <strong>물리 주소</strong>를 생성한다.
<br /><br /></li>
        </ul>
      </li>
    </ol>
  </li>
  <li>가상 주소에서 물리 주소로의 변환이 <strong>주소 변환</strong>이라고 부르는 바로 그 기술이다.</li>
  <li>이 주소의 재배치는 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에, <strong>동적 재배치(dynamic relocation)</strong>라고도 불린다.
<br /><br /></li>
  <li><strong>바운드</strong> 레지스터는 보호를 지원하기 위해 존재한다. 프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인한다.</li>
  <li>바운드 레지스터의 정의 방법
    <ol>
      <li>주소 공간의 크기를 저장하는 방식</li>
      <li>주소 공간의 마지막 물리 주소를 저장하는 방식
<br /><br /></li>
    </ol>
  </li>
  <li>주소 변환에 도움을 주는 프로세서의 일부를 <strong>메모리 관리 장치(memory management unit,MMU)</strong>라고 부르기도 한다.</li>
</ul>

<h2 id="22-하드웨어-지원">2.2 하드웨어 지원</h2>

<h3 id="하드웨어-요구사항">하드웨어 요구사항</h3>
<ul>
  <li>특권 모드
    <ul>
      <li>사용자 모드 프로세스가 특권 연산을 실행하는 것을 방지하기 위해 필요</li>
    </ul>
  </li>
  <li>베이스/바운드 레지스터
    <ul>
      <li>주소 변환과 범위 검사를 지원하기 위하여 CPU 당 한 쌍의 레지스터가 필요</li>
    </ul>
  </li>
  <li>가상 주소를 변환하고 범위 안에 있는지 검사하는 능력
    <ul>
      <li>주소 변환과 범위 검사를 위한 회로. 매우 간단함</li>
    </ul>
  </li>
  <li>베이스/바운드를 갱신하기 위한 특권 명령어
    <ul>
      <li>프로그램 시작 전에 운영체제가 베이스와 바운드 레지스터 값을 지정할 수 있어야 함</li>
    </ul>
  </li>
  <li>예외 핸들러 등록을 위한 특권 명령어
    <ul>
      <li>운영체제가 예외 처리 코드를 하드웨어에게 알려줄 수 있어야 함</li>
    </ul>
  </li>
  <li>예외 발생 기능
    <ul>
      <li>프로세스가 특권 명령어 실행을 시도하거나 범위를 벗어난 메모리의 접근을 시도할 때 예외를 발생시킬 수 있어야 함</li>
    </ul>
  </li>
</ul>

<h2 id="23-운영체제-이슈">2.3 운영체제 이슈</h2>
<ul>
  <li>베이스와 바운드 방식의 가상 메모리 구현을 위해서 운영체제가 반드시 개입되어야 하는 중요한 세 개의 시점이 존재한다.
    <ol>
      <li>프로세스가 생성될 때 운영체제는 주소 공간이 저장될 메모리 공간을 찾아 조치를 취해야 한다.
        <ul>
          <li>새로운 프로세스가 생성되면 운영체제는 새로운 주소 공간 할당에 필요한 영역을 찾기 위해 <strong>빈 공간 리스트(free list)</strong> 자료 구조를 검색해야 한다.</li>
        </ul>
      </li>
      <li>프로세스가 종료할 때, 즉 정상적으로 종료될 때 또는 잘못된 행동을 하여 강제적으로 죽게될 때 프로세스가 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용할 수 있게 해야 한다.</li>
      <li>운영체제는 문맥 교환이 일어날 때에도 몇가지 추가 조치를 취해야 한다.
        <ul>
          <li>운영체제는 프로세스 전환 시 베이스와 바운드 쌍을 저장하고 복원해야 한다.</li>
          <li>운영체제가 실행중인 프로세스를 중단시키기로 결정하면 운영체제는 메모리에 존재하는 프로세스 별 자료 구조 안에 베이스와 바운드 레지스터의 값을 저장해야 한다.</li>
          <li>이 자료 구조는 <strong>프로세스 구조체(process structure)</strong> 또는 <strong>프로세스 제어 블럭(process control block, PCB)</strong>라고 불린다.</li>
        </ul>
      </li>
      <li>운영체제는 예외 핸들러 또는 호출된 함수를 제공해야 한다.</li>
    </ol>
  </li>
</ul>

<h2 id="24-주소변환바운드-베이스-요약">2.4 주소변환(바운드 베이스) 요약</h2>
<ul>
  <li>주소 변환이라고 알려진 가상 메모리 기법을 통해 제한적 직접 실행의 개념을 확장하였다.</li>
  <li><strong>주소 변환</strong>을 사용하면 운영체제는 프로세스의 모든 메모리 접근을 제어할 수 있고 ,접근이 항상 주소 공간의 범위 내에서 이루어지도록 보장할 수 있다.</li>
  <li>베이스 바운드, 즉 동적 재배치는 비효율적이다. 재배치된 프로세스는 스택과 힙 사이의 공간이 단순히 낭비되고 있다. 즉 <strong>내부 단편화(internal fragmentation)</strong>이 발생한다.
    <ul>
      <li>이를 해결하기 위해 베이스 바운드를 일반화한 기법 <strong>세그멘테이션(segmentation)</strong>을 사용한다.</li>
    </ul>
  </li>
</ul>

<h1 id="3">3.</h1>

:ET