I"<h1 id="1-스케줄링-개요">1. 스케줄링: 개요</h1>
<p>이전 포스트에서는 프로세스를 실행시키기 위한 문맥 교환 등의 저수준 <strong>기법</strong>에 대해서 설명하였다.
이번 포스트에서는 운영체제 스케줄러의 고수준 <strong>정책</strong>에 관한 이야기다.</p>

<h2 id="11-워크로드에-대한-가정">1.1 워크로드에 대한 가정</h2>
<ul>
  <li>프로세스가 동작하는 일련의 행위를 <strong>워크로드(workload)</strong>라 한다.
    <ul>
      <li>적절한 워크로드의 선정은 스케줄링 정책 개발에 매우 중요한 부분이다.</li>
    </ul>
  </li>
  <li>스케줄러의 종류를 임의로 세가지로 구분한다.
    <ul>
      <li>기본 스케줄러
        <ul>
          <li>선입선출(FIFO)</li>
          <li>최단 작업 우선(SJF, Shortest Job First)</li>
          <li>최소 잔여시간 우선(STCF, Shortest Time-to-Completion First)</li>
          <li>라운드 로빈(RR, Round-Robin)</li>
        </ul>
      </li>
      <li>멀티 레벨 피드백 큐(MLFQ)</li>
      <li>비례 볘분 or 공정 배분
        <ul>
          <li>추첨 스케줄링(lottery scheduling)</li>
          <li>보폭 스케줄링(stride scheduling)</li>
          <li>리눅스 CFS(Completely Fair Scheduler)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="2-기본-스케줄러">2. 기본 스케줄러</h1>

<h2 id="21-선입선출fifo">2.1 선입선출(FIFO)</h2>
<ul>
  <li>먼저 도착한 프로세스를 우선적으로 스케줄링 한다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_1.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 FIFO의 간단한 예이다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_2.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 FIFO의 단점을 보여주는 예이다.
    <ul>
      <li>긴 실행 시간을 가진 A가 먼저 도착했기 때문에 전체 평균 반환 시간이 110초로 늘어났다.</li>
      <li>만약 B, C를 먼저 해결한다면 전체 평균 반환 시간은 대폭 줄어들 것이다.</li>
      <li>해당 현상을 convoy effect 라고 부르며 CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상을 말한다.</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>반환시간은 작업이 완료된 시각에서 작업이 도착한 시각을 뺀 시각이다.</p>
</blockquote>

<h2 id="22-최단-작업-우선sjf">2.2 최단 작업 우선(SJF)</h2>
<ul>
  <li>앞서 소개한 convoy effect는 최단 작업 우선 스케줄링으로 간단하게 해결할 수 있다.</li>
  <li>가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_3.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 SJF의 간단한 예이다.</li>
</ul>

<p><img src="../../assets/img/ostep/03/img_4.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 SJ의 단점을 보여주는 예이다.
    <ul>
      <li>긴 실행 시간을 가진 A가 실행중에 B,C가 도착했기 때문에 convoy 문제가 다시 발생한다.</li>
    </ul>
  </li>
</ul>

<h2 id="23-최소-잔여시간-우선stcf">2.3 최소 잔여시간 우선(STCF)</h2>
<ul>
  <li>SJF에 선점 기능을 추가한 스케줄러다.
    <ul>
      <li>현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/03/img_4.png" width="50%" height="100%" /></p>
<ul>
  <li>위의 그림은 STCF의 간단한 예이다.</li>
</ul>

<h2 id="24-라운드-로빈rr">2.4 라운드 로빈(RR)</h2>
<blockquote>
  <p>FIFO, SJF, STCF는 모두 평가 기준을 반환 시간인 스케줄러이다. RR은 스케줄러의 응답 시간 평가 기준을 추가한 기법이다.</p>
</blockquote>

<ul>
  <li>RR은 프로세스의 작업이 끝날 때 까지 기다리지 않는다. 대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.
    <ul>
      <li>이때 작업이 실행되는 일정 시간을 <strong>타임 슬라이스(time slice)</strong> 또는 <strong>스케줄링 퀀텀(scheduling quantum)</strong>이라 부른다.</li>
      <li>RR은 때때로 <strong>타임 슬라이싱</strong>이라고 불린다.</li>
    </ul>
  </li>
</ul>
:ET