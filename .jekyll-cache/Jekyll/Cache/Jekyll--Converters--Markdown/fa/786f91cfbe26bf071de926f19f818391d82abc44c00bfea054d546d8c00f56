I"%<h1 id="1-페이징-더-빠른-변환tlb">1. 페이징: 더 빠른 변환(TLB)</h1>
<ul>
  <li>페이징은 주소 공간을 작은 크기(페이지)로 나누고 각 페이지의 실제 위치(매핑 정보)를 메모리에 저장한다. 매핑 정보를 저장하는 자료 구조를 페이지 테이블이라 한다.</li>
  <li>페이징은 성능 저하를 유발할 수 있다.
    <ul>
      <li>가상 주소에서 물리 주소로의 주소 변환을 위해 메모리에 존재하는 매핑 정보를 읽어야 한다는 사실은 페이지 테이블 접근을 위한 메모리 읽기 작업이며 이는 엄청난 성능 저하를 유발한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>주소 변환을 빠르게 하기 위해서 우리는 <strong>변환-색인 버퍼(translation-lookaside buffer)</strong> 또는 <strong>TLB</strong>를 도입한다.
    <ul>
      <li>TLB는 칩의 <strong>메모리 관리부(memory-management unit, MMU)</strong>의 일부이다.</li>
      <li>자주 참조되는 VirtualMemory-PhysicalMemory 변환 정보를 저장하는 하드웨어 캐시이다.</li>
      <li>가상 메모리 참조 시, 하드웨어는 먼저 TLB에 원하는 변환 정보가 있는지를 확인한다. 만약 있다면 페이지 테이블을 통하지 않고 변환을 빠르게 수행한다. 실질적으로 TLB는 페이징 성능을 엄청나게 향상시킨다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-tlb의-기본-알고리즘">1.1 TLB의 기본 알고리즘</h2>
<ul>
  <li>주소 변환부는 단순한 <strong>선형 페이지 테이블</strong>(배열로 이루어진 페이지 테이블) 과 <strong>하드웨어로 관리되는 TLB</strong>로 구성되어 있다.</li>
  <li>하드웨어 부분의 알고리즘은 다음과 같이 동작한다. (TLB Hit 과 Miss로 나뉨)</li>
  <li>TLB Hit
    <ol>
      <li>가상주소에서 가상 페이지 번호(virtual page nubmer, <strong>VPN</strong>)을 추출한 후, 해당 VPN을 TLB 존재 여부를 검사한다.</li>
      <li>만약 존재한다면 <strong>TLB 히트</strong>이고 TLB가 변환 값을 갖고 있다는 것을 뜻한다.</li>
      <li>해당 TLB 항목에서 페이지 프레임 번호(page fame number, PFN)을 추출한다.</li>
      <li>해당 페이지에 대한 접근 권한 검사가 성공하면</li>
      <li>그 정보를 원래 가상 주소의 오프셋과 합쳐서 원하는 물리 주소를 구성하고 메모리에 접근한다.</li>
    </ol>
  </li>
  <li>TLB Miss
    <ol>
      <li>위의 2번에서 TLB Miss되면</li>
      <li>하드웨어가 변환 정보를 찾기 위해서 페이지 테이블에 접근한다.</li>
      <li>프로세스가 생성한 가상 메모리 참조가 유효하고 접근 가능하다면</li>
      <li>해당 변환정보를 TLB로 읽어들인다.(시간이 많이 소요되는 작업, 테이블 접근을 위한 메모리 참조 때문)</li>
      <li>TLB가 갱신되면 하드웨어는 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB는 프로세싱 코어와 가까운 곳에 위치하고 있고, 매우 빠른 하드웨어로 구성되기 때문에, 주소 변환 작업은 그다지 부담스러운 작업이아니다.</li>
  <li>TLB 미스가 많이 발생할수록 메모리 접근 횟수가 많아진다.
    <ul>
      <li>TLB 미스가 발생하는 경우를 최대한 피해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="12-예제-배열-접근">1.2 예제: 배열 접근</h2>

<p><img src="../../assets/img/ostep/07/img.png" width="40%" height="100%" /></p>
<ul>
  <li>위의 그림과 같이 배열의 데이터가 저장되어 있다고 가정하자.
    <ul>
      <li>index 0부터 9까지 배열을 읽으면 index0을 읽을 때 TLB는 초기화 되어있기 때문에 TLB미스가 발생하고 VPN 06번 페이지를 TLB를 가져온다.</li>
      <li>이후 1번과 2번 index를 읽을 때는 TLB히트가 발생하여 바로 가져올 수 있다.</li>
      <li>다시 3번 index를 읽을 때는 TLB미스가 발생하여 VPN 07번 페이지를 TLB로 가져온다.</li>
    </ul>
  </li>
  <li>위의 예제를 통해 배열이 처음으로 접근되었지만, TLB는 <strong>공간 지역성</strong>으로 인해서 성능을 개선할 수 있다.</li>
  <li>만약 TLB가 모든 주소 변환 정보를 저장할 정도로 충분히 크다면 히트, 히트, 히트, 히트, … 히트 를 얻는다.
    <ul>
      <li>이 경우에는 <strong>시간 지역성</strong>으로 인해 TLB의 히트율이 높아진다.</li>
    </ul>
  </li>
  <li>프로그램이 공간 혹은 시간 지역성을 보이는 경우, TLB 사용 효과가 더욱 두드러지게 나타날 것이다.</li>
</ul>

<h2 id="13-tlb-미스는-누가-처리할까">1.3 TLB 미스는 누가 처리할까</h2>
<ul>
  <li>TLB 미스의 처리는 두 가지 방법이 있다.
    <ul>
      <li>하드웨어와 소프트웨어이다.</li>
    </ul>
  </li>
</ul>

<h3 id="cisccomplex-instruction-set-computers-tlb-미스를-하드웨어가-처리하도록-설계">CISC(complex-instruction set computers): TLB 미스를 하드웨어가 처리하도록 설계</h3>
<ul>
  <li>이를 위해서 하드웨어가 페이지 테이블에 대한 명확한 정보를 가지고 있어야 한다.
    <ul>
      <li>메모리 상 위치(<strong>page-table base register</strong>를 통해서)와 정확한 형식을 파악하고 있어야 한다.</li>
    </ul>
  </li>
  <li>미스 발생시 다음과 같은 일을 한다.
    <ol>
      <li>페이지 테이블에서 원하는 페이지 테이블 엔트리를 찾고</li>
      <li>필요한 변환 정보를 추출하여</li>
      <li>TLB를 갱신한 후</li>
      <li>TLB 미스가 발생한 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>x86 CPU가 하드웨어로 관리 되는 TLB의 대표적인 예다.
    <ul>
      <li>멀티 레벨 페이지 테이블을 사용한다.</li>
    </ul>
  </li>
</ul>

<h3 id="riscreduced-instruction-set-computing-소프트웨어-관리-tlb-사용">RISC(reduced instruction set computing): 소프트웨어 관리 TLB 사용</h3>
<ul>
  <li>RISC 기반 컴퓨터에서 TLB 미스를 처리하는 과정은 다음과 같다.
    <ol>
      <li>TLB에서 주소 찾는 것이 실패하면, 하드웨어는 예외 시그널을 발생시킨다.</li>
      <li>예외 시그널을 받은 운영체제는 명령어 실행을 잠정 중지하고, 실행 모드를 커널 모드로 변경하여, 커널 코드 실행을 준비한다.
        <ul>
          <li>실행 모드를 커널 모드로 변경하는 작업의 핵심은 커널 주소 공간을 접근할 수 있또록 특권 레벨(privilege level)로 상향 조정하는 것이다.</li>
        </ul>
      </li>
      <li>커널 모드로 변경이 되면 <strong>트랩 핸들러(trap handler)</strong>를 실행한다.
        <ul>
          <li>이 때 실행되는 트랩 핸들러는 TLB 미스의 처리를 담당하는 운영체제 코드이다.</li>
        </ul>
      </li>
      <li>이 트랩 핸들러는 페이지 테이블을 검색하여 변환 정보를 찾고, TLB 접근이 가능한 “특권” 명령어를 사용하여 TLB를 갱신한 후에 리턴한다.</li>
      <li>트랩 핸들러에서 리턴되면 하드웨어가 명령어를 재실행한다.</li>
    </ol>
  </li>
  <li>TLB 미스를 처리하는 트랩 핸들러는 시스템 콜 호출 시 사용되는 트랩 핸들러와의 차이가 있다.
    <ul>
      <li>TLB 미스 처리의 경우 다음 명령어의 PC값을 트랩을 발생시킨 명령을 다시 실행해야한다.</li>
    </ul>
  </li>
  <li>
    <p>TLB 미스 핸들러를 실행할 때, TLB 미스가 무한 반복되지 않도록 주의해야 한다.</p>
  </li>
  <li>TLB를 소프트웨어로 관리하는 방식의 주된 장점은 유연성과 단순함이다.</li>
</ul>

<h2 id="14-tlb의-구성-무엇이-있나">1.4 TLB의 구성: 무엇이 있나?</h2>
<ul>
  <li>TLB는 32, 64, 또는 128개의 엔트리를 가지며, <strong>완전 연관(fully associative)</strong> 방식으로 설계된다.
    <ul>
      <li>완전 연관 방식에서 변환 정보는 TLB 내에 어디든 위치할 수 있으며, 원하는 변환 정보를 찾는 검색은 TLB 전체에서 병렬적으로 수행된다.</li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>TLB의 구성: VPN</td>
          <td>PFN</td>
          <td>offset(다른 비트들)</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>하드웨어 측면에서 보자면, TLB는 <strong>완전 연관</strong> 캐시이다.</li>
    </ul>
  </li>
  <li>TLB는 일반적으로 <strong>valid bit</strong>을 갖고 있다.
    <ul>
      <li>특정 항목이 유효한 변환 정보를 갖고 있는지 여부를 나타낸다.</li>
    </ul>
  </li>
  <li><strong>보호(protection)</strong>비트라는 것도 있다.
    <ul>
      <li>보호 비트들은 페이지가 어떻게 접근될 수 있는지를 나타낸다.</li>
    </ul>
  </li>
  <li><strong>더티 비트(dirty bit)</strong>라는 것도 있다.
    <ul>
      <li>페이지가 변경되었는지에 대한 정보를 가지고 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="15-tlb의-문제-문맥-교환">1.5 TLB의 문제: 문맥 교환</h2>
<ul>
  <li>TLB에 있는 가상 주소와 실제 주소 간의 변환 정보는 그것을 탑재시킨 프로세스에서만 유효하다.
    <ul>
      <li>새로운 프로세스에서는 이전에 실행하던 프로세스의 변환 정보를 사용하지 않도록 주의해야 한다.</li>
    </ul>
  </li>
</ul>

:ET