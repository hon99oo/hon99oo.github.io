I"&<h1 id="1-파일-시스템-구현">1. 파일 시스템 구현</h1>
<ul>
  <li><strong>vsfs(Very Simple File System)</strong>은 Unix 파일 시스템을 단순화한 것으로 디스크 자료구조(on-disk structure)와 접근 방법 그리고 다양한 파일 시스텤들의 정책들을 소개하기 위한 용도이다.</li>
  <li>파일 시스템은 순수한 소프트웨어이다.</li>
  <li>어떻게 간단한 파일 시스템을 만들 것인가
    <ul>
      <li>간단한 파일 시스템을 어떻게 만들 수 있을까?</li>
      <li>디스크 위에는 어떤 자료 구조가 필요할까?</li>
      <li>그러한 자료 구조는 어떤 정보를 추적해야 하는가?</li>
      <li>그 자료 구조들은 어떻게 접근되어야 하는가?</li>
    </ul>
  </li>
</ul>

<h1 id="11-생각하는-방법">1.1 생각하는 방법</h1>
<ul>
  <li>파일 시스템에 대해 학습할 때, 두 가지 측면에서 접근해야 한다.
    <ol>
      <li>파일 시스템의 <strong>자료 구조</strong>
        <ul>
          <li>파일 시스템이 자신의 데이터와 메타데이터를 관리하기 위해 디스크 상에 어떤 종류의 자료 구조가 있어야 하겠는가?</li>
        </ul>
      </li>
      <li><strong>접근 방법(access method)</strong>
        <ul>
          <li>프로세스가 호출하는 open(), read(), write() 등의 명령들은 파일 시스템의 자료 구조와 어떤 관련이 있는가?</li>
          <li>특정 시스템 콜을 실행할 때에 어떤 자료 구조들이 읽히는가?</li>
          <li>이 모든 과정이 얼마나 효율적으로 동작하는가?</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h1 id="12-전체-구성">1.2 전체 구성</h1>
<ul>
  <li>가장 먼저 해야 할 것은 디스크를 <strong>블럭(block)</strong>들로 나누는 것이다.</li>
</ul>

<p><img src="../../assets/img/ostep/18/img.png" width="80%" height="100%" /></p>

<ul>
  <li>파일 시스템의 대부분의 공간은 사용자 데이터로 이루어져 있다.</li>
  <li>사용자 데이터가 있는 디스크 공간을 <strong>데이터 영역(data region)</strong>이라고 하자.</li>
</ul>

<p><img src="../../assets/img/ostep/18/img_1.png" width="80%" height="100%" /></p>

<ul>
  <li>파일 시스템은 각 파일에 대한 정보를 관리한다.</li>
  <li>그 정보가 <strong>메타데이터(metadata)</strong>의 핵심이다.</li>
  <li>파일을 구성하는 데이터 블럭(데이터 영역 내의)들과 그 파일의 크기, 소유자, 접근 권한, 접근과 변경 시간 등과 같은 정보들이 이에 해당한다.</li>
  <li>파일 시스템은 이 정보를 보통 <strong>아이노드(inode)</strong>라고 부르는 자료 구조에 저장한다.</li>
  <li>아이노드들의 저장을 위해 디스크 공간이 필요하다.
    <ul>
      <li>이 영역을 <strong>아이노드 테이블(inode table)</strong>이라 한다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/18/img_2.png" width="80%" height="100%" /></p>
<ul>
  <li>꼭 필요한 정보는 아이노드나 데이터 블럭의 사용여부에 대한 것이다.
    <ul>
      <li>각 블럭이 현재 사용 중인지 아닌지를 표현할 <strong>할당 구조(allocation structure)</strong>가 필요하다.</li>
      <li>예를 들면 <strong>프리 리스트(free list)</strong>를 사용하여, 사용 중이 아닌 블럭들을 링크드 리스트 형태로 관리할 수 있다.</li>
      <li>아이노드 첫 번째 프리 블럭의 위치만 기억하면 된다.</li>
      <li>우리는 단순한 <strong>비트맵(bitmap)</strong>을 사용한다.</li>
    </ul>
  </li>
  <li>데이터 영역에 있는 블럭들의 사용여부를 표현하기 위해서 <strong>데이터 비트맵(data bitmap)</strong>을, 아이노드 테이블에 있는 아이노드들이 사용 중인지를 나타내기 위해서 <strong>아이노드 비트맵(inode bitmap)</strong>을 사용한다.
    <ul>
      <li>비트맵은 비트들의 배열이다.</li>
    </ul>
  </li>
</ul>

<p><img src="../../assets/img/ostep/18/img_3.png" width="80%" height="100%" /></p>
<ul>
  <li>남은 한 블럭의 존재는 <strong>슈퍼블럭(super block)</strong>을 위한 공간이다.
    <ul>
      <li>슈퍼블럭은 이 파일 시스템 전체에 대한 정보를 담고 있다.</li>
      <li>예를 들면 파일 시스템에 몇 개의 아이노드와 데이터 블럭이 있는지, 아이노드 테이블은 어디에서 시작하는지 같은 정보를 담고 있다.</li>
      <li>일반적으로 대부분의 파일 시스템은 슈퍼블럭을 몇 개 복사 해둔다.</li>
    </ul>
  </li>
  <li>파일 시스템을 마운트할 때, 운영체제는 우선 슈퍼블럭을 읽어들여서 파일 시스템의 여러가지 요소들을 초기화하고, 그 후에 각 파티션을 파일 시스템 트리에 붙히는 작업을 진행한다.</li>
</ul>

<h2 id="13-파일-구성-아이노드">1.3 파일 구성: 아이노드</h2>
<ul>
  <li>파일 시스템의 디스크 자료 구조 중 가장 중요한 것은 <strong>아이노드(inode)</strong>이다.</li>
  <li>아이노드는 <strong>인덱스 노드(index node)</strong>의 줄임말이다.</li>
  <li>이 노드들은 원래는 배열로 되어 있었는데, 각 배열은 특정 아이노드를 접근하기 위해 탐색된다.</li>
  <li><strong>아이노드</strong>
    <ul>
      <li>이 자료 구조는 파일 크기, 접근권한 그리고 파일 블럭들의 위치 정보를 가지고 있다.</li>
    </ul>
  </li>
  <li>각 아이노드는 숫자(<strong>아이-넘버(i-number)</strong>)로 표현된다.</li>
</ul>

<p><img src="../../assets/img/ostep/18/img_4.png" width="80%" height="100%" /></p>
<ul>
  <li>아이노드에는 파일에 대한 정보가 다 들어있다.
    <ul>
      <li>파일의 종류(예, 일반 파일, 디렉터리 등), 크기, 할당된 블럭 수, 보호 정보(파일의 소유, 접근 권한 등), 시간 정보와 더불어 데이터 블럭이 디스크 어디에 존재하는지(예, 포인터의 일종)와 같은 정보들이 담겨 있다.</li>
      <li>이와 같은 정보들을 <strong>메타데이터(metadata)</strong>라고 한다.</li>
    </ul>
  </li>
  <li>아이노드를 설계 시 가장 중요한 결정 중 하나는 데이터 블럭의 위치를 표현하는 방법이다.
    <ul>
      <li>간단한 방법은 아이노드 내에 여러 개의 <strong>직접 포인터(direct pointer, 디스크 주소)</strong>를 두는 것이다.</li>
      <li>각 포인터는 파일의 디스크 블럭 하나를 기리킨다.</li>
      <li>이 방법에는 파일 크기의 제한이 있다. 파일 크기는 (포인터의 개수)*(블럭 크기)</li>
    </ul>
  </li>
</ul>

<h3 id="멀티-레벨-인덱스">멀티 레벨 인덱스</h3>
<ul>
  <li>큰 파일을 지원하기 위해서 파일 시스템 개발자들은 아이노드 내에 다른 자료 구조를 추가해야 했다.</li>
  <li>일반적으로 사용되는 방법 중 하나는 <strong>간접 포인터(indirect pointer)</strong>라는 특수한 포인터를 사용하는 것이다.</li>
  <li>간접 포인터는 데이터 블럭을 가리키지 않는다.</li>
  <li>
    <p>간접 포인터가 가리키는 블럭에는 데이터 블럭을 가리키는 포인터들이 저장된다.</p>
  </li>
  <li>더 큰 파일을 저장하고 싶을 땐 <strong>이중 간접 포인터(double indirect pointer)</strong>를 추가한다.
    <ul>
      <li>이중 간접 포인터가 가르키는 블럭에는 간접 포인터들이 저장되어 있다.</li>
      <li>더 큰 파일을 저장하고 싶다면 <strong>삼중 간접 포인터(triple indirect pointer)</strong>를 사용하면 된다.</li>
    </ul>
  </li>
  <li>디스크 블럭들은 일종의 트리 형태로 구성되어 하나의 파일을 이룬다. 이러한 구성방식을 <strong>멀티 레벨 인덱스</strong> 기법이라 한다.</li>
</ul>

<blockquote>
  <p>위의 방식의 트리는 형태가 매우 편향적이다. 파일의 시작 부분을 이루는 블럭들은 한번의 포인터로 접근이 가능하다. 큰 파일의 경우, 파일의 끝부분에 있는 블럭들은 포인터를
세 번 따라가야 실제 블럭을 읽을 수 있다. 왜 이렇게 했을까? <strong>대부분의 크기가 작기</strong> 때문이다. 대부분의 파일들이 작다면, 작은 파일을 빨리 읽고 쓸 수 있도록 파일 구조를 설계 해야한다.</p>
</blockquote>

<h2 id="14-디렉터리-구조">1.4 디렉터리 구조</h2>
<ul>
  <li>디렉터리는 (항목의 이름, 아이노드 번호) 쌍의 배열로 구성되어 있다.</li>
</ul>

<p><img src="../../assets/img/ostep/18/img_6.png" width="80%" height="100%" /></p>
<ul>
  <li>위의 표는 dir의 데이터 블럭이다.
    <ul>
      <li>항목의 길이를 명시하는 이유 중에 하나가 중간에 빈 공간이 생기기 때문이다. 새로운 디렉터리 항목을 생성할 때, 기존 항목이 삭제되어 생긴 빈 공간에 새로이 생성된 항목을 위치시킬 수도 있기 때문이다.</li>
    </ul>
  </li>
  <li>대부분 파일 시스템에서 디렉터리는 특수한 종류의 파일로 간주한다.
    <ul>
      <li>디렉터리는 자신의 아이노드를 가지며, 이 아이노드는 아이노드 테이블에 존재한다.(아이노드의 type 필드에 “일반 파일” 대신에 “디렉터리”라고 명시되어 있다).</li>
      <li>디렉터리는 자신의 데이터 블럭을 갖고 있으며, 이들 블럭의 위치는 일반 파일과 마찬가지로 아이노드에 명시되어 있다.</li>
    </ul>
  </li>
  <li>파일 생성 시 현재 디렉터리에 동일한 이름의 파일이 있는지를 먼저 검사해야 한다.</li>
</ul>

:ET