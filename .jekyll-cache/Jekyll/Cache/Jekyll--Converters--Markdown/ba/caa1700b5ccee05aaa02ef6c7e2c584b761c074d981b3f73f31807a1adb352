I"<h1 id="1-세마포어semaphore">1. 세마포어(semaphore)</h1>
<ul>
  <li>세마포어는 락과 컨디션 변수로 모두 사용할 수 있다.</li>
  <li>세마포어를 어떻게 사용하는가?
    <ul>
      <li>락과 컨디션 변수 대신에 세마포어를 사용하는 방법은 무엇인가?</li>
      <li>세마포어의 정의는 무엇인가?</li>
      <li>이진 세마포어는 무엇인가?</li>
      <li>락과 컨디션 변수를 사용하여 세마포어를 만드는 것이 가능한가?</li>
    </ul>
  </li>
</ul>

<h1 id="11-세마포어-정의">1.1 세마포어: 정의</h1>
<ul>
  <li>세마포어는 정수 값을 갖는 객체로서 두 개의 루틴으로 조작할 수 있다.
    <ul>
      <li>POSIX 표준에서 이 두 개의 루틴은 sem_wait()와 sem_post()이다.</li>
      <li>세마포어는 초기값에 의해 동작이 결정되기 때문에, 사용하기 전 “제일 먼저” 값을 초기화해야 한다.</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;semaphore.h&gt;
</span>    <span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<ul>
  <li>3번째 인자로 1을 전달하여 세마포어의 값을 1로 초기화한다.</li>
  <li>2번째 인자는 0인데, 같은 프로세스 내의 쓰레드 간에 세마포어를 공유한다는 것을 의미한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
        <span class="n">decrement</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span><span class="p">;</span>
        <span class="n">wait</span> <span class="k">if</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">is</span> <span class="n">negative</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">){</span>
        <span class="n">increment</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">one</span> <span class="n">or</span> <span class="n">more</span> <span class="n">threads</span> <span class="n">waiting</span><span class="p">,</span> <span class="n">wake</span> <span class="n">one</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<ul>
  <li>세마포어: sem_wait()과 sem_post()의 정의이다.</li>
  <li>sem_wait()
    <ul>
      <li>함수는 즉시 리턴하거나(세마포어의 값이 1 이상이면) 아니면 해당 세마포어 값이 1 이상이 될 때 까지 호출자를 대기시킨다.</li>
      <li>다수의 쓰레드들이 sem_wait()을 호출할 수 있기 때문에, 대기큐에는 다수의 쓰레드가 존재할 수 있다.(대기하는 법에는 회전과 재우기의 두 가지가 있다.)</li>
    </ul>
  </li>
  <li>sem_post()
    <ul>
      <li>함수는 대기하지 않는다.</li>
      <li>세마포어 값을 증가시키고 대기 중인 쓰레드 중 하나를 깨운다.</li>
    </ul>
  </li>
  <li>세마포어가 음수라면 그 값은 현재 대기 중인 쓰레드의 개수와 같다.</li>
  <li>이 두개의 함수는 원자적으로 실행된다고 가정한다.</li>
</ul>

<h2 id="12-이진-세마포어락">1.2 이진 세마포어(락)</h2>
:ET