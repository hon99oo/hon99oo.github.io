I"H-<h1 id="1-병행성-개요">1. 병행성: 개요</h1>
<ul>
  <li>멀티 쓰레드 프로그램은 하나 이상의 실행 지점(독립적으로 불러 들여지고 실행될 수 있는 여러 개의 PC 값)을 가지고 있다.</li>
  <li>멀티 쓰레드를 이해하는 다른 방법은 각 쓰레드가 프로세스와 매우 유사하지만, 차이가 있다면 쓰레드들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다는 것이다.</li>
  <li>쓰레드는 어디서 명령어들을 불러 들일지 추적하는 프로그램 카운터(PC)와 연산을 위한 레지스터들을 가지고 있다.</li>
  <li>두 개 이상의 쓰레드가 하나의 프로세서에서 실행 중이라면 <strong>문맥 교환</strong>이 이루어져야 한다.
    <ul>
      <li>문맥 전환을 할 때 프로세스는 자신의 상태를 <strong>프로세스 제어 블럭(process control block, PCB)</strong>에 저장하듯이 쓰레드는 <strong>쓰레드 제어 블럭(thread control block, TCB)</strong>에 저장한다.</li>
      <li>가장 큰 차이 중 하나는 프로세스의 경우와 달리 쓰레드 간의 문맥 교환에서는 주소 공간을 그대로 사용한다.</li>
      <li>쓰레드와 프로세스의 또 다른 차이는 쓰레드는 자신만의 스택이 존재한다.</li>
    </ul>
  </li>
</ul>

<h2 id="11-왜-쓰레드를-사용하는가">1.1 왜 쓰레드를 사용하는가?</h2>
<ul>
  <li>쓰레드를 사용해야하는 2가지 주요 이유가 있다.
    <ol>
      <li><strong>병렬 처리(parallelism)</strong></li>
      <li>느린 I/O로 인해 프로그램 실행이 멈추지 않도록하기 위해 쓰레드를 사용한다.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>쓰레드는 병렬처리가 가능한데 문맥전환을 한다…?! 이 말의 뜻은 만약 프로세서가 1개일 때는 쓰레드가 문맥전환을 이룬다 &lt;- 이것도 멀티 프로세스보다 성능이 좋은데 그 이유는 문맥전환의 비용이 쓰레드가 더 적기 때문이다.</p>

  <p>2번의 추가 예로는 예를들어 한 프로세스에서 파일 입출력 시그널이 발생했다. 원래 같으면 해당 프로세스는 블록되고 다른 프로세스로 제어가 넘어가야한다. 하지만 멀티 쓰레드라면 파일 입출력이 진행 되는 동안 같은 프로세스에서 다른 쓰레드가 다른 작업을 이어 나갈 수 있다.</p>
</blockquote>

<h2 id="12-예제-쓰레드-생성">1.2 예제: 쓰레드 생성</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;pthread.h&gt;
</span>    
    <span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"main: begin</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"B"</span><span class="p">);</span>
        <span class="c1">// 종료할 수 있도록 대기 중인 쓰레드 병합하기</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"main: end</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<ul>
  <li>위의 코드를 실행하면, A B 또는 B A가 출력된다.
    <ul>
      <li>생성된 쓰레드는 호출자와는 별개로 실행된다는 것을 확인할 수 있다.</li>
      <li>다음에 실행될 쓰레드는 OS <strong>스케줄러(scheduler)</strong>에 의해 결정된다.</li>
    </ul>
  </li>
</ul>

<h2 id="13-훨씬-더-어려운-이유-데이터의-공유">1.3 훨씬 더 어려운 이유: 데이터의 공유</h2>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="cp">#include &lt;pthread.h&gt;
</span>    
    <span class="k">static</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// mythread()</span>
    <span class="c1">// 반복문을 사용하여 단순히 1씩 더하기</span>
    <span class="c1">// 10,000,000을 변수 counter에 더하는 방법이 아니다.</span>
    <span class="c1">// 하지만, 문제가 무엇인지 명확하게 해준다.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="nf">mythread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s: begin</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">1e7</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s: done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// main()</span>
    <span class="c1">// 두 개의 쓰레드를 실행하고 (pthread_create)</span>
    <span class="c1">// 대기한다 (pthread_join)</span>
    <span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="n">pthread_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"main: begin (counter = %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"A"</span><span class="p">);</span>
        <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">mythread</span><span class="p">,</span> <span class="s">"B"</span><span class="p">);</span>
        <span class="c1">// 종료할 수 있도록 대기 중인 쓰레드 병합하기</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">pthread_join</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"main: done with both (counter = %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span></code></pre></figure>

<ul>
  <li>위의 코드를 실행하면 출력으로 20000000이 나올 줄 알았지만, 결과는 매번 다르다. ex) 187777789, 15796892
    <ul>
      <li>왜 이런 결과가 나오는지 궁금하다면 더 읽어보자!</li>
    </ul>
  </li>
</ul>

<h2 id="14-문제의-핵심-제어-없는-스케줄링">1.4 문제의 핵심: 제어 없는 스케줄링</h2>
<ul>
  <li>mythread 함수의 for문을 역 어셈블리 하면 다음과 같은 결과를 가진다.</li>
</ul>

<figure class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">mov</span> <span class="mh">0x8049al</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
    <span class="n">add</span> <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
    <span class="n">mov</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span> <span class="mh">0x8049a1c</span></code></pre></figure>
:ET