I"<h1 id="chapter-03-프로그램의-기계수준-표현">Chapter 03. 프로그램의 기계수준 표현</h1>
<ul>
  <li>3.1 역사적 관점</li>
  <li>3.2 프로그램의 인코딩</li>
  <li>3.3 데이터의 형식</li>
  <li>3.4 정보 접근하기</li>
  <li>3.5 산술연산과 논리연산</li>
  <li>3.6 제어문</li>
</ul>

<h1 id="35-산술연산과-논리연산">3.5 산술연산과 논리연산</h1>
<p><img src="../../assets/img/csapp/06/img.png" width="80%" height="100%" /></p>
<ul>
  <li>위 그림은 x86-64 정수와 논리연산의 리스트를 보여준다. 오퍼랜드의 길이에 따른 다양한 변형이 가능하기 때문에 대부분의 연산을 인스트럭션 클래스에 따라 나열하였다.</li>
  <li>인스트럭션 클래스 ADD는 네 개의 덧셈 인스트럭션으로 이루어져 있다.
    <ul>
      <li>addb, addw, addl, addq로 각각 바이트, 워드, 어블워드, 쿼드워드를 의미한다.</li>
    </ul>
  </li>
  <li>연산들은 네 개의 그룹으로 나누어진다.
    <ul>
      <li>유효주소 적재, 단항unary, 이항binary, 쉬프트
        <ul>
          <li>이항 연산은 두 개의 오퍼랜드를 가진다.</li>
          <li>단항 연산은 한 개의 오퍼랜드를 가진다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="351-유효주소-적재-load-effective-address">3.5.1 유효주소 적재 Load Effective Address</h2>
<ul>
  <li>유효주소 적재 인스트럭션 leaq는 실제로는 movq 인스트럭션의 변형이다.</li>
  <li>메모리에서 레지스터로 읽어들이는 인스트럭션의 형태를 갖지만, 메모리를 전혀 참조하지 않는다.</li>
  <li>가리키는 위치에서 읽기를 수행하는 대신에 유효주소를 목적지에 복사한다.</li>
  <li>이 인스트럭션은 나중의 메모리 참조에 사용하게 되는 포인터를 생성하기 위해 사용한다.</li>
  <li>또한 일반적인 산술연산을 간결하게 설명하기 위해 사용된다
    <ul>
      <li>ex) %rdx가 x를 가지고 있다면, leaq 7(%rdx, %rdx, 7)은 %rdx에 5x+7을 저장한다.</li>
    </ul>
  </li>
  <li>목적 오퍼랜드는 반드시 레지스터만 올 수 있다.</li>
</ul>

<h2 id="352-단항-및-이항-연산">3.5.2 단항 및 이항 연산</h2>
<ul>
  <li>단항 연산
    <ul>
      <li>하나의 오퍼랜드가 소스와 목적지로 동시에 사용되는 단항 연산이다.</li>
      <li>오퍼랜드는 레지스터나 메모리 위치가 될 수 있다.</li>
      <li>ex) incq(%rsp)는 스택 탑의 8바이트 원소의 값을 증가시켜준다. -&gt; C에서의 ++, – 연산자</li>
    </ul>
  </li>
  <li>이항 연산
    <ul>
      <li>두 번째 오퍼랜드는 소스이면서 목적지로 사용된다.</li>
      <li>C에서 x -= y와 유사하다.</li>
    </ul>
  </li>
</ul>

<h1 id="36-제어문">3.6 제어문</h1>

<h1 id="37-프로시저">3.7 프로시저</h1>
:ET